% for syncweb -to_tex
<<www/lexurl.ml>>=
@
<<http/lexheaders.ml>>=
@
<<http/lexdate.ml>>=
@
<<html/lexhtml.ml>>=
@

%TODO
<<commons/timer_.ml>>=
@
<<commons/fileevent_.ml>>=
@

%external
<<commons/common.ml>>=
@
<<commons/simple_color.ml>>=
@

\section{[[commons/]]}

\subsection*{[[commons/condition.mli]]}

%todo: replaced with the one in ocaml?

<<signature [[Condition.create]]>>=
val create : unit -> t
@
<<signature [[Condition.wait]]>>=
val wait : t -> unit
@

<<signature [[Condition.set]]>>=
val set : t -> unit
@

<<signature [[Condition.free]]>>=
val free : t -> unit
@


%-------------------------------------------------------------

<<commons/condition.mli>>=
type t

type condition_backend = {
  create: t -> unit;
  set: t -> unit;
  wait: t -> unit;
  free: t -> unit;
}

val backend: condition_backend ref

<<signature [[Condition.create]]>>
<<signature [[Condition.set]]>>
<<signature [[Condition.wait]]>>
<<signature [[Condition.free]]>>
@


\subsection*{[[commons/condition.ml]]}

<<type [[Condition.t]]>>=
type t = string
@


%-------------------------------------------------------------

<<commons/condition.ml>>=
(* Conditions *)
open Common

<<type [[Condition.t]]>>

type condition_backend = {
  create: t -> unit;
  set: t -> unit;
  wait: t -> unit;
  free: t -> unit;
}

let default_backend () = {
  create = (fun _s -> ());
  set = (fun _s -> ());
  wait = (fun _s -> ());
  free = (fun _s -> ());
}
let backend = ref (default_backend ())
  
let count = ref 0

let create () =
  incr count;
  let var = spf "var%d" !count in
  (!backend).create var;
  var

let set s =
  !backend.set s

let wait s = 
  !backend.wait s

let free s = 
  !backend.free s
@


\subsection*{[[commons/date.mli]]}

%-------------------------------------------------------------

<<commons/date.mli>>=
<<copyright header v6>>

<<signature [[Date.asc_wkday]]>>

<<signature [[Date.asc_month]]>>

<<signature [[Date.asc]]>>

<<signature [[Date.asc_now]]>>

<<signature [[Date.commonlog]]>>

<<signature [[Date.compare_time]]>>

@


\subsection*{[[commons/date.ml]]}


%-------------------------------------------------------------

<<commons/date.ml>>=
<<copyright header v6>>

open Printf
open Unix

<<function [[Date.asc_wkday]]>>

<<function [[Date.asc_month]]>>

<<function [[Date.asc]]>>

<<function [[Date.asc_now]]>>


<<function [[Date.commonlog]]>>


<<function [[Date.compare_time]]>>
@


\subsection*{[[commons/ebuffer.mli]]}

%todo: replaced with the one in ocaml? buffer.mli

<<signature [[Ebuffer.create]]>>=
val create : int -> t
  (* [create n] creates a buffer with initial size [n] *)
@

<<signature [[Ebuffer.output_string]]>>=
val output_string : t -> string -> unit
  (* [output_string buf s] appends [s] to [buf] *)
@

<<signature [[Ebuffer.output_char]]>>=
val output_char : t -> char -> unit
  (* [output_char buf c] appends [c] to [buf] *)
@

<<signature [[Ebuffer.output]]>>=
val output : t -> string -> int -> int -> unit
  (* [output buf s offs len] appends [len] characters of [s], starting
     at offset [offs] to [buf].
     Raises [Invalid_argument] if [offs] and [len] do not designate a
     valid substring of [s] *)
@

<<signature [[Ebuffer.get]]>>=
val get : t -> string
  (* [get buf] returns the current contents of [buf] *)
@

<<signature [[Ebuffer.used]]>>=
val used : t -> int
  (* [used buf] returns the current length of [buf] *)
@

<<signature [[Ebuffer.reset]]>>=
val reset : t -> unit
  (* [reset buf] emties [buf] *)  
@


%-------------------------------------------------------------

<<commons/ebuffer.mli>>=
<<copyright header v6>>

(* Extensible buffers *)

type t 

<<signature [[Ebuffer.create]]>>

<<signature [[Ebuffer.output_string]]>>
<<signature [[Ebuffer.output_char]]>>
<<signature [[Ebuffer.output]]>>

<<signature [[Ebuffer.get]]>>
<<signature [[Ebuffer.used]]>>

<<signature [[Ebuffer.reset]]>>
@


\subsection*{[[commons/ebuffer.ml]]}

<<type [[Ebuffer.t]]>>=
(* Extensible buffers *)
type t = {
    mutable buffer : bytes;
    mutable pos : int;
    mutable len : int}
@

<<function [[Ebuffer.create]]>>=
let create n = {
   buffer = Bytes.create n;
   pos = 0;
   len = n
   }
@

<<function [[Ebuffer.reset]]>>=
let reset buf =
    buf.pos <- 0
@

<<function [[Ebuffer.newsize]]>>=
let newsize old added =
  if added < old then old + old
  else old + old + added
@

<<function [[Ebuffer.output_string]]>>=
let output_string buf s =
  let l = String.length s in
  if buf.pos + l > buf.len then begin
    let size = newsize buf.len l in
    let news = Bytes.create size in
      Bytes.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  Bytes.unsafe_blit_string s 0 buf.buffer buf.pos l;
  buf.pos <- buf.pos + l
@

<<function [[Ebuffer.output_char]]>>=
let output_char buf c =
  if buf.pos >= buf.len then begin
    let size = newsize buf.len 1 in
    let news = Bytes.create size in
      Bytes.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  Bytes.set buf.buffer buf.pos c;
  buf.pos <- buf.pos + 1
@

<<function [[Ebuffer.output]]>>=
let output buf s ofs l =
  if buf.pos + l > buf.len then begin
    let size = newsize buf.len l in
    let news = Bytes.create size in
      Bytes.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  String.blit s ofs buf.buffer buf.pos l;
  buf.pos <- buf.pos + l
@

<<function [[Ebuffer.get]]>>=
let get buf = 
  Bytes.sub_string buf.buffer 0 buf.pos
@

<<function [[Ebuffer.used]]>>=
let used buf =
  buf.pos
@


%-------------------------------------------------------------

<<commons/ebuffer.ml>>=
<<copyright header v6>>

<<type [[Ebuffer.t]]>>

<<function [[Ebuffer.create]]>>

<<function [[Ebuffer.reset]]>>

<<function [[Ebuffer.newsize]]>>

<<function [[Ebuffer.output_string]]>>
<<function [[Ebuffer.output_char]]>>

<<function [[Ebuffer.output]]>>


<<function [[Ebuffer.get]]>>

<<function [[Ebuffer.used]]>>
@


\subsection*{[[commons/error.mli]]}



%-------------------------------------------------------------

<<commons/error.mli>>=

<<signature class [[Error.t]]>>

<<signature [[Error.default]]>>

<<signature [[Error.f]]>>
<<signature [[Error.ok]]>>
<<signature [[Error.choose]]>>
<<signature [[Error.ari]]>>

@


\subsection*{[[commons/error.ml]]}


%-------------------------------------------------------------

<<commons/error.ml>>=
open Common

<<class [[Error.t]]>>

class virtual t = object
 method virtual f : string -> unit
 method virtual ok : string -> unit
 method virtual choose : string -> bool
 method virtual ari : string -> int
end

class x = object
  inherit t
  method f _ = Logs.err (fun m -> m "TODO: Error.x.f")
  method ok _ = Logs.err (fun m -> m "TODO: Error.x.ok")
  method choose _ = failwith "TODO: Error.x.choose"
  method ari _ = failwith "TODO: Error.x.ari"
end

<<constant [[Error.default]]>>

(* backward compatibility *)
<<functions [[Error.xxx]]>>
@


\subsection*{[[commons/i18nprintf.mli]]}

%todo: remove?

<<signature [[I18nprintf.fprintf]]>>=
(* Module [Printf]: formatting printing functions *)

val fprintf: out_channel -> ('a, out_channel, unit) format -> 'a
        (* [fprintf outchan format arg1 ... argN] formats the arguments
           [arg1] to [argN] according to the format string [format],
           and outputs the resulting string on the channel [outchan].

           The format is a character string which contains two types of
           objects:  plain  characters, which are simply copied to the
           output channel, and conversion specifications, each of which
           causes  conversion and printing of one argument.

           Conversion specifications consist in the [%] character, followed
           by optional flags and field widths, followed by one conversion
           character. The conversion characters and their meanings are:
-          [d] or [i]: convert an integer argument to signed decimal
-          [u]: convert an integer argument to unsigned decimal
-          [x]: convert an integer argument to unsigned hexadecimal,
                using lowercase letters.
-          [X]: convert an integer argument to unsigned hexadecimal,
                using uppercase letters.
-          [s]: insert a string argument
-          [c]: insert a character argument
-          [f]: convert a floating-point argument to decimal notation,
                in the style [dddd.ddd]
-          [e] or [E]: convert a floating-point argument to decimal notation,
                in the style [d.ddd e+-dd] (mantissa and exponent)
-          [g] or [G]: convert a floating-point argument to decimal notation,
                in style [f] or [e], [E] (whichever is more compact)
-          [b]: convert a boolean argument to the string [true] or [false]
-          [a]: user-defined printer. Takes two arguments and apply the first
                one to [outchan] (the current output channel) and to the second
                argument. The first argument must therefore have type
                [out_channel -> 'b -> unit] and the second ['b].
                The output produced by the function is therefore inserted
                in the output of [fprintf] at the current point.
-          [t]: same as [%a], but takes only one argument (with type
                [out_channel -> unit]) and apply it to [outchan].
-          Refer to the C library [printf] function for the meaning of
           flags and field width specifiers.

           If too few arguments are provided, printing stops just
           before converting the first missing argument. *)
@

<<signature [[I18nprintf.printf]]>>=
val printf: ('a, out_channel, unit) format -> 'a
        (* Same as [fprintf], but output on [stdout]. *)
@

<<signature [[I18nprintf.eprintf]]>>=
val eprintf: ('a, out_channel, unit) format -> 'a
        (* Same as [fprintf], but output on [stderr]. *)
@

<<signature [[I18nprintf.sprintf]]>>=
val sprintf: ('a, unit, string) format -> 'a
        (* Same as [printf], but return the result of formatting in a
           string. *)
@


%-------------------------------------------------------------

<<commons/i18nprintf.mli>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

<<signature [[I18nprintf.fprintf]]>>

<<signature [[I18nprintf.printf]]>>

<<signature [[I18nprintf.eprintf]]>>

<<signature [[I18nprintf.sprintf]]>>
@


\subsection*{[[commons/i18nprintf.ml]]}

<<function [[I18nprintf.fprintf]]>>=
let fprintf outchan format =
  let format = (Obj.magic format : string) in
  let outside_iso8859 = ref false in
  let rec doprn i =
    if i >= String.length format then
      Obj.magic ()
    else begin
      let c = String.unsafe_get format i in
      if c = '\027' then begin
    if i+2 < String.length format &&
       String.unsafe_get format (i+1) = '\040' && 
       String.unsafe_get format (i+2) = '\066' then
         outside_iso8859 := false
    else outside_iso8859 := true
      end;
      if c <> '%' || !outside_iso8859 then begin
        output_char outchan c;
        doprn (succ i)
      end else begin
        let j = skip_args (succ i) in
        match String.unsafe_get format j with
          '%' ->
            output_char outchan '%';
            doprn (succ j)
        | 's' ->
            Obj.magic(fun s ->
              if j <= i+1 then
                output_string outchan s
              else begin
                let p =
                  try
                    int_of_string (String.sub format (i+1) (j-i-1))
                  with _ ->
                    invalid_arg "I18nprintf.fprintf: bad %s format" in
                if p > 0 && String.length s < p then begin
                  output_string outchan
                                (String.make (p - String.length s) ' ');
                  output_string outchan s
                end else if p < 0 && String.length s < -p then begin
                  output_string outchan s;
                  output_string outchan
                                (String.make (-p - String.length s) ' ')
                end else
                  output_string outchan s
              end;
              doprn (succ j))
        | 'c' ->
            Obj.magic(fun c ->
              output_char outchan c;
              doprn (succ j))
        | 'd' | 'o' | 'x' | 'X' | 'u' ->
            Obj.magic(fun n ->
              output_string outchan
                            (format_int (String.sub format i (j-i+1)) n);
              doprn (succ j))
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            Obj.magic(fun f ->
              output_string outchan
                            (format_float (String.sub format i (j-i+1)) f);
              doprn (succ j))
        | 'b' ->
            Obj.magic(fun b ->
              output_string outchan (string_of_bool b);
              doprn (succ j))
        | 'a' ->
            Obj.magic(fun printer arg ->
              printer outchan arg;
              doprn(succ j))
        | 't' ->
            Obj.magic(fun printer ->
              printer outchan;
              doprn(succ j))
        | _c ->
            invalid_arg ("I18nprintf.fprintf: unknown format")
      end
    end

  and skip_args j =
    match String.unsafe_get format j with
      '0' .. '9' | ' ' | '.' | '-' -> skip_args (succ j)
    | _c -> j

  in doprn 0
@

<<function [[I18nprintf.sprintf]]>>=
let sprintf format =
  let format = (Obj.magic format : string) in
  let outside_iso8859 = ref false in
  let rec doprn start i accu =
    if i >= String.length format then begin
      let res = 
        if i > start    
        then String.sub format start (i-start) :: accu
        else accu in
      Obj.magic(String.concat "" (List.rev res))
    end else
      let c = String.unsafe_get format i in
      if c = '\027' then begin
    if i+2 < String.length format &&
       String.unsafe_get format (i+1) = '\040' && 
       String.unsafe_get format (i+2) = '\066' then
         outside_iso8859 := false
    else outside_iso8859 := true
      end;
      if c <> '%' || !outside_iso8859 then
        doprn start (i+1) accu
      else begin
        let accu1 =
          if i > start then
          String.sub format start (i-start) :: accu
          else accu in
        let j = skip_args (succ i) in
        match String.unsafe_get format j with
          '%' ->
            doprn j (succ j) accu1
        | 's' ->
            Obj.magic(fun s ->
              let accu2 =
                if j <= i+1 then
                  s :: accu1
                else begin
                  let p =
                    try
                      int_of_string (String.sub format (i+1) (j-i-1))
                    with _ ->
                      invalid_arg "I18nprintf.fprintf: bad %s format" in
                  if p > 0 && String.length s < p then
                    s :: String.make (p - String.length s) ' ' :: accu1
                  else if p < 0 && String.length s < -p then
                    String.make (-p - String.length s) ' ' :: s :: accu1
                  else
                    s :: accu1
                end in
              doprn (succ j) (succ j) accu2)
        | 'c' ->
            Obj.magic(fun c ->
              doprn (succ j) (succ j) (String.make 1 c :: accu1))
        | 'd' | 'o' | 'x' | 'X' | 'u' ->
            Obj.magic(fun n ->
              doprn (succ j) (succ j)
                    (format_int (String.sub format i (j-i+1)) n :: accu1))
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            Obj.magic(fun f ->
              doprn (succ j) (succ j)
                    (format_float (String.sub format i (j-i+1)) f :: accu1))
        | 'b' ->
            Obj.magic(fun b ->
              doprn (succ j) (succ j) (string_of_bool b :: accu1))
        | 'a' ->
            Obj.magic(fun printer arg ->
              doprn (succ j) (succ j) (printer () arg :: accu1))
        | 't' ->
            Obj.magic(fun printer ->
              doprn (succ j) (succ j) (printer () :: accu1))
        | _c ->
            invalid_arg ("I18nprintf.sprintf: unknown format")
      end

  and skip_args j =
    match String.unsafe_get format j with
      '0' .. '9' | ' ' | '.' | '-' -> skip_args (succ j)
    | _c -> j

  in doprn 0 0 []
@


%-------------------------------------------------------------

<<commons/i18nprintf.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

external format_int: string -> int -> string = "caml_format_int"
external format_float: string -> float -> string = "caml_format_float"

<<function [[I18nprintf.fprintf]]>>

let printf fmt = fprintf stdout fmt
and eprintf fmt = fprintf stderr fmt

<<function [[I18nprintf.sprintf]]>>
@


\subsection*{[[commons/ibtree.mli]]}

%todo: replace with Map?
% have notion of interval? good for anchors?

%(* Exemples
%let anchors = [
% {start = 1,3; stop = 1,7};
% {start = 1,13; stop = 1,17};
% {start = 1,30; stop = 1,70};
% {start = 10,3; stop = 10,7};
% {start = 11,3; stop = 12,1};
% {start = 12,3; stop = 13,17};
% {start = 14,30; stop = 15,7};
% {start = 100,3; stop = 100,7};
% {start = 101,3; stop = 101,7};
% {start = 101,31; stop = 101,37}
% ]
%do_list add_anchor anchors
%
%find_anchor (1,6)
%find_anchor (12,0)
%find_anchor (11,7)
%find_anchor (101,3)
%find_anchor (15,3)
%find_anchor (16,3)
%
%(* A bit long (more than 3 seconds in Caml Light) *)
%for i = 0 to 10000 do 
% add_anchor {start = i, 1+i/2; stop = i, i}
%done
%*)

%-------------------------------------------------------------

<<commons/ibtree.mli>>=
module type S =
  sig
    type key
    type 'a t
    val empty: 'a t
    val add: (key * key) -> 'a -> 'a t -> 'a t
    val find: key -> 'a t -> 'a

    val find_interval : key -> 'a t -> key * key
  end

module Make(Ord: Map.OrderedType): (S with type key = Ord.t)

@


\subsection*{[[commons/ibtree.ml]]}


%-------------------------------------------------------------

<<commons/ibtree.ml>>=
(* Simple binary trees with no redondant elements, and no delete function *)

module type S =
  sig
    type key
    type 'a t
    val empty: 'a t
    val add: (key * key) -> 'a -> 'a t -> 'a t
    val find: key -> 'a t -> 'a
    val find_interval : key -> 'a t -> key * key
  end


module Make(Ord: Map.OrderedType) = struct

type key = Ord.t

type balance = Eq | Le | Ri

type 'a element = {
    interval : key * key;
    image : 'a
  } 

type 'a t =
 | Empty
 | Node of 'a node

and 'a node =
 {balance : balance; height : int;
  left : 'a t; element : 'a element; right : 'a t}

let height = function
  | Empty -> 0
  | Node {height = h; _} -> h

let create_node l e r =
  let hl = height l in
  let hr = height r in
  Node
   {
     balance = 
       (if hl = hr 
       then Eq 
       else 
         if hl < hr then Ri else Le
        )
     ;
     height = 1 + (if hr > hl then hr else hl);
     left = l; 
     element = e; 
     right = r;
   }

let turn_right = function
 | Empty -> Empty
 | Node
    {left =
      Node
       {balance = Eq | Ri;
        left = lle; element = le;
        right = Node {left = lrle; element = rle; right = rrle; _}; _};
     element = e; right = re; _} ->
      create_node (create_node lle le lrle) rle (create_node rrle e re)
 | Node
    {left =
      Node
       {balance = Le | Eq; left = lle; element = le; right = rle; _};
     element = e;
     right = re; _} -> create_node lle le (create_node rle e re)
 | _ -> failwith "turn_right"

and turn_left = function
 | Empty -> Empty
 | Node
    {left = le; element = e;
     right =
      Node
       {balance = Eq | Le;
        left = Node {left = llre; element = lre; right = rlre; _};
        element = re; right = rre; _}; _} ->
     create_node (create_node le e llre) lre (create_node rlre re rre)
 | Node
    {left = le; element = e;
     right =
      Node
       {balance = Ri | Eq; left = lre; element = re; right = rre; _}; _} ->
     create_node (create_node le e lre) re rre
 | _ -> failwith "turn_left"

let reball hr l e nr =
 let hnr = height nr and nt = create_node l e nr in
 if hnr > hr then turn_left nt else nt

let rebalr hl nl e r =
 let hnl = height nl and nt = create_node nl e r in
 if hnl > hl then turn_right nt else nt

(* Si les intervalles sont disjoints, la comparaison des bornes inferieures
   est un ordre *)

let compare_elements x y =
  Ord.compare (fst x.interval) (fst y.interval)

let rec insert x t =
 match t with
 | Empty ->
    Node {balance = Eq; height = 1; left = Empty; element = x; right = Empty}
 | Node {balance = b; left = l; element = e; right = r; _} ->
    let c = compare_elements x e in
    if c = 0 then t else
    if c > 0 then
     if b = Ri then reball (height r) l e (insert x r)
      else create_node l e (insert x r) else
    if b = Le then rebalr (height l) (insert x l) e r
     else create_node (insert x l) e r


let empty = Empty

let rec find pos = function
| Empty -> raise Not_found
| Node {left = l; element = e ; right = r; _} ->
   let c_start = Ord.compare pos (fst e.interval) in
   if c_start < 0 then find pos l else
   let c_stop = Ord.compare pos (snd e.interval) in
   if c_stop < 0 then e.image else find pos r


let rec find_interval pos = function
| Empty -> raise Not_found
| Node {left = l; element = e ; right = r; _} ->
   let c_start = Ord.compare pos (fst e.interval) in
   if c_start < 0 then find_interval pos l else
   let c_stop = Ord.compare pos (snd e.interval) in
   if c_stop < 0 then e.interval else find_interval pos r


let add i v = insert {interval = i; image = v}


(* Application to anchors
type position = int * int

type anchor_position = {start : position; stop : position}

let rec anchor_of_pos pos = function
| Empty -> raise Not_found
| Node {left = l; element = e; right = r} ->
   let c_start = compare pos e.start in
   if c_start < 0 then anchor_of_pos pos l else
   let c_stop = compare pos e.stop in
   if c_stop < 0 then e else anchor_of_pos pos r

let anchors_table = ref Empty

let add_anchor a = anchors_table := insert a !anchors_table
let find_anchor mouse_pos = anchor_of_pos mouse_pos !anchors_table

 *)
(* Exemples
let anchors = [
 {start = 1,3; stop = 1,7};
 {start = 1,13; stop = 1,17};
 {start = 1,30; stop = 1,70};
 {start = 10,3; stop = 10,7};
 {start = 11,3; stop = 12,1};
 {start = 12,3; stop = 13,17};
 {start = 14,30; stop = 15,7};
 {start = 100,3; stop = 100,7};
 {start = 101,3; stop = 101,7};
 {start = 101,31; stop = 101,37}
 ]
do_list add_anchor anchors

find_anchor (1,6)
find_anchor (12,0)
find_anchor (11,7)
find_anchor (101,3)
find_anchor (15,3)
find_anchor (16,3)

(* A bit long (more than 3 seconds in Caml Light) *)
for i = 0 to 10000 do 
 add_anchor {start = i, 1+i/2; stop = i, i}
done
*)
end
@


\subsection*{[[commons/lang.mli]]}

%todo: remove?

%-------------------------------------------------------------

<<commons/lang.mli>>=
<<signature [[Lang.lang]]>>

@


\subsection*{[[commons/lang.ml]]}


%(* mmm uses this function and Jtk.is_japanse_mode also. *)
%let is_japanese () =
%  let lang = try Sys.getenv "LANG" with _ -> "" in
%  String.length lang >= 2 && String.sub lang 0 2 = "ja"


%-------------------------------------------------------------

<<commons/lang.ml>>=

<<function [[Lang.lang]]>>

(* detect and set LANG information *)

@



\subsection*{[[commons/log.mli]]}


%-------------------------------------------------------------

<<commons/log.mli>>=
<<signature [[Log.debug_mode]]>>

<<signature [[Log.f]]>>
<<signature [[Log.debug]]>>
@


\subsection*{[[commons/log.ml]]}


%-------------------------------------------------------------

<<commons/log.ml>>=


<<constant [[Log.debug_mode]]>>

<<function [[Log.f]]>>

<<function [[Log.debug]]>>

@


\subsection*{[[commons/low.mli]]}

%todo: replace with unix?

<<signature [[Low.read]]>>=
val read : file_descr -> bytes -> int -> int -> int
  (* Unix.read wrapper, to be used when data transferred has to
     be counted by the tachymeter
   *)
@

<<signature [[Low.fork]]>>=
val fork : unit -> int
  (* Unix.fork wrapper. Catches zombies *)
@

<<signature [[Low.add_fileinput]]>>=
val add_fileinput : file_descr -> (unit -> unit) -> unit
@

<<signature [[Low.remove_fileinput]]>>=
val remove_fileinput: file_descr -> unit
  (* Wrapping of Tk fileinput functions, with feedback on the tachymeter *)
@

<<signature [[Low.busy]]>>=
val busy : ('a -> 'b) -> 'a -> 'b
  (* Busy feedback during this application *)
@



<<signature [[Low.update_idletasks]]>>=
val update_idletasks : unit -> unit
@


%-------------------------------------------------------------

<<commons/low.mli>>=
open Unix

<<signature [[Low.read]]>>

<<signature [[Low.fork]]>>

<<signature [[Low.add_fileinput]]>>
<<signature [[Low.remove_fileinput]]>>

<<signature [[Low.busy]]>>

<<signature [[Low.global_time]]>>
<<signature [[Low.add_task]]>>


class  virtual tachymeter : object
  method virtual report_cnx : int -> unit     (* displays number of active cnx *)
  method virtual report_busy : bool -> unit   (* displays busy status *)
  method virtual report_traffic : int -> int -> int -> unit
       (* [report_traffic tick_duration total sample] displays traffic
          from [total] and [sample] in last [tick_duration] *)
  method virtual quit : unit
end
<<signature [[Low.cur_tachy]]>>

<<signature [[Low.init]]>>

val update_idletasks_backend: (unit -> unit) ref
<<signature [[Low.update_idletasks]]>>
@


\subsection*{[[commons/low.ml]]}

<<constant [[Low.cur_tachy]]>>=
let cur_tachy = ref (new no_tachy :> tachymeter)
@

<<function [[Low.read]]>>=
let read fd buf offs l =
  let n = Unix.read fd buf offs l in
    bytes_read := !bytes_read + n;
    sample_read := !sample_read + n;
    n
@

<<function [[Low.add_fileinput]]>>=
let add_fileinput fd f =
  incr pending_read;
  !cur_tachy#report_cnx !pending_read;
  Fileevent_.add_fileinput fd f
@

<<function [[Low.remove_fileinput]]>>=
let remove_fileinput fd =
  decr pending_read;
  !cur_tachy#report_cnx !pending_read;
  Fileevent_.remove_fileinput fd
@

<<function [[Low.fork]]>>=
let fork () =
 begin try
  while 
    let p, _s = Unix.waitpid [Unix.WNOHANG] 0 in 
      (*
      Printf.eprintf "%d\n" p;
      begin match s with
        WEXITED n -> Printf.eprintf "Exit %d\n" n
       | WSIGNALED(n,_) -> 
           Printf.eprintf "SIG %d\n" n
       | WSTOPPED n -> Printf.eprintf "Stopped %d\n" n
      end;
      flush Pervasives.stderr;
      *)
      p <> 0
 do () done
 with
  Unix.Unix_error(_,_,_) -> ()
 end;
 (* Don't let children play stupid games *)
 match Unix.fork() with
   0 -> at_exit (fun () -> sys_exit 0); 0
 | n -> n
@

<<function [[Low.busy]]>>=
let busy f x =
  !cur_tachy#report_busy true;
  try 
    let v = f x in
    !cur_tachy#report_busy false; v
  with
    e ->
      !cur_tachy#report_busy false;
      raise e
@


<<constant [[Low.tick_duration]]>>=
let tick_duration = 500
@



<<function [[Low.add_task]]>>=
let add_task f = tasks := f :: !tasks
@


<<constant [[Low.last_update]]>>=
(* We need manual refresh for progressive display (?), but we don't
   want to do it too frequently *)
let last_update = ref !global_time
@

<<function [[Low.update_idletasks]]>>=
let update_idletasks () =
  if !global_time <> !last_update then begin
    !update_idletasks_backend ();
    last_update := !global_time
  end
@

<<global [[Low.pending_read]]>>=
let pending_read = ref 0
@

%-------------------------------------------------------------

<<commons/low.ml>>=
(* Wrapping of some low-level functions *)




(* Tachymeter support *)
class  virtual tachymeter = object
  method virtual report_cnx : int -> unit     (* displays number of active cnx *)
  method virtual report_busy : bool -> unit   (* displays busy status *)
  method virtual report_traffic : int -> int -> int -> unit
       (* [report_traffic tick_duration total sample] displays traffic
          from [total] and [sample] in last [tick_duration] *)
  method virtual quit : unit
  end

class no_tachy = object
  inherit tachymeter

  method report_cnx _cnx = ()
  method report_busy _flag = ()
  method report_traffic _tick _total _sample = ()
  method quit = ()
end

<<constant [[Low.cur_tachy]]>>

(* for the tachymeter *)
<<global [[Low.bytes_read]]>>
<<global [[Low.sample_read]]>>

<<function [[Low.read]]>>

<<global [[Low.pending_read]]>>
let _action = ref (fun _ -> ())

<<function [[Low.add_fileinput]]>>

<<function [[Low.remove_fileinput]]>>

(* We catch dead children here, to avoid large number of zombies.
   I know about SICHLD of course, but I hate interrupted syscalls
 *)

external sys_exit : int -> 'a = "caml_sys_exit"

<<function [[Low.fork]]>>


<<function [[Low.busy]]>>

<<constant [[Low.global_time]]>>
<<constant [[Low.tick_duration]]>>

<<constant [[Low.tasks]]>>

<<function [[Low.refresh]]>>

<<function [[Low.add_task]]>>

<<function [[Low.init]]>>

let update_idletasks_backend = 
  ref (fun _ -> failwith "no update_idletasks defined")


<<constant [[Low.last_update]]>>
<<function [[Low.update_idletasks]]>>
@


\subsection*{[[commons/mlist.mli]]}


%-------------------------------------------------------------

<<commons/mlist.mli>>=
<<signature [[Mlist.hdn]]>>
<<signature [[Mlist.tln]]>>

<<signature [[Mlist.except_assoc]]>>
<<signature [[Mlist.exceptq]]>>
<<signature [[Mlist.rev_do_list]]>>

<<signature [[Mlist.do_listi]]>>
@


\subsection*{[[commons/mlist.ml]]}


%-------------------------------------------------------------

<<commons/mlist.ml>>=
(*
 * List utilities
 *)
<<function [[Mlist.tln]]>>

<<function [[Mlist.hdn]]>>

<<function [[Mlist.except_assoc]]>>

<<function [[Mlist.exceptq]]>>



<<function [[Mlist.rev_do_list]]>>


<<function [[Mlist.do_listi]]>>

@


\subsection*{[[commons/mstring.mli]]}


%-------------------------------------------------------------

<<commons/mstring.mli>>=
<<signature [[Mstring.split_str]]>>
<<signature [[Mstring.get_suffix]]>>

<<signature [[Mstring.hex_to_dec]]>>
<<signature [[Mstring.dec_to_hex]]>>

<<signature [[Mstring.hex_to_string]]>>

<<signature [[Mstring.gensym]]>>
<<signature [[Mstring.egensym]]>>

<<signature [[Mstring.rem_trailing_sp]]>>

<<signature [[Mstring.catenate_sep]]>>

<<signature [[Mstring.norm_crlf]]>>
@


\subsection*{[[commons/mstring.ml]]}


%-------------------------------------------------------------

<<commons/mstring.ml>>=
(*
 * String utilities
 *)

<<function [[Mstring.split_str]]>>

<<function [[Mstring.get_suffix]]>>

<<function [[Mstring.hex_to_dec]]>>

<<function [[Mstring.dec_to_hex]]>>

<<function [[Mstring.hex_to_string]]>>

<<constant [[Mstring.gensym]]>>

<<function [[Mstring.egensym]]>>

<<function [[Mstring.rem_trailing_sp]]>>

<<function [[Mstring.catenate_sep]]>>

<<function [[Mstring.norm_crlf]]>>



@


\subsection*{[[commons/msys.mli]]}



%-------------------------------------------------------------

<<commons/msys.mli>>=
<<copyright header v6>>

<<signature [[Msys.tilde_subst]]>>

<<signature [[Msys.rm]]>>

<<signature [[Msys.fsize]]>>

<<signature [[Msys.mktemp]]>>
@


\subsection*{[[commons/msys.ml]]}


%-------------------------------------------------------------

<<commons/msys.ml>>=
<<copyright header v6>>


open Unix

(* Tilde substitution *)

<<function [[Msys.next_slash]]>>

<<function [[Msys.tilde_subst]]>>

<<function [[Msys.rm]]>>
<<function [[Msys.rmdir]]>>

<<function [[Msys.fsize]]>>

<<constant [[Msys.tmp_dir]]>>

<<constant [[Msys.mktemp]]>>
@


\subsection*{[[commons/i18n.mli]]}



%-------------------------------------------------------------

<<commons/i18n.mli>>=
<<signature [[I18n.message_file]]>>
<<signature [[I18n.language]]>>

<<signature [[I18n.sprintf]]>>
(* pad's compact alias *)
val s_: ('a, unit, string) format -> 'a

<<signature [[I18n.menu_option]]>>
<<signature [[I18n.menu_pattern]]>>

val translate: string -> string
@


\subsection*{[[commons/i18n.ml]]}


%-------------------------------------------------------------

<<commons/i18n.ml>>=

<<function [[I18n.fprintf]]>>
<<function [[I18n.sprintf]]>>

<<constant [[I18n.language]]>>
<<constant [[I18n.message_file]]>>

<<function [[I18n.read_transl_file]]>>

<<type [[I18n.translation_table]]>>

<<constant [[I18n.transl_table]]>>

<<function [[I18n.translate]]>>

<<function I18n.fprintf (./commons/i18n.ml)>>

<<function I18n.sprintf (./commons/i18n.ml)>>

let s_ fmt = sprintf fmt




<<function [[I18n.menu_option]]>>

<<exception [[I18n.Found]]>>

<<function [[I18n.menu_pattern]]>>
@


\subsection*{[[commons/munix.ml]]}

<<function [[Munix.execvp]]>>=
(* If execvp fails in one of our children, it may be dangerous to leave
   the program running, since we don't know how Tk would react *)
let execvp s args =
  try 
    execvp s args
  with
    Unix_error(e, _, _) ->
       Printf.eprintf "%s\n" (Unix.error_message e);
       flush Stdlib.stderr;
       exit 1
@

<<constant [[Munix.quote]]>>=
let quote = Str.regexp "'"
@

<<function [[Munix.quote_for_shell]]>>=
let quote_for_shell s =
  sprintf "'%s'" (Str.global_replace quote "'\\''" s)
@

<<function [[Munix.system]]>>=
(* Wrapping of Sys.command with trivial arg quoting *)
let system cmd args back =
  let b = Ebuffer.create 128 in
   Ebuffer.output_string b cmd;
   List.iter (fun s ->
     Ebuffer.output_char b ' ';
     Ebuffer.output_string b (quote_for_shell s))
    args;
   if back then Ebuffer.output_string b " &";
   Sys.command (Ebuffer.get b)
@

<<function [[Munix.eval_cmd]]>>=
let eval_cmd cmd args back =
 let _ = system cmd args back in ()
@

<<function [[Munix.write_string]]>>=
let write_string fd (s : string) =
  ignore (write fd (Bytes.of_string s) 0 (String.length s))
@

<<function [[Munix.read_line]]>>=
(*
 * Read a line (terminated by \n or \r\n).
 *   strips terminator !
 *)
let read_line fd =
  let rec read_rec (buf : bytes) bufsize offs =
    let n = Low.read fd buf offs 1 in
      if n = 0 then raise End_of_file
      else if Bytes.get buf offs = '\n'
           then (* strips \n and possibly \r  *)
             let len = if offs >= 1 && Bytes.get buf (offs-1) = '\r' then offs-1 
                       else offs in
               Bytes.sub_string buf 0 len
           else let offs = succ offs in
                  if offs = bufsize 
                  then read_rec (Bytes.cat buf (Bytes.create 128)) (bufsize + 128) offs
                  else read_rec buf bufsize offs in
  read_rec (Bytes.create 128) 128 0 
@

<<function [[Munix.full_random_init]]>>=
let full_random_init () =
  try 
    let env = environment () in
    let vect =
      Array.append (Array.map Hashtbl.hash env)
           [| getpid(); Stdlib.truncate (time()); (* JPF: bogus *)
              getuid(); getgid();
              Hashtbl.hash (getlogin()) |] in
    Random.full_init vect
  with
    _ -> ()
@

<<function [[Munix.digdir]]>>=
let rec digdir dir perm =
  (* try to create the directory dir *)
  if Sys.file_exists dir then () 
  else begin
    let pdir = Filename.dirname dir in
    digdir pdir perm;
    Unix.mkdir dir perm
  end
@

<<constant [[Munix.dns]]>>=
(* DNS Caching. It really helps on slow lines... *)
let dns = Hashtbl.create 307
@

<<function [[Munix.gethostbyname]]>>=
let gethostbyname h =
  try Hashtbl.find dns h
  with
    Not_found ->
      let addr = Unix.gethostbyname h in
        Hashtbl.add dns h addr;
     addr
@

<<toplevel [[Munix._1]]>>=
let _ =
  full_random_init()
@

<<constant [[Munix.vars]]>>=
(* Hack to run some external command with parameter substitution 
 * The command is a string containing $X
 * The arguments are [X, v]
 * For arguments not substituted, add them at the end,
 *)
let vars = Str.regexp "\\$[A-Z]+"
@

<<function [[Munix.system_eval]]>>=
let system_eval cmd args back =
  let replaced = ref []
  and _qargs = List.map (fun (x, v) -> x, quote_for_shell v) args
  in
  let replfun s =
    let matched = Str.matched_string s in
    let thevar = String.sub matched 1 (String.length matched - 1) in
    try 
      let res = List.assoc thevar args in
      replaced := thevar :: !replaced;
      res
    with
      Not_found -> matched
  in
  (* replace vars *)
  let scmd = Str.global_substitute vars replfun cmd in
  (* for vars that haven't been replaced, add them at the end 
   * (backward compatibility with our previous versions)
   *)
  let remaining = ref [] in
  List.iter (fun (x,v) -> 
    if not (List.mem x !replaced) then remaining := v :: !remaining)
    args;
  system scmd (List.rev !remaining) back
@


%-------------------------------------------------------------

<<commons/munix.ml>>=
open Printf
open Unix

(*
 * Simple Unix utilities
 *)


<<function [[Munix.execvp]]>>

<<constant [[Munix.quote]]>>
<<function [[Munix.quote_for_shell]]>>

<<function [[Munix.system]]>>

<<function [[Munix.eval_cmd]]>>

<<function [[Munix.write_string]]>>

<<function [[Munix.read_line]]>>


<<function [[Munix.full_random_init]]>>

<<function [[Munix.digdir]]>>

<<constant [[Munix.dns]]>>
<<function [[Munix.gethostbyname]]>>

<<toplevel [[Munix._1]]>>

<<constant [[Munix.vars]]>>

<<function [[Munix.system_eval]]>>

@


\subsection*{[[commons/feed.mli]]}




%-------------------------------------------------------------

<<commons/feed.mli>>=
<<type [[Feed.internal]]>>

<<type [[Feed.t]]>>

<<signature [[Feed.of_fd]]>>
<<signature [[Feed.internal]]>>
@


\subsection*{[[commons/feed.ml]]}



%-------------------------------------------------------------

<<commons/feed.ml>>=
<<type [[Feed.internal]]>>

<<type [[Feed.t]]>>

<<function [[Feed.of_fd]]>>
 
<<function [[Feed.internal]]>>

@


\subsection*{[[tk/glevents.mli]]}

%\subsection{[[Glevents]]}

<<signature [[Glevents.get]]>>=
val get : string -> (modifier list * xEvent) list 
@

<<signature [[Glevents.reset]]>>=
val reset : unit -> unit
@

<<constant [[Glevents.events]]>>=
(* A global table for describing events
 * TODO: use virtual events because here we don't change bindings in 
 * place after a preference reload
 *)

let events = Hashtbl.create 37
@

<<constant [[Glevents.builtin_defaults]]>>=
let builtin_defaults = [

  (* tachymeter bindings *)
  "tachy_about", [[], ButtonPressDetail 3];
  "tachy_gc",[[], KeyPressDetail "g"; [], KeyPressDetail "c"];
  "tachy_new", [[], ButtonPressDetail 1];
  "tachy_sel", [[], ButtonPressDetail 2];

  (* bindings on inlined images *)
  "loadimage", [[Control], ButtonPressDetail 1];
  "alt_imap", [[],ButtonPressDetail 1];	(* alt mode client side img map *)
  "stopanim",  [[], ButtonPressDetail 2];
  "restartanim", [[Shift], ButtonPressDetail 2];
  "copyimgurl", [[], ButtonPressDetail 2];
  "updateimage", [[Shift], ButtonPressDetail 2];

  (* anchor bindings *)
  "goto", [[], ButtonPressDetail 1];
  "save", [[Shift], ButtonPressDetail 1];
  "gotonew", [[], ButtonPressDetail 3];
  "hypermenu", [[Control], ButtonPressDetail 1];
]
@
% ???

<<constant [[Glevents.get]]>>=
let get = Hashtbl.find events
@

<<function [[Glevents.reset]]>>=
(* This is for preferences *)
let reset () =
  Hashtbl.clear events;
  (* Now: for all names defined in defaults, check a possible overriding value
     in resources *)
  List.iter (fun (name,default) ->
    Hashtbl.add events 
      name (Tkresource.event_sequence (sprintf "bind<%s>" name) default))
    builtin_defaults
@





%-------------------------------------------------------------

<<commons/glevents.mli>>=
open Tk

<<signature [[Glevents.get]]>>
<<signature [[Glevents.reset]]>>
@


\subsection*{[[tk/glevents.ml]]}


%-------------------------------------------------------------

<<commons/glevents.ml>>=
open Printf
open Tk

<<constant [[Glevents.events]]>>

<<constant [[Glevents.builtin_defaults]]>>

<<constant [[Glevents.get]]>>

<<function [[Glevents.reset]]>>
    
  
@


\subsection*{[[commons/hotlist.ml]]}

%-------------------------------------------------------------

<<commons/hotlist.ml>>=
open I18n
<<constant [[Hotlist.program]]>>

<<function [[Hotlist.f]]>>
@



\section{[[globals/]]}

\subsection*{[[globals/version.mli]]}


%-------------------------------------------------------------

<<globals/version.mli>>=
<<signature [[Version.number]]>>
<<signature [[Version.http]]>>
<<signature [[Version.about]]>>

<<signature [[Version.initurl]]>>
<<signature [[Version.html]]>>

<<signature [[Version.helpurl]]>>
<<signature [[Version.home]]>>
<<signature [[Version.applet_init]]>>
@


\subsection*{[[globals/version.ml]]}



%-------------------------------------------------------------

<<globals/version.ml>>=
(* To merge FR and JP strings correctly, you have to encode the characters
 * more than 0x7F, for example "Fran\231ois".
 *) 

<<constant [[Version.number]]>>
<<constant [[Version.version_number]]>>

<<constant [[Version.http]]>>

<<function [[Version.about]]>>

<<function [[Version.home]]>>

<<function [[Version.initurl]]>>

<<function [[Version.helpurl]]>>

<<function [[Version.html]]>>

<<constant [[Version.applet_init]]>>
@


\section{[[www/]]}

\subsection*{[[www/uri.mli]]}



%-------------------------------------------------------------

<<www/uri.mli>>=
<<type [[Uri.abs_uri]]>>

<<signature [[Uri.is_absolute]]>>
@


\subsection*{[[www/uri.ml]]}


%-------------------------------------------------------------

<<www/uri.ml>>=



<<type [[Uri.abs_uri]]>>

<<function [[Uri.is_absolute]]>>
@


\subsection*{[[www/url.mli]]}


%-------------------------------------------------------------

<<www/url.mli>>=
<<type [[Url.protocol]]>>

<<signature [[Url.string_of_protocol]]>>

<<type [[Url.t]]>>

<<signature [[Url.string_of]]>>

<<signature [[Url.distant_path]]>>

<<exception [[Url.Url_Lexing]]>>


@


\subsection*{[[www/url.ml]]}



%-------------------------------------------------------------

<<www/url.ml>>=


<<type [[Url.protocol]]>>

<<function [[Url.string_of_protocol]]>>


<<type [[Url.t]]>>

<<exception [[Url.Url_Lexing]]>>
<<exception [[Url.Invalid_url]]>>

<<function [[Url.string_of]]>>

<<function [[Url.distant_path]]>>

@


\subsection*{[[www/urlenc.mli]]}


%-------------------------------------------------------------

<<www/urlenc.mli>>=
<<copyright header v6>>

<<signature [[Urlenc.decode]]>>
<<signature [[Urlenc.encode]]>>

<<signature [[Urlenc.strict_form_standard]]>>
<<signature [[Urlenc.form_encode]]>>
<<signature [[Urlenc.form_decode]]>>

<<signature [[Urlenc.unquote]]>>
@


\subsection*{[[www/urlenc.ml]]}


%-------------------------------------------------------------

<<www/urlenc.ml>>=
<<copyright header v6>>

open Mstring

<<function [[Urlenc.hexchar]]>>

<<function [[Urlenc.decode]]>>

<<constant [[Urlenc.keep_quoted]]>>
<<function [[Urlenc.unquote]]>>

<<function [[Urlenc.encode]]>>


<<constant [[Urlenc.strict_form_standard]]>>

<<function [[Urlenc.form_encode]]>>

<<constant [[Urlenc.form_decode]]>>
         
@


\subsection*{[[www/lexurl.mli]]}


%-------------------------------------------------------------

<<www/lexurl.mli>>=
<<signature [[Lexurl.f]]>>
<<signature [[Lexurl.make]]>>
<<signature [[Lexurl.maken]]>>

<<signature [[Lexurl.remove_dots]]>>
<<signature [[Lexurl.normalize]]>>
@



\subsection*{[[www/lexurl.mll]]}

%-------------------------------------------------------------

<<www/lexurl.mll>>=
{



open Mlist

open Url

<<function [[Lexurl.normalize_port]]>>

<<function [[Lexurl.normalize_host]]>>

}

<<function [[Lexurl.f]]>>

<<function [[Lexurl.slashslash]]>>
	
<<function [[Lexurl.userpass]]>>

<<function [[Lexurl.hostport]]>>

<<function [[Lexurl.pathsearch]]>>

<<functions [[Lexurl.xxx]]>>

{

<<function [[Lexurl.make]]>>



<<function [[Lexurl.remove_dots]]>>

<<function [[Lexurl.maken]]>>

<<function [[Lexurl.normalize]]>>

}
@


\subsection*{[[www/hyper.mli]]}



%-------------------------------------------------------------

<<www/hyper.mli>>=
(* An hypertext(media) link on the Web *)

<<type [[Hyper.link_method]]>>

<<signature [[Hyper.parse_method]]>>

<<type [[Hyper.link]]>>

<<signature [[Hyper.default_link]]>>

<<type [[Hyper.link_error]]>>

<<exception [[Hyper.Invalid_link]]>>

<<signature [[Hyper.urlconcat]]>>

<<signature [[Hyper.resolve]]>>
<<signature [[Hyper.string_of]]>>
@


\subsection*{[[www/hyper.ml]]}



%-------------------------------------------------------------

<<www/hyper.ml>>=
open I18n
open Printf

open Uri
open Url

(* An hypertext(media) link on the Web *)

<<type [[Hyper.link_method]]>>

<<function [[Hyper.parse_method]]>>


<<type [[Hyper.link]]>>

<<type [[Hyper.link_error]]>>

<<function [[Hyper.default_link]]>>

<<exception [[Hyper.Invalid_link]]>>

<<function [[Hyper.urlconcat]]>>
          
<<function [[Hyper.resolve]]>>

<<function [[Hyper.string_of]]>>
@


\subsection*{[[www/maps.mli]]}


%-------------------------------------------------------------

<<www/maps.mli>>=
<<type [[Maps.area_kind]]>>

<<type [[Maps.area]]>>

<<type [[Maps.map]]>>

<<type [[Maps.t]]>>

<<type [[Maps.map_status]]>>

<<signature [[Maps.parse_coords]]>>
<<signature [[Maps.get]]>>

val broadcast_backend: (string -> unit) ref
<<signature [[Maps.add]]>>
@


\subsection*{[[www/maps.ml]]}



%-------------------------------------------------------------

<<www/maps.ml>>=
open Printf

(* Client-side image maps:
     the "only" difficulty in implementing client-side image maps is that
     the map may well come *after* the image in the document. In general,
     anyway, the map may be an arbitrary URL.

   We thus have to implement a general delay mechanism for maps : the idea
   here is to use a table of maps, each map being accessed by an URI (that is,
   an URL plus a fragment).

   PROBLEM: we have no idea in general when to flush this table.

 *)

<<type [[Maps.area_kind]]>>

<<type [[Maps.area]]>>

<<type [[Maps.map]]>>

<<type [[Maps.t]]>>


<<type [[Maps.map_status]]>>

<<constant [[Maps.table]]>>

<<constant [[Maps.coord_sep]]>>
<<function [[Maps.parse_coords]]>>

let broadcast_backend = ref (fun _ev -> failwith "no broadcast defined")

<<function [[Maps.add]]>>

<<function [[Maps.get]]>>
@


\subsection*{[[www/www.mli]]}


%-------------------------------------------------------------

<<www/www.mli>>=
<<type [[Www.request]]>>

<<exception [[Www.Invalid_request]]>>

<<signature [[Www.make]]>>

(* Table of unresolved active connexions *)
module UrlSet : Set.S with type elt = Url.t

<<signature [[Www.is_active_cnx]]>>
<<signature [[Www.add_active_cnx]]>>
<<signature [[Www.rem_active_cnx]]>>

<<type [[Www.aborter]]>>

@


\subsection*{[[www/www.ml]]}



%-------------------------------------------------------------

<<www/www.ml>>=
open Uri
open Url

<<type [[Www.request]]>>

<<exception [[Www.Invalid_request]]>>

<<constant [[Www.sp]]>>

<<function [[Www.make]]>>
 


<<module Www.UrlSet>>

<<constant [[Www.active_connexions]]>>
<<functions [[Www.xxx_active_cnx]]>>

<<type [[Www.aborter]]>>

@


\subsection*{[[www/document.mli]]}



%-------------------------------------------------------------

<<www/document.mli>>=
<<type [[Document.document_id]]>>

<<signature [[Document.no_stamp]]>>
<<signature [[Document.new_stamp]]>>

<<signature type Document.logger>>
<<signature [[Document.tty_logger]]>>

<<type [[Document.handle]]>>

<<type [[Document.document_continuation]]>>

<<type [[Document.document_data]]>>

<<type [[Document.document]]>>

module DocumentIDSet : Set.S with type elt = document_id

<<signature [[Document.dclose]]>>

val add_log_backend: (handle -> string -> (unit -> unit) -> unit) ref

<<signature [[Document.add_log]]>>
<<signature [[Document.put_log]]>>
<<signature [[Document.progress_log]]>>
<<signature [[Document.end_log]]>>
<<signature [[Document.destroy_log]]>>

<<signature [[Document.document_id]]>>
@


\subsection*{[[www/document.ml]]}


%-------------------------------------------------------------

<<www/document.ml>>=
open Feed
open Www
open Hyper

<<type [[Document.logger]]>>

<<type [[Document.document_id]]>>

<<module Document.DocumentIDSet>>

<<type [[Document.handle]]>>

<<type [[Document.document_continuation]]>>

<<type [[Document.document_data]]>>

<<type [[Document.document]]>>

<<constant [[Document.stamp_counter]]>>
<<constant [[Document.no_stamp]]>>

<<function [[Document.new_stamp]]>>

<<function [[Document.document_id]]>>


<<function [[Document.dclose]]>>


<<constant [[Document.tty_logger]]>>

let add_log_backend = ref (fun _ _ _ -> failwith "no add_log defined")
  
<<function [[Document.add_log]]>>
<<functions [[Document.xxx_log]]>>
<<function [[Document.end_log]]>>

@


\section{[[html/]]}

\subsection*{[[html/dtd.mli]]}

%-------------------------------------------------------------

<<html/dtd.mli>>=
module Elements : Set.S with type elt = string

<<type [[Dtd.t]]>>

<<signature [[Dtd.dtd20]]>>
<<signature [[Dtd.dtd32]]>>
<<signature [[Dtd.dtd32f]]>>

<<signature [[Dtd.get]]>>
<<signature [[Dtd.add]]>>
<<signature [[Dtd.name]]>>

<<signature [[Dtd.names]]>>

<<signature [[Dtd.current]]>>

<<signature [[Dtd.dump]]>>
@


\subsection*{[[html/dtd.ml]]}

%-------------------------------------------------------------

<<html/dtd.ml>>=
open Printf

<<module Dtd.elements>>

<<type [[Dtd.t]]>>

<<function [[Dtd.name]]>>


<<function [[Dtd.sol]]>>
<<function [[Dtd.sos]]>>

<<constant [[Dtd.dtd20]]>>


<<function [[Dtd.dump]]>>



<<constant [[Dtd.dtd32]]>>

<<constant [[Dtd.current]]>>

<<constant [[Dtd.table]]>>

<<function [[Dtd.add]]>>
<<constant [[Dtd.get]]>>

<<function [[Dtd.names]]>>

<<toplevel [[Dtd._1]]>>

<<constant [[Dtd.dtd32f]]>>

<<toplevel [[Dtd._2]]>>
@


\subsection*{[[html/html.mli]]}

<<signature [[Html.beautify2]]>>=
val beautify2 : string -> string
  (* [beautify2 s] removes leading/trailing space and sequences of SP *)
@

<<signature [[Html.issp]]>>=
val issp : string -> bool
  (* [issp s] is true if s is formed only of SP *)
@


%-------------------------------------------------------------

<<html/html.mli>>=
<<type [[Html.attribute_name]]>>
<<type [[Html.attribute_value]]>>
<<type [[Html.attributes]]>>

<<type [[Html.tag]]>>

<<type [[Html.token]]>>

<<type [[Html.location]]>>

<<exception [[Html.Html_Lexing]]>>
<<exception [[Html.Invalid_Html]]>>


<<signature [[Html.init]]>>

<<signature [[Html.verbose]]>>

<<signature [[Html.warning]]>>

<<signature [[Html.print]]>>

<<signature [[Html.beautify]]>>

<<signature [[Html.beautify2]]>>

<<signature [[Html.issp]]>>

<<signature [[Html.get_entity]]>>

<<signature [[Html.get_attribute]]>>

<<signature [[Html.has_attribute]]>>

<<type [[Html.length]]>>
      
<<signature [[Html.length_of_string]]>>

@


\subsection*{[[html/html.ml]]}


%?? -> <> 
<<function [[Html.beautify2]]>>=
(* Remove also trailing space. Used for OPTION tags and TITLE *)
let beautify2 s =
  let s1 = beautify true s in
   match String.length s1 with
     0 | 1 -> s1
   | n -> if s1.[n-1] = ' ' then String.sub s1 0 (n-1) else s1
@

<<function [[Html.issp]]>>=
(* Is SP: when a PCData is only spaces, we skip it *)
let issp s =
  try
    for i = 0 to String.length s - 1 do
      match s.[i] with 
       ' '|'\t'|'\r'|'\n'|'\000' -> ()
      | _ -> failwith "subliminal"
    done;
    true
  with
    Failure "subliminal" -> false
@


%-------------------------------------------------------------

<<html/html.ml>>=
open Printf

<<type [[Html.attribute_name]]>>
<<type [[Html.attribute_value]]>>
<<type [[Html.attributes]]>>

<<type [[Html.tag]]>>


<<type [[Html.token]]>>

<<type [[Html.location]]>>

<<exception [[Html.Html_Lexing]]>>
<<exception [[Html.Invalid_Html]]>>

<<constant [[Html.verbose]]>>

<<function [[Html.warning]]>>


<<function [[Html.print]]>>

<<function [[Html.beautify]]>>

<<function [[Html.beautify2]]>>


<<function [[Html.issp]]>>
  
<<constant [[Html.ampersand_table]]>>

<<constant [[Html.latin1_normal]]>>

<<function [[Html.init]]>>

<<constant [[Html.get_entity]]>>


<<constant [[Html.default_attributes]]>>

<<function [[Html.get_attribute]]>>

<<function [[Html.has_attribute]]>>

<<type [[Html.length]]>>

<<function [[Html.length_of_string]]>>

@


\subsection*{[[html/lexhtml.mli]]}




%-------------------------------------------------------------

<<html/lexhtml.mli>>=
<<signature [[Lexhtml.strict]]>>

<<signature type Lexhtml.t>>
<<signature [[Lexhtml.new_data]]>>

<<type [[Lexhtml.warnings]]>>

<<signature [[Lexhtml.html]]>>
<<signature [[Lexhtml.cdata]]>>
@

\subsection*{[[html/lexhtml.mll]]}

<<html/lexhtml.mll>>=
(* An HTML lexer *)
{
open Html

<<type [[Lexhtml.tagtoken]]>>

<<type [[Lexhtml.t]]>>

<<function [[Lexhtml.new_data]]>>

<<global [[Lexhtml.strict]]>>

<<type [[Lexhtml.warnings]]>>

<<helper functions [[Lexhtml.xxx]]>>
}

<<function [[Lexhtml.html]]>>


<<function [[Lexhtml.lenient_end_comment]]>>

<<function [[Lexhtml.comment]]>>

<<function [[Lexhtml.next_comment]]>>


<<function [[Lexhtml.text]]>>

<<function [[Lexhtml.ampersand]]>>


<<function [[Lexhtml.opentag]]>>

<<function [[Lexhtml.closetag]]>>

<<function [[Lexhtml.attrib]]>>

<<function [[Lexhtml.tagattrib]]>>

<<function [[Lexhtml.attribvalue]]>>


<<function [[Lexhtml.inquote]]>>

<<function [[Lexhtml.insingle]]>>

<<function [[Lexhtml.skip_to_close]]>>

<<function [[Lexhtml.cdata]]>>

@



\subsection*{[[html/html_eval.mli]]}



%-------------------------------------------------------------

<<html/html_eval.mli>>=
<<signature [[Html_eval.debug]]>>

<<type [[Html_eval.minimization]]>>

<<signature [[Html_eval.add_html_filter]]>>
<<signature [[Html_eval.sgml_lexer]]>>

<<signature [[Html_eval.automat]]>>
@


\subsection*{[[html/html_eval.ml]]}


%-------------------------------------------------------------

<<html/html_eval.ml>>=
open Printf
open Html
open Dtd

<<type [[Html_eval.minimization]]>>

<<constant [[Html_eval.debug]]>>

<<exception [[Html_eval.CantMinimize]]>>

<<constant [[Html_eval.initial]]>>


<<function [[Html_eval.dump_stack]]>>

<<function [[Html_eval.ominimize]]>>

<<function [[Html_eval.cminimize]]>>

<<function [[Html_eval.is_cdata]]>>

<<function [[Html_eval.sgml_lexer]]>>

<<constant [[Html_eval.filters]]>>
<<function [[Html_eval.add_html_filter]]>>

<<function [[Html_eval.sgml_lexer]] ([[html/html_eval.ml]])>>
  
  
<<function [[Html_eval.automat]]>>
@


\subsection*{[[html/htparse.ml]]}


%-------------------------------------------------------------

<<html/htparse.ml>>=
(* Testing the HTML Lexer/evaluator *)
open Html
open Printf

<<toplevel [[Htparse._1]]>>

<<type [[Htparse.mode]]>>

<<constant [[Htparse.verbose]]>>
<<constant [[Htparse.mode]]>>

<<function [[Htparse.error]]>>


<<function [[Htparse.line_reporting]]>>

<<function [[Htparse.html_lex]]>>

<<function [[Htparse.html_nest]]>>

<<function [[Htparse.html_indent]]>>

<<function [[Htparse.main]]>>

<<toplevel [[Htparse._2]]>>
@


\section{[[http/]]}

\subsection*{[[http/base64.mli]]}


%-------------------------------------------------------------

<<http/base64.mli>>=
<<copyright header v6>>

<<signature [[Base64.encode]]>>
<<signature [[Base64.decode]]>>
@


\subsection*{[[http/base64.ml]]}


%-------------------------------------------------------------

<<http/base64.ml>>=
<<copyright header v6>>

<<constant [[Base64.index64]]>>
<<toplevel [[Base64._1]]>>

<<function [[Base64.decode]]>>


<<constant [[Base64.char64]]>>
<<toplevel [[Base64._2]]>>

<<function [[Base64.encode]]>>

@


\subsection*{[[http/http_date.mli]]}



%-------------------------------------------------------------

<<http/http_date.mli>>=
<<copyright header v6>>

(* HTTP Date format *)

<<type [[Http_date.http_time]]>>


<<signature [[Http_date.expired]]>>

<<signature [[Http_date.compare]]>>

<<signature [[Http_date.string_of_ht]]>>

<<signature [[Http_date.tm_of_ht]]>>
<<signature [[Http_date.stamp_of_ht]]>>

<<signature [[Http_date.ht_of_stamp]]>>
@


\subsection*{[[http/http_date.ml]]}


%-------------------------------------------------------------

<<http/http_date.ml>>=
<<copyright header v6>>

open Printf
open Unix

open Date

<<type [[Http_date.http_time]]>>

<<function [[Http_date.expired]]>>

<<function [[Http_date.compare]]>>

<<function [[Http_date.string_of_ht]]>>

<<function [[Http_date.tm_of_ht]]>>

<<function [[Http_date.stamp_of_ht]]>>


<<function [[Http_date.ht_of_stamp]]>>
@


\subsection*{[[http/messages.mli]]}



%-------------------------------------------------------------

<<http/messages.mli>>=
<<copyright header v6>>

(* HTTP Messages *)

<<type [[Messages.request]]>>

<<type [[Messages.status]]>>

<<type [[Messages.header]]>>


(* HTTP messages: requests and responses
 *  What a client sends to a server is called a request 
 *  What a server answers is called a response
 *)

<<type [[Messages.request_message]]>>

<<type [[Messages.response_message]]>>

@


\subsection*{[[http/http_headers.mli]]}


<<signature [[Http_headers.location]]>>=
val location : Messages.header list -> string
  (* Location *)
@


<<signature [[Http_headers.rem_contentencoding]]>>=
val rem_contentencoding : Messages.header list -> Messages.header list
@

<<signature [[Http_headers.status_msg]]>>=
val status_msg : Messages.header list -> string
@


<<signature [[Http_headers.status_message]]>>=
val status_message : int -> string
  (* [status_message n] returns Reason-Phrase for code [n] *)
@



<<signature [[Http_headers.hints]]>>=
val hints : string -> Messages.header list
@


%-------------------------------------------------------------

<<http/http_headers.mli>>=

<<exception [[Http_headers.Invalid_HTTP_header]]>>

<<signature [[Http_headers.parse_status]]>>

<<signature [[Http_headers.parse_request]]>>

<<signature [[Http_headers.get_header]]>>

<<signature [[Http_headers.get_multi_header]]>>

<<signature [[Http_headers.merge_headers]]>>

<<signature [[Http_headers.remove_headers]]>>

<<signature [[Http_headers.header_type]]>>


<<signature [[Http_headers.contenttype]]>>
<<signature [[Http_headers.contentlength]]>>
<<signature [[Http_headers.contentencoding]]>>
<<signature [[Http_headers.location]]>>
<<signature [[Http_headers.challenge]]>>
<<signature [[Http_headers.proxy_challenge]]>>
<<signature [[Http_headers.expires]]>>

<<signature [[Http_headers.rem_contentencoding]]>>

<<signature [[Http_headers.status_msg]]>>

<<signature [[Http_headers.http_status]]>>
<<signature [[Http_headers.status_message]]>>

(* 
 * Details for specific headers
 *)

<<type [[Http_headers.authScheme]]>>

<<type [[Http_headers.authChallenge]]>>

<<type [[Http_headers.media_parameter]]>>
<<type [[Http_headers.media_type]]>>

<<type [[Http_headers.hint]]>>

<<signature [[Http_headers.hints]]>>

<<signature [[Http_headers.read_suffix_file]]>>
@


\subsection*{[[http/http_headers.ml]]}



<<function [[Http_headers.status_msg]]>>=
let rec status_msg = function
    [] -> raise Not_found
  | s::l -> if String.length s >= 5 (* "HTTP/" *)
          && (String.sub s 0 5) = "HTTP/"
         then (parse_status s).status_message
         else status_msg l
@

<<constant [[Http_headers.is_contentencoding]]>>=
let is_contentencoding =
  let l = String.length "Content-Encoding" in
  (fun s ->
       String.length s >= l + 2
    && String.lowercase_ascii (String.sub s 0 (l+2)) = "content-encoding: ")
@

<<function [[Http_headers.rem_contentencoding]]>>=
let rec rem_contentencoding = function
   [] -> []
 | h::l when is_contentencoding h -> l
 | x::l -> x :: rem_contentencoding l
@











%-------------------------------------------------------------

<<http/http_headers.ml>>=
open Printf
open Str
open Mstring
open Messages

<<exception [[Http_headers.Invalid_HTTP_header]]>>

<<function [[Http_headers.parse_status]]>>

(* Request-Line = Method SP Request-URI SP HTTP-Version CRLF *)
<<function [[Http_headers.parse_request]]>>


<<function [[Http_headers.get_header]]>>

<<function [[Http_headers.get_multi_header]]>>

<<function [[Http_headers.header_type]]>>

<<function [[Http_headers.merge_headers]]>>

<<function [[Http_headers.remove_headers]]>>

<<function [[Http_headers.status_msg]]>>


<<functions [[Http_headers.xxx]] [[get_header]] applications>>
let location = 
  get_header "location"
let challenge = 
  get_header "www-authenticate"
let proxy_challenge = 
  get_header "proxy-authenticate"

let expires hs =
  try Some (Lexdate.ht_of_string (get_header "expires" hs))
  with
     Not_found -> None
   | _ -> Log.f ("warning: Can't parse Expires header ");
      None 

<<constant [[Http_headers.is_contentencoding]]>>

<<function [[Http_headers.rem_contentencoding]]>>



(* 
 * Details for specific headers
 *)

<<type [[Http_headers.authScheme]]>>

<<type [[Http_headers.authChallenge]]>>

<<type [[Http_headers.media_parameter]]>>
<<type [[Http_headers.media_type]]>>

<<type [[Http_headers.hint]]>>

<<constant [[Http_headers.suffixes]]>>

<<function [[Http_headers.read_suffix_file]]>>

<<constant [[Http_headers.default_hints]]>>

(* Even if we don't have a suffix file... *)
<<toplevel [[Http_headers._1]]>>

<<function [[Http_headers.hints]]>>



<<constant [[Http_headers.status_messages]]>>
<<toplevel [[Http_headers._2]]>>

<<function [[Http_headers.status_message]]>>

<<function [[Http_headers.http_status]]>>


@


\subsection*{[[http/auth.mli]]}



%-------------------------------------------------------------

<<http/auth.mli>>=

<<type [[Auth.authSpace]]>>


<<signature [[Auth.lifetime]]>>
<<signature [[Auth.auth_file]]>>

val edit_backend: (unit -> unit) ref

(* pad: only for edit_backend *)
type authEntry = {
   auth_cookie : string;
   mutable auth_lastused : float
   }
val authorizations: (authSpace, authEntry) Hashtbl.t

<<signature [[Auth.edit]]>>
<<signature [[Auth.load]]>>
<<signature [[Auth.save]]>>

<<signature [[Auth.add]]>>
<<signature [[Auth.get]]>>

<<signature [[Auth.init]]>>

val open_passwd_ref: (string -> string * string) ref

<<signature [[Auth.check]]>>
@


\subsection*{[[http/auth.ml]]}



%-------------------------------------------------------------

<<http/auth.ml>>=
(* HTTP Basic Authentication *)
open I18n

open Unix
open Http_headers

open Www

<<type [[Auth.authSpace]]>>

<<type [[Auth.authEntry]]>>

<<constant [[Auth.authorizations]]>>


<<function [[Auth.get]]>>

<<constant [[Auth.lifetime]]>>


<<function [[Auth.lookup]]>>

let open_passwd_ref = ref (fun _ -> failwith "no Auth.open_passswd defined")
<<function [[Auth.ask_cookie]]>>

<<function [[Auth.replace]]>>
  

<<function [[Auth.add]]>>

<<function [[Auth.check]]>>

let edit_backend = ref (fun _ -> failwith "no Auth.edit defined") 

(* Authorisation control *)
<<function [[Auth.edit]]>>

<<constant [[Auth.auth_file]]>>

<<function [[Auth.save]]>>

<<function [[Auth.load]]>>


<<function [[Auth.init]]>>
       
@


\subsection*{[[http/lexheaders.mli]]}


%-------------------------------------------------------------

<<http/lexheaders.mli>>=

<<signature [[Lexheaders.media_type]]>>
<<signature [[Lexheaders.challenge]]>>

@

\subsection*{[[http/lexheaders.mll]]}

<<http/lexheaders.mll>>=
{
open Http_headers


(* 
    CHAR = ['\000'-'\126']
    CTL  = ['\000'-'\031' '\127']
    CHAR except CTL = ['\032'-'\126']
    tspecials = ['(' ')' '<' '>' '@' ',' ';' ':' '\\' '"' '/' '[' ']' '?' '=' 
                 ' ' '\t']
*)

}

rule challenge = parse
 | [^ ' ' '\t' '\r' '\n']+
    { let scheme_name = String.lowercase_ascii (Lexing.lexeme lexbuf) in
      let scheme = 
    match scheme_name with
      "basic" -> AuthBasic
    | _ -> AuthExtend scheme_name in
      let _ = lws lexbuf in
      let _ = starlws lexbuf in
      let realm = realm lexbuf in
      let params = authparam lexbuf in
        { challenge_scheme = scheme;
      challenge_realm = realm;
      challenge_params = params}
    }

 | _ { raise (Invalid_HTTP_header "auth-scheme expected")}

and quotedstring = parse
   '"' [^ '"' '\000'-'\031' '\127'-'\255' ]* '"'
     { let t = Lexing.lexeme lexbuf in
         String.sub t 1 (String.length t - 2)
     }
 
 | _ { raise (Invalid_HTTP_header "quotedstring expected") }

<<function [[Lexheaders.token]]>>

<<function [[Lexheaders.value]]>>
 
(* LWS *)
and lws = parse
   ("\r\n")? [' ' '\t']+ { () }
  | _ { raise (Invalid_HTTP_header "LWS expected")}

<<function [[Lexheaders.starlws]]>>

and realm = parse
   ['R' 'r']['E' 'e']['A' 'a']['L' 'l']['M' 'm']'='
     { quotedstring lexbuf }
 | _ { raise (Invalid_HTTP_header "realm expected") }


and authparam = parse
   ',' 
    { let _ = starlws lexbuf in
      let t = token lexbuf in
      let _ = lit_equal lexbuf in
      let qt = quotedstring lexbuf in
      let _ = starlws lexbuf in
        (t,qt) :: authparam lexbuf
    }
 | "" { [] }

<<function [[Lexheaders.lit_equal]]>>

and lit_slash = parse
    '/' { () }
 |  _  { raise (Invalid_HTTP_header "= expected") }


<<function [[Lexheaders.media_parameters]]>>

<<function [[Lexheaders.media_type]] lexer>>

{

<<function [[Lexheaders.media_type]]>>

}
@


\subsection*{[[http/retype.mli]]}



%-------------------------------------------------------------

<<http/retype.mli>>=
<<signature [[Retype.f]]>>

@


\subsection*{[[http/retype.ml]]}



%-------------------------------------------------------------

<<http/retype.ml>>=
open Document
open Http_headers

<<function [[Retype.f]]>>


@


\subsection*{[[http/http.mli]]}


%-------------------------------------------------------------

<<http/http.mli>>=

<<exception [[Http.End_of_headers]]>>

<<signature [[Http.read_headers]]>>

<<exception [[Http.HTTP_error]]>>

<<signature [[Http.req]]>>

<<signature [[Http.proxy_xxx]]>>

<<signature [[Http.proxy_req]]>>

val always_proxy: bool ref
val send_referer: bool ref
val user_agent: string ref
val timeout: int ref
val verbose: bool ref
@

\subsection*{[[http/http.ml]]}


%-------------------------------------------------------------

<<http/http.ml>>=
(* Retrieve an HTTP document *)
open I18n
open Unix
open Www
open Hyper
open Auth
open Document
open Feed
open Messages
open Http_headers
open Url

<<constant [[Http.always_proxy]]>>
<<constant [[Http.timeout]]>>

<<global [[Http.proxy]]>>
<<global [[Http.proxy_port]]>>

<<constant [[Http.verbose]]>>

<<exception [[Http.HTTP_error]]>>

<<type [[Http.status]]>>

<<class [[Http.cnx]]>>


<<function [[Http.tcp_connect]]>>

<<constant [[Http.send_referer]]>>
<<constant [[Http.user_agent]]>>

<<function [[Http.std_request_headers]]>>

<<function [[Http.full_request]]>>


<<function [[Http.failed_request]]>>


(*
 *  Process an HTTP request asynchronously
 *)

<<exception [[Http.End_of_headers]]>>

<<function [[Http.read_headers]]>>


<<function [[Http.process_response]]>>

(* The same for HTTP 0.9, so we directly call the continuation *)
and process_response09  wwwr cont cnx =
   let dh =
       { document_id = document_id wwwr;
         document_referer = wwwr.www_link.h_context;
         document_status = 200;
         dh_headers = ["Content-Type: text/html"];
         document_feed = Feed.of_fd cnx#fd;
         document_fragment = wwwr.www_fragment;
         document_logger = tty_logger} 
   in
   cnx#set_status Discharged;
   cont.document_process dh

<<function [[Http.async_request]]>>


(* wrappers for request/response transaction *)
<<function [[Http.start_request]]>>

and start_request09 proxy_mode wwwr cont cnx =
  async_request proxy_mode wwwr (process_response09 wwwr cont) cnx


<<function [[Http.proxy_request]]>>

and proxy_request09 wr cont =
  tcp_connect !proxy !proxy_port wr.www_logging
          (start_request09 true wr cont)
          (failed_request wr cont.document_finish)

<<function [[Http.request]]>>

and request09 wr cont =
  if !always_proxy 
  then proxy_request09 wr cont
  else 
    let urlp = wr.www_url in
    if urlp.protocol = HTTP then
      let host = 
        match urlp.host with
        | Some h -> h 
        | _ -> raise (HTTP_error (s_ "Missing host in url"))
      in
      let port = 
        match urlp.port with
        | Some p -> p
        | None -> 80  (* default http port *)
      in
      try 
       tcp_connect host port wr.www_logging
        (start_request09 false wr cont)
        (failed_request wr cont.document_finish)
      with HTTP_error _ ->
        tcp_connect !proxy !proxy_port wr.www_logging
               (start_request09 true wr cont)
              (failed_request wr cont.document_finish)
    else 
      raise (HTTP_error (s_ "INTERNAL ERROR\nHttp.request09 (not a distant http url): %s" (Url.string_of wr.www_url)))

(* Wrappers returning the abort callback *)
<<function [[Http.req]]>>
<<function [[Http.prox_req]]>>
@




\section{[[protocols/]]}

\subsection*{[[protocols/cache.mli]]}


<<signature [[Cache.history_mode]]>>=
val history_mode : bool ref
@
<<signature [[Cache.max_documents]]>>=
val max_documents : int ref
@
<<signature [[Cache.cleann]]>>=
val cleann : int ref
@




<<type [[Cache.cache_fill]]>>=
type cache_fill = {
  cache_write : string -> int -> int -> unit;
  cache_close : unit -> unit
 }
@

<<exception [[Cache.DontCache]]>>=
exception DontCache
@

<<signature [[Cache.tofile]]>>=
val tofile : Document.handle -> Document.document_data * cache_fill
@


<<signature [[Cache.dummy]]>>=
val dummy : Document.handle  -> Document.document_data * cache_fill
@

<<signature [[Cache.discard]]>>=
val discard: cache_fill
@

<<signature [[Cache.wrap]]>>=
val wrap: cache_fill -> Document.handle -> Document.handle
@

<<signature [[Cache.patch]]>>=
val patch : Document.document_id -> string list -> unit
@

<<signature [[Cache.cutlinks]]>>=
val cutlinks : (Document.document_id -> unit) list ref
@

<<signature [[Cache.make_handle]]>>=
val make_handle : Www.request -> Document.document -> Document.handle
@

<<signature [[Cache.renew_handle]]>>=
val renew_handle : Document.handle -> Document.handle
@

<<signature [[Cache.make_embed_handle]]>>=
val make_embed_handle : Document.document -> Document.handle
@


%-------------------------------------------------------------

<<protocols/cache.mli>>=
(* Document and image cache *)

<<signature [[Cache.debug]]>>
<<signature [[Cache.history_mode]]>>
<<signature [[Cache.max_documents]]>>
<<signature [[Cache.cleann]]>>

<<signature [[Cache.init]]>>

<<signature [[Cache.add]]>>
<<signature [[Cache.find]]>>
<<signature [[Cache.finished]]>>
<<signature [[Cache.touch]]>>
<<signature [[Cache.kill]]>>

<<signature [[Cache.postmortem]]>>

<<type [[Cache.cache_fill]]>>

<<exception [[Cache.DontCache]]>>

<<signature [[Cache.tofile]]>>
<<signature [[Cache.tobuffer]]>>
<<signature [[Cache.dummy]]>>

<<signature [[Cache.discard]]>>
<<signature [[Cache.wrap]]>>

<<signature [[Cache.patch]]>>

<<signature [[Cache.cutlinks]]>>

<<signature [[Cache.make_handle]]>>
<<signature [[Cache.renew_handle]]>>
<<signature [[Cache.make_embed_handle]]>>
@


\subsection*{[[protocols/cache.ml]]}


<<constant [[Cache.history_mode]]>>=
let history_mode = ref false
  (* history mode means that we keep only the documents present in some
     navigator window. This mode is meant to be used in conjunction with
     a caching proxy *)
@


<<constant [[Cache.cutlinks]]>>=
(* A list of operations to do when we remove a document from the cache. *)
let cutlinks = ref []
@

<<type [[Cache.cache_fill]] ([[protocols/cache.ml]])>>=
type cache_fill = {
  cache_write : string -> int -> int -> unit;
  cache_close : unit -> unit
 }
@


<<exception [[Cache.DontCache]] ([[protocols/cache.ml]])>>=
exception DontCache
@




<<function [[Cache.internal_kill]]>>=
(* Kills a document: stop and destroy all its dinfo
 * The caller is responsible for possible removing the document itself
 * from the memory.
 *)
let internal_kill did _e =
   (* Remove pointers to in-lined images and other goodies *)
   List.iter (fun f -> f did) !cutlinks
@

<<function [[Cache.make_room]]>>=
let make_room () =
  if !debug then Log.f "Trying to make room in cache";
  (* Sort.list according to lru *)
  memory := List.sort 
            (fun (_,e) (_,e') -> Stdlib.compare e.cache_lastused e'.cache_lastused)
         !memory;
  (* if the more recent entry has lu max_lastused, then we have to augment 
     the cache, since this means that only pending connexions are
     in the cache *)
  begin match !memory with
    [] -> ()
  | (_,e)::_l ->
     if e.cache_lastused = max_lastused then max_documents := !max_documents + 5
     else (* cleanup the oldests entries *)
       let rec rem1 n l = 
        if n = 0 then l
     else match l with
       [] -> []
    | (did, e)::l ->
         internal_kill did e;
         decr current;
         rem1 (n-1) l
        in
      memory := rem1 !cleann !memory
  end;
  if !debug then begin
     Log.f (sprintf "Cache size(max): %d(%d)" !current !max_documents);
     Log.f "Cache contents:";
     postmortem()
  end
@

<<function [[Cache.finalize]]>>=
(* Remove the document source. *)
let finalize = function
   FileData (f, true) -> Msys.rm f
 | _ -> () (* gc ! *)
@

<<function [[Cache.kill_entry]]>>=
(* kill: removes a document from the cache
 *   Used by Reload. It can fail to find url in memory !
 *   It can also be used to remove something from the file cache
 *)
let kill_entry did e =
  if !debug then
    Log.f (sprintf  "Killing cache entry %s(%d)"
         (Url.string_of did.document_url)
         did.document_stamp);
  internal_kill did e;	(* kill dinfo in all windows *)
  finalize e.cache_document.document_data;	(* remove source *)
  memory := Mlist.except_assoc did !memory;
  decr current
@

<<function [[Cache.kill]]>>=
let kill did =
  try
    let e = List.assoc did !memory in
      kill_entry did e
  with
    Not_found -> ()
@


<<function [[Cache.finished]]>>=
(* since they have lu = max_lastused *)
let finished did =
  if !debug then
     Log.f (sprintf "%s completed" (Url.string_of did.document_url));
  try
    let entry = List.assoc did !memory in
      entry.cache_lastused <- Unix.time();
      entry.cache_pending <- false;
      Condition.set entry.cache_condition
  with
    Not_found -> ()
@

<<function [[Cache.touch]]>>=
let touch did =
  try
    let entry = List.assoc did !memory in
      entry.cache_lastused <- max (Unix.time()) entry.cache_lastused
  with
    Not_found -> ()
@

<<function [[Cache.patch]]>>=
(* Patch the headers of an existing entry *)
let patch did headers =
  try
    let entry = List.assoc did !memory in
    let newd = {
      document_address = entry.cache_document.document_address;
      document_data = entry.cache_document.document_data;
      document_headers = 
        merge_headers entry.cache_document.document_headers headers
      } in
     entry.cache_document <- newd;
    entry.cache_lastused <- max (Unix.time()) entry.cache_lastused
  with
    Not_found -> () (* is this an error ? *)
@


<<function [[Cache.tofile]]>>=
(* Cache savers *)
let tofile _dh =
  let f = Msys.mktemp "mmmcache" in
  let oc = open_out_bin f in
    FileData (f,true), 
      {cache_write = (fun s n1 n2 -> output oc (Bytes.of_string s) n1 n2);
       cache_close = (fun () -> close_out oc)}
@


<<constant [[Cache.discard]]>>=
let discard =
    {cache_write = (fun _buf _offs _len -> ());
     cache_close = (fun () -> ())}
@

<<function [[Cache.dummy]]>>=
(* Pseudo-caching for documents that can be obtained from the local
   file system. Relies on trailing slash for directories !
 *)

let dummy dh =
  let url = dh.document_id.document_url in
   match url.protocol with
     FILE -> 
       begin match url.path with
     None -> tobuffer dh
       | Some "" -> tobuffer dh
       | Some p ->
      if p.[String.length p - 1] = '/' then tobuffer dh
      else FileData ("/"^p, false), discard
       end
   | _ -> raise DontCache
@

<<function [[Cache.replace]]>>=
let _replace = function
   MemoryData b ->
    Ebuffer.reset b; 
    {cache_write = Ebuffer.output b; cache_close = (fun () -> ())}
 | FileData (f, _) ->
  let oc = open_out_bin f in
    {cache_write = (fun s n1 n2 -> output oc (Bytes.of_string s) n1 n2);
     cache_close = (fun () -> close_out oc)}
@

<<function [[Cache.wrap]]>>=
(* Wrap a feed with cache saving *)
let wrap c dh = 
  let wfeed = {
    feed_read = 
      (fun buf offs len ->
        let r = dh.document_feed.feed_read buf offs len in
     if r <> 0 then c.cache_write (Bytes.to_string buf) offs r;
     r);
    feed_schedule = dh.document_feed.feed_schedule;
    feed_unschedule = dh.document_feed.feed_unschedule;
    feed_close =
      (fun () ->
        dh.document_feed.feed_close();
     c.cache_close();
     finished dh.document_id);
    feed_internal = dh.document_feed.feed_internal
    }
  in
  { dh with document_feed = wfeed }
@

<<function [[Cache.fd_of_doc]]>>=
(* This is stupid: to display a source that we have in the cache, we must
 * save it to disk in order to get a file descriptor...
 *)

let fd_of_doc doc =
  match doc.document_data with
    MemoryData buf ->
      let f = Msys.mktemp "mmmbuf" in
      let oc = open_out f in
      output_string oc (Ebuffer.get buf);
      close_out oc;
      let fd = openfile f [O_RDONLY] 0 in
      Msys.rm f;
      fd
  | FileData (f,_) -> openfile f [O_RDONLY] 0
@

<<function [[Cache.make_handle]]>>=
let make_handle wwwr doc =
  { document_id = { document_url = wwwr.www_url; document_stamp = no_stamp};
    document_referer = wwwr.www_link.h_context;
    document_status = 200;
    dh_headers = doc.document_headers;
    document_feed = Feed.of_fd (fd_of_doc doc);
    document_fragment = wwwr.www_fragment;
    document_logger = tty_logger}
@

<<function [[Cache.renew_handle]]>>=
(* The same, if we kept the old dh *)
let renew_handle dh =
  let did = dh.document_id in
  let doc = find did in
  { document_id = dh.document_id;
    document_referer = dh.document_referer;
    document_status = dh.document_status;
    dh_headers = doc.document_headers;
    document_feed = Feed.of_fd (fd_of_doc doc);
    document_fragment = dh.document_fragment;
    document_logger = dh.document_logger}
@

<<function [[Cache.make_embed_handle]]>>=
(* Same for embedded objects (but we don't have wwwr handy) *)
let make_embed_handle doc =
  let fd =
    match doc.document_data with
      MemoryData buf ->
    let f = Msys.mktemp "mmmbuf" in
      let oc = open_out f in
        output_string oc (Ebuffer.get buf);
        close_out oc;
    let fd = openfile f [O_RDONLY] 0 in
      Msys.rm f;
      fd
    | FileData (f,_) -> openfile f [O_RDONLY] 0
  in
    {document_id = 
    { document_url = doc.document_address; document_stamp = no_stamp};
     document_referer = None;
     document_status = 200;
     dh_headers = doc.document_headers;
     document_feed = Feed.of_fd fd;
     document_fragment = None;
     document_logger = tty_logger}
@

<<function [[Cache.cleanup]]>>=
let cleanup () =
  List.iter 
    (fun (_did, entry) ->
      match entry.cache_document.document_data with
       FileData (f, true) -> Msys.rm f
      | _ -> ())
    !memory
@

<<toplevel [[Cache._1]]>>=
let _ = at_exit cleanup
@


%-------------------------------------------------------------

<<protocols/cache.ml>>=
(* Document caching (in memory !) *)
open Printf
open Unix
open Url
open Www
open Hyper
open Document
open Feed
open Http_headers

<<constant [[Cache.debug]]>>
<<constant [[Cache.history_mode]]>>

<<constant [[Cache.max_lastused]]>>

(* The max values refer documents kept in memory *)
let max_documents = ref 30
and cleann = ref 5
and current = ref 0

<<constant [[Cache.cutlinks]]>>

<<type [[Cache.cache_fill]] ([[protocols/cache.ml]])>>

<<type [[Cache.entry]]>>

<<exception [[Cache.DontCache]] ([[protocols/cache.ml]])>>

<<constant [[Cache.memory]]>>

<<function [[Cache.postmortem]]>>


<<function [[Cache.find]]>>

<<function [[Cache.internal_kill]]>>

<<function [[Cache.make_room]]>>


<<function [[Cache.finalize]]>>

<<function [[Cache.kill_entry]]>>

<<function [[Cache.kill]]>>

<<function [[Cache.add]]>>



(* Pending documents should never be removed from the cache *)
<<function [[Cache.finished]]>>

<<function [[Cache.touch]]>>

<<function [[Cache.patch]]>>

<<function [[Cache.init]]>>


<<function [[Cache.tofile]]>>

<<function [[Cache.tobuffer]]>>

<<constant [[Cache.discard]]>>

<<function [[Cache.dummy]]>>

<<function [[Cache.replace]]>>

<<function [[Cache.wrap]]>>

(* Obtain a dh from a cache entry *)
<<function [[Cache.fd_of_doc]]>>

<<function [[Cache.make_handle]]>>

<<function [[Cache.renew_handle]]>>


<<function [[Cache.make_embed_handle]]>>

   
<<function [[Cache.cleanup]]>>

<<toplevel [[Cache._1]]>>
@


\subsection*{[[protocols/file.mli]]}



%-------------------------------------------------------------

<<protocols/file.mli>>=
<<signature [[File.request]]>>
<<exception [[File.File_error]]>>

(* pad: for tk_file.ml *)
val binary_path: string list ref

<<signature [[File.pref_init]]>>
<<signature [[File.pref_set]]>>
@


\subsection*{[[protocols/file.ml]]}


% ???
<<signature [[File.pref_init]]>>=
@
<<signature [[File.pref_set]]>>=
@


<<function [[File.pref_init]]>>=
@

<<function [[File.pref_set]]>>=
@

<<constant [[File.r]]>>=
let _r = Str.regexp ":"
@

%-------------------------------------------------------------

<<protocols/file.ml>>=
(* The file: protocol *)
open I18n
open Printf
open Unix
open Filename

open Hyper
open Www
open Url
open Messages
open Http_headers
open Http
open Document
open Feed

<<exception [[File.File_error]]>>

<<function [[File.isdir]]>>

<<function [[File.d2html]]>>

<<function [[File.dir]]>>
  

<<function [[File.document_id]]>>

<<function [[File.fake_cgi]]>>

<<constant [[File.binary_path]]>>
<<constant [[File.r]]>>
<<function [[File.pref_init]]>>
<<function [[File.pref_set]]>>

<<function [[File.is_cgi]]>>
<<function [[File.request]]>>
@


\subsection*{[[protocols/mailto.ml]]}

%-------------------------------------------------------------

<<protocols/mailto.ml>>=
(* mailto: *)
open I18n

open Unix
open Www
open Hyper
open Url

<<constant [[Mailto.mailer]]>>

<<type [[Mailto.msg]]>>

<<function [[Mailto.error]]>>

<<function [[Mailto.sendmail]]>>

<<global [[Mailto.internal_backend]]>>

<<function [[Mailto.internal]]>>
   
<<function [[Mailto.get]]>>

<<function [[Mailto.f]]>>
@


\subsection*{[[protocols/protos.mli]]}

%-------------------------------------------------------------

<<protocols/protos.mli>>=

<<signature [[Protos.get]]>>
@

\subsection*{[[protocols/protos.ml]]}

%todo: no protos.mli?


%-------------------------------------------------------------

<<protocols/protos.ml>>=
open Url

<<constant [[Protos.protos]]>>

<<toplevel [[Protos._1]]>>
<<toplevel [[Protos._2]]>>
<<toplevel [[Protos._3]]>>
<<toplevel [[Protos._4]]>>
<<toplevel [[Protos._5]]>>
<<toplevel [[Protos._6]]>>
<<toplevel [[Protos._7]]>>

<<constant [[Protos.get]]>>
@


\section{[[retrieve/]]}

\subsection*{[[retrieve/progress.mli]]}



%-------------------------------------------------------------

<<retrieve/progress.mli>>=
<<signature [[Progress.no_meter]]>>
<<signature [[Progress.meter]]>>
@


\subsection*{[[retrieve/progress.ml]]}



%-------------------------------------------------------------

<<retrieve/progress.ml>>=
<<constant [[Progress.no_meter]]>>

<<function [[Progress.meter]]>>
@


\subsection*{[[retrieve/retrieve.mli]]}


%-------------------------------------------------------------

<<retrieve/retrieve.mli>>=
(* Document retrieval *)

<<type [[Retrieve.retrievalStatus]]>>

<<signature [[Retrieve.f]]>>

<<type [[Retrieve.behaviour]]>>

<<signature [[Retrieve.add_http_processor]]>>
@


\subsection*{[[retrieve/retrieve.ml]]}



%-------------------------------------------------------------

<<retrieve/retrieve.ml>>=
(* Document retrieval *)
open I18n
open Printf
open Www
open Hyper
open Url
open Document
open Http
open Http_headers
open Auth

<<type [[Retrieve.retrievalStatus]]>>

<<type [[Retrieve.behaviour]]>>

<<constant [[Retrieve.http_process]]>>

<<constant [[Retrieve.add_http_processor]]>>

<<function [[Retrieve.wrap_cache]]>>

<<function [[Retrieve.http_check]]>>

<<function [[Retrieve.f]]>>


(* In all the following, we avoid popping up dialog boxes, and use
 * wwwr logging instead. Otherwise we might get too verbose for
 * in-lined images...
 *)

<<function [[Retrieve.code200]]>>

<<function [[Retrieve.code204]]>>

<<function [[Retrieve.forward]]>>

<<function [[Retrieve.forward_permanent]]>>

(* 304 : Response to a conditional GET, the document is not modified
let update wr dh =
   Cache.patch dh.document_id dh.dh_headers;
   Stop (s_ "Document %s has not changed.\n" (Url.string_of wr.www_url))
Because of recursive update, this has moved elsewhere.
*)

<<function [[Retrieve.code400]]>>

<<function [[Retrieve.ask_auth]]>>

<<function [[Retrieve.unauthorized]]>>

<<function [[Retrieve.ask_proxy_auth]]>>

<<function [[Retrieve.proxy_unauthorized]]>>

<<toplevel [[Retrieve._1]]>>
@


\subsection*{[[retrieve/img.mli]]}

<<signature [[Img.gif_anim_load]]>>=
val gif_anim_load : bool ref
@



%-------------------------------------------------------------

<<retrieve/img.mli>>=
open Document
<<signature [[Img.gif_anim_load]]>>

module ImageData : sig
  type t = Tkanim.imageType

  val gamma : float ref
  val jpeg_converter : string ref
  val verbose : bool ref

  val load : handle -> document_id list -> string -> Tkanim.imageType
  val cache_access : Url.t -> document_id -> Tkanim.imageType
  val error :
      Url.t -> (document_id * ((Url.t -> Tkanim.imageType -> unit) * Scheduler.progress_func)) list -> unit
    val error_msg : Www.request * string -> unit
    val remove_reference : document_id -> unit
    val dump: unit -> unit
  end

module ImageScheduler : Scheduler.S with
    type shared_data = ImageData.t

<<signature [[Img.get]]>>
<<signature [[Img.update]]>>
@


\subsection*{[[retrieve/img.ml]]}

<<constant [[Img.gif_anim_load]]>>=
(* Images are a special case of embedded data, because Tk caches them
   internally. Thus, we attempt to maintain our own cache logic above
   Tk's one 
 *)

let gif_anim_load = ref false
@

<<toplevel [[Img._1]]>>=
(* Advertise ourselfs to the internal cache *)
let _ =
 Cache.cutlinks := ImageData.remove_reference :: !Cache.cutlinks
@



%-------------------------------------------------------------

<<retrieve/img.ml>>=
(* Image cache and scheduled image downloading *)
open Printf

open Tk
open Tkanim

open Document
open Www


open Http_headers

<<constant [[Img.gif_anim_load]]>>

module ImageData =
  struct
    
    type t = Tkanim.imageType

    let gamma = ref 1.0
    let jpeg_converter = ref "djpeg"
    let verbose = ref false

   (* 
    * The image cache
    *)


    let set_of_list l = List.fold_right DocumentIDSet.add l DocumentIDSet.empty

    (* url -> (option for tk configure, set of referers, headers) *)
    let img_cache = 
       (Hashtbl.create 53 : (Url.t, 
                 Tkanim.imageType * DocumentIDSet.t ref
                   * string list) Hashtbl.t)

    (* Debugging *)
    let dump () =
      Hashtbl.iter (fun url (_,r, _) ->
       Log.f (sprintf "IMG %s" (Url.string_of url));
    DocumentIDSet.iter 
         (fun did -> Log.f (sprintf "\tref: %s"
                         (Url.string_of did.document_url)))
         !r)
    img_cache

    let add url imgdesc referers headers =
      Hashtbl.add img_cache url (imgdesc, ref (set_of_list referers), headers)

    (* Raises Not_found *)
    let cache_access url from =
      let img, refs, _ = Hashtbl.find img_cache url in
    refs := DocumentIDSet.add from !refs;
    img

    let direct_cache_access  = Hashtbl.find img_cache

    (* Delete an image from the cache *)
    let delete_image img =
      if !verbose then Log.f (sprintf "Removing img %s" (Url.string_of img));
      match Hashtbl.find img_cache img with
    Still x, _, _ ->
      begin match x with
        Bitmap _ -> ()
      | ImageBitmap n ->
          Imagebitmap.delete n; Hashtbl.remove img_cache img
      | ImagePhoto n ->
          Imagephoto.delete n; Hashtbl.remove img_cache img
      | _ -> assert false
      end
      |	Animated anm, _, _ -> Tkanim.delete anm; Hashtbl.remove img_cache img

    (* Remove reference to an image, clean *)
    let remove_reference referer =
      if !verbose then 
     Log.f (sprintf "Removing img references from %s(%d)" 
            (Url.string_of referer.document_url)
             referer.document_stamp);
      let delete_them = ref [] in
      Hashtbl.iter
    (fun img (_o, refs, _) ->
        refs := DocumentIDSet.remove referer !refs;
        if DocumentIDSet.is_empty !refs then
         delete_them := img :: !delete_them)
    img_cache;
      List.iter delete_image !delete_them

    let broken_data = Still (Bitmap (Predefined "error"))

    (* load an image *)
    (* For GIFs, we use JPF's Tkanim package first *)
    let tk_load_gif file =
      try
    if !gif_anim_load then Tkanim.create file
    else Still (ImagePhoto (Imagephoto.create [File file; Gamma !gamma]))
      with Protocol.TkError _ -> broken_data

    (* For JPEG, we attempt internal load first, because we might have
       an extension for loading them *)
    let tk_load_jpeg file =
      try Still (ImagePhoto (Imagephoto.create [File file; Gamma !gamma]))
      with Protocol.TkError _ ->
    let pnmfile = Msys.mktemp "pnm" in
    let cmd = (!jpeg_converter^" "^file^" > "^pnmfile) in
    try match Sys.command cmd with
      0 ->
        let img = Still (ImagePhoto (Imagephoto.create
                     [File pnmfile; Gamma !gamma])) in
        Msys.rm pnmfile;
        img
    | _ -> Msys.rm pnmfile; broken_data
    with
      Protocol.TkError _ ->
        Msys.rm pnmfile;
        Still (Bitmap (Predefined "question"))

    (* other formats *)
    let tk_load_other file =
      Still (
        try ImageBitmap (Imagebitmap.create [File file])
    with
      Protocol.TkError _ ->
        try ImagePhoto (Imagephoto.create [File file; Gamma !gamma])
        with
         Protocol.TkError _ -> Bitmap (Predefined "question"))

    let load dh referers file =
      Retype.f dh;
      match dh.document_status with
    200 ->
      let url = dh.document_id.document_url in
      let img = 
        try
          let ctype = contenttype dh.dh_headers in
          match Lexheaders.media_type ctype with
           ("image","jpeg"), _ -> Low.busy tk_load_jpeg file
          | ("image","gif"), _ -> Low.busy tk_load_gif file
          | _,_ -> Low.busy tk_load_other file
        with
        | Not_found -> Low.busy tk_load_other file 
        | Invalid_HTTP_header _ -> Msys.rm file; broken_data
          in
      if !verbose then
        Log.f (sprintf "Loaded %s as %s" file (Url.string_of url));
      Msys.rm file;
      add url img referers dh.dh_headers;
      img
      |	304 -> (* we did an update an a document, and it induced a 
          recursive update. The document didn't change *)
      begin try 
        Msys.rm file;
        cache_access dh.document_id.document_url (List.hd referers)
      with
        Not_found -> broken_data
      end
        
      | _ -> (* other cases *)
      Msys.rm file; broken_data
      
      (* error during img downloading *)
    let error url job =
      Log.f (sprintf "Could not load image at %s" (Url.string_of url));
      let img = Still (Bitmap (Predefined "error")) in
      add url img (List.map fst job) [];
      List.iter (fun (_, (cont,_)) -> cont url img) job
    
      (* Invalid urls in images are silently ignored *)
    let error_msg (w, msg) = 
      Log.f (sprintf "Invalid image request: %s (%s)" 
           (Url.string_of w.www_url) msg);
      
  end
    

module ImageScheduler = Scheduler.Make(ImageData)


<<toplevel [[Img._1]]>>

<<function [[Img.get]]>>

<<function [[Img.update]]>>

@


\subsection*{[[retrieve/scheduler.mli]]}




%-------------------------------------------------------------

<<retrieve/scheduler.mli>>=
(*
 * Certain kind of documents need to be shared, such as in-lined images.
 * In this case, instead of working with Retrieve.f and the normal
 * document continuation, we queue the request to a scheduler, with a
 * continuation to be applied to an object representing the shared 
 * information for that document.
 * E.G: for in-lined images, the shared information is the Tk-handle to
 * the image.
 *)


<<signature [[Scheduler.debug]]>>

<<type [[Scheduler.progress_func]]>>

module type Data =
  sig
   type t
        (* Type of shared objects
         * The table of objects in managed in this module
         *)
   val load : Document.handle -> Document.document_id list -> string -> t
        (* [load dh referers file]
         *   is responsible for creating the shared handle
         *)
   val cache_access : Url.t -> Document.document_id -> t
        (* [cache_access url referer]
         *   attempts to find a shared handle for an URL.
         *   Raises Not_found
         *)       	     
   val error : 
        Url.t -> 
      (Document.document_id * ((Url.t -> t -> unit) * progress_func)) list -> unit
        (* [error url [(did,(cont,progress))]]
         *  if an error occurs, then each pending continuation is called
         *  (if necessary) as required (e.g. with "default" information)
         *)
   val error_msg : Www.request * string -> unit
       (* Retrieval produces Invalid_url *)
  end
   

module type S =
  sig
    type shared_data
    val add_request : Www.request -> Document.document_id ->
                      (Url.t -> shared_data -> unit) -> progress_func -> unit
        (* [add_request delayed wr referer cont progress_func]
         *   returns job handle that can subsequently by awakened
         *)

    val stop : Document.document_id -> unit
        (* [stop did]
         *   stops jobs for which did is the only referer
         *)

    (* Delayed queues for this scheduler *)
    type delayed
    val new_delayed : unit -> delayed
    val add_delayed : 
       delayed -> Www.request -> Document.document_id -> 
            (Url.t -> shared_data -> unit) -> progress_func -> unit
    val flush_delayed : delayed -> unit
    val flush_one : delayed -> Url.t -> unit
    val is_empty : delayed -> bool
    val maxactive : int ref
    val maxsamehost : int ref
  end


module Make(J : Data):(S with type shared_data = J.t)
@


\subsection*{[[retrieve/scheduler.ml]]}


%-------------------------------------------------------------

<<retrieve/scheduler.ml>>=
(* Scheduled downloading *)
open Printf
open Unix
open Www
open Document
open Url
open Feed

open Http_headers

<<constant [[Scheduler.debug]]>>

<<type [[Scheduler.progress_func]]>>

(* Handling of data downloaded by this scheduler *)
module type Data =
  sig
   type t

   val load : handle -> document_id list -> string -> t
        (* [load dh referers file] *)
   val cache_access : Url.t -> document_id -> t
        (* [cache_access url referer] *)       	     
   val error : Url.t -> 
      (document_id * ((Url.t -> t -> unit) * progress_func)) list ->  unit
        (* [error url conts] *)
   val error_msg : (Www.request * string) -> unit
       (* Retrieval produces Invalid_url *)
  end
   

module type S =
  sig
    type shared_data
    val add_request : 
       Www.request -> document_id -> (Url.t -> shared_data -> unit) -> 
      progress_func -> unit
        (* [add_request wwwr ref_did cont progress_func] *)
    val stop : document_id -> unit
        (* [stop ref_did] *)

    (* Delayed queues for this scheduler *)
    type delayed
    val new_delayed : unit -> delayed
    val add_delayed : 
       delayed -> Www.request -> document_id -> 
      (Url.t -> shared_data -> unit) -> progress_func -> unit
    val flush_delayed : delayed -> unit
    val flush_one : delayed -> Url.t -> unit
    val is_empty : delayed -> bool
    val maxactive : int ref
    val maxsamehost : int ref
  end   


module Make(J: Data) = struct

  type shared_data = J.t

  let maxactive = ref 10
  let maxsamehost = ref 2

  (* A job is: a list of referers, with the continuations *)
  type job = {
      mutable stop : unit -> unit;
      mutable conts : (document_id * 
             ((Url.t -> shared_data -> unit) * progress_func)) list;
      mutable bytes_loaded : int;
      mutable contentlength : int option  
    }

  (* The list of active requests : this is used to share the requests
     for all jobs on the same Url. *)
  let active = ref 0
  and actives = (Hashtbl.create 11 : (Url.t, job) Hashtbl.t)

  (* We need a two-level queue system, so that 
     1- we respect the image loading order for each document
     2- we can use maxactive connexions
     3- there is a max of maxsamehost connexions on the same host
     *)
    
  let samehost = (Hashtbl.create 11 : (string, int ref) Hashtbl.t)
    (* count of cnx on each host (IP number is best choice), but for
       performance reason (DNS lookups), we take FQDN *)

  let addhost url =
    let s = match url.host with Some s -> s | None -> "" in
    try
      let count = Hashtbl.find samehost s in
      if !count < !maxsamehost then (incr count; true) else false
    with
      Not_found -> 
    Hashtbl.add samehost s (ref 1);
    true (* assumes maxsamehost >= 1 *)

  let remhost url =
    let s = match url.host with Some s -> s | None -> "" in
    try 
      let r = Hashtbl.find samehost s in
      decr r;
      if !r <= 0 then Hashtbl.remove samehost s
    with Not_found -> () (* that's an error actually *)

  type queue = (request * document_id * (Url.t -> shared_data -> unit) * progress_func ) Queue.t
    (* queue for one batch of docs *)

  let queues = (ref [] : queue list ref)
    (* pending queues for documents *)

  (* How we pick the next request *)
      
  exception Busy

  let skip_cache wr =
    try
      get_header "pragma" wr.www_headers = "no-cache" 
    with
      Not_found -> false

  let pick() =
    let pick_in_batch q =
      try
    let (wr,_,_,_) = Queue.peek q in
    let url = wr.www_url in
    if addhost url then Some (Queue.take q) else None
      with
    Queue.Empty -> (* this batch is empty *)
      raise Queue.Empty
    in
    let rec walk_batches remaining = function
      | [] ->
      (* we've reached the end : reset the remaining scheduled jobs *)
      queues := List.rev remaining;
      raise Busy
      |	x::l -> 
      try match pick_in_batch x with
      | Some r -> r
      | None -> (* nothing pickable yet, look further *)
          walk_batches (x::remaining) l
      with Queue.Empty -> (* this queue is empty ! *)
        walk_batches remaining l
    in
    walk_batches [] !queues

  (* Whenever we add something in the queue, we must call this *)
  (* Whenever a job finished, we must call this *)
  let rec next_request () =
    if !active < !maxactive then
      try
        let j = pick() in
        process_request j;
        next_request() (* check if more can be done *)
      with
        Busy -> ()

  (* when adding a request individually (meant to be treated ASAP), we
     use a new singleton queue *)
  and add_request wr did cont prog =
    let q = Queue.create() in
    Queue.add (wr, did, cont, prog) q;
    queues := q :: !queues;
    next_request()

  (* error during data downloading *)
  and error url job =
    job.stop();
    J.error url job.conts;
    if !debug then 
      Log.f (sprintf "Retrieval of %s failed\n" (Url.string_of url));
    next_request()

  (* process_request always follows pick, thus hostcount has always been
   * incremented for the URL of this request *)
  and process_request (wr, did, cont, prog) =
    try (* if we are in the cache of shared objects, apply continuation *)
      if skip_cache wr then raise Not_found
      else begin
       let data = J.cache_access wr.www_url did in
       remhost wr.www_url; (* we're done *)
       cont wr.www_url data
      end
    with
      Not_found ->
        (* find out if we are in the active jobs *)
        let url = wr.www_url in
        try
          let oldjob = Hashtbl.find actives url in
      (* then add a new continuation *)
          oldjob.conts <- (did, (cont, prog)) :: oldjob.conts;
      remhost wr.www_url;       (* we're done *)
        with
          Not_found -> begin (* start a new job *)
            if !debug then
              Log.f (sprintf "Starting job for %s" (Url.string_of url));
            let job = {
              stop = (fun () ->
        Hashtbl.remove actives url;
        decr active;
        remhost url);
              conts =  [did, (cont, prog)];
              contentlength = None;
          bytes_loaded = 0
            } in
            (* Add to set of active *)
            incr active;
            Hashtbl.add actives url job;

           (* We are now going to run the retrieval process *)

           (* Continuations for the retrieval *)
            let handle_data dh =
          (* add more things to do in stop *)
          let oldstop = job.stop in
          job.stop <- (fun () -> dclose true dh; oldstop());
              try
                (* open the temporary file in which doc is to be saved *)
                let file = Msys.mktemp "data" in
                let oc = open_out file 
                and buffer = Bytes.create 2048 in

        (* JPF HACK -- for Image retrieval progress meter *)
        begin try 
          job.contentlength <-
            Some (Http_headers.contentlength dh.dh_headers)
        with
          Not_found -> ()
        end;

        (* actually start sucking data *)
                dh.document_feed.feed_schedule (fun _ ->
          try
            let n = dh.document_feed.feed_read buffer 0 2048 in

            (* JPF HACK -- for Image retrieval progress meter *)
            job.bytes_loaded <- job.bytes_loaded + n;
              List.iter (fun (_,(_,prog)) -> 
                prog job.contentlength job.bytes_loaded) 
                  job.conts;

            if n <> 0 then output oc buffer 0 n
            else begin (* end of document *)
              dclose true dh; (* see comment below *)
              close_out oc;
              (* proceed to load and run continuations *)
              let referers = List.map fst job.conts in
              begin
            try 
                         let data = J.load dh referers file in
              List.iter (fun (_referer,(cont,_)) -> 
                try Printexc.print 
                (cont dh.document_id.document_url) data
                with _ -> flush Stdlib.stderr)
                           job.conts
            with (* load failed *)
              e -> 
                Log.f (sprintf "Load error %s" 
                                          (Printexc.to_string e));
                           J.error url job.conts
              end;
              (* we must remove from active only after 
             loading because otherwise, if loading is interactive,
             there could be a moment during which the document 
             is not marked as loaded, but not active either.
             This would cause multiple retrievals.
             But then dh has to be closed otherwise the
             callback will we called indefinitely *)
              oldstop();
              if !debug then
            Log.f (sprintf "Finished job for %s" 
                           (Url.string_of url));
              (* proceed with more requests *)
              next_request()
            end
          with (* errors in retrieval *)
            Unix_error(code,s,s') -> 
              Log.f (sprintf "Unix error (%s) in scheduler %s %s"
                         (error_message code) s s');
              close_out oc;
              error url job
                 | Sys_error s ->
              Log.f (sprintf "IO error (%s) in scheduler" s);
                     close_out oc;
              error url job
                 | e -> 
              Log.f (sprintf "Bug in scheduler %s"
                         (Printexc.to_string e));
                     close_out oc;
              error url job)
              with (* error creating tmp file *)
        Sys_error s -> 
          Log.f (sprintf "Can't create temporary file (%s)" s);
                 error url job
          | e -> 
          Log.f (sprintf "Bug in scheduler %s" (Printexc.to_string e));
          error url job

           (* Data has moved. The best way to do this properly is to 
              reschedule the job conts as new requests *)
        and retry_data hlink =
          try
        job.stop();
        let newr = Www.make hlink in
        newr.www_error <- wr.www_error;
        newr.www_logging <- wr.www_logging;
        List.iter (fun (did,(cont,prog)) ->
          add_request newr did cont prog)
          job.conts
          with (* can't proceed with retry *)
        _ -> error url job
            in
       (* Okay, go for the retrieval now *)
        try 
          match Retrieve.f wr retry_data
               {document_process = handle_data;
                document_finish = (fun f -> if f then error url job)}
              with
        Retrieve.Started _ -> ()
          | Retrieve.InUse ->
          (* somebody else has started a request bypassing the
             scheduler, dammit. Our only hope is that he's going
             to set the cache properly, so we can reschedule 
             ourself and try later *)
          job.stop();
          List.iter (fun (did,(cont,prog)) -> 
            add_request wr did cont prog)
            job.conts
        with
          Invalid_request(w,msg) -> (* retrieve failed *)
            J.error_msg (w,msg);
        error url job
      end 



  (*
   * And now, various utilities
   *)

  (* remove pending requests whose referer is did *)
  let stop did =
    (* For all queues, for all request in the queue, if the request matches
       the predicate, it is removed from the queue. *)
    queues := 
       List.map (fun q ->
     let newq = Queue.create () in
     Queue.iter (function
       | (_wr, didr, _cont, _progress) when did = didr -> ()
       | r -> Queue.add r newq)
       q;
     newq)
     !queues;

    (* If the request is active, remove the particular continuation, and if it
       was the only continuation, kill the job
    *)
    let rem = ref [] in (* jobs to kill *)
    Hashtbl.iter 
      (fun _url job ->
    try 
      job.conts <- Mlist.except_assoc did job.conts;
      if job.conts = [] then rem := job :: !rem
    with
      Not_found -> ())
      actives;
    (* each stop closes the cnx properly and remove the job from actives *)
    List.iter (fun job -> job.stop()) !rem;
    if !rem <> [] then next_request()

  
  (*
   * Delayed queues
   *)
  type delayed = queue

  let new_delayed = Queue.create

  let is_empty q = 
    try Queue.peek q |> ignore; false with Queue.Empty -> true

  (* add a new request in the queue *)
  (* Actually, if the document is already in the cache, then process
     the continuation *)
  let add_delayed q wr did cont progress =
    try 
      if skip_cache wr then raise Not_found
      else cont wr.www_url (J.cache_access wr.www_url did)
    with Not_found -> Queue.add (wr,did,cont,progress) q

  (* Put the queue in the list of queues *)
  let flush_delayed q =
    (* Queue.iter (function (_,_,_,prog) -> prog None 0) q;(* create the gauge *) *)
    queues := !queues @ [q];
    next_request()

  (* Flush a particular request from a queue : we do it in place 
     because we don't know if the queue has been put in the list yet
   *)
  let flush_one l url =
    let flushedqueue = Queue.create()
    and restqueue = Queue.create() in
    (* split in two *)
    Queue.iter (function
      | (wr,did,cont,prog) when wr.www_url = url ->
      prog None 0; (* create the gauge *)
      Queue.add (wr,did,cont,prog) flushedqueue
      | r -> Queue.add r restqueue)
      l;
    (* the flushed goes at the beginning *)
    queues := flushedqueue :: !queues;
    (* copy back the remaining in l (MUST BE THE SAME l) *)
    Queue.clear l;
    Queue.iter (fun r -> Queue.add r l) restqueue;
    (* try to process the flushed items *)
    next_request()

end
@


\section{[[viewers/]]}

\subsection*{[[viewers/decoders.mli]]}



%-------------------------------------------------------------

<<viewers/decoders.mli>>=
(* Decoders *)

<<signature [[Decoders.insert]]>>
<<signature [[Decoders.add]]>>

@


\subsection*{[[viewers/decoders.ml]]}


<<function [[Decoders.gzip]]>>=
(* Note: we must use the feed interface to read from the old dh,
 * and not read directly from the feed_internal file descriptor, because
 * the feed might implement side effects (such as caching).
 * Since we are reading and writing to the same process, we might get
 * deadlocked if we don't watch writes.
 *)
let gzip dh =
  let (gread, mwrite) = pipe()
  and (mread, gwrite) = pipe()
  in
  Unix.set_close_on_exec mread;
  Unix.set_close_on_exec mwrite;
  
  match Low.fork() with
    0 ->  
      dup2 gread stdin; dup2 gwrite stdout;
      Munix.execvp "gunzip" [| "gunzip"; "-c" |]
      (* dh (* fake *) *)
  | _n ->  
      close gread; close gwrite;
     (* it is safe to close feed because the son has a copy *)
      let newdh =
       { dh with 
         dh_headers = rem_contentencoding dh.dh_headers;
         document_feed = Feed.of_fd mread;
       }
      in
      let buffer = Bytes.create 4096 in
      let rec copy () =
      try
        let n = dh.document_feed.feed_read buffer 0 4096 in
            if n = 0 then (dclose true dh; close mwrite)
            else begin
          dh.document_feed.feed_unschedule();
          Fileevent.add_fileoutput mwrite
        (fun () -> 
          ignore (write mwrite buffer 0 n);
          Fileevent.remove_fileoutput mwrite;
          dh.document_feed.feed_schedule copy)
        end
      with
        Unix_error(_e,_,_) -> dclose true dh; close mwrite
      in
      dh.document_feed.feed_schedule copy;
      newdh
@


<<constant [[Decoders.add]]>>=
let add = Hashtbl.add decoders
@

<<function [[Decoders.insert]]>>=
let insert dh =
(* CERN proxy sets Content-Encoding when return code = 500 ! *)
  if dh.document_status >= 400 then dh else
  try
    Hashtbl.find decoders (String.uppercase_ascii (contentencoding dh.dh_headers)) dh
  with
    Not_found -> dh
  | Unix_error(_,_,_) -> dh
@


%-------------------------------------------------------------

<<viewers/decoders.ml>>=
open Unix
open Document
open Feed
open Http_headers

<<constant [[Decoders.decoders]]>>

<<function [[Decoders.gzip]]>>
  

<<toplevel [[Decoders._1]]>>

<<constant [[Decoders.add]]>>

<<function [[Decoders.insert]]>>

@


\subsection*{[[viewers/embed.mli]]}





%-------------------------------------------------------------

<<viewers/embed.mli>>=
module EmbeddedScheduler : Scheduler.S with
  type shared_data = Document.document

<<signature [[Embed.add_viewer]]>>

<<signature [[Embed.rem_viewer]]>>

<<type [[Embed.embobject]]>>

<<signature [[Embed.add]]>>
<<signature [[Embed.update]]>>
@


\subsection*{[[viewers/embed.ml]]}



<<constant [[Embed.embedded]]>>=
(* Remember all current embedded objects by their frame *)
let embedded = (Hashtbl.create 101 : (string, embobject) Hashtbl.t)
@

<<function [[Embed.add_embed]]>>=
(* add and notify *)
let add_embed emb = 
  Hashtbl.add embedded (Widget.name emb.embed_frame) emb;
  Frx_synth.send "setembed" emb.embed_frame
@

<<function [[Embed.when_destroyed]]>>=
(* when the frame gets destroyed, remove us from the table *)
let when_destroyed w =
  Hashtbl.remove embedded (Widget.name w)
@

<<toplevel [[Embed._1]]>>=
let _ =
  Protocol.add_destroy_hook when_destroyed
@

<<function [[Embed.add]]>>=
(* Queueing an embed *)
let add ({ embed_hlink = link;
       embed_frame = frame;
       embed_context = embed_ctx;
       embed_map = _m;
       embed_alt = alt_txt} as emb) =
  (* Put up the ALT text *)
  List.iter Tk.destroy (Winfo.children frame);
  pack [Label.create_named frame "alt" [Text alt_txt]][];
  (* Check if the type is defined and a viewer available *)
  try
   let given_type = List.assoc "type" embed_ctx#params in
   let ((typ,subtyp), parms) = Lexheaders.media_type given_type in
   try
     let viewer = 
       try Hashtbl.find embedded_viewers (typ,subtyp)
       with Not_found -> Hashtbl.find embedded_viewers (typ, "*")
     in
       EmbeddedScheduler.add_request
       (Www.make link)
       (embed_ctx#base)
       (* the continuation: it will receive the document *)
       (fun _url doc ->
     let doc = {
       document_address = doc.document_address;
       document_data = doc.document_data;
       document_headers = Http_headers.merge_headers doc.document_headers
                        ["Content-Type: " ^ given_type]
       }  in
         (* Destroy the alt window *)
     List.iter Tk.destroy (Winfo.children frame);
     (* Add to our table/notify *)
     add_embed emb;
     viewer parms frame embed_ctx doc)
       (Tk_progress.meter frame)
   with
     Not_found -> (* no viewer for this *)
      let t = s_ "Embed Error: no viewer for type %s" given_type in
      pack[Label.create frame [Text t]][]
   | Invalid_request (w,msg) ->
       let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
       pack [Message.create frame [Text t]][]
   | Invalid_link _err ->
       let t = s_ "Embed Error: invalid link" in
       pack [Message.create frame [Text t ]][]
  with
     Not_found -> (* not type given, we have to retrieve to know *)
       (* Firing the request *)
       try
     EmbeddedScheduler.add_request
     (Www.make link)
     (embed_ctx#base)
     (* the continuation: it will receive the document *)
     (* In general, we don't know the type before we get the document *)
     (fun _url doc -> embedded_viewer frame embed_ctx doc)
     (Tk_progress.meter frame)
       with
     Invalid_request (w,msg) ->
       let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
       pack [Message.create frame [Text t]][]
       | Invalid_link _err ->
       let t = s_ "Embed Error: invalid link" in
       pack [Message.create frame [Text t ]][]
@

<<function [[Embed.update]]>>=
let update frame embed_ctx doc notchanged =
  try
    (* find the date of previous download, (or last-modified ?) *)
    let date_received = get_header "date" doc.document_headers in
    let rewrite_wr wr =
      wr.www_headers <- 
     ("If-Modified-Since: "^date_received) :: wr.www_headers;
      wr.www_headers <- "Pragma: no-cache" :: wr.www_headers;
      wr
    in
    let link = Hyper.default_link (Url.string_of doc.document_address) in
    (* wrapped viewer : decide if we need to redisplay or not *)
    let smart_viewer stdviewer frame embed_ctx newdoc =
      let newdate = 
    try get_header "date"  newdoc.document_headers with Not_found -> "foo"
      in if newdate <> date_received then begin
    List.iter Tk.destroy (Winfo.children frame);
    stdviewer frame embed_ctx newdoc
      end else notchanged()
    in
  (* Check if the type is defined and a viewer available *)
    try
      let given_type = List.assoc "type" embed_ctx#params in
      let ((typ,subtyp), parms) = Lexheaders.media_type given_type in
      try
      let viewer = 
      try Hashtbl.find embedded_viewers (typ,subtyp)
      with Not_found -> Hashtbl.find embedded_viewers (typ, "*")
      in
       EmbeddedScheduler.add_request
       (rewrite_wr (Www.make link))
       (embed_ctx#base)
       (* the continuation: it will receive the document *)
       (fun _url doc ->
     let doc = {
       document_address = doc.document_address;
       document_data = doc.document_data;
       document_headers = Http_headers.merge_headers doc.document_headers
                        ["Content-Type: " ^ given_type]
       }  in
     smart_viewer (viewer parms) frame embed_ctx doc)
       (Tk_progress.meter frame)
      with
      Not_found -> (* no viewer for this *)
      let t = s_ "Embed Error: no viewer for type %s" given_type in
      pack[Label.create frame [Text t]][]
      | Invalid_request (w,msg) ->
      let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
      pack [Message.create frame [Text t]][]
      | Invalid_link _err ->
      let t = s_ "Embed Error: invalid link" in
      pack [Message.create frame [Text t ]][]
    with
      Not_found -> (* not type given, we have to retrieve to know *)
       (* Firing the request *)
        try
      EmbeddedScheduler.add_request
        (rewrite_wr (Www.make link))
        (embed_ctx#base)
     (* the continuation: it will receive the document *)
     (* In general, we don't know the type before we get the document *)
        (fun _url doc -> smart_viewer embedded_viewer frame embed_ctx doc)
        (Tk_progress.meter frame)
        with
      Invalid_request (w,msg) ->
        let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
        pack [Message.create frame [Text t]][]
        | Invalid_link _err ->
        let t = s_ "Embed Error: invalid link" in
        pack [Message.create frame [Text t ]][]
  with
    Not_found -> (* Document has no Date: header *)
      notchanged() 
@


%-------------------------------------------------------------

<<viewers/embed.ml>>=
(* Embedded documents *)
open I18n
open Tk
open Document
open Www
open Hyper

open Http_headers

(* Assume any kind of data could be embedded 
 * The normal retrieval, used by the scheduler, makes its own decision
 * about the need to cache the document (basically, it caches html and text)
 * Thus, we want to decide here if we want to cache documents retrieved
 * via Embed.
 *)
module EmbeddedData =
  struct

    type t = document

    let cache_access url _referer =
      let did =  {document_url = url; document_stamp = no_stamp} in
      (* look in the cache *)
      Cache.find did

    (* The document is here in the file. Either it's been cached, and
       then we just get its cache value, or we add it to the cache 
       dh is closed; we use only the headers
       NOTE: if we are updating over an old version, fix the cache
     *)
    let load dh referers file =
      Retype.f dh;
      match dh.document_status with
    200 ->
      begin try 
        let doc = Cache.find dh.document_id in
        let this_date = get_header "date" dh.dh_headers in
        let cache_date = get_header "date" doc.document_headers in
        if this_date <> cache_date then raise Not_found
        else doc
      with
        Not_found ->
          let doc = { document_address = dh.document_id.document_url;
                 document_data = FileData (file, true);
                 document_headers = dh.dh_headers} in
          Cache.add dh.document_id doc;
          Cache.finished dh.document_id;
          doc
      end
      |	304 -> (* return the previous version *)
      begin try 
        Msys.rm file;
        cache_access dh.document_id.document_url (List.hd referers)
      with
        Not_found -> failwith "load"
      end

      |	_ -> failwith "load"

    let error url _jobs = 
      Error.f (s_ "Can't find embedded document %s"  (Url.string_of url))

    let error_msg (_,_) = ()
  end


(* The embedded data scheduler *)
module EmbeddedScheduler = Scheduler.Make(EmbeddedData)


<<constant [[Embed.embedded_viewers]]>>
let add_viewer = Hashtbl.add embedded_viewers 
and rem_viewer = Hashtbl.remove embedded_viewers


<<function [[Embed.embedded_viewer]]>>


<<type [[Embed.embobject]]>>

<<constant [[Embed.embedded]]>>

<<function [[Embed.add_embed]]>>

<<function [[Embed.when_destroyed]]>>
<<toplevel [[Embed._1]]>>

<<function [[Embed.add]]>>


<<function [[Embed.update]]>>
@


\subsection*{[[viewers/save.mli]]}


<<signature [[Save.transfer]]>>=
val transfer : Www.request -> Document.handle -> (Unix.file_descr * bool) option -> unit
@

<<signature [[Save.tofile]]>>=
val tofile : (string -> unit) -> Document.handle -> string -> string -> unit
@

<<signature [[Save.document]]>>=
val document : Document.document_id -> string option -> unit
@

<<signature [[Save.print_command]]>>=
val print_command : string ref
@


%-------------------------------------------------------------

<<viewers/save.mli>>=
<<signature [[Save.interactive]]>>
<<signature [[Save.transfer]]>>
<<signature [[Save.tofile]]>>


<<signature [[Save.document]]>>
<<signature [[Save.print_command]]>>
@


\subsection*{[[viewers/save.ml]]}

<<function [[Save.f]]>>=
(* unprotected against Sys_error *)
let f cont dh fname endmsg =
  let oc = open_out_bin fname in
  let buffer = Bytes.create 1024 in
  let red = ref 0 in
  let size =   
    try Http_headers.contentlength dh.dh_headers
    with Not_found -> 40000 (* duh *)
  in
  dh.document_feed.feed_schedule
    (fun () ->
      try
    let n = dh.document_feed.feed_read buffer 0 1024 in
    if n = 0 then begin
      dclose true dh;
      close_out oc;
      Document.end_log dh endmsg;
      cont fname (* cont is responsible for deleting fname *)
    end
    else begin
          output oc buffer 0 n;
         red := !red + n;
      Document.progress_log dh (!red * 100 / size)
    end
      with
    Unix_error(_,_,_) | Sys_error _ ->
      dclose true dh;
      close_out oc;
      Document.destroy_log dh false;
      Msys.rm fname;
      Error.f (s_ "Error during retrieval of %s" 
                     (Url.string_of dh.document_id.document_url))
     )
@

<<function [[Save.tofile]]>>=
(* Used for external viewers in batch mode. Deprecated *)
let tofile cont dh fname endmsg =
  try
    f cont dh fname endmsg
  with Sys_error msg -> 
    dclose true dh;
    Document.destroy_log dh false;
    Error.f (s_ "Cannot save to %s\n(%s)" fname msg)
@


<<function [[Save.transfer]]>>=
let transfer wr dh dest =
  wr.www_logging (s_ "Saving...");
  match dest with
    None -> interactive (fun _s -> wr.www_logging "") dh
  | Some (fd, flag) ->
      (* if flag we should output the headers as well *)
      if flag then begin
    dh.dh_headers |> List.rev |> List.iter (fun h -> 
      Munix.write_string fd h; Munix.write_string fd "\n"
    );
    Munix.write_string fd "\n";
      end;
      let buffer = Bytes.create 1024 in
      dh.document_feed.feed_schedule
       (fun () ->
      try
        let n = dh.document_feed.feed_read buffer 0 1024 in
        if n = 0 then begin
          dclose true dh;
          close fd;
        end
     else ignore (write fd buffer 0 n)
    with
     Unix_error(_,_,_) | Sys_error _ ->
       dclose true dh;
       close fd;
       Error.f (s_"Error during retrieval of %s" 
                    (Url.string_of dh.document_id.document_url))
       )
@

<<function [[Save.save_from_string]]>>=
let save_from_string url s f =
  try
    let oc = open_out_bin f in
    begin try
      output_string oc s;
      Error.ok (s_ "Document %s\nsaved in\n%s" (Url.string_of url) f)
    with Sys_error e ->
      Error.f (s_ "Cannot save to %s\n(%s)" f e)
   end;
   close_out oc
  with Sys_error e ->
    Error.f (s_ "Cannot save to %s\n(%s)" f e)
@

<<function [[Save.copy_file]]>>=
let copy_file url src dst =
  try
    let ic = open_in_bin src
    and oc = open_out_bin dst 
    and buf = Bytes.create 2048 in
    let rec copy () =
      let n = input ic buf 0 2048 in
      if n <> 0 then begin output oc buf 0 n; copy() end
    in
    begin try 
      copy();
      Error.ok (s_ "Document %s\nsaved in\n%s" (Url.string_of url) dst)
    with Sys_error e ->
      Error.f (s_ "Cannot save to %s\n(%s)" dst e)
    end;
    close_in ic; 
    close_out oc
  with Sys_error e ->
    Error.f (s_ "Cannot save to %s\n(%s)" dst e)
@

<<function [[Save.pipe_from_string]]>>=
(* Cmd can be composite. We add the URL at the end *)
let pipe_from_string url data cmd =
  let urls = Url.string_of url in
  try
    (* we have to open a pipe and write to it *)
    let fd_in, fd_out = pipe() in
    let len = String.length data and pos = ref 0 in
    (* now fork the command *)
    match Low.fork() with
      0 ->
    dup2 fd_in stdin; close fd_in; close fd_out;
    ignore (Munix.system_eval cmd ["URL", urls] false);
    exit 0
    | _n ->
    close fd_in;
       Fileevent.add_fileoutput fd_out (fun () ->
      if !pos < len then begin
        let n = min 512 (len - !pos) in
        try
          let w = write fd_out (Bytes.of_string data) !pos n in
          pos := !pos + w
        with
          Unix_error (_,_,_) -> (* can't write *)
        Fileevent.remove_fileoutput fd_out;
        close fd_out;
        Error.f (s_ "Error during |%s in %s" cmd urls)
      end else begin (* we're done *)
        Fileevent.remove_fileoutput fd_out;
        close fd_out
      end)
  with
  | Unix_error(_,_,_) -> (* pipe failed, fork failed *)
      Error.f (s_ "Can't execute command %s for %s" cmd urls)
@

<<function [[Save.pipe_from_file]]>>=
let pipe_from_file url f cmd =
  let urls = Url.string_of url in
  try
    (* just open the file and read from it *)
    match Low.fork() with
      0 ->
    let fd = openfile f [O_RDONLY] 0 in
    dup2 fd stdin; close fd;
    ignore (Munix.system_eval cmd ["URL", urls] false);
    exit 0
    | _n ->
    ()
  with Unix_error(_,_,_) -> (* pipe failed, fork failed *)
    Error.f (s_ "Can't execute command %s for %s" cmd urls)
@

<<function [[Save.document]]>>=
let document did arg =
  let open_selection_box act =
    Fileselect.f (s_ "Save or pipe to file")
      (function [] -> ()
             | [s] -> act s
          | _l -> raise (Failure "multiple selection"))
      "*" (* should be better *)
      (Filename.basename (Url.string_of did.document_url))
      false
      true
  in
  let proceed f = match arg with
    None -> open_selection_box f
  | Some s -> f s
  in
  try
    match Cache.find did with
      {document_data = MemoryData buf; _} ->
        proceed
      (fun s ->
        if String.length s <> 0 && s.[0] == '|' then
          pipe_from_string did.document_url (Ebuffer.get buf)
        (String.sub s 1 (String.length s - 1))
        else
          save_from_string did.document_url (Ebuffer.get buf) s)
      
    |  {document_data = FileData (f, _); _} ->
        proceed 
      (fun s ->
        if String.length s <> 0 && s.[0] == '|' then
          pipe_from_file did.document_url f 
        (String.sub s 1 (String.length s - 1))
        else
          copy_file did.document_url f s)
  with Not_found ->
    Error.f ("Document is not in cache.")
@

<<constant [[Save.print_command]]>>=
let print_command = ref ""
@


%-------------------------------------------------------------

<<viewers/save.ml>>=
open I18n

open Unix
open Document
open Url
open Www
open Feed

(* Save to file fname, and apply continuation cont to this file *)
<<function [[Save.f]]>>

<<function [[Save.tofile]]>>

<<function [[Save.interactive]]>>


<<function [[Save.transfer]]>>

<<function [[Save.save_from_string]]>>

<<function [[Save.copy_file]]>>


<<function [[Save.pipe_from_string]]>>


<<function [[Save.pipe_from_file]]>>

<<function [[Save.document]]>>
    
<<constant [[Save.print_command]]>>
@


\subsection*{[[viewers/viewers.mli]]}

<<type [[Viewers.hyper_func]]>>=
type hyper_func = {
  hyper_visible : bool;
  hyper_title : string;

  hyper_func : frame_targets -> Hyper.link -> unit
}
@


%-------------------------------------------------------------

<<viewers/viewers.mli>>=

<<type [[Viewers.vparams]]>>
<<type [[Viewers.frame_targets]]>>

<<type [[Viewers.hyper_func]]>>

(* list of additionnal parameters for the viewer, according to its
   activation point *)

<<signature class [[Viewers.context]]>>

<<signature class [[Viewers.display_info]]>>


<<signature [[Viewers.di_compare]]>>

<<type [[Viewers.t]]>>

<<signature [[Viewers.add_viewer]]>>
<<signature [[Viewers.rem_viewer]]>>
<<signature [[Viewers.add_builtin]]>>
<<signature [[Viewers.reset]]>>

(* !!! main entry point!!!! *)
<<signature [[Viewers.view]]>>


<<signature [[Viewers.frame_adopt]]>>
<<signature [[Viewers.frame_fugue]]>>

@


\subsection*{[[viewers/viewers.ml]]}

<<function [[Viewers.metamail]]>>=
(* Metamail options
   -b : not an RFC822 message
   -z : delete when finished 
   -x : not on a tty 
 *)
let metamail ctype file =
  ignore (Munix.system "metamail -b -z -x -c" [ctype; file] true)
@

<<function [[Viewers.extern_batch]]>>=
(* Batch version: we transfer everything and then run metamail *)
let _extern_batch dh ctype = 
  let outfile = Msys.mktemp "mmm" in
  Document.add_log dh (
    s_ "Saving %s\nfor external display with MIME type %s"
          (Url.string_of dh.document_id.document_url) ctype)
    (fun () -> Msys.rm outfile);
  let endmsg =
    s_ "Running metamail with MIME media-type: %s" ctype in
    Save.tofile (metamail ctype) (Decoders.insert dh) outfile endmsg
@



%-------------------------------------------------------------

<<viewers/viewers.ml>>=
(*
 * Multimedia
 *)
open Common
open I18n

open Document

(* The context given to a viewer *)
<<type [[Viewers.vparams]]>>
<<type [[Viewers.frame_targets]]>>

<<function [[Viewers.frame_adopt]]>>

<<function [[Viewers.frame_fugue]]>>

<<type [[Viewers.hyper_func]]>>

<<class [[Viewers.context]]>>

(* The object created/returned by a viewer *)
class  virtual display_info () =
 object (_self : 'a)
  (* boilerplate class decl *)
  <<[[Viewers.display_info]] virtual methods signatures>>
  <<[[Viewers.display_info]] graphic cache methods>>
end

<<function [[Viewers.di_compare]]>>

(* 
 * The default external viewer
 *)

<<function [[Viewers.metamail]]>>

<<function [[Viewers.extern_batch]]>>

<<function [[Viewers.extern]]>>

(*
 * Viewer control
 * Specify on the base of MIME type if we want to
 *   - use an internal displayer (assumed to exist)
 *   - use an external displayer (metamail or other)
 *   - save to file
 *)

(* Table of viewers, according to media-type (MIME)
 * Actually, this is only for internal viewers, since the rest
 * will be passed to metamail.
 *)

<<type [[Viewers.t]]>>

<<type [[Viewers.spec]]>>

<<constant [[Viewers.viewers]]>>

<<function [[Viewers.add_viewer]]>>

<<function [[Viewers.rem_viewer]]>>

<<function [[Viewers.unknown]]>>

<<function [[Viewers.interactive]]>>

<<function [[Viewers.view]]>>

<<constant [[Viewers.builtin_viewers]]>>
<<function [[Viewers.add_builtin]]>>

<<function [[Viewers.reset]]>>
    
@


\subsection*{[[viewers/plain.ml]]}



%-------------------------------------------------------------

<<viewers/plain.ml>>=
open Tk
open Unix
open Frx_text
open Document

open Feed

<<class [[Plain.plain]]>>

<<function [[Plain.display_plain]]>>

<<toplevel [[Plain._1]]>>
@


\section{[[display/]]}

\subsection*{[[display/attrs.mli]]}

<<signature [[Attrs.color_mappings]]>>=
val color_mappings : (string, string) Hashtbl.t
@

<<signature [[Attrs.html_color]]>>=
val html_color : string -> string
@

<<signature [[Attrs.circle_data]]>>=
val circle_data : string
@

<<signature [[Attrs.disc_data]]>>=
val disc_data : string
@

<<signature [[Attrs.square_data]]>>=
val square_data : string
@

<<signature [[Attrs.bullet_table]]>>=
val bullet_table : (string, Tk.options) Hashtbl.t
@

<<signature [[Attrs.init]]>>=
val init : string -> unit
@


%-------------------------------------------------------------

<<display/attrs.mli>>=
module TagSet : Set.S with type elt = string

class tags :
  Widget.widget ->
  object
    val mutable configured : TagSet.t
    val mutable decorations : (Tk.textTag * Tk.textIndex * Tk.textIndex) list
    val mutable onhold : (TagSet.elt * Tk.options list) list
    val wid : Widget.widget
    method add : Tk.textTag * Tk.textIndex * Tk.textIndex -> unit
    method change : TagSet.elt -> Tk.options list -> unit
    method define : TagSet.elt -> Tk.options list -> unit
    method flush : unit
  end

module LocMap :
  sig
    type key = Tk.index
    type 'a t
    val empty : 'a t
    val add : key * key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val find_interval : key -> 'a t -> key * key
  end

class anchortags :
  Widget.widget ->
  object
    val mutable anchor_table : Hyper.link LocMap.t
    val mutable configured : TagSet.t
    val mutable decorations : (Tk.textTag * Tk.textIndex * Tk.textIndex) list
    val mutable mappings : (Tk.textIndex * Tk.textIndex * Hyper.link) list
    val mutable onhold : (TagSet.elt * Tk.options list) list
    val wid : Widget.widget
    method add : Tk.textTag * Tk.textIndex * Tk.textIndex -> unit
    method add_anchor : Tk.textIndex -> Tk.textIndex -> Hyper.link -> unit
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method change : TagSet.elt -> Tk.options list -> unit
    method define : TagSet.elt -> Tk.options list -> unit
    method flush : unit
    method getlink : Tk.eventInfo -> Hyper.link
    method getrange : LocMap.key -> LocMap.key * LocMap.key
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end

class virtual ['a] nested :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> 'a -> unit
    method virtual pop_convert : 'a -> unit
    method push : Tk.textIndex -> 'a -> unit
    method virtual push_convert : 'a -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end

class align :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> string -> unit
    method pop_convert : string -> unit
    method push : Tk.textIndex -> string -> unit
    method push_convert : string -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end

class margin :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    val mutable current : int
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> int -> unit
    method pop_convert : int -> unit
    method push : Tk.textIndex -> int -> unit
    method push_convert : int -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end

class font :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    val mutable basefont : Fonts.fontDesc
    val mutable font_stack : Fonts.fontDesc list
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> Fonts.fontAttrs -> unit
    method pop_all : Tk.textIndex -> unit
    method pop_convert : Fonts.fontAttrs -> unit
    method push : Tk.textIndex -> Fonts.fontAttrs -> unit
    method push_convert : Fonts.fontAttrs -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
    method set_base : Tk.textIndex -> int -> unit
  end

<<signature [[Attrs.color_mappings]]>>
<<signature [[Attrs.html_color]]>>

class fgcolor :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> string -> unit
    method pop_convert : string -> unit
    method push : Tk.textIndex -> string -> unit
    method push_convert : string -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end

class bgcolor :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> string -> unit
    method pop_convert : string -> unit
    method push : Tk.textIndex -> string -> unit
    method push_convert : string -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end

class offset :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    val mutable cur_offset : int
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> int -> unit
    method pop_convert : int -> unit
    method push : Tk.textIndex -> int -> unit
    method push_convert : int -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end

class misc :
  < add : 'a * Tk.textIndex * Tk.textIndex -> unit; 
    define : 'a -> 'b -> 'c;
    .. > *
  'a * 'b ->
  object
    val mutable start_pos : Tk.textIndex
    val tagname : 'a
    method pop : Tk.textIndex -> unit
    method push : Tk.textIndex -> unit
  end

class spacing :
  < add : string * Tk.textIndex * Tk.textIndex -> unit;
    define : string -> Tk.options list -> unit; .. > ->
  object
    method pop : Tk.textIndex -> int -> unit
    method push : Tk.textIndex -> int -> unit
  end

<<signature [[Attrs.circle_data]]>>
<<signature [[Attrs.disc_data]]>>
<<signature [[Attrs.square_data]]>>
<<signature [[Attrs.bullet_table]]>>
<<signature [[Attrs.init]]>>
@


\subsection*{[[display/attrs.ml]]}

<<constant [[Attrs.color_mappings]]>>=
(* Special mapping of pre-defined HTML3.2 colors *)
let color_mappings = Hashtbl.create 37
@

<<toplevel [[Attrs._1]]>>=
let _ = List.iter (fun (name, value) -> Hashtbl.add color_mappings name value)
  [ "black",   "#000000";
    "silver",  "#c0c0c0";
    "gray",    "#808080";
    "white",   "#ffffff";
    "maroon",  "#800000";
    "red",     "#ff0000";
    "purple",  "#800080";
    "fuchsia", "#ff00ff";
    "green",   "#008000";
    "lime",    "#00ff00";
    "olive",   "#808000";
    "yellow",  "#ffff00";
    "navy",    "#000080";
    "blue",    "#0000ff";
    "teal",    "#008080";
    "aqua",    "#00ffff" ]
@

<<function [[Attrs.html_color]]>>=
let html_color s =
  try Hashtbl.find color_mappings (String.lowercase_ascii s)
  with Not_found -> s
@

<<constant [[Attrs.circle_data]]>>=
(* Bullet images *)
let circle_data = 
"#define circle_width 9
#define circle_height 9
static unsigned char circle_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x44, 0x00, 0x44, 0x00, 0x44, 0x00,
   0x38, 0x00, 0x00, 0x00, 0x00, 0x00};"
@

<<constant [[Attrs.disc_data]]>>=
let disc_data =
"#define disc_width 9
#define disc_height 9
static unsigned char disc_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00,
   0x38, 0x00, 0x00, 0x00, 0x00, 0x00};"
@

<<constant [[Attrs.square_data]]>>=
let square_data = 
"#define square_width 9
#define square_height 9
static unsigned char square_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00,
   0x7c, 0x00, 0x00, 0x00, 0x00, 0x00};"
@

<<constant [[Attrs.bullet_table]]>>=
let bullet_table = Hashtbl.create 11
@

<<function [[Attrs.init]]>>=
let init bg =
  let _bgTODO = Background (NamedColor bg) in
  Hashtbl.add bullet_table
     "circle" (ImageBitmap(Imagebitmap.create [Data circle_data]));
  Hashtbl.add bullet_table
     "disc" (ImageBitmap(Imagebitmap.create [Data disc_data]));
  Hashtbl.add bullet_table
     "square" (ImageBitmap(Imagebitmap.create [Data square_data]))
@


%-------------------------------------------------------------

<<display/attrs.ml>>=


(* Utilities for tags and attributes *)

open Printf
open Protocol
open Tk

open Fonts



(* Delayed and shared configuration of tags *)

module TagSet = Set.Make(struct type t = string let compare = compare end)

class tags (thtml) =
 object
  val mutable onhold = []
  val mutable configured = TagSet.empty
  val mutable decorations = []
  val wid = thtml

  (* define a new tag *)
  method define tagname attrs =
    if TagSet.mem tagname configured then ()
    else begin
      onhold <- (tagname,attrs) :: onhold;
      configured <- TagSet.add tagname configured
    end

  (* change a tag value *)
  method change tagname attrs =
    onhold <- (tagname,attrs) :: onhold;
    configured <- TagSet.add tagname configured

  method add deco =
    decorations <- deco :: decorations

  (* flush tag definitions *)
  method flush =
    onhold |> List.rev |> List.iter (fun (t,d) -> 
      try Text.tag_configure wid t d with TkError _ -> ());
    decorations |> List.rev |> List.iter (fun (t,d,e) -> 
      Text.tag_add wid t d e);
    onhold <- [];
    decorations <- []
end

module LocMap = Ibtree.Make(struct
  type t = index
  let compare = compare
  end)

class anchortags (thtml) =
 object (_self)
  inherit tags (thtml) as tags
  inherit Htbind.hypertext (thtml)

  val mutable mappings = []
  val mutable anchor_table = LocMap.empty

  method add_anchor s e h =
    tags#add ("anchor", s, e);
    mappings <- (s,e,h) :: mappings

  method! flush =
    tags#flush;
    mappings |> List.iter (fun (s,e,h) ->
      let loc1 = Text.index wid s
      and loc2 = Text.index wid e
      in
      anchor_table <- LocMap.add (loc1,loc2) h anchor_table
    );
    mappings <- []

  method getlink ei =
     (* The index of the click position *)
     let i = 
       Text.index thtml (TextIndex (AtXY (ei.ev_MouseX,ei.ev_MouseY), [])) in
     LocMap.find i anchor_table

  method getrange i = LocMap.find_interval i anchor_table

end


(* Conversion of moral attributes to Tk attributes.
 * This virtual class has to be instantiated for each converter.
 * 'a is an logical attribute description (or "delta")
 *)
class  virtual ['a] nested (tagdef) =
 object (self)
  val mutable last_change = TextIndex(LineChar(0,0),[])
  val mutable stack = []
  (* val tagdef = tagdef *)

  method virtual push_convert : 'a -> string * Tk.options list
  method virtual pop_convert : 'a -> unit

  method put current_pos tagname =
   if last_change <> current_pos then begin
     tagdef#add (tagname, last_change, current_pos);
     last_change <- current_pos
   end

  (* Push some new attribute. *)
  method push current_pos desc =
    let tag, attr = self#push_convert desc in
    tagdef#define tag attr;
    begin match stack with
       [] -> 
        (* no current definition, don't issue a put *)
        last_change <- current_pos
     | curtag::_l ->
        self#put current_pos curtag
    end;
    stack <- tag :: stack;

(* Doesn't check the nature of desc *)
  method pop current_pos (desc : 'a) =
     self#pop_convert desc;
     match stack with
       [] ->
        last_change <- current_pos
     | c::l ->
    stack <- l;
        self#put current_pos c
end

(* 
 * Alignment attribute is left/right/center
 *)
class align (tagdef) =
 object
  inherit [string] nested tagdef
  method push_convert ad =
    match String.lowercase_ascii ad with
     "right" -> "right", [Justify Justify_Right]
       | "center" -> "center", [Justify Justify_Center]
       | _ -> "left", [Justify Justify_Left]
  method pop_convert _ad = ()
end

(*
 * Margin attribute is cumulative
 *)
class margin (tagdef) =
 object
  inherit [int] nested tagdef
  val mutable current = 0
  method push_convert ad =
    current <- current + ad;
    sprintf "margin%d" current, 
    [LMargin1 (Pixels current); LMargin2 (Pixels current)]
  method pop_convert ad =
    current <- current - ad
end


(*
 * Font attributes
 *)

class font (tagdef) =
 object (self)
  inherit [fontInfo list] nested tagdef
  val mutable font_stack = []
  val mutable basefont = !Fonts.default
  method push_convert fil = 
    let curfd = match font_stack with
      [] -> basefont
    | x::_l -> x in
    let newfd = Fonts.merge curfd fil in
      font_stack <- newfd :: font_stack;
      Fonts.compute_tag newfd

  method pop_convert _ = 
    match font_stack with
      [] -> ()
    | _x::l -> font_stack <- l

  (* by changing the base, we should be changing both the current default size 
     and the behaviour of subsequent FONT SIZE tags. The size changes is easy.
     The header styles being defined with an absolute font, they are not 
     affected
     It's logical also to push this as the current font, but the problem
     is that it doesn't work because basefont do not obey nesting rules
     (consider <FONT> <BASEFONT> </FONT> !). We do deal with this situation.
   *)
  method set_base current_pos n =
    basefont <- { basefont with pxlsz= n };
    self#push current_pos [FontIndex n];

  method pop_all current_pos =
    while font_stack <> [] do
      self#pop current_pos []
    done

end


<<constant [[Attrs.color_mappings]]>>
<<toplevel [[Attrs._1]]>>

<<function [[Attrs.html_color]]>>

(*
 * Foreground color
 *)

class fgcolor (tagdef) =
 object
  inherit [string] nested tagdef 
  method push_convert s =
    let colordef = html_color s in
    if Frx_color.check colordef then
      s, [Foreground (NamedColor colordef)]
    else
      s, []
  method pop_convert _s = 
    ()
end

(*
 * Background color
 *)

class bgcolor (tagdef) =
 object
  inherit [string] nested tagdef 
  method push_convert s =
    let colordef = html_color s in
    if Frx_color.check colordef then
      s, [Background (NamedColor colordef)]
    else 
      s, []
  method pop_convert _s = 
    ()
end

(*
 * Super and sub script.
 * BOGUS: should depend on current font size
 *)
class offset (tagdef) =
 object
  inherit [int] nested tagdef
  val mutable cur_offset = 0
  method push_convert n =
    cur_offset <- cur_offset + n;
    sprintf "offset%d" cur_offset, [Offset (Pixels cur_offset)]
  method pop_convert n =
    cur_offset <- cur_offset - n
end
(* 
 * Other stuff where nesting is not important
*)
class misc (tagdef, tagname, attr) =
 object (_self)
  
  val mutable start_pos = TextIndex(LineChar(0,0),[])
  (* val tagdef = tagdef *)
  val tagname = 
     let _ = tagdef#define tagname  attr in
     tagname

  method pop current_pos =
   if start_pos <> current_pos then begin
     tagdef#add (tagname, start_pos, current_pos)
   end

  method push current_pos  =
     start_pos <- current_pos

end

(* 
 * Spacing is specific, due to Tk's line model and BR
 *  push corresponds to top spacing for the first line
 *  pop corresponds to bottom spacing for the first line
 *)

class spacing (tagdef) =
 object
  (* val tagdef = tagdef *)
 
  method push current_pos n =
    let topname = sprintf "topspace%d" n in
     tagdef#define topname [Spacing1 (Pixels n)];
     match current_pos with
       TextIndex(base,[x]) ->
     tagdef#add (topname, TextIndex(base, [x;LineStart]),
                      TextIndex(base, [x;LineEnd]));
     ()
     | _ -> assert false

  method pop current_pos n =
    let botname = sprintf "botspace%d" n in
    tagdef#define botname [Spacing3 (Pixels n)];
     match current_pos with
       TextIndex(base,[x]) ->
     tagdef#add (botname, TextIndex(base, [x;LineStart]),
                      TextIndex(base, [x;LineEnd]));
     ()
     | _ -> assert false
end

<<constant [[Attrs.circle_data]]>>

<<constant [[Attrs.disc_data]]>>

<<constant [[Attrs.square_data]]>>

<<constant [[Attrs.bullet_table]]>>
<<function [[Attrs.init]]>>
@


\subsection*{[[display/cmap.ml]]}

<<exception [[Cmap.Syntax]]>>=
(* Client Side Image Maps
   We must have two modes: one when the image has not been loaded.
   In that case, we need something like a popup menu. And then, when
   the image is loaded, we use a canvas
   *)

exception Syntax of string
@

<<function [[Cmap.alt_mode]]>>=
let alt_mode emb m l =
  Log.debug (sprintf "Alt mode map for %s" (Widget.name l));
  let menu = Menu.create_named l "map" [] in
  List.iter (fun area ->
    Menu.add_command menu
      [Label (if area.area_alt = "" then 
    area.area_link.h_uri
      else area.area_alt);
    Command (fun () -> emb.embed_context#goto area.area_link)])
    m;
  bind l (Glevents.get "alt_imap")
    (BindSet ([Ev_RootX; Ev_RootY],
          (fun ei -> Menu.popup menu ei.ev_RootX ei.ev_RootY)))
@

<<function [[Cmap.printTagOrId]]>>=
let printTagOrId = function
  | Id n -> Log.f (sprintf "Id %d" n)
  | Tag s -> Log.f (sprintf "Tag %s" s)
@

<<function [[Cmap.gfx_mode]]>>=
(* This is called when the image has been loaded *)
let gfx_mode emb map c =
  Log.debug (sprintf "Gfx mode map for %s" (Widget.name c));

  (* Build the canvas items corresponding to active zones *)

  (* For points *inside* rects and circle items to be actually considered
     inside for the purpose of activation, we must use both an empty outline
     and an empty fill. *)
  let opts = [Outline (NamedColor ""); FillColor (NamedColor "")] in

  let items = 
    List.map (fun area ->
      try
        match area.area_kind with
      Default -> Id 1, area.area_link (* the image itself *)
        | Rect -> 
        begin match area.area_coords with
        | [x1;y1;x2;y2] ->
           Canvas.create_rectangle c
          (Pixels x1) (Pixels y1) (Pixels x2) (Pixels y2) 
          opts,
           area.area_link
        | _ -> 
        raise (Syntax "rect")
        end
        | Circle ->
        begin match area.area_coords with
        | [x;y;r] ->
           Canvas.create_oval c
          (Pixels (x-r)) (Pixels (y-r))
          (Pixels (x+r)) (Pixels (y+r))
          opts,
           area.area_link
        | _ -> raise (Syntax "circle")
        end
        | Poly ->
        let l = List.length area.area_coords in
        (* there must be at least three points, and by pair *)
        if l < 6 || l mod 2 <> 0 then begin
          Log.f "Invalid coords for polygon shape";
          raise (Syntax "polygon")
        end
        else
          Canvas.create_polygon c
               (List.map (fun x -> Pixels x) area.area_coords)
               opts,
          area.area_link
      with 
      |	Syntax s ->
      Log.f (sprintf "Wrong syntax in area mapping (%s)" s);
      Tag "area error", area.area_link
      | Protocol.TkError s -> 
      Log.f (sprintf "Error in area mapping (%s)" s);
      Tag "area error", area.area_link
     )
     map
  in
  Canvas.lower_bot c (Id 1);
  let htobj = new imap(c,items) in
    htobj#init emb.embed_context
@


%-------------------------------------------------------------

<<display/cmap.ml>>=
open Printf
open Tk
open Embed
open Maps
open Hyper


<<exception [[Cmap.Syntax]]>>

<<function [[Cmap.alt_mode]]>>

<<function [[Cmap.printTagOrId]]>>


(* See Htbind for semantics of this class *)
class imap (c, items) =
 object (self)
 inherit Htbind.active () as super

 (* val items = items *)
 (* val c = c *)
 method widget = c

 method getlink ei =
   let cx = truncate (Canvas.canvasx c (Pixels ei.ev_MouseX))
   and cy = truncate (Canvas.canvasy c (Pixels ei.ev_MouseY)) in
     match Canvas.find c [Closest (Pixels cx, Pixels cy)] with
       [id] -> List.assoc id items
     |  _ -> raise Not_found

 method binder = Canvas.bind c (Tag "current") 

 method highlight _ = ()
 method markused _ei = ()

 method! init ctx =
   super#init ctx;
   self#binder [[], Motion]
    (BindSet ([Ev_MouseX; Ev_MouseY], 
          (fun ei ->
            try
              let link = self#getlink ei in
              ctx#invoke "pointsto" link
            with
              Not_found -> ())))
end
 



<<function [[Cmap.gfx_mode]]>>


@


\subsection*{[[display/fit.mli]]}

<<signature [[Fit.debug]]>>=
val debug : bool ref
@

<<signature [[Fit.set_initial_width]]>>=
val set_initial_width : Widget.widget -> int option
@

<<signature [[Fit.set_initial_height]]>>=
val set_initial_height: Widget.widget -> unit
@

<<signature [[Fit.horiz]]>>=
(* [horiz textw stop continuation] returns [scrollcommand, check] *)
val horiz: 
  Widget.widget -> (unit -> bool) -> (unit -> unit) ->
  (float -> float -> unit) * (unit -> unit)
@

<<signature [[Fit.vert]]>>=
val vert: 
  Widget.widget -> 
  (float -> float -> unit) * (unit -> unit)
@

<<signature [[Fit.bound_check]]>>=
val bound_check : Widget.widget -> int -> (unit -> bool)
@

<<signature [[Fit.fixed_horiz]]>>=
val fixed_horiz : Widget.widget -> int -> unit
@


%-------------------------------------------------------------

<<display/fit.mli>>=

<<signature [[Fit.debug]]>>

<<signature [[Fit.set_initial_width]]>>
<<signature [[Fit.set_initial_height]]>>

<<signature [[Fit.horiz]]>>

<<signature [[Fit.vert]]>>

<<signature [[Fit.bound_check]]>>

<<signature [[Fit.fixed_horiz]]>>
@


\subsection*{[[display/fit.ml]]}

<<constant [[Fit.debug]]>>=
let debug = ref false
@

<<function [[Fit.set_initial_width]]>>=
(* initial width : a nested formatter starts with w=1 h=1
 * if the only contents is an embedded window, it's a bit short
 * thus we check for max width of embedded windows
 * We take an arbitrary width of 10 pixels per char.
 *)
let set_initial_width wid =
  let ewidth = ref 0 in
  Text.window_names wid |> List.iter (fun w -> 
    ewidth := max (Winfo.reqwidth w) !ewidth
  );
  if !ewidth > 10 then begin
    let w = !ewidth / 10 in
    if !debug 
    then Log.f (sprintf "Setting initial width of %s to %d"(Widget.name wid) w);
    Text.configure wid [TextWidth w];
    Some w
  end
  else None
@

<<function [[Fit.wheight]]>>=
(* I still don't understand the difference between height and reqheight *)
let wheight w = max (Winfo.height w) (Winfo.reqheight w)
@

<<function [[Fit.set_initial_height]]>>=
let set_initial_height wid =
  match Text.index wid (TextIndex(End,[])) with
    LineChar (l,_) ->
      let height = ref (l-1) in
      for i = 0 to l - 1 do
    match Text.index wid (TextIndex(LineChar(i,0), [LineEnd])) with
      LineChar (_,c) -> height := !height + c / 100
    | _ -> ()
      done;
      begin
    let embedded = Text.window_names wid in
    if embedded = [] then () 
    else begin
      let lines = Hashtbl.create (List.length embedded) in
      let addh l h =
        try
          let r = Hashtbl.find lines l in
          r := max h !r
        with
          Not_found -> Hashtbl.add lines l (ref h)
      in
      List.iter (fun w ->
        match Text.index wid (TextIndex(Embedded w, [])) with
          LineChar(l,_) -> addh l (wheight w)
        | _ -> assert false)
        embedded;
      Hashtbl.iter (fun _ r -> height := !height + !r / 15) lines
       end;
     let curheight = int_of_string (cget wid CHeight) in
    if !height > curheight then begin
      if !debug then 
        Log.f (sprintf "Setting initial height of %s to %d (%d)"
                       (Widget.name wid) !height (l-1));
         Text.configure wid [TextHeight (!height)]
    end else if !debug then 
        Log.f (sprintf "Initial height of %s is %d (%d)"
                       (Widget.name wid) !height (l-1))
      end
  | _ -> ()
@

<<function [[Fit.fixed_horiz]]>>=
(* Grow horizontally until we reached the maxium authorized width 
 * (or bound is reached)
 *)
let rec fixed_horiz wid maxw =
  let curw = Winfo.reqwidth wid in
  if  curw >= maxw then ()
  else begin
    let w = (succ (int_of_string (cget wid CWidth))) in
    if !debug then
      Log.f (sprintf "Growing %s to %d (w=%d) (max=%d)"
                 (Widget.name wid) w curw maxw);
    Text.configure wid [TextWidth w];
    fixed_horiz wid maxw
  end
@

<<function [[Fit.horiz]]>>=
let horiz wid stop continuation =
  (* all conditions for stopping *)
  let finished visible = visible >= 0.999 || stop()
  (* bail out *)
  and over () = 
   (* deconnect ourselves *)
   (*Text.configure wid [XScrollCommand (fun _ _ -> ())];*)
   continuation()
  and last_visible = ref 0.0 
  in
  (* if we want to restart after we were disconnected*)
  let rec check () = 
    let first, last = Text.xview_get wid in 
     scroll first last
  (* binding to XScrollCommand *)
  and scroll first last =
    let curwidth = int_of_string (cget wid CWidth)
    and visible = last -. first in
    (* Don't attempt anything if widget is not visible *)
    (* Especially, DO NOT DECIDE TO STOP *)
    if not (Winfo.viewable wid) then begin
      if !debug then
    Log.f (sprintf "%s HC %d %f %f notviewable"
                   (Widget.name wid) curwidth first last);
      (* Try again later *)
      bind wid [[], Expose] (BindSet ([], fun _ ->
    bind wid [[], Expose] BindRemove;
    check()))
    end
    else if finished visible then over()
    else if visible = !last_visible then 
      (* it didn't change since our last resize ! *)
      ()
    else begin
      (* how much do we need to grow
     This code is disabled because it causes masking of table cells
     (we don't have a reasonable estimation of a minimum horiz growth
      that would avoid masking). We now grow by 1, despite the 
      slowness.
      let delta = 
    if last = 0.0 then 1
        else begin
      last_visible := visible;
      let visible = max 0.2 visible in
      let missing = 1. -. visible in
      (* at least one char, but not too much *)
      let computed = truncate (float curwidth *. missing /. visible) in
      if computed = 0 then 1 else min 5 computed
        end
      in
      let newsize = curwidth + delta in
     *)
      last_visible := visible;
      let newsize = curwidth + (if visible < 0.1 then 5 else 1) in
      if !debug then
       Log.f (sprintf "%s H %d %f %f newsize: %d"
                   (Widget.name wid) curwidth first last newsize);
      Text.configure wid [TextWidth newsize];
    end
    
  in
  scroll, check
@

<<function [[Fit.vert]]>>=
(* somehow we need to do it differently : resize is delayed *)
let vert wid =
  let finished visible = visible >= 0.999
  and last_visible = ref (-1.0)   (* last value of visible *)
  and stuck = ref false     (* last resize didn't have an effect *)
  and pending_check = ref false
  and delayed = ref false   (* we have a binding on Expose *)
  and pending_resize = ref false (* a resize is pending *)
  and newsize = ref 0
  in
  let rec check () = 
    if Winfo.exists wid then begin (* we must check since we use a delay *)
    let first, last = Text.yview_get wid in 
      pending_check := false;
      scroll first last
    end
  and scroll first last =
    let curheight = int_of_string (cget wid CHeight)
    and visible = last -. first in
    (* Don't attempt anything if widget is not visible *)
    if not (Winfo.viewable wid) then begin
      if !debug then
    Log.f (sprintf "%s VC %d %f %f notviewable"
                   (Widget.name wid) curheight first last);
      (* Try again later *)
      if not !delayed then begin
    delayed := true;
       bind wid [[], Expose] (BindSet ([], fun _ ->
      bind wid [[], Expose] BindRemove;
      delayed := false;
      check()))
      end
    end
    else if finished visible then ()
    else if !stuck then
      if !pending_check then ()
      else begin
      (* last check had same last value than before *)
      pending_check := true;
      if !debug then Log.f (sprintf "Stuck %s" (Widget.name wid));
      Timer.set 50 (fun () -> stuck := false; Frx_after.idle check)
      end
    else begin
      let delta = 
  if visible = !last_visible then (stuck := true; 1) 
        else if last = 0.0 then (last_visible := 0.0; 1)
    else begin
      last_visible := visible; stuck := false;
          (* never to more than double *)
      let visible = max 0.5 visible in
      let missing = 1. -. visible in
      (* at least one char, but not too much *)
      let computed = truncate (float curheight *. missing /. visible) in
      if computed = 0 then 1 else min 5 computed
        end 
      in
      newsize := max (curheight + delta) !newsize;
      (* Since we may not be fully visible anyway, decouple the loop *)
      if !pending_resize then ()
      else begin
    if !debug then 
      Log.f (sprintf "Scheduling resize of %s" (Widget.name wid));
    pending_resize := true;
        Timer.set 50 (fun () -> Frx_after.idle (resize first last))
      end
    end
  and resize first last () =
    pending_resize := false;
    let curheight = int_of_string (cget wid CHeight) in
    if !newsize > curheight then begin
      if !debug then
       Log.f (sprintf "%s V %d %f %f newsize: %d"
               (Widget.name wid) curheight first last !newsize);
      Text.configure wid [TextHeight !newsize]
    end
  in
  scroll, check
@

<<function [[Fit.bound_check]]>>=
let bound_check wid width =
  let stop_now = ref false in
  bind wid [[], Configure]
    (BindExtend([Ev_Width], (fun ei ->
      if !debug then
    Log.f (sprintf "Configure %s width is %d (max %d) (req %d)"
                  (Widget.name wid) ei.ev_Width width
                  (Winfo.reqwidth wid));
      if ei.ev_Width >= width then begin
    stop_now := true;
  bind wid [[], Configure] BindRemove
      end)));
  (fun () -> !stop_now)
@


%-------------------------------------------------------------

<<display/fit.ml>>=
open Printf
open Tk


<<constant [[Fit.debug]]>>

<<function [[Fit.set_initial_width]]>>

(* initial height: we have to grow at least to the number of
 * lines of text so that the entire text is visible. Moreover,
 * large lines will fold so adjust. Moreover, embedded window
 * provide height.
 *)
<<function [[Fit.wheight]]>>

<<function [[Fit.set_initial_height]]>>


<<function [[Fit.fixed_horiz]]>>

<<function [[Fit.horiz]]>>


<<function [[Fit.vert]]>>

<<function [[Fit.bound_check]]>>

@


\subsection*{[[display/fonts.mli]]}

<<type [[Fonts.fontInfo]]>>=
type fontInfo =
  | Family of string
  | Weight of string
  | Slant of string
  | FontIndex of int
  | FontDelta of int
@

<<type [[Fonts.fontAttrs]]>>=
type fontAttrs = fontInfo list
@

<<type [[Fonts.fontDesc]]>>=
type fontDesc = { 
  pattern: Jpf_font.pattern;
  mutable pxlsz: int;
}
@

<<signature [[Fonts.default]]>>=
val default: fontDesc ref
@

<<signature [[Fonts.print_fontAttrs]]>>=
val print_fontAttrs: fontAttrs -> unit
@

<<signature [[Fonts.merge]]>>=
val merge: fontDesc -> fontAttrs -> fontDesc
@

<<signature [[Fonts.compute_tag]]>>=
val compute_tag: fontDesc -> string * Tk.options list
@

<<signature [[Fonts.font_index]]>>=
val font_index: int -> int
@

<<signature [[Fonts.pxlsz]]>>=
val pxlsz: int -> int
@

<<signature [[Fonts.default_sizes]]>>=
(*-*)
val default_sizes: string list
@

<<signature [[Fonts.reset]]>>=
val reset: unit -> unit
@


%-------------------------------------------------------------

<<display/fonts.mli>>=

<<type [[Fonts.fontInfo]]>>

<<type [[Fonts.fontAttrs]]>>

<<type [[Fonts.fontDesc]]>>

<<signature [[Fonts.default]]>>

<<signature [[Fonts.print_fontAttrs]]>>

<<signature [[Fonts.merge]]>>
<<signature [[Fonts.compute_tag]]>>

<<signature [[Fonts.font_index]]>>
<<signature [[Fonts.pxlsz]]>>

<<signature [[Fonts.default_sizes]]>>

<<signature [[Fonts.reset]]>>
@


\subsection*{[[display/fonts.ml]]}

<<type Fonts.fontDesc (./display/fonts.ml)>>=
(* Font manipulation *)

type fontDesc = 
    { pattern: Jpf_font.pattern;
      mutable pxlsz: int (* not pxlsz, but font index *)
    }
@

<<type Fonts.fontInfo (./display/fonts.ml)>>=
type fontInfo =
   Family of string
 | Weight of string
 | Slant of string
 | FontIndex of int
 | FontDelta of int
@

<<type Fonts.fontAttrs (./display/fonts.ml)>>=
type fontAttrs = fontInfo list
@

<<function [[Fonts.copy]]>>=
let copy fd = { pattern= Jpf_font.copy fd.pattern;
        pxlsz= fd.pxlsz }
@

<<function [[Fonts.print_fontAttrs]]>>=
let print_fontAttrs attrs =
  List.iter (function 
    Family s -> prerr_string ("family: " ^ s ^ " ")
  | Weight s -> prerr_string ("weight: " ^ s ^ " ")
  | Slant s -> prerr_string ("slant: " ^ s ^ " ")
  | FontIndex i -> prerr_string ("index: " ^ string_of_int i ^ " ")
  | FontDelta i -> prerr_string ("delta: " ^ string_of_int i ^ " ")) attrs;
  prerr_endline "";
@

<<function [[Fonts.merge]]>>=
(* Merge font attributes in a fontDesc *)
let merge fd fil =
  let newfd = copy fd in
  List.iter (function
      Family s -> newfd.pattern.family <- Some s
    | Weight s -> newfd.pattern.weight <- Some s
    | Slant s -> newfd.pattern.slant <- Some s
    | FontIndex i -> newfd.pxlsz <- i
    | FontDelta n -> newfd.pxlsz <- newfd.pxlsz + n
    )
    fil;
  newfd
@

<<constant [[Fonts.default_sizes]]>>=
(* List of authorized pixel sizes *)
let default_sizes = ["8"; "10"; "12"; "14"; "15"; "16"; "18"; "20"; "24"; "26"; "28"]
@

<<constant [[Fonts.sizes]]>>=
let sizes = ref (Array.of_list (List.map int_of_string default_sizes))
@

<<function [[Fonts.get_index]]>>=
(* Given a size in pixels, find out the corresponding index array 
   (which is the max of defined sized lower than argument)
 *)
let get_index size =
  let len = Array.length !sizes in
  let rec walk n =
    if n >= len then len - 1
    else if !sizes.(n) > size then n-1
    else walk (succ n)
  in 
  let idx = walk 0 in
  if idx < 0 then 0 else idx
@

<<constant [[Fonts.base_index]]>>=
let base_index = ref (get_index 15)
@

<<function [[Fonts.font_index]]>>=
(* Convert a pxlsz to an absolute font 
 * (the base_index is always the absolute font 3 byte defintion of HTML)
 *)
let font_index pxlsz =
  (get_index pxlsz) - (!base_index - 3)
@

<<function [[Fonts.pxlsz]]>>=
(* Convert an absolute font to a pxlsz *)
let pxlsz absfont =
  let font_idx = absfont + (!base_index - 3) in
  let safe_idx = 
    if font_idx < 0 then 0
    else if font_idx >= Array.length !sizes then Array.length !sizes - 1
    else font_idx in
@

<<constant [[Fonts.tags]]>>=
(*
 * Tag names for fonts (this table is shared by all widgets)
 * We share tags for fonts, but this requires combinations of all
 * possible styles (weight, slant and size). The tag attribute is computed 
 * on demand. Each widget must do its "tag configure" separately, since these
 * are not shared by all text widgets (even in a same class)
 *)


let tags = Hashtbl.create 37
@

<<constant [[Fonts.default]]>>=
let default = ref 
    { pattern= Jpf_font.copy Jpf_font.empty_pattern;
      pxlsz = 3 }
@

<<function [[Fonts.compute_tag]]>>=
(* For a given fontDesc, return the name of the tags and its attributes *)
let rec compute_tag fd =
  let font_key = 
    Jpf_font.string_of_pattern fd.pattern ^ string_of_int fd.pxlsz 
  in
  try 
    Hashtbl.find tags font_key
  with Not_found ->
    let tagdesc =
      let pxlsz = pxlsz fd.pxlsz in
      let pattern = {fd.pattern with pixelSize= Some pxlsz} in
      try
        let display = 
          match Protocol.default_display () with
            "" -> None | x -> Some x
        in
        let fontid, fontname =
              (* find latin font *)
          let xlfd = Jpf_font.nearest_pixel_size display true pattern in
          let latin_f = Jpf_font.string_of_valid_xlfd xlfd in
          xlfd.family^xlfd.weight^xlfd.slant^(string_of_int pxlsz), latin_f
        in
    
        fontid, [Font fontname]
      with (* Invalid_argument f *) _ ->  (* font is not available *)
        Log.f (s_ "Font for %s is not available" 
                 (Jpf_font.string_of_pattern pattern));
        if fd = !default 
        then ("fixedfont", [Font "fixed"])
        else compute_tag !default
     in
     Hashtbl.add tags font_key tagdesc;
     tagdesc
@
%        (*    
%        (* japanese mode, search jp fonts *)
%        if !Lang.japan then begin
%         (*
%          let pattern = { Jpf_font.empty_pattern with
%                          registry= Some "jisx0208.1983";
%                          pixelSize= Some pxlsz } in
%          *)
%          let retry pattern =
%            let xlfd = Jpf_font.nearest_pixel_size display (pxlsz > 20) 
%            pattern 
%            in
%            let japan_f = Jpf_font.string_of_valid_xlfd xlfd in
%            fontid, [Font (Font.create [Compound [ fontname; japan_f ]])]
%          in
%    
%          (* fst retry *)
%          let pattern = { fd.pattern with
%                          foundry= None;
%                          family= None;
%                          registry= Some "jisx0208.1983";
%                          pixelSize= Some pxlsz } 
%          in
%          try retry pattern with _ ->
%          
%              (* snd retry *)
%          let pattern = { pattern with slant= None } in
%          try retry pattern with _ ->
%            
%              Log.f (s_ "Japanese font for %s is not available" (Jpf_font.string_of_pattern pattern));
%          fontid, [Font fontname] (* we should do more... *)
%        end else 
%          *)


<<function [[Fonts.reset]]>>=
(* Mapping with preferences : *fontPixels is also used to define our array 
 * We use a mute preference handler to synchronize : this handler is called
 * after the loading of the resource file.
 *)
let reset () =
  Hashtbl.clear tags; (* since tags use font index *)
  let l = Tkresource.stringlist "fontPixels" default_sizes in
  sizes := Array.of_list (List.map (fun x -> 
    try 
      int_of_string x 
    with 
      e -> 
    Log.f ("Fonts.reset error for size "^x); 
    raise e) l);
  (* now we need to compute the base (we need to know some of Prefs internal)*)
  let b = Tkresource.string "prefDefaultFont" "" in
  if b = "" then base_index := get_index 15
  else
    let tokens = Mstring.split_str (fun c -> c='-') b in
    base_index := get_index (
       try int_of_string (List.nth tokens 6)
       with Failure "int_of_string" | Failure "nth" -> 15)
@


%-------------------------------------------------------------

<<display/fonts.ml>>=
open I18n

open Tk
open Jpf_font

<<type Fonts.fontDesc (./display/fonts.ml)>>

<<type Fonts.fontInfo (./display/fonts.ml)>>

<<type Fonts.fontAttrs (./display/fonts.ml)>>

<<function [[Fonts.copy]]>>

<<function [[Fonts.print_fontAttrs]]>>
;;

<<function [[Fonts.merge]]>>

(* HTML3.2 specifies that absolute font size are ranging from 1 to 7, 
   the default basefont, used for "normal" text, being 3.

   The preference settings allow:
    - definition of list of pixel sizes
    - definition of default size   
    - definition of header size.

   To compute the HTML fonts [1..7], we look for the default
   pixel size in the list of the given sizes: this defines the 
   default base (3).

   We map these sizes to X Font Pxlsz, keeping some latitude for
   mapping the base. The lowest reasonable font is 8
 *)

<<constant [[Fonts.default_sizes]]>>
<<constant [[Fonts.sizes]]>>

<<function [[Fonts.get_index]]>>


<<constant [[Fonts.base_index]]>>

<<function [[Fonts.font_index]]>>


<<function [[Fonts.pxlsz]]>>
   !sizes.(safe_idx)

<<constant [[Fonts.tags]]>>

<<constant [[Fonts.default]]>>

<<function [[Fonts.compute_tag]]>>



<<function [[Fonts.reset]]>>
@


\subsection*{[[display/hr.mli]]}

<<signature [[Hr.create_named]]>>=
val create_named: 
  Widget.widget -> string -> Html.length -> int -> bool -> 
  Widget.widget
@


%-------------------------------------------------------------

<<display/hr.mli>>=

<<signature [[Hr.create_named]]>>
@


\subsection*{[[display/hr.ml]]}

<<function [[Hr.create_named]]>>=
(* When creating an HR in a nested window (eg table cell), reqwidth is
   probably the width of 1 character
 *)
let create_named top name length height solid =
  let fr = Frame.create_named top name [] in
  let width = match length with
    Nolength | LengthRel _-> truncate (float (Winfo.reqwidth top) *. 0.95)
  | LengthRatio r -> truncate (float (Winfo.reqwidth top) *. r)
  | LengthPixels n -> n
  in
  Frame.configure fr [Width (Pixels width)];
  if solid then
    Frame.configure fr [BorderWidth (Pixels 0); Height (Pixels height)]
  else
    Frame.configure fr [Relief Groove;
            BorderWidth (Pixels 2); Height (Pixels (height+2))];
  fr
@


%-------------------------------------------------------------

<<display/hr.ml>>=
open Tk
open Html

<<function [[Hr.create_named]]>>

@


\subsection*{[[display/htbind.mli]]}


%-------------------------------------------------------------

<<display/htbind.mli>>=

class virtual active :
  unit ->
  object
    method virtual binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method virtual getlink : Tk.eventInfo -> Hyper.link
    method virtual highlight : bool -> unit
    method init : Viewers.context -> unit
    method virtual markused : Tk.eventInfo -> unit
    method virtual widget : Widget.widget
  end

class virtual hypertext :
  Widget.widget ->
  object
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method virtual getlink : Tk.eventInfo -> Hyper.link
    method virtual getrange : Tk.index -> Tk.index * Tk.index
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end

class directmap :
  Widget.widget * Hyper.link ->
  object
    val link : Hyper.link
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method getlink : Tk.eventInfo -> Hyper.link
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end

class servermap :
  Widget.widget * Hyper.link ->
  object
    val link : Hyper.link
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method getlink : Tk.eventInfo -> Hyper.link
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end

class formmap :
  Widget.widget * (int * int -> Hyper.link) ->
  object
    val formlink : int * int -> Hyper.link
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method getlink : Tk.eventInfo -> Hyper.link
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end
@


\subsection*{[[display/htbind.ml]]}


%-------------------------------------------------------------

<<display/htbind.ml>>=
(* Bindings for hypernavigation *)
open Printf
open Tk
open Hyper
open Viewers

(*
An active object is assumed to have the following methods:
*)    


class  virtual active () =
 object (self)
 method virtual widget : Widget.widget
      (* returns the widget to which an hypermenu can be attached *)
 method virtual getlink : eventInfo -> Hyper.link
      (* returns the link pointed to by the object *)
 method virtual binder : (modifier list * xEvent) list -> bindAction -> unit
      (* binds events on the object *)
 method virtual highlight : bool -> unit
      (* user feedback (mostly cursor) indicating that object is active *)
 method virtual markused : eventInfo -> unit
      (* say that we've activated this link *)

 method init (ctx : Viewers.context) =
  (* Install all navigation bindings *)
  List.iter (fun hyname ->
    try 
      let _hyperfTODO = List.assoc hyname ctx#hyper_funs in
      self#binder (Glevents.get hyname)
    (BindSet ([Ev_MouseX; Ev_MouseY],
          (fun ei -> 
             try let link = self#getlink ei in
                  self#markused ei;
                  ctx#invoke hyname link;
             with Not_found -> ())))
    with
      Not_found -> ())
    ["goto"; "save"; "gotonew"];

  (* Install the menu (created by need only) *)
  let menulink = ref None
  and menuei = ref None in
  let hypermenu = Frx_misc.autodef (fun () ->
     let m = Menu.create_named self#widget "hypermenu" [] in
        (* The first entry has its text replaced by the link url *)
        Menu.add_command m [Label ""];
        Menu.add_separator m;
    List.iter (fun (fname, f) ->
             if f.hyper_visible then
              Menu.add_command m
               [Label f.hyper_title; 
                Command (fun () -> 
                  match !menuei, !menulink with
                Some ei, Some link ->
                  self#markused ei;
                  ctx#invoke fname link
                  |	_, _ -> ())])
          ctx#hyper_funs;
    m) in
  self#binder (Glevents.get "hypermenu")
   (BindSet ([Ev_MouseX; Ev_MouseY; Ev_RootX; Ev_RootY], 
       (fun ei -> 
     try
       let link = self#getlink ei in
       menuei := Some ei; menulink := Some link;
       let m = hypermenu() in
       Menu.configure_command m (Number 1) [Label (Hyper.string_of link)];
       Menu.popup m ei.ev_RootX ei.ev_RootY
     with
       Not_found -> ())));

  (* Install the pointsto internal bindings *)
  self#binder [[], Enter]
    (BindExtend ([Ev_MouseX; Ev_MouseY], 
         (fun ei ->
           try
             let link = self#getlink ei in
             self#highlight true;
             ctx#invoke "pointsto" link
           with Not_found -> ())));
  let fakehlink = Hyper.default_link "" in
  self#binder [[], Leave]
    (BindSet ([Ev_MouseX; Ev_MouseY], 
          (fun _ei ->
        self#highlight false;
        ctx#invoke "clearpointsto" fakehlink)))
end

(*
 * The various active objects
 *)

(* Text widget with anchors marked as tags *)

class  virtual hypertext (thtml) =
 object (self)
  inherit active () as super
  (* val thtml = thtml *)  (* keep our own copy *)

  method widget = thtml

  method virtual getlink : eventInfo -> Hyper.link

  method binder = Text.tag_bind thtml "anchor" 

  method highlight flag = 
    if flag then
      Text.configure thtml [Cursor (XCursor "hand2")]
    else
      Text.configure thtml [Cursor (XCursor "xterm")]

  method virtual getrange : index -> index * index

  method markused ei =
     (* The index of the click position *)
     let i = 
       Text.index thtml (TextIndex (AtXY (ei.ev_MouseX,ei.ev_MouseY), [])) in
     (* Tags at this place *)
     let s,e = self#getrange i in
       Text.tag_add thtml "visited" (TextIndex (s,[])) (TextIndex (e,[]))

  (* we don't get Enter/Leave when tags are contiguous, so the 
     pointed link displayed in pointsto is no always correct
     Thus, extend initialisation to bind pointsto on motion
   *)
  method! init ctx =
    super#init ctx;
    self#binder [[], Motion]
      (BindSet ([Ev_MouseX; Ev_MouseY], 
        (fun ei ->
          try
            let link = self#getlink ei in
            ctx#invoke "pointsto" link
          with
            Not_found -> ())))
end


(* embedded objects with direct map *)
class directmap (frame, link) =
 object (_self)
  inherit active ()
  (* val frame = frame *)
  method widget = frame
  val link = (link : Hyper.link)
  method getlink (_ei : eventInfo) = link
  method binder = bind frame
  method highlight (_flag : bool) = ()  (* we already set up the cursor *)
  method markused _ei =
    Frame.configure frame [Relief Sunken]
end

(* embedded objects with server map (ISMAP) *)
(* pointsto will get some arbitrary value for x,y... *)
class servermap (frame,link) =
 object (_self)
  inherit active ()
  inherit! directmap (frame, link)
  method! getlink ei = 
    {h_uri = sprintf "%s?%d,%d" link.h_uri
                                ei.ev_MouseX ei.ev_MouseY;
     h_context = link.h_context;
     h_method = GET;
     h_params = link.h_params}
end

(* embedded objects with form submission *)
class formmap (frame,formlink) =
 object (_self)
  inherit active ()
  (* val frame = frame *)
  method widget = frame
  val formlink = (formlink : int * int -> Hyper.link)
  method getlink ei = formlink (ei.ev_MouseX, ei.ev_MouseY)
  method binder = bind frame
  method highlight (_flag : bool) = ()  (* we already set up the cursor *)
  method markused _ei =
    Frame.configure frame [Relief Sunken]
end


(* Client side image maps are defined in Cmap *)
@


\subsection*{[[display/source.mli]]}

<<signature [[Source.annotate]]>>=
val annotate: 
  Widget.widget -> (Tk.textTag * Html.location) list -> unit
@



%-------------------------------------------------------------

<<display/source.mli>>=

<<signature [[Source.annotate]]>>

<<signature [[Source.view]]>>
@


\subsection*{[[display/source.ml]]}

<<function [[Source.annotate]]>>=
(* HTML source viewer/editor *)
let annotate txt =
  Hashtbl.iter (fun elem _  ->
    let color = Tkresource.string (sprintf "Source<%s>" elem) "white" in
    Text.tag_configure txt elem [Background (NamedColor color)])
    !Dtd.current.Dtd.contents;
    (fun annotations ->
      List.iter (function (name,Loc(s,e)) ->
    let idxs = abs_index s
    and idxe = abs_index e in
    Text.tag_add txt name idxs idxe)
      annotations)
@



%        (*
%        if !Lang.japan then begin
%          (* In Japanese mode, We must insert line by line. *) 
%         let ic = open_in fname 
%         and buf = String.create 2048
%         and prevbuf = ref ""
%         in
%          try
%             while true do
%               let n = input ic buf 0 2048 in
%                   let txt = 
%                     if n = 2048 then begin
%                       (* try to find last newline *)
%                       let pos = 
%                     try String.rindex buf '\n' + 1 
%                     with Not_found -> 0
%                       in
%                       let txt = !prevbuf ^ (String.sub buf 0 pos) in
%                       prevbuf := String.sub buf pos 
%                          (String.length buf - pos);
%                       txt
%                     end else begin
%                       let txt = !prevbuf ^ (String.sub buf 0 n) in
%                       prevbuf := "";
%                       txt
%                     end
%                   in
%                   (* if coding = ISO8859 or JIS, the chars > \127
%                    * must be preceded with esc sequence 
%                    *)
%                   let txt =
%                     if coding = Japan.Code Japan.ISO8859 || 
%                        coding = Japan.Code Japan.JIS then
%                       let buf = Ebuffer.create (String.length txt * 2) in
%                       for i = 0 to String.length txt - 1 do
%                     if txt.[i] > '\127' then 
%                       (* sorry for hard coding *)
%                       Ebuffer.output_string buf "\027\040\066";
%                     Ebuffer.output_char buf txt.[i]
%                       done;
%                       Ebuffer.get buf
%                     else txt
%                   in
%                   Text.insert t textEnd txt [];
%                   (* Then EOF check *)
%                   if n = 0 then raise End_of_file
%             done
%       with End_of_file -> close_in ic
%     end else 
%     *)


%-------------------------------------------------------------

<<display/source.ml>>=
open I18n
open Printf
open Tk
open Frx_text
open Document
open Html

<<function [[Source.annotate]]>>

<<function [[Source.view]]>>

@


\subsection*{[[display/ctext.mli]]}

<<signature [[Ctext.create]]>>=
(* [create parent opts nav_keys] creates a text widget
 * with "pixel scrolling". Based on a trick learned from Steve Ball.
 * Returns (frame widget, text widget).
 *)
val create :
  Widget.widget -> Tk.options list -> bool -> 
  Widget.widget * Widget.widget
@

<<signature [[Ctext.init]]>>=
val init : unit -> unit
@


%-------------------------------------------------------------

<<display/ctext.mli>>=

<<signature [[Ctext.create]]>>

<<signature [[Ctext.init]]>>
@


\subsection*{[[display/ctext.ml]]}

<<constant [[Ctext.tag_name]]>>=
let tag_name = "CTEXT_RO"
@

<<function [[Ctext.navigation_keys]]>>=
let navigation_keys tx =
  let tags = bindtags_get tx in
  match tags with
  | (WidgetBindings t)::l when t = tx ->
      Canvas.configure (Winfo.parent t) [YScrollIncrement (Pixels 15)];
      bindtags tx ((WidgetBindings tx) :: (TagBindings tag_name) :: l)
  | _ -> ()
@

<<function [[Ctext.create]]>>=
let create top opts navigation =
  let f = Frame.create_named top "smoothf" [] in
  let lf = Frame.create_named f "left" [] in
  let rf = Frame.create_named f "right" [] in
  let c = Canvas.create_named lf "smoothc" [BorderWidth (Pixels 0); TakeFocus true]
  and xscroll = Scrollbar.create_named lf "x" [Orient Horizontal]
  and yscroll = Scrollbar.create_named rf "y" [Orient Vertical] 
  and secret = Frame.create_named rf "secret" []
  in
  (* automatic scrollbars *)
  let has_x = ref false
  and has_y = ref false
  in
  let putx () = 
    pack [xscroll] [Before c; Side Side_Bottom; Fill Fill_X];
    pack [secret] [Before yscroll; Side Side_Bottom];
    has_x := true
  and remx () = 
    Pack.forget [xscroll; secret];
    has_x := false
  and puty () = 
    pack [rf] [Before lf; Side Side_Right; Fill Fill_Y];
    has_y := true
  and remy () = Pack.forget [rf]; has_y := false
  in

  let wrap_scroll isthere put rem scrollcmd   =
    fun first last ->
      scrollcmd first last;
      if !isthere then 
       if first = 0.0 && last = 1.0 then rem() else ()
      else
       if first <> 0.0 || last <> 1.0 then put() else ()
  in
  let t = Text.create_named c "smootht" (BorderWidth(Pixels 0) :: opts) in
    if navigation then navigation_keys t;
 
    (* Make the text widget an embedded canvas object *)
    ignore (
      Canvas.create_window c (Pixels 0) (Pixels 0)
       [Anchor NW; Window t; Tags [Tag "main"]]);
    Canvas.focus c (Tag "main");
    Canvas.configure c 
    [YScrollCommand (wrap_scroll has_y puty remy (Scrollbar.set yscroll))];
    (* The horizontal scrollbar is directly attached to the
     * text widget, because h scrolling works properly *)
    Scrollbar.configure xscroll [ScrollCommand (Text.xview t)];
    (* But vertical scroll is attached to the canvas *)
    Scrollbar.configure yscroll [ScrollCommand (Canvas.yview c)];
    let scroll, _check = Fit.vert t in
    Text.configure t [
       XScrollCommand (wrap_scroll has_x putx remx (Scrollbar.set xscroll));
        YScrollCommand (fun first last ->
          scroll first last;
       let x,y,w,h = Canvas.bbox c [Tag "main"] in
         Canvas.configure c 
              [ScrollRegion (Pixels x, Pixels y, Pixels w, Pixels h)]);
        ];
    (* B2 Scrolling : based on std script text.tcl 
     * Since t has the focus, it will handle the event, even if we play
     * with bindtags. Thus ev_MouseX/Y are given in the "full" text.
     * Moreover, as the text scrolls, the re-positionning of the text
     * affects the event fields (non-monotonicity !)
     * However, since "scan" is interested only in relative positions,
     * we can use root coordinates directly
     *)
    let x = ref 0
    and y = ref 0
    in
    bind t [[], ButtonPressDetail 2]
      (BindSetBreakable ([Ev_RootX; Ev_RootY],
        (fun ei -> 
          x := ei.ev_RootX;
          y := ei.ev_RootY;
          Canvas.scan_mark c !x !y)));
    bind t [[Button2], Motion]
      (BindSetBreakable ([Ev_RootX; Ev_RootY],
        (fun ei -> 
          let dx = ei.ev_RootX
          and dy = ei.ev_RootY
          in 
          if dx <> !x || dy <> !y then
            Canvas.scan_dragto c dx dy)));

    bind c [[],Configure] (BindSet ([Ev_Width], (fun ei ->
      Canvas.configure_window c (Tag "main") [Width (Pixels ei.ev_Width)])));

    pack [c] [Side Side_Left; Fill Fill_Both; Expand true];
    pack [lf] [Side Side_Left; Fill Fill_Both; Expand true];
    (* pack [secret] [Side Side_Bottom]; *)
    pack [yscroll] [Side Side_Top; Fill Fill_Y; Expand true];
    (* pack [rf] [Side Side_Right; Fill Fill_Y]; *)
    (* pack [xscroll] [Side Side_Bottom; Fill Fill_X]; *)
    f, t
@

<<function [[Ctext.init]]>>=
(* We use Mod1 instead of Meta or Alt *)
let init () = 
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> page_up ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "BackSpace"];
        [[], KeyPressDetail "Delete"];
        [[], KeyPressDetail "Prior"];
        [[], KeyPressDetail "b"];
        [[Mod1], KeyPressDetail "v"]
       ];
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> page_down ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "space"];
        [[], KeyPressDetail "Next"];
        [[Control], KeyPressDetail "v"]
       ];
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> line_up ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "Up"];
        [[Mod1], KeyPressDetail "z"]
       ];
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> line_down ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "Down"];
        [[Control], KeyPressDetail "z"]
       ];

  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> top ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "Home"];
        [[Mod1], KeyPressDetail "less"]
       ];

  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> bottom ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "End"];
        [[Mod1], KeyPressDetail "greater"]
       ]
@


%-------------------------------------------------------------

<<display/ctext.ml>>=
(* A trick by Steve Ball to do pixel scrolling on text widgets *)
(* USES frx_fit *)
open Tk

<<constant [[Ctext.tag_name]]>>

<<function [[Ctext.navigation_keys]]>>


<<function [[Ctext.create]]>>


(* Same as frx_text, but work on canvas instead of text for scrolling *)
let page_up tx   =  Canvas.yview (Winfo.parent tx) (ScrollPage (-1))
and page_down tx =  Canvas.yview (Winfo.parent tx) (ScrollPage 1)
and line_up tx   =  Canvas.yview (Winfo.parent tx) (ScrollUnit (-1))
and line_down tx =  Canvas.yview (Winfo.parent tx) (ScrollUnit 1)
and top tx = Canvas.yview (Winfo.parent tx) (MoveTo 0.0)
and bottom tx = Canvas.yview (Winfo.parent tx) (MoveTo 1.0)

<<function [[Ctext.init]]>>
@


\subsection*{[[display/htmlfmt.ml]]}


%-------------------------------------------------------------

<<display/htmlfmt.ml>>=
(* HTML  "display device" *)

<<type [[Htmlfmt.gattr]]>>

<<type [[Htmlfmt.formatterSpec]]>>

<<type [[Htmlfmt.formatter]]>>


<<type [[Htmlfmt.input_kind]]>>

class  virtual form_behaviour () = object
    method virtual add_get : input_kind -> (unit -> (string * string) list) -> unit
    method virtual add_reset : (unit -> unit) -> unit
    method virtual submit : (string * string) list -> Hyper.link
    method virtual single_submit : Hyper.link option
    method virtual reset : unit
end

<<type [[Htmlfmt.width_constraint]]>>

(*
module type TableDisplay = sig
    type cell_type = HeaderCell | DataCell
    type t = {
      table_master : Widget.widget;
      add_col : Html.tag -> unit;
      open_row : Html.tag -> unit;
      close_row : unit -> unit;
      close_table : unit -> unit;
      new_cell : 
      cell_type -> Html.tag -> Widget.widget -> string -> width_constraint;
      bound : unit -> bool
      }

    val create : Widget.widget -> Html.tag -> width_constraint -> t

    val topwidth : Widget.widget -> int
 end
*)

(*
module type FormDisplay = sig
   (* A form manager *)
   type t = {
     text_input : Widget.widget -> Html.tag -> unit;
     (* [text_input top tag] *)
     checkbox_input : Widget.widget ->  Html.tag -> unit;
     (* [input top tag] *)
     radio_input : Widget.widget ->  Html.tag -> unit;
     (* [input top tag] *)
     image_input : Widget.widget ->  Html.tag -> Embed.embobject;
     (* [input top tag] *)
     submit_input : Widget.widget ->  Html.tag -> unit;
     (* [input top tag] *)
     reset_input : Widget.widget ->  Html.tag -> unit;
     (* [input top tag] *)
     select : Widget.widget -> (string * string * bool) list -> Html.tag -> unit;
     (* [select top elements tag] *)
     textarea:  Widget.widget -> string -> Html.tag -> unit
     (* [textarea top initial attrs] *)
     }

   val create : string -> form_behaviour -> Viewers.context -> t
      (* [create base behaviour ctx] *)

 end
*)

(*
module type GfxHTML = sig
 val create : 
    (unit -> string) ->
    formatterSpec -> Widget.widget -> Viewers.context -> 
      formatter * Widget.widget
 end
*)

@


\subsection*{[[display/imgload.mli]]}

<<type [[Imgload.mode]]>>=
type mode =
  | DuringDoc
  | AfterDocAuto
  | AfterDocManual
@

<<signature [[Imgload.mode]]>>=
val mode : mode ref
@
<<signature [[Imgload.no_images]]>>=
val no_images : bool ref
@
<<signature [[Imgload.gif_anim_auto]]>>=
val gif_anim_auto : bool ref
@



%-------------------------------------------------------------

<<display/imgload.mli>>=

<<type [[Imgload.mode]]>>

<<signature [[Imgload.mode]]>>
<<signature [[Imgload.no_images]]>>
<<signature [[Imgload.gif_anim_auto]]>>

<<class [[Imgload.loader]] signature>>

<<signature [[Imgload.create]]>>

@


\subsection*{[[display/imgload.ml]]}

<<type Imgload.mode (./display/imgload.ml)>>=
(* Images are embedded objects, with a twist *)
type mode =
    DuringDoc
  | AfterDocAuto
  | AfterDocManual
@

<<constant [[Imgload.mode]]>>=
(* Preference settings *)
let mode = ref AfterDocManual
@

<<constant [[Imgload.no_images]]>>=
let no_images = ref false
@

<<constant [[Imgload.gif_anim_auto]]>>=
let gif_anim_auto = ref false
@

<<function [[Imgload.display]]>>=
(* Utilities *)
let display emb i =
  let prop = ref false in
  begin
  if Winfo.exists emb.embed_frame then
  match emb.embed_map with
    ClientSide hlink -> (* kill'em all *)
      begin try
    List.iter destroy (Winfo.children emb.embed_frame);
    let w, h =
     match i with
       Still x -> 
         begin match x with
           ImageBitmap i -> Imagebitmap.width i, Imagebitmap.height i
         | ImagePhoto  i -> Imagephoto.width i, Imagephoto.height i
         | _ -> failwith "invalid image" 
         end
     | Animated anm -> Tkanim.width anm, Tkanim.height anm in
    let c = Canvas.create emb.embed_frame 
           [Width (Pixels w); Height (Pixels h)] in
    prop := true; (*fit the size to the image*)
    Tk.bindtags c ((WidgetBindings emb.embed_frame)::Tk.bindtags_get c);
      pack [c][];
    let ii = Canvas.create_image c (Pixels 0) (Pixels 0)
                   [Anchor NW] in
    begin
      match i with
        Still x -> Canvas.configure_image c ii [x]
      | Animated anm -> 
          begin
        let f = Tkanim.animate_canvas_item c ii anm in
        (* binding on c is bad... *)
        bind c (Glevents.get "stopanim") (BindSet ([], (fun _ ->
          f false)));
        bind c (Glevents.get "restartanim") (BindSet ([], (fun _ ->
          f true)));
        (* I am sure it doesn't work *)
        Canvas.configure c [Cursor (XCursor "watch")];
        if !gif_anim_auto then f false
          end
    end;
    (* now we have the image displayed in a canvas.
       and we can create the client side map *)
    let uri = Hyper.resolve hlink in
    let name =
      match uri.uri_fragment with 
        None -> uri.uri_url
      | Some frag -> sprintf "%s#%s" uri.uri_url frag
    in
      match Maps.get name with
        KnownMap m -> Cmap.gfx_mode emb m c
      | RequestedMap event ->
         Frx_synth.bind c event 
         (fun c -> 
            match Maps.get name with
              RequestedMap _ ->
             Log.f "INTERNAL ERROR: delayed_client_side"
            | KnownMap m -> Cmap.gfx_mode emb m c)
      with
    e -> Log.f (sprintf "INTERNAL ERROR in display (%s)"
                    (Printexc.to_string e))
      end

  | _ ->
    (* in all other cases, get the alt label, and configure it *)
    (* WARNING: there may be an hypermenu here *)
    List.iter (function w ->
      match Winfo.class_name w with
    "Label" ->
    (* remove its border *)
    Label.configure w [BorderWidth (Pixels 0)];
    begin match i with
      Still x -> 
        Label.configure w [x];
        begin match x with
          ImageBitmap _ | ImagePhoto _ ->
        prop := true; (*fit the size to the image*)
        | _ -> () (*We cannot restore the origianl size of the window...*)
        end;
        (* Utility to copy the img url in the selection buffer *)
        bind w (Glevents.get "copyimgurl")
          (BindSet ([], (fun _ ->
        emb.embed_context#invoke "copy" emb.embed_hlink)));
        (* Updating an image *)
        begin
          try 
        let url = 
          Lexurl.make (Hyper.resolve emb.embed_hlink).uri_url in
         bind w (Glevents.get "updateimage")
          (BindSet ([], (fun _ -> Img.update url)))
          with
        Url.Url_Lexing _ -> ()
        end

    | Animated anm -> 
        begin
          let f = Tkanim.animate w anm in
          bind w (Glevents.get "stopanim") (BindSet ([], (fun _ ->
        f false)));
          bind w (Glevents.get "restartanim") (BindSet ([], (fun _ ->
        f true)));
        Label.configure w [Cursor (XCursor "watch")];
          if !gif_anim_auto then f false;
          prop := true (*fit the size to the image*)
        end
    end
      |	"Canvas" -> destroy w (* delete the progress meter *)
      |	_ -> ())
      (Winfo.children emb.embed_frame)
  end;
  if !prop then Pack.propagate_set emb.embed_frame true
@

<<function [[Imgload.put_alt]]>>=
(* put up the alternate text *)
let put_alt emb =
  let m = Label.create_named emb.embed_frame "alt" [Text emb.embed_alt] in
  (* make sure all bindings we put on the frame are attached there *)
  Tk.bindtags m ((WidgetBindings emb.embed_frame)::Tk.bindtags_get m);
  pack [m][Fill Fill_Both; Expand true];
  if not (Pack.propagate_get emb.embed_frame) then begin (* with width and height *)
    if Winfo.reqwidth emb.embed_frame < Winfo.reqwidth m then
      Frame.configure emb.embed_frame [Width (Pixels (Winfo.reqwidth m))];
    if Winfo.reqheight emb.embed_frame < Winfo.reqheight m then
      Frame.configure emb.embed_frame [Height (Pixels (Winfo.reqheight m))];
(* Buggy
    let wf = Winfo.reqwidth emb.embed_frame 
    and wm = Winfo.reqwidth m
    and hf = Winfo.reqheight emb.embed_frame 
    and hm = Winfo.reqheight m
    in
    if wf < wm || hf < hm then begin
      bind emb.embed_frame [[], Enter] (BindExtend ([], (fun _ ->
    if wf < wm then
      Frame.configure emb.embed_frame [Width (Pixels wm)];
    if hf < hm then
      Frame.configure emb.embed_frame [Height (Pixels hm)])));
      bind emb.embed_frame [[], Leave] (BindExtend ([], (fun _ ->
    Frame.configure emb.embed_frame [Width (Pixels wf)];
    Frame.configure emb.embed_frame [Height (Pixels hf)])))
    end
*)
  end
@

<<function [[Imgload.make_auto]]>>=
(* for delayed load, add binding *)
let make_auto delayed emb =
  try
    let url = (Www.make emb.embed_hlink).www_url in
    bind emb.embed_frame
      (Glevents.get "loadimage")
      (BindSet ([], (fun _ -> Img.ImageScheduler.flush_one delayed url)))
  with
    e -> Log.f (sprintf "Can't compute image link (%s)" (Printexc.to_string e))
@

<<function [[Imgload.make_map]]>>=
(* If the object is clickable, make it visible *)

let make_map emb =
  let visible = [
    BorderWidth (Pixels (Tkresource.int "clickableBorderWidth" 2)); 
    Relief (Tkresource.relief "clickableRelief" Raised); 
    Cursor (XCursor (Tkresource.string "clickableCursor" "hand2"));
    Background (NamedColor (Tkresource.string "clickableBackground" "white"))]
  and visible_map = [
    BorderWidth (Pixels (Tkresource.int "clickableBorderWidth" 2)); 
    Relief (Tkresource.relief "clickableRelief" Raised); 
    Cursor (XCursor (Tkresource.string "clickableMapCursor" "left_ptr"));
    Background (NamedColor (Tkresource.string "clickableBackground" "white"))]
  in
  let reconfigure_frame f =
    let internal_width = try int_of_string (cget f CWidth) with _ -> 0 
    and internal_height = try int_of_string (cget f CHeight) with _ -> 0
    and border_width = try int_of_string (cget f CBorderWidth) with _ -> 0
    in
    if internal_width = 0 || internal_height = 0 then ()
    else
      Frame.configure f [ Width (Pixels (internal_width + border_width * 2));
              Height (Pixels (internal_height + border_width * 2))]
  in
  match emb.embed_map with
    ClientSide hlink ->
      Frame.configure emb.embed_frame visible_map;
      reconfigure_frame emb.embed_frame; 
     (* At this moment, we assume that we are in alt mode.
    If the image gets loaded, the label gets destroyed and
    the callback will never be invoked. Instead, it will
    be called from "display" *)
      begin try
       match Winfo.children emb.embed_frame with
    [l] when Winfo.class_name l = "Label" ->
      let uri = Hyper.resolve hlink in
      let name =
        match uri.uri_fragment with 
          None -> uri.uri_url
        | Some frag -> sprintf "%s#%s" uri.uri_url frag in
      begin match Maps.get name with
        KnownMap m -> Cmap.alt_mode emb m l
      | RequestedMap event ->
         Frx_synth.bind l event 
         (fun l -> 
            match Maps.get name with
              RequestedMap _ -> Log.f 
             "INTERNAL ERROR: delayed_client_side"
            | KnownMap m -> Cmap.alt_mode emb m l)
      end
       | _ -> Log.f "make_map. children not a label"
      with
    _ -> ()
      end
  | ServerSide link ->
      Frame.configure emb.embed_frame visible;
      reconfigure_frame emb.embed_frame; 
      (new Htbind.servermap (emb.embed_frame, link))#init emb.embed_context
  | Direct link -> 
      Frame.configure emb.embed_frame visible;
      reconfigure_frame emb.embed_frame; 
      (new Htbind.directmap (emb.embed_frame, link))#init emb.embed_context
  | NoMap -> ()
  | FormMap getlink ->
      Frame.configure emb.embed_frame visible;
      reconfigure_frame emb.embed_frame; 
      (new Htbind.formmap (emb.embed_frame, getlink))#init emb.embed_context
@

<<function [[Imgload.create]]>>=
let create () =
   if !no_images then new loader ()
   else match !mode with
     DuringDoc -> (new synchronous () :> loader)
   | AfterDocAuto -> (new auto() :> loader)
   | AfterDocManual -> (new manual() :> loader)
@


%-------------------------------------------------------------

<<display/imgload.ml>>=
open Printf
open Tk
open Tkanim
open Www
open Uri

open Maps
open Embed
open Img


<<type Imgload.mode (./display/imgload.ml)>>

<<constant [[Imgload.mode]]>>
<<constant [[Imgload.no_images]]>>
<<constant [[Imgload.gif_anim_auto]]>>

<<function [[Imgload.display]]>>

<<function [[Imgload.put_alt]]>>

<<function [[Imgload.make_auto]]>>

(* for manual load, add binding
let make_manual emb =
  try
    let url = (Www.make emb.embed_hlink).www_url in
    bind emb.embed_frame
      (Glevents.get "loadimage")
      (BindSet ([], (fun _ -> activate emb)))
  with
    e -> Log.f (sprintf "Can't compute image link (%s)" (Printexc.to_string e))
 *)

<<function [[Imgload.make_map]]>>


(* The default behavior *)
class loader () =
 object (self)
  val mutable loaded = UrlSet.empty

  method private add_loaded url = 
    loaded <- UrlSet.add url loaded

  method add_image emb =
    put_alt emb; (* make the alt widget*)
    make_map emb (* and possible bindings *)

  method private activate emb =
    Log.debug "Activating image";
    try
      Img.get emb.embed_context#base
    emb.embed_hlink
        (fun url i -> 
      display emb i;
      self#add_loaded url)
        (Tk_progress.meter emb.embed_frame)
    with
      e -> Log.f (sprintf "Can't load image (%s)" (Printexc.to_string e))

  method flush_images = ()
  method load_images = ()
  method update_images = 
    UrlSet.iter Img.update loaded
end

class synchronous () =
 object
  inherit loader () as super

  method! add_image emb =
    super#add_image emb; super#activate emb
end

class auto () =
 object (self)
  inherit loader () as super
  val q = ImageScheduler.new_delayed()

  method! add_image emb =
     super#add_image emb;
     try
       let wr = Www.make emb.embed_hlink in
       wr.www_headers <- "Accept: image/*" :: wr.www_headers;
       ImageScheduler.add_delayed q
     wr
     emb.embed_context#base
     (fun url i -> display emb i; self#add_loaded url)
     (Tk_progress.meter emb.embed_frame)
     with
       e -> Log.f (sprintf "Can't compute image link (%s)"
                   (Printexc.to_string e))

  method! flush_images = ImageScheduler.flush_delayed q
end

class manual () =
 object
  inherit auto () as super

  method! add_image emb =
    super#add_image emb;
    make_auto q emb
 
  method! flush_images = ()

  method! load_images = ImageScheduler.flush_delayed q
end

<<function [[Imgload.create]]>>

@


\subsection*{[[display/html_form.mli]]}


%-------------------------------------------------------------

<<display/html_form.mli>>=

class behaviour :
  string * Html.tag * string option * (string -> string) ->
  object
    val action : string
    val mutable elem_reset : (unit -> unit) list
    val mutable elem_value :
      (Htmlfmt.input_kind * (unit -> (string * string) list)) list
    val encoding : string
    val mutable entries : int
    val fmethod : string
    val h_params : (string * string) list
    method add_get :
      Htmlfmt.input_kind -> (unit -> (string * string) list) -> unit
    method add_reset : (unit -> unit) -> unit
    method reset : unit
    method single_submit : Hyper.link option
    method submit : (string * string) list -> Hyper.link
  end

(*
module Make :
  functor (FormDisplay : Htmlfmt.FormDisplay) ->
    sig
      val init :
        < add_tag : string ->
                    (Htmlfmt.formatter -> Html.tag -> unit) ->
                    (Htmlfmt.formatter -> unit) -> unit;
          base : string; ctx : Viewers.context;
          i18n_encoder : string -> string;
          imgmanager : < add_image : Embed.embobject -> unit; .. >;
          pop_action : unit; push_action : (string -> unit) -> unit;
          remove_tag : string -> unit; target : string option; .. > ->
        unit
    end
*)
val init: 
        < add_tag : string ->
                    (Htmlfmt.formatter -> Html.tag -> unit) ->
                    (Htmlfmt.formatter -> unit) -> unit;
          base : string; ctx : Viewers.context;
          i18n_encoder : string -> string;
          imgmanager : < add_image : Embed.embobject -> unit; .. >;
          pop_action : unit; push_action : (string -> unit) -> unit;
          remove_tag : string -> unit; target : string option; .. > ->
        unit

@


\subsection*{[[display/html_form.ml]]}


%-------------------------------------------------------------

<<display/html_form.ml>>=
open Printf
open Hyper

open Html
open Htmlfmt

(*
 * Level 2 stuff (forms)
 *)

(* The behaviour of a form *)

class behaviour (base, formtag, deftarget, i18n_encoder) =
 object (self)
  val mutable (*private*) elem_value = ([] : (input_kind * (unit -> (string * string) list)) list)
  val mutable (*private*) elem_reset = ([] : (unit -> unit) list)
  val (*private*) fmethod = String.uppercase_ascii (get_attribute formtag "method")    
  val (*private*) encoding = get_attribute formtag "enctype"
  (* val i18n_encoder = i18n_encoder *)
  val (*private*) action = try get_attribute formtag "action" with Not_found -> base
  (* val base = base *)
  val (*private*) h_params = 
    try ["target", get_attribute formtag "target"]
    with Not_found ->
      (match deftarget with
      | Some s -> ["target", s]
      | None -> []
      )

  val mutable (*private*) entries = 0 (* number of text entries *)

  (* Contribute a value to the form *)
  method add_get kind f = 
    elem_value <- (kind, f) :: elem_value;
    if kind = EntryInput then  entries <- entries + 1

  (* How to reset the element *)
  method add_reset f = elem_reset <- f :: elem_reset

  (* The link for a given submit activation *)
  method submit l = 
    let values = List.flatten (List.map (function (_,f)  -> f()) elem_value) in
    let values = l @ values in
    (* These values must be encoded in the same Kanji code of the source here,
     * if it is Japanese mode. And the difficulty is the Kanji code of the
     * document is usually lazily determined. --- JPF 
     *)
    let values_i18n = List.map (fun (t,v) -> t, i18n_encoder v) values in
    let evalues = Urlenc.form_encode (List.rev values_i18n) in
     match fmethod with
       "POST" -> {h_uri = action;
          h_context = Some base;
          h_method = POST evalues;
          h_params = h_params
                 }
     | _ -> 
       let uri = 
         let l = String.length action in 
         if l = 0 then sprintf "?%s" evalues
     else if action.[l-1] = '?' then action ^ evalues
         else sprintf "%s?%s" action evalues
       in
            {h_uri = uri;
             h_context = Some base;
         h_method = GET;
         h_params = h_params}

  (* Submit if only one entry in the form. This may not be the proper test. *)
  method single_submit =
    if entries = 1 then Some (self#submit []) else None

  (* Resetting the form *)
  method reset = List.iter (fun f -> f ()) elem_reset

end

(*
module Make(FormDisplay : FormDisplay) = 
 struct
  open FormDisplay
*)
module FormDisplay = Form
(*
 * <!ELEMENT FORM - - %body.content -(FORM)>
 * <!ATTLIST FORM
 *         action %URL #REQUIRED -- server-side form handler --
 *         method (%HTTP-Method) GET -- see HTTP specification --
 *         enctype %Content-Type; "application/x-www-form-urlencoded"
 *         >
 *)

let init mach =
mach#add_tag "form"
 (fun _fo tform ->
  let behav = 
    new behaviour (mach#base, tform, mach#target, mach#i18n_encoder) in
  let fm = 
    FormDisplay.create mach#base behav mach#ctx in

  (* 8.1.2 Input Field : INPUT *)
  let open_input fo t =
    let inputtype = String.uppercase_ascii (get_attribute t "type") in
    (* Special case for hidden, since there is no formatting *)
    (* HTML 3.2 doesn't specify that NAME and VALUE are required, but
       this is stupid *)
    if inputtype = "HIDDEN" then
    begin try 
      let name = get_attribute t "name" in
      let v = get_attribute t "value" in
      behav#add_get OtherInput (fun () -> [name, v])
    with Not_found -> 
      raise (Invalid_Html "missing NAME or VALUE in input HIDDEN")
    end
    else (* Other cases *)
      let fr = fo.create_embedded (get_attribute t "align") None None in
       match inputtype with
       | "TEXT" | "PASSWORD" ->  fm.text_input fr t
       | "CHECKBOX" -> fm.checkbox_input fr t
       | "RADIO" -> fm.radio_input fr t
       | "IMAGE" -> mach#imgmanager#add_image (fm.image_input fr t)
       | "SUBMIT" -> fm.submit_input fr t
       | "RESET" -> fm.reset_input fr t
       (* TODO: file *)
       | s -> raise (Invalid_Html ("Invalid INPUT TYPE="^s))
  in
  mach#add_tag "input" open_input (fun _ -> ());

  (* 8.1.3 Selection : SELECT *)
  (* the /SELECT does all the job, so we have to transmit the info ! *)
  let options = ref []       (* the components from which to select *)
  and tselect = ref {tag_name = "select"; attributes = []}
  in
  let open_select _fo t =
    options := [];
    tselect := t;
    mach#add_tag "option"
       (fun _fo tag ->
      mach#push_action 
           (fun s ->
           let s = beautify2 s in
           (* the val is by default the "content" of the tag *)
               let va = try get_attribute tag "value" with Not_found -> s in
           options := (va, s,
                          has_attribute tag "selected") :: !options;
           ))
       (fun _ -> mach#pop_action)
  and close_select fo =
    mach#remove_tag "option";
    let fr = fo.create_embedded (get_attribute !tselect "align") None None in
       fm.select fr (List.rev !options) !tselect
  in

  mach#add_tag "select" open_select close_select;

  (* 8.1.4 Text Area: TEXTAREA *)
  let textarea_initial = Ebuffer.create 128 
  and ttextarea = ref {tag_name = "textarea"; attributes = []} in
  let open_textarea _fo tag =
    ttextarea := tag;
    Ebuffer.reset textarea_initial;
    mach#push_action (fun s -> Ebuffer.output_string textarea_initial s)
  and close_textarea fo =
    mach#pop_action;
    let _nameTODO = get_attribute !ttextarea "name" in
    let fr = 
      fo.create_embedded (get_attribute !ttextarea "align") None None in
        fm.textarea fr (Ebuffer.get textarea_initial) !ttextarea

  in

  mach#add_tag "textarea" open_textarea  close_textarea
  )
  (fun _fo -> ["input"; "select"; "textarea"] |> List.iter mach#remove_tag )

(*end *)
@


\subsection*{[[display/htmlw.mli]]}

<<signature [[Htmlw.frames_as_links]]>>=
val frames_as_links : bool ref
@

<<signature [[Htmlw.pscrolling]]>>=
val pscrolling : bool ref
@

<<signature [[Htmlw.ignore_meta_charset]]>>=
val ignore_meta_charset : bool ref
@

<<signature [[Htmlw.progress_report]]>>=
val progress_report : 
    Widget.widget -> Viewers.context -> Widget.widget * Scheduler.progress_func
@

<<signature [[Htmlw.html_head_ui]]>>=
val html_head_ui :
    string list -> (unit -> unit) -> bool ref -> Widget.widget ->
      Viewers.context ->
    Widget.widget * (string -> unit) * (string -> Hyper.link -> unit) *
    (string -> string -> unit) * ((Widget.widget -> unit) -> unit)
(* [html_head_ui headers redisplay scrollmode top ctx]
   returns 
   hgroup, set_title, add_link, add_header, add_extra_header
*)
@

<<signature [[Htmlw.display_html]]>>=
(* [html_head_ui headers redisplay scrollmode top ctx]
   returns 
   hgroup, set_title, add_link, add_header, add_extra_header
*)

val display_html : Viewers.t
@


%-------------------------------------------------------------

<<display/htmlw.mli>>=

<<signature [[Htmlw.frames_as_links]]>>
<<signature [[Htmlw.pscrolling]]>>
<<signature [[Htmlw.ignore_meta_charset]]>>

class  virtual viewer_globs : (Viewers.context * Document.handle) -> object
  (* val ctx : Viewers.context *)
  val mutable dh : Document.handle
  val did : Document.document_id
  method ctx : Viewers.context
  method dh : Document.handle
  method did : Document.document_id
end
(*pad: seems mostly boilerplate getters of params *)

<<signature [[Htmlw.progress_report]]>>

<<signature [[Htmlw.html_head_ui]]>>
<<signature [[Htmlw.display_html]]>>
@


\subsection*{[[display/htmlw.ml]]}


<<constant [[Htmlw.pscrolling]]>>=
let pscrolling = ref false
@

<<constant [[Htmlw.ignore_meta_charset]]>>=
let ignore_meta_charset = ref false
@

<<constant [[Htmlw.scroll_icon]]>>=
let scroll_icon ="
#define mini-scroll-arrows_width 16
#define mini-scroll-arrows_height 14
static char mini-scroll-arrows_bits[] = {
 0x80,0x00,0xc0,0x01,0xc0,0x01,0xe0,0x03,0xf0,0x07,0xf0,0x07,0x00,0x00,0x00,
 0x00,0xf0,0x07,0xf0,0x07,0xe0,0x03,0xc0,0x01,0xc0,0x01,0x80,0x00};
"
@

<<constant [[Htmlw.scroll_image]]>>=
let scroll_image = 
  lazy (ImageBitmap(Imagebitmap.create [Data scroll_icon]))
@


<<function [[Htmlw.html_head_ui]]>>=
let html_head_ui headers redisplay pscroll top ctx =
  (* The frame for all head UI elements *)
  let headgroup = Frame.create_named top "head" [] in
  (* The menubar frame *)
  let bargroup = Frame.create_named headgroup "menubar" [] in
  let titlev = Textvariable.create_temporary headgroup in

  let headersb = Menubutton.create_named bargroup "headers" 
      [TextVariable titlev; TextWidth 80]
  in
  let headersm = Menu.create_named headersb "menu" [] in
  Menubutton.configure headersb [Menu headersm];

  (* The link button and menu *)
  let linkb = 
    Menubutton.create_named bargroup "links" [Text "Links"; State Disabled] in
  let linkmenu = Menu.create_named linkb "linkmenu" [] in
  Menubutton.configure linkb [Menu linkmenu];

  (* The scroll-mode button *)
  let scrollv = Textvariable.create_temporary bargroup in
  Textvariable.set scrollv 
      (if !pscroll then "1" else "0");
  let scrollb = 
    Checkbutton.create_named bargroup "smoothScroll" 
      [ Variable scrollv; Lazy.force scroll_image;
    IndicatorOn false; Command (fun () ->
      match Textvariable.get scrollv with
        "1" -> pscroll := true; redisplay()
      | _ -> pscroll := false; redisplay())]
  in
  (* bargroup IN THIS ORDER -- RESIZING *)
  pack [linkb][Side Side_Right];
  pack [scrollb][Side Side_Right; Fill Fill_Y];
  pack [headersb][Side Side_Left; Fill Fill_X; Expand true];
  pack [bargroup][Side Side_Top; Fill Fill_X];

  let set_title t =
    let tl = Winfo.toplevel top
    and title = s_ "MMM Browser@%s" t in
    if Widget.known_class tl = "toplevel" then
      (Wm.title_set tl title; Wm.iconname_set tl title);
    Textvariable.set titlev t

  and add_link title hlink = 
    Menubutton.configure linkb [State Normal];
    Menu.add_command linkmenu [ Label title; 
                Command (fun () -> ctx#goto hlink)]
      
  in
  
  (* Extra headers: META tags should be parsed by *servers*, not by clients.
     TODO: find interface so we can export this feature to applets/modules
     *)
  let sep_added = ref false in
  let add_header h v =
    if not !sep_added then (sep_added := true; Menu.add_separator headersm);
    let txt = sprintf "%s: %s" h v in
    match String.lowercase_ascii h with
      "refresh" ->
       begin try
          let pos = String.index v ';'
          and pos2 = String.index v '=' in
          let _delay = int_of_string (String.sub v 0 pos)
          and url = String.sub v (pos2+1) (String.length v - pos2 - 1) in
      Menu.add_command headersm 
        [Label txt;
          Command (fun () -> ctx#goto {
        h_uri = url;
        h_context = Some (Url.string_of ctx#base.document_url);
        h_method = GET;
            h_params = []})]
    with Not_found | Failure "int_of_string" -> ()
    end
    | _ -> Menu.add_command headersm [Label txt] 

  in
  (* the head menu is a good place to put some other information and ui *)
  (* you must be sure that this function is used after all the head ui
   * stuff using add_header are finished. 
   *)  
  let sep_extra_added = ref false in 
  let add_extra_header f =
    if not !sep_extra_added then
       (sep_extra_added := true; Menu.add_separator headersm);
    f headersm
  in

  set_title (Url.string_of ctx#base.document_url);
  List.iter (function h -> Menu.add_command headersm [Label h])
    (List.rev headers);
  
  headgroup, set_title, add_link, add_header, add_extra_header
@

<<function [[Htmlw.ignore_open]]>>=
(*
 * Extend a display machine to interpret HEAD elements with
 * an influence on the HEAD ui display.
 * NOTE: some other HEAD elements interpretation *must* be done
 * even if we don't have UI for HEAD (e.g. base)
 *)
let ignore_open _ _ = ()
@

<<function [[Htmlw.ignore_close]]>>=
let ignore_close _ = ()
@

<<function [[Htmlw.head_hook]]>>=
let head_hook (headgroup,set_title,add_link,add_header) mach =
  mach#add_tag "title" 
    (fun _fo _t ->
      mach#push_action
    (fun s -> 
      set_title (Html.beautify2 s);
      mach#pop_action))
    ignore_close;
      
  mach#add_tag "isindex"
    (fun _fo tag ->
      let prompt = get_attribute tag "prompt" in
      let action s =
    mach#ctx#goto { h_uri = "?" ^ Urlenc.encode s;
               h_context = Some mach#base;
               h_method = GET;
               h_params = []} in
      let f,_e = Frx_entry.new_label_entry headgroup prompt action in
      pack [f] [Fill Fill_X])
    ignore_close;

  mach#add_tag "link"
    (fun _fo tag ->
      try
        let href = get_attribute tag "href" in
    let name = 
      try get_attribute tag "title"
      with Not_found ->
        try get_attribute tag "rel"
        with Not_found -> 
          try get_attribute tag "rev"
          with Not_found -> href in
    let h_params =
      try ["target", get_attribute tag "target"]
      with
        Not_found ->
          match mach#target with
        Some s -> ["target", s]
          |	None -> []
        in
        add_link name { h_uri = href; h_context = Some mach#base;
            h_method = GET; h_params = h_params}
      with
    Not_found -> () (* no href *))
    ignore_close;

  begin
    let old =
      try
    let oldo, _c = mach#get_tag "meta" in oldo
      with
    Not_found -> ignore_open in
    mach#add_tag "meta"
      (fun fo tag ->
       try 
      old fo tag;
      add_header 
        (get_attribute tag "http-equiv")
        (get_attribute tag "content")
       with Not_found -> ())
      ignore_close;
  end;

  (* Non standard extensions *)
  if !frames_as_links  then
    mach#add_tag "frame"
      (fun _fo tag ->
    try
         let src = get_attribute tag "src" in
         let name =
        sprintf "Frame %s" 
          (try get_attribute tag "name"
          with Not_found -> "unnamed")
      in
      add_link name { h_uri = src; h_context = Some mach#base;
              h_method = GET; h_params = []}
    with
      Not_found -> () (* no src *))
      ignore_close
@


<<function [[Htmlw.embedded_html]]>>=
(* TODO: we should be able to share the imgmanager, but I don't see
 *  where we can get it from (except by adding something in ctx)
 *)
let embedded_html mediapars top ctx doc =
  let imgmanager = Imgload.create() in
  let dh = Decoders.insert (Cache.make_embed_handle doc) in
  let ctx = ctx#in_embed dh.document_id in
  let viewer = new display_html (top,ctx,mediapars,imgmanager,dh) in
  viewer#init false;
  pack [viewer#di_widget][Expand true; Fill Fill_Both];
  (* set for events *)
  Frx_synth.bind viewer#di_widget "load_images" 
    (fun _top -> viewer#di_load_images);
  Frx_synth.bind viewer#di_widget "update" 
    (fun _ -> Embed.update top ctx doc (fun () -> viewer#di_update))
@


<<toplevel [[Htmlw._2]]>>=
let _ =
  Embed.add_viewer ("text", "html") embedded_html
@


%-------------------------------------------------------------

<<display/htmlw.ml>>=
open I18n
open Printf
open Tk
open Html
open Html_eval
open Hyper
open Document
open Viewers
open Htmlfmt
open Feed
open Embed
open Htframe

<<constant [[Htmlw.frames_as_links]]>>
<<constant [[Htmlw.pscrolling]]>>
<<constant [[Htmlw.ignore_meta_charset]]>>

<<constant [[Htmlw.scroll_icon]]>>

<<constant [[Htmlw.scroll_image]]>>

<<module Htmlw.F>>


<<function [[Htmlw.progress_report]]>>

<<function [[Htmlw.html_head_ui]]>>


<<function [[Htmlw.ignore_open]]>>
<<function [[Htmlw.ignore_close]]>>

<<function [[Htmlw.head_hook]]>>

(* This class only defines globals *)
class  virtual viewer_globs ((ctx : Viewers.context),
                (dh' : Document.handle)) =
 object

  (* copy params *)
  (* val ctx = ctx *)           
  method ctx = ctx

  val mutable dh = dh'
  method dh = dh

  val did = dh'.document_id
  method did = did
end

(* We still need dh at construction for the definition of feed_red *)
class  virtual html_parse (dh) =
 object (self)

  method virtual dh : Document.handle
  method virtual set_progress: int option -> int -> unit

  (* red tape for progress report *)
  val mutable red = 0
  val mutable size = 
    try Some (Http_headers.contentlength dh.dh_headers)
    with Not_found -> None (* duh *)
  val mutable feed_read = new Japan.read_i18n (fun _s _o _n -> 0)

  val mutable (*private*) lexbuf = Lexing.from_string "" (* duh *)
  method lexbuf = lexbuf  

  val mutable lexer = sgml_lexer !Dtd.current

  (* Japanese parse configuration *)
  val jpn_config = Japan.default_config ()

  method parse_init =
    red <- 0;
    feed_read <-
       Japan.create_read_native self#dh.document_feed.feed_read;
    (* Q: do we need to restart a new sgml_lexer ? *)
    lexer <- sgml_lexer !Dtd.current;
    lexbuf <- 
       Lexing.from_function (fun buf n -> 
     let r = feed_read#read buf 0 n in
     red <- red + r;
     self#set_progress size red;
     r)
end

class  virtual html_body () =
 object (self)

  method virtual mach : Html_disp.machine
  method virtual ctx: context
  method virtual frame : Widget.widget

  val current_scroll_mode = ref !pscrolling
  method current_scroll_mode = current_scroll_mode

  (* hack for frames on incorrect html *)
  val mutable body_frame = None
  method body_init full =
    (* Install a tag handler for body that will actually create the
       a formatter and install it *)
    let body_formatter = ref None in
    self#mach#add_tag "body" 
      (fun _fo t ->
    match !body_formatter with
    | None -> (* it's the first body *)
        let format, fhtml = 
          self#mach#create_formatter 
           (if full then (TopFormatter !current_scroll_mode) 
           else FrameFormatter self#ctx#params)
           self#frame
        in
        self#mach#push_formatter format;
        body_formatter := Some format;
        body_frame <- Some fhtml;
        pack [fhtml][Side Side_Left; Expand true; Fill Fill_Both];
         List.iter (function
          | "bgcolor", color -> 
             format.set_defaults "background" [BgColor color]
          | "text", color -> 
          format.set_defaults "foreground" [FgColor color]
          | "link", color ->
          format.set_defaults "link" [FgColor color]
          | "alink", color ->
          format.set_defaults "alink" [FgColor color]
          | "vlink", color ->
          format.set_defaults "vlink" [FgColor color]
          | _,_ -> ())
             t.attributes
    | Some f -> (* multiple body... *)
        self#mach#push_formatter f
     )
      (fun _t -> 
    ignore self#mach#pop_formatter)
end

(* geek stuff *)
class  virtual bored () =
 object (self)
  method virtual ctx: context
  method virtual mach: F.machine

  method bored_init hgbas =
    let bored = 
      Resource.get Widget.default_toplevel "bored" "bored" = "yes"
    || begin try
       ignore (
         Str.search_forward (Str.regexp_case_fold "sandra") self#mach#base 0);
       Resource.add "*bored" "yes" Interactive;
       true
    with Not_found -> false
    end in
    if bored then begin
      let b = Button.create hgbas [
       Text "\182"; BorderWidth (Pixels 0);
       Command (fun () ->
      self#ctx#goto 
       (Hyper.default_link  
         "http://www.columbiatristar.co.uk/the_net/contents.html")
      )] in
      let l  = Winfo.children hgbas in
      pack [b][After (List.hd l); Side Side_Right]
    end

end

<<class [[Htmlw.display_html]]>>
      
<<function [[Htmlw.display_html]]>>

<<function [[Htmlw.embedded_html]]>>

<<toplevel [[Htmlw._1]]>>
<<toplevel [[Htmlw._2]]>>

@

<<[[Htmlfmt.gattr]] color cases>>=
| BgColor of string
@


%       (*
%       if !Lang.japan 
%       then Japan.create_read_japanese self#dh.document_feed.feed_read jpn_config
%       else 
%       *)


\subsection*{[[display/form.mli]]}

<<signature [[Form.form_bg]]>>=
val form_bg : string ref
@

<<type [[Form.t]]>>=
type t = {
  text_input : Widget.widget -> Html.tag -> unit;
      (* [text_input top tag] *)
  checkbox_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  radio_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  image_input : Widget.widget ->  Html.tag -> Embed.embobject;
      (* [input top tag] *)
  submit_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  reset_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  select : Widget.widget -> (string * string * bool) list -> Html.tag -> unit;
      (* [select top elements tag] *)

  textarea:  Widget.widget -> string -> Html.tag -> unit
      (* [textarea top initial attrs] *)
}
@

<<signature [[Form.create]]>>=
val create: 
  string -> Htmlfmt.form_behaviour -> Viewers.context -> t
@


%-------------------------------------------------------------

<<display/form.mli>>=

<<signature [[Form.form_bg]]>>

<<type [[Form.t]]>>

<<signature [[Form.create]]>>

@


\subsection*{[[display/form.ml]]}

<<constant [[Form.form_bg]]>>=
let form_bg = ref "#d9d9d9"
@

<<type Form.t (./display/form.ml)>>=
type t = {
  text_input : Widget.widget -> tag -> unit;
      (* [text_input top tag] *)
  checkbox_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  radio_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  image_input : Widget.widget ->  tag -> embobject;
      (* [input top tag] *)
  submit_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  reset_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  select : Widget.widget -> (string * string * bool) list -> tag -> unit;
      (* [select top elements tag] *)
  textarea:  Widget.widget -> string -> tag -> unit
      (* [textarea top initial attrs] *)
  }
@

<<function [[Form.mapi]]>>=
(* mapi (fun n x -> ...) n0 l *)
let rec mapi f n l =
  match l with
    [] -> [] 
  | x::l -> let v = f n x in v::(mapi f (succ n) l)
@

<<function [[Form.focus_link]]>>=
(* Do our own Tab/Shift-Tab : don't call it for Text widgets ! *)
let focus_link prev w =
  match !prev with
    None -> prev := Some w;
  | Some old ->
      bind old [[], KeyPressDetail "Tab"]
       (BindSetBreakable ([], fun _ei -> try Focus.set w with _ -> ()));
      bind w [[Shift], KeyPressDetail "Tab"]
       (BindSetBreakable ([], fun _ei -> try Focus.set old with _ -> ()));
      prev := Some w
@

<<function [[Form.text_input]]>>=
(* TODO: MAXLENGTH *)
let text_input prev_widget ctx behav top tag =
  try
    let name = get_attribute tag "name"
    and inputtype = get_attribute tag "type" in
    (* Create an entry widget : don't take focus unless we click in it *)
    let e = Entry.create top [ExportSelection false; TakeFocus false; 
                  Background (NamedColor !form_bg)] in
    (* Check for size *)
    begin try 
     let s = get_attribute tag "size" in
      try Entry.configure e [TextWidth (int_of_string s)]
      with Failure "int_of_string" ->
     Log.f (sprintf "%s not a valid val for SIZE" s)
    with Not_found -> ()
    end;
    (* Check for passwd *)
    if String.lowercase_ascii inputtype = "password" then 
      Entry.configure e [Show '*'];
    (* The behaviours *)
    let reset = 
      try
    let v = get_attribute tag "value" in
     Entry.insert e End v;
     (fun () -> Entry.delete_range e (Number 0) End;
            Entry.insert e End v)
      with Not_found ->
     (fun () -> Entry.delete_range e (Number 0) End)
    (* spec says we could omit if empty *)
    and get_value () = [name, Entry.get e]
    in
      focus_link prev_widget e;
      pack [e][];
      behav#add_get EntryInput get_value;
      behav#add_reset reset;
     (* single-entry : enter submits the form *)
      Tk.bind e [[], KeyPressDetail "Return"] 
         (BindSet ([], (fun _ -> 
       match behav#single_submit with
         Some h -> ctx#goto h
       | None -> ())))
  with
    Not_found ->
      raise (Invalid_Html "Missing NAME in TEXT or PASSWORD")
@

<<function [[Form.checkbox_input]]>>=
(* A CHECKBOX input *)
let checkbox_input prev_widget behav top tag =
  try
    let name = get_attribute tag "name" in
    let v = Textvariable.create_temporary top in  (* variable val is 1/0 *)
    let c = Checkbutton.create top [Variable v; TakeFocus false] in
    let reset =
      if has_attribute tag "checked" then begin
    Checkbutton.select c;
    (fun () -> Checkbutton.select c)
    end
      else (fun () -> Checkbutton.deselect c)
    and get_value =
      let value = 
    try get_attribute tag "value" 
    with Not_found ->
         (* other browsers seem to use "on". Thanks to Dave Love for pointing
            this out *)
     Log.f "no VALUE given for input CHECKBOX, using \"on\"";
     "on" in
      (* spec says we SHOULD omit when not selected *)
      (fun () -> 
     match Textvariable.get v with 
       "1" -> [name, value]
     | _ -> [])
    in
      focus_link prev_widget c;
      pack [c][];
      behav#add_get OtherInput get_value;
      behav#add_reset reset
  with
    Not_found ->
      raise (Invalid_Html "Missing NAME in CHECKBOX")
@

<<function [[Form.radio_input]]>>=
(* ONLY THE FIRST BUTTON RESET/GET_VALUE IS USED *)
let radio_input prev_widget behav = 
  (* Table of radio names *)
  let radios = Hashtbl.create 17 in
  (fun top tag ->
     try
       let name = get_attribute tag "name" in
       let r = Radiobutton.create top [TakeFocus false]
       and checked = has_attribute tag "checked"
       and va = try get_attribute tag "value" with Not_found -> "on"
       in
       try
     let v, sel = Hashtbl.find radios name in
       (* We already have a radiobutton with this name *)
       Radiobutton.configure r [Variable v; Value va];
       if checked then begin 
         Radiobutton.select r; (* select it *)
         sel := r (* store it in table for reset *)
       end;
       (* no need to add behaviour *)
       focus_link prev_widget r;
       pack [r][]
       with
     Not_found ->
       (* this is the first radio button with this name *)
       (* it this thus assumed checked *)
        let v = Textvariable.create_temporary top in
         Hashtbl.add radios name (v, ref r);
        let get_value () = [name, Textvariable.get v]
        and reset () = 
           (* to reset, we must lookup the table *)
          let _, sel = Hashtbl.find radios name in
        Radiobutton.select !sel 
        in
        Radiobutton.configure r [Variable v; Value va];
        Radiobutton.select r; (* assume selected *)
        focus_link prev_widget r;
        pack [r][];
        behav#add_get OtherInput get_value;
        behav#add_reset reset
    with
      Not_found ->
    raise (Invalid_Html "Missing NAME in RADIO"))
@

<<function [[Form.image_input]]>>=
(* An IMAGE input 
 * Q: no target here ?
 *)
let image_input _prev_widget ctx base behav top tag =
  try
    let n = get_attribute tag "name" in
    let src = get_attribute tag "src" in
    let alt = 
       try get_attribute tag "alt"
       with Not_found -> "[INPUT IMAGE]"
    in
      {
      embed_hlink = 
          { h_uri = src; h_context = Some base; h_method = GET; h_params =[] };
      embed_frame = top;
      embed_context = ctx; (* pass as is... *)
      embed_map = FormMap (fun (x, y) ->
                 let subargs =
                                [sprintf "%s.x" n, string_of_int x;
                                 sprintf "%s.y" n, string_of_int y] in
                   behav#submit subargs);
      embed_alt = alt}
  with
  Not_found ->
    raise (Invalid_Html "missing NAME or SRC in input IMAGE")
@

<<function [[Form.submit_input]]>>=
(* A Submit button *)
let submit_input _prev_widget ctx behav top tag = 
  let l = 
    try get_attribute tag "value"
    with Not_found -> s_ "Submit"
  in
  try
    let n = get_attribute tag "name" in
    pack [Button.create top [Text l; TakeFocus false;
         Command (fun () -> ctx#goto (behav#submit [n,l]))]]
         []
  with
    Not_found ->
     (* if name is not present, the button does not contribute a value *)
     pack [Button.create top [Text l; TakeFocus false;
          Command (fun () -> ctx#goto (behav#submit []))]]
      []
@

<<function [[Form.reset_input]]>>=
let reset_input _prev_widget behav top tag = 
  let l = 
    try get_attribute tag "value"
    with Not_found -> s_ "Reset" in
  let b = Button.create top [Text l; TakeFocus false;
                 Command (fun () -> behav#reset)] in
    pack[b][]
@

<<function [[Form.select]]>>=
(* options is: (val, displayed thing, selected) list *)    
let select prev_widget behav top options tag =
  let name = get_attribute tag "name" in
  let ssize = get_attribute tag "size" in
  let size =
     try int_of_string ssize
     with _ -> 
    Log.f (sprintf "%s not a valid val for SIZE" ssize);
    5 in
  let multiple = has_attribute tag "multiple" in
  (* assume 20 vertical pixels per menu item *)
  let fit_vertical n = 20 * n < Winfo.screenheight top in
  if size = 1 && not multiple && fit_vertical (List.length options)
  then begin (* menus larger than screen are bad, use an optionmenu *)
    let vard = Textvariable.create_temporary top   (* var to display *)
    and varv = Textvariable.create_temporary top   (* var for val *)
    in
    let m = Menubutton.create top 
         [TextVariable vard; Relief Raised; Anchor Center; TakeFocus false] in
    let mmenu = Menu.create m [TearOff false] in
     Menubutton.configure m [Menu mmenu];
     let initial =
       match options with
     [] -> raise (Invalid_Html ("No OPTION in SELECT"))
       | opt :: _ -> ref opt in
     List.iter (function (v,d,s) as x ->
        Menu.add_command mmenu
            [Label d;
             Command (fun () -> 
                   Textvariable.set varv v;
                   Textvariable.set vard d
                  )];
        if s then initial := x
        )
          options;
     let reset () =
       match !initial with
    (v,d,_) -> 
         Textvariable.set varv v;
         Textvariable.set vard d
     and get_value () = [name, Textvariable.get varv] in
       reset();
       focus_link prev_widget m;
       pack [m][];
       behav#add_get OtherInput get_value;
       behav#add_reset reset
     end
  else begin (* use a listbox *)
   (* listbox indices start at 0 *)
   (* we must not ExportSelection, otherwise one unique listbox can *)
   (* have a current selection *)
    let nth_entry n l =
      let (v,_,_) = List.nth l n in v in
    let f,lb = Frx_listbox.new_scrollable_listbox top 
      [TextHeight size; TextWidth 0; (* automatic size *)
       (if multiple then SelectMode Multiple else SelectMode Single);
       ExportSelection false; Background (NamedColor !form_bg)] in
      Listbox.configure lb [TakeFocus false];
    let initial = ref [] in
    let entries =
     mapi (fun i (_,v,s) -> 
           if s then initial := i :: !initial;
           v) 0 options in
      Listbox.insert lb End entries;
    if !initial = [] then initial := [0];
    let reset () = 
       Listbox.selection_clear lb (Number 0) End;
       List.iter (fun i ->
         Listbox.selection_set lb (Number i)(Number i))
           !initial
    and get_value () =
       List.map (function
          Number n -> name, nth_entry n options
        | _ -> name, nth_entry 0 options (* fatal error ! *))
       (Listbox.curselection lb)
    in
      reset (); 
      focus_link prev_widget f;
      pack [f][];
      behav#add_reset reset;
      behav#add_get OtherInput get_value
    end
@

<<function [[Form.textarea]]>>=
let textarea _prev_widget behav top initial tag = 
  try 
    let name = get_attribute tag "name" in
    let f,t = 
       Frx_text.new_scrollable_text top
           [ExportSelection false; TakeFocus false] false in
    Text.configure t [Background (NamedColor !form_bg)];
    begin try
      let w = get_attribute tag "cols" in
      try Text.configure t [TextWidth (int_of_string w)]
      with Failure "int_of_string" ->
    Log.f (sprintf "%s not a valid val for COLS" w)
    with Not_found -> ()
    end;
    begin try
      let h = get_attribute tag "rows" in
      try Text.configure t [TextHeight (int_of_string h)]
      with Failure "int_of_string" ->
    Log.f (sprintf "%s not a valid val for ROWS" h)
    with Not_found -> ()
    end;
    Text.insert t Frx_text.textEnd initial [];
    let reset () =
      Text.delete t (TextIndex(LineChar(0,0), [])) Frx_text.textEnd;
      Text.insert t Frx_text.textEnd initial []
    and get_value () =
      [name, Text.get t (TextIndex(LineChar(0,0), [])) 
           (TextIndex(End, [CharOffset (-1)]))]
    in
       pack [f][];
       behav#add_reset reset;
       behav#add_get EntryInput get_value
  with
    Not_found -> raise (Invalid_Html "Missing NAME in TEXTAREA")
@

<<function [[Form.create]]>>=
let create base behav ctx =
  let prev_widget = ref None in
  { text_input = text_input prev_widget ctx behav;
    checkbox_input = checkbox_input prev_widget behav;
    radio_input = radio_input prev_widget behav;
    image_input = image_input prev_widget ctx base behav;
    submit_input = submit_input prev_widget ctx behav;
    reset_input = reset_input prev_widget behav;
    select = select prev_widget behav;
    textarea = textarea prev_widget behav
  }
@


%-------------------------------------------------------------

<<display/form.ml>>=
(* Tk based FormDisplay  *)
open I18n
open Printf
open Tk
open Hyper

open Html
open Htmlfmt
open Maps
open Embed


<<constant [[Form.form_bg]]>>

<<type Form.t (./display/form.ml)>>

(* Most of the widgets created here are created with [TakeFocus false];
 * The reason is that otherwise, in "focus follows mouse" mode, when scrolling
 * a text widget containing form elements, the mouse may come over one of
 * these elements; it would then set the focus to the element, and break
 * further scrolling. Instead, with [TakeFocus false], the user has to
 * click explicitly in the widgets (especially entries and text) in order
 * to fill them.
 * However, we do attempt to re-implement the Tab/Shift-Tab system that we
 * inevitably broke by setting [TakeFocus false].
 * Phew.
 *)


<<function [[Form.mapi]]>>

<<function [[Form.focus_link]]>>

(* A TEXT or PASSWORD input *)
<<function [[Form.text_input]]>>


<<function [[Form.checkbox_input]]>>


(* A RADIO input *)
<<function [[Form.radio_input]]>>


<<function [[Form.image_input]]>>


<<function [[Form.submit_input]]>>


<<function [[Form.reset_input]]>>



 (* TODO: FILE (RFC 1867) *)



(* A SELECT list *)
<<function [[Form.select]]>>

<<function [[Form.textarea]]>>


<<function [[Form.create]]>>
@


\subsection*{[[display/html_table.mli]]}


%-------------------------------------------------------------

<<display/html_table.mli>>=
(*
module Make :
  functor (TableDisplay : Htmlfmt.TableDisplay) ->
    sig
      val init :
        < add_tag : string ->
                    (Htmlfmt.formatter -> Html.tag -> unit) ->
                    (Htmlfmt.formatter -> unit) -> unit;
          create_formatter : Htmlfmt.formatterSpec ->
                             Widget.widget -> 'a * Widget.widget;
          pop_formatter : 'b; push_formatter : 'a -> 'c;
          remove_tag : string -> unit; .. > ->
        unit
    end
*)
val init: 
        < add_tag : string ->
                    (Htmlfmt.formatter -> Html.tag -> unit) ->
                    (Htmlfmt.formatter -> unit) -> unit;
          create_formatter : Htmlfmt.formatterSpec ->
                             Widget.widget -> 'a * Widget.widget;
          pop_formatter : 'b; push_formatter : 'a -> unit;
          remove_tag : string -> unit; .. > ->
        unit

@


\subsection*{[[display/html_table.ml]]}


%-------------------------------------------------------------

<<display/html_table.ml>>=
open Html
open Htmlfmt

(* 
HTML Tables are defined by RFC1942, e.g.
  <URL:ftp://ds.internic.net/rfc/rfc1942.txt>

This code *assumes* that minimisation rules are used for
cells (td and th) and for rows.
 *)

(*
module Make (TableDisplay: TableDisplay) =
struct
open TableDisplay
*)
module TableDisplay = Table
open Table

let init mach =

  (* Tables may be nested, so we need to remember *)
  let table_stack = ref ([] : TableDisplay.t list) in

  (* Access to the stack *)
  let tm () = match !table_stack with
      tm::_ -> tm
    | [] -> raise (Invalid_Html "Table element outside <TABLE></TABLE>")
  and pop_table () = match !table_stack with
    | _tm::l -> table_stack := l
    | [] -> raise (Invalid_Html "Unmatched </TABLE>")
  and push_table tm = table_stack := tm :: !table_stack
  and _is_nested () = 
    match !table_stack with
      [] -> false
    | _ -> true
  in

  (* Layout information : the current constraint width *)

  let widths = ref [] in (* because tables are nested *)
  let current_width () = 
    match !widths with
      [] -> TopWidth
    | x::_l -> x
  and push_width w =
    widths := w :: !widths
  and pop_width () = 
    match !widths with
      [] -> ()
    | _x::l -> widths := l
  in
  (* <TABLE> starts a table *)
  let open_table fo t =
    fo.new_paragraph();
    (* Create the widget for embedding this table *)
    let fr = fo.create_embedded "" None None in
    (* And the table manager *)
    let tm = TableDisplay.create fr t (current_width()) in 
    (* push the table on the stack *)
    push_table tm;
    (* define behavior of other tags *)
    (* align/valign attributes *)
    let current_row_align = ref None
    and current_row_valign = ref None
    in
    let change_aligns t =
      current_row_align := 
     (try Some (String.lowercase_ascii (get_attribute t "align"))
      with Not_found -> None);
      current_row_valign := 
     (try Some (String.lowercase_ascii (get_attribute t "valign"))
      with Not_found -> None)
    in 

   let cell_aligns attrs =
     begin try Some (String.lowercase_ascii (get_attribute attrs "align"))
       with Not_found -> !current_row_align
     end,
     begin try Some (String.lowercase_ascii (get_attribute attrs "valign"))
       with Not_found -> !current_row_valign
     end
   in
    (* <TR> : starts a row *)
    let open_tr _fo t = change_aligns t; tm.open_row t
    and close_tr _fo = tm.close_row() in
    mach#add_tag "tr" open_tr close_tr;

    (* A new cell *)
    let open_cell kind _fo t =
      let align,_valign = cell_aligns t in
      let align = match align with 
    Some align -> align
      |	None -> match kind with 
      HeaderCell -> "center"
    | DataCell -> "left"
      in
      (* Create a new formatter, given as parent the table widget *)
      let formatter, tcell = 
    mach#create_formatter NestedFormatter tm.table_master in
    mach#push_formatter formatter;
    push_width (tm.new_cell kind t tcell align)

    and close_cell fo =
      (* fo is the formatter that was open for *this* cell *)
      fo.flush();
      (* pop it *)
      mach#pop_formatter |> ignore;
      pop_width()
    in
    mach#add_tag "th" (open_cell HeaderCell) close_cell;
    mach#add_tag "td" (open_cell DataCell) close_cell;
    mach#add_tag "col" (fun _fo t -> tm.add_col t) (fun _ -> ());

  and close_table fo = 
    (* close the table manager *)
    (tm()).close_table();
    pop_table();
    fo.close_paragraph ();
     (* NOTE: this is the correct fo only if minimisation were applied
        and the correct current formatter is passed to close table
      *)
    (* remove tags *)
    List.iter mach#remove_tag ["tr";"th";"td";"col"];
  in

  mach#add_tag "table" open_table close_table;

(* end *)
@


\subsection*{[[display/styles.mli]]}

<<signature [[Styles.init]]>>=
val init : string -> string -> unit
    (* [init family slant] *)
@

<<signature [[Styles.set_font]]>>=
val set_font : string -> Fonts.fontAttrs -> unit
    (* [set_font symbolic_name attrs] *)
@

<<signature [[Styles.get_font]]>>=
val get_font : string -> Fonts.fontAttrs
    (* [get_font symbolic_name] *)
@

<<signature [[Styles.get]]>>=
(*
 * Retrieves graphical attributes for a given font
 *)

val get : string -> Htmlfmt.gattr list
@


%-------------------------------------------------------------

<<display/styles.mli>>=
(*
 * Definition of attributes of symbolic fonts (font-modifiers)
 *)

<<signature [[Styles.init]]>>

<<signature [[Styles.set_font]]>>
<<signature [[Styles.get_font]]>>

<<signature [[Styles.get]]>>
@


\subsection*{[[display/styles.ml]]}

<<constant [[Styles.fonttable]]>>=
(* Definition of font attributes *)
let fonttable = (Hashtbl.create 37 : (string, fontAttrs) Hashtbl.t)
@

<<constant [[Styles.get_font]]>>=
let get_font =  Hashtbl.find fonttable
@

<<function [[Styles.set_font]]>>=
let set_font name attrs =
  Hashtbl.remove fonttable name;
  Hashtbl.add fonttable name attrs;
  if name = "default" then 
    Fonts.default := Fonts.merge !Fonts.default attrs
@

<<constant [[Styles.table]]>>=
(* 
 * Graphical attributes for a given symbolic name 
 * TODO: to support a notion of style sheet, this table should be
 * specific to each display machine, and should define all the properties
 * of the style sheet display model
 *)
let table = (Hashtbl.create 37 : (string, gattr list) Hashtbl.t)
@

<<function [[Styles.get]]>>=
(* Merge font attributes and other attributes *)
let get s = 
  let fontattrs = 
   try Hashtbl.find fonttable s with Not_found -> []
  and otherattrs =
   try Hashtbl.find table s with Not_found -> []
  in
  let attrs =  List.map (fun fi -> Font fi) fontattrs @ otherattrs 
  in
   if attrs = [] then raise Not_found else attrs
@

<<function [[Styles.define_style]]>>=
let define_style name attrs =
  Hashtbl.remove table name;
  Hashtbl.add table name attrs
@

<<function [[Styles.init]]>>=
let init family slant =
  Hashtbl.clear fonttable;
  Hashtbl.clear table;
  (* font initialisation is moot if we have preferences,
     but just in case (no preference file at all), we keep it*)
  List.iter (function (name,attrs) -> set_font name attrs)
    [ "default",  [Family family;  Weight "medium"; Slant "r";  FontIndex 3];
      "header1", [Family family;  Weight "bold"; Slant "r"; FontIndex 7];
      "header2", [Family family;  Weight "bold"; Slant "r"; FontIndex 6];
      "header3", [Family family;  Weight "medium"; Slant slant; FontIndex 5];
      "header4", [Family family;  Weight "bold"; Slant "r"; FontIndex 4];
      "header5", [Family family;  Weight "medium"; Slant slant; FontIndex 4];
      "header6", [Family family;  Weight "bold"; Slant "r"; FontIndex 4];
      "bold", [ Weight "bold"];
      "italic", [ Slant slant];
      (* should be a fixed font. Since we have newlines, spacing should be 0 *)
      "verbatim", [Family "courier"];
      "fixed", [Family "courier"]
    ];
  List.iter (function (name,attrs) -> define_style name attrs)
    [ "default", [Justification "center"; Spacing 2];
      "verbatim", [Spacing 1];
      "header1", [Justification "center"; Spacing 20];
      "header2", [Justification "center"; Spacing 10];
      "header3", [Justification "left"; Spacing 10];
      "header4", [Justification "left"; Spacing 5];
      "header5", [Justification "left"];
      "header6", [Justification "left"]
    ]
@

<<toplevel [[Styles._1]]>>=
let _ = init "helvetica" "o"
@


%-------------------------------------------------------------

<<display/styles.ml>>=
(* Styles are common display attributes *)
open Htmlfmt
open Fonts


<<constant [[Styles.fonttable]]>>

<<constant [[Styles.get_font]]>>
<<function [[Styles.set_font]]>>


<<constant [[Styles.table]]>>

<<function [[Styles.get]]>>

<<function [[Styles.define_style]]>>

<<function [[Styles.init]]>>


<<toplevel [[Styles._1]]>>
@


\subsection*{[[display/table.mli]]}

<<signature [[Table.debug]]>>=
(* TABLES *)

val debug : bool ref
@

<<signature [[Table.strict_32]]>>=
val strict_32 : bool ref
@

<<type [[Table.cell_type]]>>=
type cell_type = HeaderCell | DataCell
@

<<type [[Table.t]]>>=
type t = {
  table_master : Widget.widget;
  add_col : Html.tag -> unit;
  open_row : Html.tag -> unit;
  close_row : unit -> unit;
  close_table : unit -> unit;
  new_cell : cell_type -> Html.tag -> Widget.widget -> string -> Htmlfmt.width_constraint;
  bound : unit -> bool
  }
@

<<signature [[Table.create]]>>=
val create : Widget.widget -> Html.tag -> Htmlfmt.width_constraint -> t
@

<<signature [[Table.topwidth]]>>=
val topwidth : Widget.widget -> int
@


%-------------------------------------------------------------

<<display/table.mli>>=
<<signature [[Table.debug]]>>
<<signature [[Table.strict_32]]>>

<<type [[Table.cell_type]]>>

<<type [[Table.t]]>>

<<signature [[Table.create]]>>

<<signature [[Table.topwidth]]>>
@


\subsection*{[[display/table.ml]]}

<<constant [[Table.debug]]>>=
(* Table support using the grid manager and a gross hack to obtain 
   resizing of a text widget to show its entire content.

 * Notes:
  1  we must keep geometry propagation on the grid, otherwise we'll never
     get vertical resizing
  2  the same is valid for each cell (frame around text)
  3  the spec says that the table should grow to fit its contents. However,
     this is ambiguous because in practice we must limit the width to the
     currently displayed page width.
     Having geometry propagation turned on, and letting all cells grow will
     of course keep the grid growing...
     Thus we have to set a maximum width for each cell.
     For text cells, we have to put a limit on their "automatic" horizontal
     resizing. When the limit is reached, we switch to vertical resizing,
     resetting wordwrap if allowed.
 *)

let debug = ref false
@

<<constant [[Table.strict_32]]>>=
let strict_32 = ref true
    (* in this mode, we ignore WIDTH of TD defined with %
       This is also better for pages written for MSIE where you find
       either TD WIDTH=100% or TD WIDTH=NN
       *)
@

<<type [[Table.cell_type]] ([[display/table.ml]])>>=
(* a manager for a single TABLE *)
type cell_type = HeaderCell | DataCell
@

<<type [[Table.t]] ([[display/table.ml]])>>=
type t = {
  table_master : Widget.widget;
  add_col : Html.tag -> unit;
  open_row : Html.tag -> unit;
  close_row : unit -> unit;
  close_table : unit -> unit;
  new_cell : cell_type -> Html.tag -> Widget.widget -> string -> width_constraint;
  bound : unit -> bool
  }
@

<<type [[Table.table]]>>=
(* Internal structure of tables *)
type table = {
  master_widget : Widget.widget;
  _width : length;
  mutable slaves :
      (Widget.widget * (int*int*int*int*width_constraint*length*string)) list;
  mutable cur_col : int;
  mutable cur_row : int;
  mutable slots : int array;
  mutable cols : int option list;
  cellpadding : int;
  cellspacing : int
  }
@

<<function [[Table.topwidth]]>>=
(* Get up to the widget that has HFrame class, or to toplevel *)
let topwidth wid =
  let f = ref wid in
  try
    while true do
      let cl = Winfo.class_name !f in
      if List.mem cl ["MMM"; "HFrame"] then raise Exit
      else f := Winfo.parent !f
    done;
    0
  with
    Exit ->    
      truncate (float (Winfo.width !f) *. 0.95)
@

<<function [[Table.text_align]]>>=
let text_align cell align =
  Text.tag_add cell "align" Frx_text.textBegin Frx_text.textEnd;
  Text.tag_configure cell "align"
    (match align with
      "right" -> [Justify Justify_Right]
    | "center" -> [Justify Justify_Center]
    | _ -> [Justify Justify_Left])
@

<<function [[Table.dynamic_fight]]>>=
(* Fight for your life ! *)
let dynamic_fight cell nowrap gameover align =
  match Winfo.class_name cell with
  | "Text" ->
      if !debug then
    Log.f (sprintf "DYNAMIC %s" (Widget.name cell));
      let when_finished () =
    if !debug then
      Log.f (sprintf "Switching %s to vertical resize"
                     (Widget.name cell));
        (* in all cases, we have to grow vertically *)
       let scroll, _check = Fit.vert cell in
       Text.configure cell [YScrollCommand scroll];
        (* A posteriori updates for embedded windows
       List.iter 
      (fun embedded ->
        bind embedded [[], Configure]
          (BindSet([], (fun _ ->
           bind embedded [[], Configure] BindRemove;
           Frx_after.idle check;
              ()))))
          (Text.window_names cell)
         *)
      in
      let scroll, check = Fit.horiz cell gameover (
    let first_time = ref true in
    (fun () ->
      if !first_time then begin
        first_time := false;
        text_align cell align;
        if not nowrap then Text.configure cell [Wrap WrapWord];
        when_finished()
    end))
      in
      Text.configure cell [XScrollCommand scroll];
      check()
  | s ->
      if !debug then
    Log.f (sprintf "Table.dynamic_size: unknown children class %s" s);
@

<<function [[Table.fixed_size]]>>=
(* We know the size in pixels *)
let fixed_size cell width nowrap align =
  match Winfo.class_name cell with
  | "Text" ->
      if !debug then
    Log.f (sprintf "FIXED %s to %d" (Widget.name cell) width);
      if not nowrap then Text.configure cell [Wrap WrapWord];
      Fit.fixed_horiz cell width;
      (* we have to do alignment here, because it kills horizontal resizing *)
      text_align cell align;
      (* in all cases, we have to grow vertically *)
      let scroll, check = Fit.vert cell in
      Text.configure cell [YScrollCommand scroll];
      (* A posteriori updates for embedded windows
      List.iter 
    (fun embedded ->
      bind embedded [[], Configure]
        (BindSet([], (fun _ ->
          bind embedded [[], Configure] BindRemove;
          Frx_after.idle check;
             ()))))
        (Text.window_names cell);
       *)
      check()
  | s ->
      if !debug then
    Log.f (sprintf "Table.dynamic_size: unknown children class %s" s);
@

<<function [[Table.sizing]]>>=
(*
 * Determine how we should set resizing for our cells
 *  table.width contains the specified width for the table
 *  contextwidth was the width computed the context of the table
 *)
let sizing table nowrap _width =
  (* For cells of given width and colspan 1, set a col minsize *)
  let colwidths = Array.make (Array.length table.slots) 0 in
  let setcolwidth col n =
    if n > colwidths.(col) then begin
      colwidths.(col) <- n;
      if !debug then
    Log.f (sprintf "%s col %d minsize %d"
               (Widget.name table.master_widget) col n);
      Grid.column_configure table.master_widget col [Minsize (Pixels n)]
    end
  in
  (* second pass to see if we have a proper column width for these *)
  let dynamic = ref [] in
  let add_dynamic w f = dynamic := (w,f) :: !dynamic in
  (* adjust sizes with padding/spacing *)
  let adjust w = w - 2 * table.cellspacing - 2 * table.cellpadding in
  (* Set initial size and dynamic resizing *)
  List.iter (function w,(_,col,_,cspan,cellwidth,_,align) -> 
    (* set initial width from images *)
    let _initw = Fit.set_initial_width w
    (* set initial height from line number *)
    and _ = Fit.set_initial_height w in
    match cellwidth with
      FixedWidth n ->
    if cspan=1 then setcolwidth col n; (* this col is at least n*)
    fixed_size w (adjust n) nowrap align
    | UnknownWidth bound ->
    add_dynamic w bound
    | _ -> assert false)
    (List.rev table.slaves);
  (* second pass on dynamics : if we know exactly the size of the
     cell because we know exactly the size of each column it belongs to
     then set it *)
  List.iter (fun (w, f) ->
    let unknown_col = ref false
    and width = ref 0 in
    let (_,col,_,cspan,_,_,align) = List.assoc w table.slaves in
    for i = col to col + cspan - 1 do
      width := !width + colwidths.(i);
      if colwidths.(i) = 0 then unknown_col := true
    done;
    if not !unknown_col then fixed_size w (adjust !width) nowrap align
    else dynamic_fight w nowrap f align)
    !dynamic
@

<<function [[Table.packem]]>>=
(* TODO: alignment *)
let packem table =
  let default_opts = [Sticky "nswe";
    PadX (Pixels table.cellspacing); PadY (Pixels table.cellspacing);
    IPadX (Pixels table.cellpadding); IPadY (Pixels table.cellpadding)]
  in
  List.iter 
    (fun (w, (row,col,rspan,cspan, _, _, _)) ->
       (* Sticky opt gives Expand true, Fill Both *)
       grid [w] ([Row row; Column col; RowSpan rspan; ColumnSpan cspan]
                 @default_opts))
    table.slaves
@

<<function [[Table.get_slot]]>>=
(* 
 * Slots represent, by column, the number of "pending" row-spanning cells 
 * If this number is zero, the slot is empty. When we allocate slots for
 * col-spanning cells, we keep these slots contiguous (case of overlapping
 * cells)
 *)

let get_slot table needed_cols rspan =
  (* First free slot in cur_col *)
  let rec first_free n =
    if n < Array.length table.slots then
      if table.slots.(n) = 0 then n
      else first_free (n+1)
    else raise Not_found in
  try 
    let first = first_free table.cur_col in
    (* Grow if overflow  (the next free would be first + needed_cols) *)
    if first + needed_cols > Array.length table.slots then
      table.slots <- 
         Array.append table.slots 
           (Array.make (first + needed_cols - (Array.length table.slots)) 
                         rspan);
    (* Mark used *)
    for i = first to first + needed_cols - 1 do
      table.slots.(i) <- max rspan table.slots.(i)
    done;
    table.cur_col <- first + needed_cols;
    first
  with
    Not_found -> (* Grow *)
      let first = Array.length table.slots in
      table.slots <- Array.append table.slots (Array.make needed_cols rspan);
      table.cur_col <- Array.length table.slots;
      first
@

<<function [[Table.next_row]]>>=
let next_row table =
  for i = 0 to Array.length table.slots - 1 do
    table.slots.(i) <- 
       match table.slots.(i) with
      0|1 -> 0
    | n -> n-1
  done
@

<<function [[Table.create]]>>=
(*
 * The table manager 
 * [top] is the frame that will be embedded in the text widget
 *)


let create top tag contextwidth =
 let width = 
   try length_of_string (get_attribute tag "width")
   with Not_found -> Nolength
 and cellpadding =
   try int_of_string (get_attribute tag "cellpadding")
   with Not_found | Failure "int_of_string" -> 0 
 and cellspacing =
   try int_of_string (get_attribute tag "cellspacing")
   with Not_found | Failure "int_of_string" -> 0
 and bwidth =
   try int_of_string (get_attribute tag "border")
   with Not_found -> 0
      | Failure "int_of_string" -> 1
 and nowrap = has_attribute tag "nowrap"
 (* align attribute is ignored (flow of text) *)
 in
 Frame.configure top [BorderWidth (Pixels bwidth); Relief Raised];
 let tab = {
    master_widget = top;
    slaves = [];
    _width = width;
    cur_col = 0;
    cur_row = -1; (* Start with TR *)
    slots = [||];
    cols = [];
    cellpadding = cellpadding;
    cellspacing = cellspacing} in

 (* Compute (if possible) the width of this table *)
 (* Set up the resize condition for cells of this table *)
 let size, bound = 
   match width with
     Nolength | LengthRel _ -> (* assume then 100% of context *)
       begin match contextwidth with
     TopWidth ->
       let w = topwidth tab.master_widget in
       None, Fit.bound_check tab.master_widget w
       | FixedWidth n -> (* size of parent cell *)
       Some n, Fit.bound_check tab.master_widget n
       | UnknownWidth f -> 
           (* the previous bound must have been reached
        * and we (the frame) may occupy 100% of the context 
        * (the text widget). Adjust to 95% for tuning.
        *)
       None, (fun () ->
         f() &&
           let w1 = Winfo.reqwidth top
           and w2 = Winfo.width (Winfo.parent top) in
           if !debug then
         Log.f (sprintf "Grow check %s=%d %s=%d"
                    (Widget.name top) w1
                    (Widget.name (Winfo.parent top)) w2);
            float w1 >= (float w2 *. 0.95))
       end
   | LengthPixels n -> 
       Some n, Fit.bound_check tab.master_widget n
   | LengthRatio r -> (* check the context *)
       begin match contextwidth with
     TopWidth ->
       let w = truncate (float (topwidth tab.master_widget) *. r) in
       Some w, Fit.bound_check tab.master_widget w
       | FixedWidth n -> (* size of parent cell *)
       let w = truncate (float n *. r) in
       Some w, Fit.bound_check tab.master_widget w
       | UnknownWidth f -> 
       None,
      (* the previous bound must have been reached,
         and we must occupy the ratio *)
       (fun () -> f()
           && 
         (let w1 = Winfo.reqwidth top in
          let w2 = Winfo.width (Winfo.parent top) in
           if !debug then
         Log.f (sprintf "Grow check %s=%d %s=%d"
                    (Widget.name top) w1
                    (Widget.name (Winfo.parent top)) w2);
          w1 >= truncate (r *. float w2)))
       end
  in
  (* SPECIAL FIX FOR THE PEOPLE WHO DON'T RESPECT THE DTD : we always make
     sure we are in a row *)
  let in_row = ref false in

   {table_master = top;
    bound = bound;
    close_table =
     (fun () ->
       packem tab;
       sizing tab nowrap size);
    add_col =  (fun tag -> 
      let span = 
       try int_of_string (get_attribute tag "span")
       with Not_found | Failure "int_of_string" -> 1 in
      let width = 
       (* Specification of the columns width (only pixel size supported) *)
       try Some (int_of_string (get_attribute tag "width"))
       with Not_found | Failure "int_of_string" -> None
      in 
      for _i = 1 to span do
    tab.cols <- width :: tab.cols 
      done);

    open_row = (fun _t ->
    tab.cur_col <- 0;
    tab.cur_row <- 1 + tab.cur_row;
        in_row := true;
        next_row tab);

    close_row = (fun () -> in_row := false);

    new_cell = (fun ctype attrs w align ->
      (* SPECIAL FIX FOR THE PEOPLE WHO DON'T RESPECT THE DTD *)
      if not !in_row then begin
    tab.cur_col <- 0;
    tab.cur_row <- 1 + tab.cur_row;
        in_row := true;
        next_row tab
    end;
      let opts = match ctype with
     HeaderCell -> [Relief Groove]
       | DataCell -> [Relief Sunken]
      in
      begin match Winfo.class_name w with
      |	"Text" -> Text.configure w opts
      |	_ -> assert false
      end;
      (* Tk needs spans > 0 *)
      let rspan = 
    try max 1 (int_of_string (get_attribute attrs "rowspan")) 
    with Not_found | Failure "int_of_string" -> 1
      and cspan = 
    try max 1 (int_of_string (get_attribute attrs "colspan"))
    with Not_found | Failure "int_of_string" -> 1
      and width = 
    try length_of_string (get_attribute attrs "width")
    with Not_found -> Nolength
      and height = 
    try length_of_string (get_attribute attrs "height")
    with Not_found -> Nolength
      in
      (* find its place *)
      let real_col = get_slot tab cspan rspan in
      if !debug then
          Log.f (sprintf "Cell %s at row=%d col=%d rspan=%d cspan=%d"
                 (Widget.name w)
                     tab.cur_row real_col rspan cspan);
      (* compute the size of this cell, so that tables in it have 
     something to work on *)
      let wconstraint = match width with
       Nolength | LengthRel _ -> UnknownWidth bound
      |	LengthPixels n -> FixedWidth n
      |	LengthRatio r -> 
      if !strict_32 then UnknownWidth bound
      else
        (* variable size : do we know the size of the table ? *)
      match size with
        None -> UnknownWidth (fun () ->
          bound() &&
           let w1 = Winfo.reqwidth w
           and w2 = Winfo.width top in
           w1 >= truncate (float w2 *. r))
      | Some n -> FixedWidth (truncate (float n *. r))
      in
       (* We delay the gridding until we have all cells *)
       tab.slaves <- 
          (w, (tab.cur_row, real_col,
           rspan, cspan,
           wconstraint, height, align))
         :: tab.slaves;
       wconstraint
       )}
@


%-------------------------------------------------------------

<<display/table.ml>>=
open Printf
open Tk
open Html
open Htmlfmt

<<constant [[Table.debug]]>>
<<constant [[Table.strict_32]]>>

<<type [[Table.cell_type]] ([[display/table.ml]])>>
<<type [[Table.t]] ([[display/table.ml]])>>

<<type [[Table.table]]>>

<<function [[Table.topwidth]]>>


<<function [[Table.text_align]]>>

<<function [[Table.dynamic_fight]]>>
      assert false


<<function [[Table.fixed_size]]>>
      assert false

<<function [[Table.sizing]]>>

<<function [[Table.packem]]>>


<<function [[Table.get_slot]]>>
      

<<function [[Table.next_row]]>>


<<function [[Table.create]]>>
@


\subsection*{[[display/htframe.ml]]}

<<constant [[Htframe.geom_sep]]>>=
(* geometry specs *)
let geom_sep = Str.regexp "[ \t\n]+\\|\\([ \t\n]*,[ \t\n]*\\)"
@

<<function [[Htframe.parse_geom]]>>=
let parse_geom s = List.map Html.length_of_string (Str.split geom_sep s)
@

<<function [[Htframe.figure_geom]]>>=
(* to deal with relative length n*, we have to combine relD and absD
 *   n* is n fragments of Total - Fixed
 *   = (Total - Fixed) * n/Sigma_n
 *   = Total * n/Sigma_n - Fixed * n/Sigma_n
 *   -> -relD (n/Sigma_n) -absD (-Fixed * n/Sigma_n)
 *)
let figure_geom l =
  (* compute the amount of fixed size *)
  let fixed = ref 0
  and totalrel = ref 0 in
  List.iter (function 
      LengthPixels n -> fixed := n + !fixed
    | LengthRel n -> totalrel := n + !totalrel
    | _ -> ())
    l;
  if !totalrel = 0 then (* simple case *)
    List.map (fun x -> [x]) l
  else
    List.map (function
      |	LengthRel n ->
      let ratio = float n /. float !totalrel in
      let opts = [LengthRatio (min ratio 1.)] in
      if !fixed = 0 then opts
      else
        opts @ [LengthPixels (- (truncate (float !fixed *. ratio)))]
      |	x -> [x])
      l
@

<<type [[Htframe.frame]]>>=
type frame = {
    frame_src : string;
    frame_name : string;
    frame_scrolling : string; (* yes | no | auto *)
    frame_opts : Tk.options list;
    frame_params : (string * string) list;
  } 
@

<<type [[Htframe.frameset]]>>=
and frameset =
    int ref * int ref * celldesc array array
@

<<type [[Htframe.cell_contents]]>>=
and cell_contents = 
  | Frame of frame
  | Frameset of frameset
@

<<type [[Htframe.celldesc]]>>=
and celldesc = {
    cell_width : Html.length list;
    cell_height : Html.length list;
    mutable cell_contents : cell_contents option
  } 
@

<<function [[Htframe.ignore_fo]]>>=
(* This is morally for the <noframes> section *)
let ignore_fo f = {
  new_paragraph = (fun () -> ());
  close_paragraph = (fun () -> ());
  print_newline = (fun _b -> ());
  print_verbatim = (fun _s -> ());
  format_string = (fun _s -> ());
  hr = (fun _l _n _b -> ());
  bullet = (fun _n -> ());
  set_defaults = (fun _s _l -> ());
  push_attr = (fun _l -> ());
  pop_attr = (fun _l -> ());
  isindex = (fun _s _s' -> ());
  start_anchor = (fun () -> ());
  end_anchor = (fun _h -> ());
  add_mark = (fun _ -> ());
  create_embedded = (fun _a _w _h -> Frame.create f []);
  see_frag = (fun _ -> ());
  flush = (fun () -> ());
  } 
@

<<constant [[Htframe.ignore_close]]>>=
let ignore_close = fun _ -> ()
@

<<function [[Htframe.add_frames]]>>=
let add_frames load_frames kill_body top mach =
  (* we start from an initial cell of "full size" *)
  let initial_cell = { 
    cell_width = [LengthRatio 100.];
    cell_height = [LengthRatio 100.];
    cell_contents = None 
  } in
  (* framesets can be defined recursively, this is our context stack *)
  let framesets = ref ([] : frameset list) in
  (* each nested frame/frameset occupies a cell in its parent
   * the current cell to occupy is defined by ri/rj.
   *)
  let next_cell set ri rj =
    incr rj;
    if !rj >= Array.length set.(!ri) then begin
      rj := 0; incr ri
    end
  in

  (* Create the frames with the proper placing, launch the display *)
  let doit () =
    (* compute the real frames (the ones with embedded documents) *)
    let frames = ref ([] : (frame * Widget.widget) list) in
    let framesym = Mstring.egensym "framecell" in
    (* in some top window, place the given cell and proceed with its
     * contents recursively. [pos] defines the placing options in x/y
     *)
    let rec docell top cell pos = 
      let f = 
    Frame.create_named top 
      (if cell == initial_cell then "frames"
       else framesym()) [Class "HFrame"] in
      let place_opts = ref (In top :: pos) in
      (* the displacement caused by this cell in its parent *)
      let delta_x = ref 0 and delta_relx = ref 0.
      and delta_y = ref 0 and delta_rely = ref 0.
      in
      List.iter (function
       | Nolength | LengthRel _ -> assert false
       | LengthPixels n ->
        place_opts := Width (Pixels n) :: !place_opts;
        delta_x := n
       | LengthRatio w -> 
        place_opts := RelWidth w :: !place_opts;
        delta_relx := w)
    cell.cell_width;
      List.iter (function
       | Nolength | LengthRel _ -> assert false
       | LengthPixels n ->
        place_opts := Height (Pixels n) :: !place_opts;
        delta_y := n
       | LengthRatio w -> 
        place_opts := RelHeight w :: !place_opts;
        delta_rely := w)
    cell.cell_height;
      (* place the cell, unless it is the top cell *)
      if cell == initial_cell then begin
    pack [f] [Expand true; Fill Fill_Both];
    Pack.propagate_set f false
      end else place f !place_opts;
      (* proceed with its contents *)
      begin match cell.cell_contents with
      |	None -> () (* this is an error ! *)
      |	Some (Frame frame) ->
      (* just store it so we can run the viewers later.
         (we need to have all frames in order to give proper navigation
         context for links with targets) *)
      frames := (frame, f) :: !frames;
      Frame.configure f frame.frame_opts
                    
      |	Some (Frameset (_,_,rows)) ->
      (* this is again a frameset. Thus [f] is still only a container *)
      (* positions of the embedded cells *)
      let curabs_x = ref 0 and curabs_y = ref 0
      and currel_x = ref 0. and currel_y = ref 0. in
      (* placer options for each embedded cell *)
      let curpos () = [X (Pixels !curabs_x); RelX !currel_x;
               Y (Pixels !curabs_y); RelY !currel_y] in
      (* Iterate on cells *)
      Array.iter (fun row ->
        (* for each row, we start horizontally at 0 *)
        curabs_x := 0; currel_x := 0.;
        (* the vertical size contributed by this row. It's constant
           for all cells in the row, but we compute it n times...*)
        let row_delta_y = ref 0
        and row_delta_rely = ref 0. in
        (* now iterate on each cell in this row (eg on columns) *)
        Array.iter (fun cell -> 
          (* place this cell and return its occupation *)
          let delta_x, delta_relx, delta_y, delta_rely =
        docell f cell (curpos()) in
          (* switch current horiz position, store vert occupation *)
          curabs_x := delta_x + !curabs_x;
          currel_x := delta_relx +. !currel_x;
          row_delta_y := delta_y;
          row_delta_rely := delta_rely
          ) row;
        (* we finished the row. Move vertically now *)
        curabs_y := !curabs_y + !row_delta_y;
        currel_y := !currel_y +. !row_delta_rely)
        rows
      end;
      (* our caller expects us to return our size *)
      !delta_x, !delta_relx, !delta_y, !delta_rely
    in
    (* The initial cell is always at 0/0 *)
    ignore (docell top initial_cell [X (Pixels 0); Y (Pixels 0)]);
    (* And now proceed with frame loading *)
    load_frames !frames;
    (* some people put a body outside the noframes section, so we should
       ignore it completely if we saw frames. And we must kill the body
       if it was already created *)
    kill_body();
    mach#add_tag "body"
      (fun _fo _t -> mach#look_for EOF) ignore_close

  in
  mach#add_tag "frameset"
      (fun _fo t ->
    let rows = get_attribute t "rows"
    and cols = get_attribute t "cols" in
    let newset =
      ref 0, ref 0,
      Array.of_list
        (List.map (fun h ->  
          Array.of_list (List.map  (fun w -> 
        { cell_width = w;
          cell_height = h;
          cell_contents = None})
                   (figure_geom (parse_geom cols))))
           (figure_geom (parse_geom rows)))
    in
    match !framesets with
    | [] -> 
        (* if there two or more non-nested framesets, we will cause 
           an error later *)
        if initial_cell.cell_contents <> None then
          raise (Invalid_Html "illegal <frameset>")
        else begin
          initial_cell.cell_contents <- Some (Frameset newset);
          framesets := newset :: !framesets
        end
    | (ri, rj, set)::_l ->
        if !ri >= Array.length set then
          raise (Invalid_Html "no room for <frameset> in this <frameset>")
        else begin
          set.(!ri).(!rj).cell_contents <-  Some (Frameset newset);
          next_cell set ri rj;
          framesets := newset :: !framesets
        end)
      (fun _t -> 
    match !framesets with
    | [] -> 
        raise (Invalid_Html "unmatched </frameset>")
    | [_x] -> (* the last one *)
        framesets := [];
        doit()
    | _x::l ->
        framesets := l);

  mach#add_tag "frame"  
    (fun _fo t ->
      match !framesets with
      | [] -> raise (Invalid_Html "<frame> outside <frameset>")
      |	(ri, rj, set) :: _ ->
      if !ri >= Array.length set then
        raise (Invalid_Html "no room for <frame> in this <frameset>")
      else begin
        try
          let src = get_attribute t "src"
          and name = try get_attribute t "name" with Not_found -> ""
          and border = 
           try int_of_string (get_attribute t "frameborder")
           with Failure "int_of_string" -> 
        (* compatibility ? *)
          if String.lowercase_ascii (get_attribute t "frameborder") = "no"
          then 0 else 1
          and scrolling = String.lowercase_ascii (get_attribute t "scrolling")
          in
          let borderopts = 
           if border = 0 then [BorderWidth (Pixels 0)]
           else [BorderWidth (Pixels border); Relief Ridge]
          in
          set.(!ri).(!rj).cell_contents <-
         Some (Frame { frame_src = src;
                   frame_name = name;
                   frame_opts = borderopts;
                   frame_scrolling = scrolling;
                   frame_params = t.attributes });
          next_cell set ri rj
        with
          Not_found -> 
           raise (Invalid_Html "missing src in <FRAME>")
      end)
    ignore_close;

  (* note: <noframes> does not necessarily cover the whole body of the
   * document. It may only hide a toc which is displayed in another frame.
   * Basically, <noframes> doesn't imply there was a <frameset> in the
   * same document. Of course, we should interpret noframes ONLY if the
   * other frame supposed to contain the info IS displayed. But we don't
   * know that, do we ?
   *)
  mach#add_tag "noframes"
    (fun _fo _t -> 
      mach#push_formatter (ignore_fo top);
      mach#look_for (CloseTag "noframes"))

    (fun _t -> mach#pop_formatter |> ignore; ())
@


%-------------------------------------------------------------

<<display/htframe.ml>>=
open Tk
open Html
open Htmlfmt

(* Frames *)

<<constant [[Htframe.geom_sep]]>>
<<function [[Htframe.parse_geom]]>>

<<function [[Htframe.figure_geom]]>>

(* We build this data structure when parsing FRAMESET *)
<<type [[Htframe.frame]]>>

<<type [[Htframe.frameset]]>>

<<type [[Htframe.cell_contents]]>>

<<type [[Htframe.celldesc]]>>

<<function [[Htframe.ignore_fo]]>>

<<constant [[Htframe.ignore_close]]>>


<<function [[Htframe.add_frames]]>>

@


\subsection*{[[display/textw_fo.mli]]}

<<signature [[Textw_fo.html_bg]]>>=
val html_bg : string ref
@

<<signature [[Textw_fo.html_fg]]>>=
val html_fg : string ref
@

<<signature [[Textw_fo.usecolors]]>>=
val usecolors : bool ref
@

<<signature [[Textw_fo.internal_buffer]]>>=
val internal_buffer : int ref
@



%-------------------------------------------------------------

<<display/textw_fo.mli>>=

<<signature [[Textw_fo.html_bg]]>>
<<signature [[Textw_fo.html_fg]]>>

<<signature [[Textw_fo.usecolors]]>>
<<signature [[Textw_fo.internal_buffer]]>>

<<signature [[Textw_fo.create]]>>
@


\subsection*{[[display/textw_fo.ml]]}

<<constant [[Textw_fo.html_bg]]>>=
(* Default background and foreground colors *)
let html_bg = ref "white"
@

<<constant [[Textw_fo.html_fg]]>>=
let html_fg = ref "black"
@

<<constant [[Textw_fo.usecolors]]>>=
(* Preference settings *)
let usecolors = ref true     (* use colors (fg/bg) specified in document *)
@

<<constant [[Textw_fo.internal_buffer]]>>=
let internal_buffer = ref 4000
@



%-------------------------------------------------------------

<<display/textw_fo.ml>>=
open Printf
open Tk
open Frx_text
open Hyper


open Htmlfmt
open Fonts


(* Text widget formatter for the HTML Display Machine
 * The main function builds a GfxHTML, in two cases
 *    1- normal (viewing an HTML document)
 *    2- nested (a cell in a table)
 *    3- 
 *)

<<constant [[Textw_fo.html_bg]]>>
<<constant [[Textw_fo.html_fg]]>>

<<constant [[Textw_fo.usecolors]]>>
<<constant [[Textw_fo.internal_buffer]]>>

<<function [[Textw_fo.create]]>>
@


\subsection*{[[display/html_disp.mli]]}



%-------------------------------------------------------------

<<display/html_disp.mli>>=

<<signature [[Html_disp.verbose]]>>
<<signature [[Html_disp.attempt_tables]]>>

<<signature class [[Html_disp.imgloader]]>>

<<signature class [[Html_disp.machine]]>>

<<signature [[Html_disp.add_hook]]>>

<<signature functor [[Html_disp.Make]]>>
@


\subsection*{[[display/html_disp.ml]]}





%-------------------------------------------------------------

<<display/html_disp.ml>>=
(* HTML Display Machine *)
open Printf
open Html
open Htmlfmt
open Hyper

open Document
open Maps
open Embed

open Fonts

<<constant [[Html_disp.verbose]]>>
<<constant [[Html_disp.attempt_tables]]>>

<<function [[Html_disp.lowernumber]]>>

<<function [[Html_disp.uppernumber]]>>

<<constant [[Html_disp.romans]]>>

<<function [[Html_disp.roman]]>>

<<class [[Html_disp.imgloader]]>>

<<class [[Html_disp.machine]]>>

<<constant [[Html_disp.user_hooks]]>>
<<function [[Html_disp.add_hook]]>>

<<constant [[Html_disp.default_fo]]>>

<<function [[Html_disp.push_style]]>>

<<function [[Html_disp.pop_style]]>>

<<functor [[Html_disp.Make]]>>
@


\section{[[gui/]]}

\subsection*{[[gui/about.mli]]}

<<signature [[About.create_tachy]]>>=
val create_tachy : Widget.widget -> Low.tachymeter
@



%-------------------------------------------------------------

<<gui/about.mli>>=
<<signature [[About.create_tachy]]>>

<<signature [[About.f]]>>
@


\subsection*{[[gui/about.ml]]}


<<constant [[About.tachy_data]]>>=
(* inside bitmap, circle is in +16+7 +66+57, radius 25 *)

let tachy_data = "GIF\056\057aP\000A\000\227\000\000\000\000\000\
\044\044\044\060\000\000YYY\138\138\138\154\154\154\170\
\170\170\186\186\186\203\203\203\219\219\219\231qq\235\235\
\235\243yy\255\255\255\000\000\000\000\000\000\033\249\004\
\001\000\000\009\000\044\000\000\000\000P\000A\000\000\004\
\255\048\201I\171\189\024H\157\056\199\096\040\142\164\213\
Hg\146\166e\235\190p\060\013\052\045\223DN\000\
M\225\223\148\001\133\005\020\233\142\187\158oY\184\009\
\039\196\162\005I\229\049\153\006\131E\032z\162\164\023\
\042\178\144\188\250\178\232J\180\226U\021\063\146\129\248\
\136\174c\235\233\009\220\212\232\175a\041\052sx\132\
\133\133P\096\033p\130H\134\142\143\006\007z\137\032\
\129rt\144\153x\007\156\136\148\147\051\151\058\154\164\
Y\156\156\004\160\159n\009\003\000\152\165\164\167I\158\
\171\173r\175\004\177\187\007I\157\018\092\171\140\059\187\
\197\060\167\146\095\148\195\186\197\197\200\008\008\182\173\176\
\206\188\007\209\210\194\213\214\187\217\209\171\141\221\206\223\
\218\137\226\227\228\223\148\220\233\222\217\231\237\238\165\229\
\096\242\143\001\001\003\001\006\174\053\006\249\000\210\131\039\
\229\158\035\125\253\250\001\232\055\064\033\141\129\230\054\196\
\064G\010\192\190\044\251\030fA\056\240\194\031\035\163\
\255b\185J\008\208\031\198\128\177\216\133\044\165\049\203\
\194\135\015\045\166\180\176\167\132AC\045\255\213\216\185\
\203\227\011\138\243\172\197\203\017t\030\205\018\031n\022\
\037u\164\150\136\020J\151f\002\064\181f\139\170\011\
\221\037\152\231\039\133\213\011\031\186J\029\167\160\172\002\
\167\033\160\046\025\219\205\236Y\025w\216\022s\043\241\
\197\021\185\187\220\190e\229\034\046\094Mt\129\248\253\
\011\041p\135\024\131\009\059\050\204\183\197\093\197\143\220\
\050\144\178\022r\228\178\147\041\023\176\092X\001\131\204\
E\054s\094\236\249s\162\209\139\063\131\150\130\186P\
i\211\148Z\215y\189\026\140l\052\170a\127\186M\
\123Z\029N\144\049\171\158\182\053R\175\172x\001\044\
\016N\092\002\170cx\023\044P\094\182\249\004\095\192\
\199J\151\174\220\250\016d\217\231m\031\239\253\176s\
\240\008\196\143\151\190\225k\034\022\208\178u\091\191\125\
\210G\091\156\202\201\039E\159\252\144\251\211\232\183N\
\045qxH\208\095\125\229\149\032\096\005\180Lp\096\
\130\048\012HA\131\009\244\007a\056\060\024\232\223\133\
\024\158\192\030\135\032\134\040\226\136\036\194\016\001\000\059\
"
@

<<constant [[About.park_data]]>>=
let park_data =
"#define break_width 15
#define break_height 11
static char break_bits[] = {
   0x0c, 0x18, 0xf4, 0x17, 0x3a, 0x2e, 0xba, 0x2d, 0xb9, 0x4d, 0x3d, 0x5e,
   0xb9, 0x4f, 0xba, 0x2f, 0xba, 0x2f, 0xf4, 0x17, 0x08, 0x08};
"
@

<<constant [[About.pi]]>>=
let pi = 3.1415926 
@

<<constant [[About.log10]]>>=
let log10 = log 10.0 
@

<<function [[About.create_tachy]]>>=
let create_tachy top = 
  let o = new default_tachy top in
  o#start;
@


%-------------------------------------------------------------

<<gui/about.ml>>=
open Tk

<<function [[About.f]]>>


(* Tachymeter *)

(* gif is 80x65 *)
<<constant [[About.tachy_data]]>>
<<constant [[About.park_data]]>>


<<constant [[About.pi]]>>
<<constant [[About.log10]]>>

class default_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable canvas = top (* dummy initialisation *)
  val mutable alive = false

  (* Various components of the canvas, all with dummy init values *)
  val mutable i_park = Tag "none"
  val mutable kilos = Tag "none"
  val mutable aig = Tag "none"
  val mutable pendings = Tag "none"


  (* this one is private *)
  method start =
    let c =
      Canvas.create_named top "tachymeter"
       [Width (Pixels 80); Height (Pixels 80); 
         BorderWidth (Pixels 0);
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *)] in
    (* Use colors so that images are not transparent *)  
    let tachy_image = 
      begin
       try
      let bgc = Tk.cget c CBackground in
           Protocol.tkCommand 
        [|Protocol.TkToken "set";
          Protocol.TkToken "TRANSPARENT_GIF_COLOR";
          Protocol.TkToken bgc |]
       with _ -> ()
      end;
    (* Agghaaa !!! TCL/TK doesn't support -data for GIF !!! *)
      let file = Msys.mktemp "tachy.gif" in
      let oc = open_out_bin file in
      output_string oc tachy_data;
      close_out oc;
      let img = Imagephoto.create [File file] in
      Msys.rm file;
      img
    and _park_image =
      Imagebitmap.create [Data park_data; Foreground Red] in

    i_park <-
      Canvas.create_rectangle c 
     (Pixels 72) (Pixels 3) 
     (Pixels 75) (Pixels 6) [FillColor Black];
    
    kilos <-
      Canvas.create_text c (Pixels 40) (Pixels 73) [Text "0"];
    
    aig <-
      Canvas.create_line c [Pixels 41; Pixels 32; Pixels 41; Pixels 57]
                       [Width (Pixels 2)];
    pendings <-
      Canvas.create_text c (Pixels 70) (Pixels 60) [Text "0"];

    let i_tachy =
      Canvas.create_image c (Pixels 0) (Pixels 0)
       [ImagePhoto tachy_image; Anchor NW]

    in

    Canvas.lower_bot c pendings;
    (* All other items must be put above the background image *)
    List.iter (fun i -> Canvas.raise_above c i i_tachy)
      [kilos; aig; i_park];

    bind c (Glevents.get "tachy_about") (BindSet ([], (fun _ -> f ())));

    bind c (Glevents.get "tachy_gc") (BindSet ([], (fun _ -> Frx_mem.f())));

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));

    pack [c][];
    alive <- true;
    canvas <- c

  val mutable last_speed = 0.
  val mutable last_total = 0
  val mutable idle = false

  method update speed total =
    if speed = 0.0 then begin
      if not idle then begin
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black];
    idle <- true
      end
    end
    else begin
      Canvas.configure_rectangle canvas i_park [FillColor Green;
                         Outline Green];
      idle <- false
    end;
    if total <> last_total then
      Canvas.configure_text canvas kilos [Text (string_of_int total)];
    last_total <- total;
    let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
    let speeds = (last_speed +. speed) /. 2. in
    if abs_float (speeds -. last_speed) > 0.1 then begin
      last_speed <- speeds;
      let v = speeds /. log10 in
      let angle = v /. 4.0 *. pi in
      let angle = if angle < 0.1 then 0.0 else angle in
      let x = 41.0 -. (sin angle *. 25.0)
      and y = 32.0 +. (cos angle *. 25.0) in
      Canvas.coords_set canvas aig 
    [Pixels 41; Pixels 32;
      Pixels (truncate x); Pixels (truncate y)];
      Low.update_idletasks()
    end

  method report_cnx n = 
    if Winfo.exists canvas then
      if n = 0 then begin
    Canvas.configure_text canvas pendings [Text ""];
       Canvas.lower_bot canvas pendings
      end
      else begin
    Canvas.configure_text canvas pendings 
      [Text (string_of_int n)];
       Canvas.raise_top canvas pendings
      end

  method report_busy busy =
    if Winfo.exists canvas then
      if busy then begin
       Canvas.lower_bot canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Red;
                          Outline Red];
    Low.update_idletasks()
      end
      else begin
       Canvas.raise_top canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy canvas

end

<<function [[About.create_tachy]]>>
  (o :> Low.tachymeter)

@


\subsection*{[[gui/fontprefs.ml]]}

<<function [[Fontprefs.fontspec2attrs]]>>=
let fontspec2attrs s =
  let tokens = Mstring.split_str (fun c -> c='-') s in
  if List.length tokens <> 14 then
    failwith ("incomplete font specification: " ^ s)
  else (* should not fail *)
    let attrs = ref [] in
      (match List.nth tokens 1 
       with "*" -> () | s -> attrs := (Family s) :: !attrs);
      (match List.nth tokens 2 
       with "*" -> () | s -> attrs := (Weight s) :: !attrs);
      (match List.nth tokens 3 
       with "*" -> () | s -> attrs := (Slant s) :: !attrs);
      (match List.nth tokens 6 with
         "*" -> () 
    | s -> try
             attrs := (FontIndex (font_index (int_of_string s))) :: !attrs
           with Failure "int_of_string" ->
         failwith ("pxlsz not an integer: " ^ s));
      !attrs
@

<<function [[Fontprefs.attrs2fontspec]]>>=
let attrs2fontspec l =
  let rec family = function
     [] -> "*"
   | (Family s)::_ -> s
   | _x::l -> family l
  and weight = function
     [] -> "*"
   | (Weight s)::_ -> s
   | _x::l -> weight l
  and slant = function
     [] -> "*"
   | (Slant s)::_ -> s
   | _x::l -> slant l
  and pxlsz = function
     [] -> "*"
   | (FontIndex s)::_ -> string_of_int (Fonts.pxlsz s)
   | _x::l -> pxlsz l in

  sprintf "-*-%s-%s-%s-normal-*-%s-*-*-*-*-*-iso8859-1"
          (family l) (weight l) (slant l) (pxlsz l)
@

<<constant [[Fontprefs.default_families]]>>=
(* Build a family menu *)
let default_families = 
  ["courier"; "helvetica"; "lucida"; "new century schoolbook";
   "times"; "fixed"; "*"]
@

<<function [[Fontprefs.families]]>>=
let families () =
 Tkresource.stringlist "fontFamilies" default_families
@

<<function [[Fontprefs.family_select]]>>=
let family_select top v = 
  Optionmenu.create  top v (families())
@

<<constant [[Fontprefs.default_weights]]>>=
(* Build a weight menu *)
let default_weights = ["bold"; "medium"; "*"]
@

<<function [[Fontprefs.weights]]>>=
let weights () =
  Tkresource.stringlist "fontWeights" default_weights
@

<<function [[Fontprefs.weight_select]]>>=
let weight_select top v =
  Optionmenu.create top v (weights())
@

<<constant [[Fontprefs.default_slants]]>>=
(* Build a slant menu *)
let default_slants = ["r"; "i"; "o"; "*"]
@

<<function [[Fontprefs.slants]]>>=
let slants () = 
  Tkresource.stringlist "fontSlants" default_slants
@

<<function [[Fontprefs.slant_select]]>>=
let slant_select top v =
  Optionmenu.create top v (slants())
@

<<function [[Fontprefs.pixels]]>>=
(* Build a pixel size menu *)
let pixels() =
  Tkresource.stringlist "fontPixels" Fonts.default_sizes
@

<<function [[Fontprefs.pixels_select]]>>=
let pixels_select top v = 
  Optionmenu.create top v (pixels())
@

<<function [[Fontprefs.font_select]]>>=
(* fontspecv is the variable used for the full X font name; it is used
 * internally (and for saving the prefs), and must be maintained consistent
 * with the displayed state.
 *   - initialisation time : 
 *      given the attributes, write the X name in the variable
 *   - edition time:
 *      electric update of the variable and the styles
 *)

let font_select top getattrs setattrs =
  let familyv = Textvariable.create_temporary top
  and weightv = Textvariable.create_temporary top
  and slantv = Textvariable.create_temporary top
  and pixelsv = Textvariable.create_temporary top
  and fontspecv = Textvariable.create_temporary top
  in
  let f = Frame.create top [] in
  let buttons = 
    List.map2 (fun create v -> 
                 Textvariable.set v "*"; 
                 let x,_ = create f v in x) 
              [family_select; weight_select; slant_select; pixels_select]
              [familyv; weightv; slantv; pixelsv] in
  pack buttons [Side Side_Left];
  (* electric updates 
   * Whenever one of the attributes changes, we must change the fontspec
   * and possibly recompute the attributes
   *)
  let setv _ =
    let font = sprintf "-*-%s-%s-%s-normal-*-%s-*-*-*-*-*-iso8859-1"
        (Textvariable.get familyv)
    (Textvariable.get weightv)
    (Textvariable.get slantv)
        (Textvariable.get pixelsv)
    in 
    let attrs = fontspec2attrs font in
    Textvariable.set fontspecv font;
    setattrs attrs
  in
  List.iter (fun v ->
    let rec el () = Textvariable.handle v (fun () -> setv(); el()) in el())
    [familyv; weightv; slantv; pixelsv];
  
  (* initialisation from memory (v=fontspecv) *)
  let init_pref _v =
    let attrs = getattrs() in
    (* Set all variables; electric update does the rest *)
    List.iter (function
        Family s -> Textvariable.set familyv s
      | Weight s -> Textvariable.set weightv s
      | Slant s -> Textvariable.set slantv s
      | FontIndex s ->
          Textvariable.set pixelsv (string_of_int (Fonts.pxlsz s))
      |	_ -> assert false)
      attrs
  (* initialisation from loaded strings (v=fontspecv) *)
  and set_pref v =
    let font = Textvariable.get v in
    let attrs = fontspec2attrs font in
    (* Set all variables; electric update rewrites everything (duh) *)
    List.iter (function
        Family s -> Textvariable.set familyv s
      | Weight s -> Textvariable.set weightv s
      | Slant s -> Textvariable.set slantv s
      | FontIndex s ->
          Textvariable.set pixelsv (string_of_int (Fonts.pxlsz s))
      |	_ -> assert false)
      attrs
  in
  f, fontspecv, init_pref, set_pref
@


%-------------------------------------------------------------

<<gui/fontprefs.ml>>=
open Printf
open Tk
(* Specify set of attributes of a font *)
(* family, weight, slant, pxlsz *)
(* We use a font string, and select only the relevant components *)
(* 
-fndry-fmly-wght-slant-sWdth-adstyl-pxlsz-ptSz-resx-resy-spc-avgWdth-reg-enc
   0    1    2    3     4      5     6     7    8    9   10    11     12  13
*)
open Fonts

<<function [[Fontprefs.fontspec2attrs]]>>

<<function [[Fontprefs.attrs2fontspec]]>>

<<constant [[Fontprefs.default_families]]>>
<<function [[Fontprefs.families]]>>

<<function [[Fontprefs.family_select]]>>

<<constant [[Fontprefs.default_weights]]>>
<<function [[Fontprefs.weights]]>>
<<function [[Fontprefs.weight_select]]>>

<<constant [[Fontprefs.default_slants]]>>
<<function [[Fontprefs.slants]]>>
<<function [[Fontprefs.slant_select]]>>

<<function [[Fontprefs.pixels]]>>
<<function [[Fontprefs.pixels_select]]>>


<<function [[Fontprefs.font_select]]>>

    

@


\subsection*{[[gui/gcache.mli]]}

<<signature [[Gcache.debug]]>>=
val debug : bool ref
@

<<signature [[Gcache.max_keep]]>>=
val max_keep : int ref
@

<<signature [[Gcache.kill]]>>=
val kill : int -> unit
  (* [kill hkey] destroy all widget cached for navigator [hkey]
     If in history mode, accordingly remove from Cache documents
     that are not shared with other navigator windows
   *)
@

<<signature [[Gcache.find]]>>=
val find : int -> Document.document_id -> Viewers.display_info
@

<<signature [[Gcache.add]]>>=
val add : int -> Document.document_id -> Viewers.display_info -> unit
@

<<signature [[Gcache.remove]]>>=
val remove : int -> Document.document_id -> unit
@

<<signature [[Gcache.displace]]>>=
val displace : int -> Document.document_id -> unit
@

<<signature [[Gcache.postmortem]]>>=
val postmortem : unit -> unit
@


%-------------------------------------------------------------

<<gui/gcache.mli>>=
(* Cache by "widget unmapping"
 * For each navigator, we keep the list of displayed documents
 *)

<<signature [[Gcache.debug]]>>

<<signature [[Gcache.max_keep]]>>

<<signature [[Gcache.kill]]>>

<<signature [[Gcache.find]]>>
<<signature [[Gcache.add]]>>
<<signature [[Gcache.remove]]>>
<<signature [[Gcache.displace]]>>

<<signature [[Gcache.postmortem]]>>

@


\subsection*{[[gui/gcache.ml]]}

<<constant [[Gcache.debug]]>>=
(* Cache by "widget unmapping"
 *  For each navigator, we keep the list of displayed documents
 *)

let debug = ref false
@

<<constant [[Gcache.max_keep]]>>=
let max_keep = ref 5
  (* maximum number of cached widget in a given window *)
@

<<constant [[Gcache.table]]>>=
let table = (Hashtbl.create 37 :
              (int, (document_id * display_info) list ref) Hashtbl.t)
@

<<function [[Gcache.get_nav]]>>=
let get_nav hkey =
  try
    Hashtbl.find table hkey
  with
    Not_found ->
      let r = ref [] in
       Hashtbl.add table hkey r;
       r
@

<<function [[Gcache.find]]>>=
(* Find a document in a given window
 * Called by the navigator when attempting to display a new request.
 * Also called by back/forward navigation in the history
 *)
let find hkey did =
  let r = get_nav hkey in
  List.assoc did !r
@

<<function [[Gcache.nocache]]>>=
(* History mode: when we remove a document from the gcache, and that it
   was its only displayed instance, then we must also remove it from cache
 *)
let nocache did =
 if !debug then Log.f
    (sprintf "Removing %s from cache" (Url.string_of did.document_url));
 let shared = ref false in
  Hashtbl.iter (fun _key dis -> if List.mem_assoc did !dis then shared := true)
    table;
 if not !shared then Cache.kill did
 else  
   if !debug then Log.f "Don't, it's shared"
@


<<function [[Gcache.displace]]>>=
(* Removing only to redisplay (update) *)
let displace hkey did =
  if !debug then Log.f
    (sprintf "Displacing %s in window %d" (Url.string_of did.document_url) hkey);
  try
    let r = Hashtbl.find table hkey in
    let di = List.assoc did !r in
     di#di_abort;
     di#di_destroy;
     r := Mlist.except_assoc did !r;
  with
     Not_found -> Log.debug "Gcache.remove failed !"
@

<<function [[Gcache.add]]>>=
(* Add a new display_info for a document in the cache *)
let add hkey did di =
  try
    let r = Hashtbl.find table hkey in
     r := (did, di) :: !r;
    (* the problem is to find the correct ones to delete, because we are
       not sure that the older are really the older in history. Well.
     *)
    if List.length !r > !max_keep then
      let l = List.sort (fun (_,di) (_,di') -> di_compare di di') !r in
      let fluff = Mlist.tln l !max_keep in
    List.iter (fun (did,_) -> remove hkey did) fluff
  with
    Not_found -> ()
@

<<function [[Gcache.kill]]>>=
(* A window is being destroyed: kill all visible instances
 *  Note: there could be a document still being retrieved and displayed,
 *  but not present in the history. 
 *)
let kill hkey =
 if !debug then Log.f (sprintf "Killing gcache for nav %d" hkey);
 let r = get_nav hkey in
  List.iter (fun (_did, di) -> di#di_abort) !r;
  if !Cache.history_mode then begin
     let fluff = !r in
       r := []; (* so that we don't find them again *)
       List.iter (fun (did, _) -> nocache did) fluff
  end;
 Hashtbl.remove table hkey
@

<<function [[Gcache.postmortem]]>>=
let postmortem () =
  Hashtbl.iter (fun key dis ->
      Log.f (sprintf "Navigator %d" key);
      List.iter (fun (did,_) ->
     Log.f (sprintf "%s(%d)"
          (Url.string_of did.document_url)
          did.document_stamp))
         !dis)
   table
@

<<function [[Gcache.sorry]]>>=
(* If the normal cache gets full, we might *have* to destroy documents
 * that are visible. In that case, kill the gcache as well, so that
 * we don't get strange phenomenons such as image disappearing, ...
 *)

let sorry did =
  Hashtbl.iter (fun key dis -> 
    if List.mem_assoc did !dis then remove key did) table
@

<<toplevel [[Gcache._1]]>>=
let _ =
  Cache.cutlinks := sorry :: !Cache.cutlinks
@


%-------------------------------------------------------------

<<gui/gcache.ml>>=
open Printf
open Document
open Viewers

<<constant [[Gcache.debug]]>>

<<constant [[Gcache.max_keep]]>>

<<constant [[Gcache.table]]>>

<<function [[Gcache.get_nav]]>>

<<function [[Gcache.find]]>>

<<function [[Gcache.nocache]]>>

<<function [[Gcache.remove]]>>

<<function [[Gcache.displace]]>>

<<function [[Gcache.add]]>>


<<function [[Gcache.kill]]>>


<<function [[Gcache.postmortem]]>>


<<function [[Gcache.sorry]]>>


<<toplevel [[Gcache._1]]>>
@


\subsection*{[[gui/plink.mli]]}

<<signature [[Plink.make]]>>=
val make : Hyper.link -> Www.request
    (* [make hlink] is an error correcting version of Www.make
       For invalid links, a dialog box is displayed and offers
       edition facilities
     *)
@


%-------------------------------------------------------------

<<gui/plink.mli>>=
<<signature [[Plink.make]]>>
@


\subsection*{[[gui/plink.ml]]}

<<function [[Plink.dial]]>>=
let dial hlink err =
  let t = Toplevel.create Widget.default_toplevel [Class "Dialog"] in
  Focus.set t;
  Wm.title_set t (s_ "Malformed link error");

  let vuri = Textvariable.create_temporary t 
  and vcontext = Textvariable.create_temporary t in

  Textvariable.set vuri hlink.h_uri;
  (match hlink.h_context with
    Some s -> Textvariable.set vcontext s
  | None -> ());

  let msg = match err with
      LinkResolve s -> s
   |  UrlLexing (s,_) -> s in

  let tit = Label.create t [Text (s_ "Malformed link error")]
  and fc,_ec = Frx_entry.new_labelm_entry t "Context" vcontext
  and fu,eu = Frx_entry.new_labelm_entry t "Relative" vuri
  and lmsg = Label.create t [Text msg]
  in
  let cancelled = ref false in
  let fb = Frame.create t [] in
    let bok = Button.create fb
            [Text "Ok"; Command (fun _ -> Grab.release t; destroy t)]
    and bcancel = Button.create fb
            [Text "Cancel"; Command (fun _ -> cancelled := true;
                                          Grab.release t; destroy t)]
    in

    pack [bok] [Side Side_Left; Expand true];
    pack [bcancel] [Side Side_Right; Expand true];
    pack [tit;fc;fu;lmsg;fb] [Fill Fill_X];
    Tkwait.visibility t;
    Focus.set eu;
    Grab.set t;
    Tkwait.window t;
    (* because the window gets destroyed, the variables too. *)
    if !cancelled then None
    else Some
         {h_uri = Textvariable.get vuri;
      h_context = (match Textvariable.get vcontext with
                 "" -> None
                | s -> Some s);
          h_method = hlink.h_method;
      h_params = hlink.h_params}
@

<<function [[Plink.make]]>>=
(* Utility for catching link resolving errors *)
let rec make hlink =
  try
    Www.make hlink
  with
    Invalid_link msg ->
      match dial hlink msg with
    None -> raise (Invalid_link msg)
      | Some hlink -> make hlink
@


%-------------------------------------------------------------

<<gui/plink.ml>>=
open I18n
open Tk
open Hyper

<<function [[Plink.dial]]>>

<<function [[Plink.make]]>>

        
@


\subsection*{[[gui/prefs.mli]]}

<<type [[Prefs.pref_type]]>>=
(* Exported so that we can plug applet preferences *)
type pref_type =
 | Bool of bool ref
 | String of string ref
 | Int of int ref
 | Float of float ref
 | AbstractType of (Textvariable.textVariable -> unit) * 
                   (Textvariable.textVariable -> unit)
                   (* init, set *)
@

<<type [[Prefs.pref]]>>=
type pref = {
  packed_widget : Widget.widget;
  pref_variable : Textvariable.textVariable;
  pref_type : pref_type;
  pref_name : string; (* shall not contain : *)
  resource_name : string (* shall not contain : *)
}
@

<<type [[Prefs.pref_family]]>>=
(* A family of preferences *)
type pref_family =
  {family_widget: Widget.widget;
   family_init : unit -> unit;
   family_save : unit -> string PrefMap.t;
   family_load : unit -> unit;
   family_title : string
  }
@

<<signature [[Prefs.bool_pref]]>>=
val bool_pref : string -> bool ref -> Widget.widget -> pref
@

<<signature [[Prefs.int_pref]]>>=
val int_pref : string -> int ref -> Widget.widget -> pref
@

<<signature [[Prefs.float_pref]]>>=
val float_pref : string -> float ref -> Widget.widget -> pref
@

<<signature [[Prefs.string_pref]]>>=
val string_pref : string -> string ref -> Widget.widget -> pref
    (* [<type>_pref name internal_location top] *)
@

<<signature [[Prefs.option_pref]]>>=
val option_pref :
    string ->
    (Textvariable.textVariable -> unit) *
    (Textvariable.textVariable -> unit) * string list ->
    Widget.widget -> pref
@

<<signature [[Prefs.abstract_bool_pref]]>>=
val abstract_bool_pref :
    string ->
      (Textvariable.textVariable -> unit) ->
      (Textvariable.textVariable -> unit) -> Widget.widget -> pref
@

<<signature [[Prefs.abstract_string_pref]]>>=
val abstract_string_pref :
    string ->
      (Textvariable.textVariable -> unit) ->
      (Textvariable.textVariable -> unit) -> Widget.widget -> pref
@

<<signature [[Prefs.option_handlers]]>>=
val option_handlers :
    ('a * string) list ->
    (unit -> 'a) ->
    ('a -> unit) ->
    (Textvariable.textVariable -> unit) * (Textvariable.textVariable -> unit) *
    string list
@

<<signature [[Prefs.family]]>>=
val family :
    Widget.widget -> string -> (Widget.widget -> pref) list -> pref_family
@

<<signature [[Prefs.pref_error]]>>=
val pref_error : string -> unit
@

<<signature [[Prefs.resource_name]]>>=
val resource_name : string -> string
@

<<signature [[Prefs.define]]>>=
val define :
    string ->
    (Widget.widget -> pref_family) list -> (unit -> unit) list -> unit -> unit
    (* [define filename pref_builders pref_mute]
       returns a function that displays the preference panel
     *)
@


%-------------------------------------------------------------

<<gui/prefs.mli>>=
<<type [[Prefs.pref_type]]>>

<<type [[Prefs.pref]]>>

module PrefMap : Map.S with type key = string

<<type [[Prefs.pref_family]]>>

<<signature [[Prefs.bool_pref]]>>
<<signature [[Prefs.int_pref]]>>
<<signature [[Prefs.float_pref]]>>
<<signature [[Prefs.string_pref]]>>

<<signature [[Prefs.option_pref]]>>


<<signature [[Prefs.abstract_bool_pref]]>>

<<signature [[Prefs.abstract_string_pref]]>>


<<signature [[Prefs.option_handlers]]>>



<<signature [[Prefs.family]]>>

<<signature [[Prefs.pref_error]]>>

<<signature [[Prefs.resource_name]]>>

<<signature [[Prefs.define]]>>
@


\subsection*{[[gui/prefs.ml]]}

<<function [[Prefs.pref_error]]>>=
(* Generic report *)
let pref_error msg =
  Frx_dialog.f Widget.default_toplevel (gensym "error")
     (s_ "Preference Error") 
     msg
     (Predefined "") 0 [s_ "Ok"] |> ignore
@

<<function [[Prefs.resource_name]]>>=
(* Converts an arbitrary string to a name suitable as a "global" resource *)
let resource_name pref_name =
  let words = Mstring.split_str (function ' ' -> true | _ -> false) pref_name 
  in
  (* for each words, remove non alpha-numerics *)
  (* in addition, make the each first characters capital *)
  let words' = List.map (fun word ->
    let buf = Bytes.create (String.length word) in
    let pos = ref 0 in
    for i = 0 to String.length word - 1 do
      if ('A' <= word.[i] && word.[i] <= 'Z') ||
         ('a' <= word.[i] && word.[i] <= 'z') ||
         ('0' <= word.[i] && word.[i] <= '9') then begin
        Bytes.set buf !pos word.[i];
        incr pos
    end;
    done;
    let x = Bytes.sub buf 0 !pos in
    begin 
      try
    if 'a' <= Bytes.get x 0 && Bytes.get x 0 <= 'z' then
      Bytes.set x 0 (Char.chr (Char.code (Bytes.get x 0) + Char.code 'A' - Char.code 'a'));
      with
    Invalid_argument _ -> 
      (* Strangely, x could be "". *) ()
    end;
    Bytes.to_string x ) words
  in
    "pref" ^ String.concat "" words'
@

<<constant [[Prefs.class_name]]>>=
let _class_name = resource_name 
  (* it is not correct but works *)
@

<<type [[Prefs.pref_type]] ([[gui/prefs.ml]])>>=
(*
 * Various predefined preference types
 *)
type pref_type =
   Bool of bool ref
 | String of string ref
 | Int of int ref
 | Float of float ref
 | AbstractType of (Textvariable.textVariable -> unit) * 
                (Textvariable.textVariable -> unit)
                 (* init, set  as defined below *)
@

<<type [[Prefs.pref]] ([[gui/prefs.ml]])>>=
(*
 * Support for interactive setting of a preference 
 *)
type pref = {
  packed_widget : Widget.widget;	       (* visual feedback *)
  pref_variable : Textvariable.textVariable;   (* placeholder for string
                          version of pref value, and
                          possibly "electric" change *)
  pref_type : pref_type;		       (* internal definition *)
  pref_name : string;	 (* internal name (shall not contain :) *)
  resource_name : string (* resource name (shall not contain :) *)
}
@

<<function [[Prefs.init_pref]]>>=
(*
 * Init the Tk variables in the pref editor from the internal 
 * value of the preference (usually a reference)
 *)
let init_pref {pref_type = typ; pref_variable = v; _} = match typ with
   Bool r -> Textvariable.set v (if !r then "1" else "0")
 | String r -> Textvariable.set v !r
 | Int r ->  Textvariable.set v (string_of_int !r)
 | Float r ->  Textvariable.set v (string_of_float !r)
 | AbstractType(i,_) -> i v
@

<<function [[Prefs.set_pref]]>>=
(* 
 * Set the internal preference value from the editor value (ie textvariable)
 * NOTE: basic predefined types do not allow extra code to run when the
 * value is modified.
 *)
let set_pref {pref_type = typ; pref_variable = v; _} = match typ with
   Bool r -> r := Textvariable.get v = "1"
 | String r -> r := Textvariable.get v
 | Int r ->
     let s = Textvariable.get v in
      begin try 
        r := int_of_string s
      with Failure "int_of_string" ->
        pref_error (s_ "Not an integer: %s" s)
      end
 | Float r ->
     let s = Textvariable.get v in
     begin try 
        r := float_of_string s
     with Failure "float_of_string" ->
        pref_error (s_ "Not a float: %s" s)
     end
 | AbstractType(_,s) -> s v
@

<<function [[Prefs.load_pref]]>>=
(* 
 * Given the current resource database, set the internal and editor values
 * of the preference.
 *)
let load_pref pref =
  try 
    let prefdata = Resource.get Widget.default_toplevel 
      pref.resource_name pref.resource_name (* it is not correct but works *)
    in
    (* ONLY if non-empty ! *)
    if prefdata <> "" then begin
      Textvariable.set pref.pref_variable prefdata;
      set_pref pref
    end
  with
    Not_found -> () (* Never happen if database is complete *)
@

<<function [[Prefs.save_pref]]>>=
(* 
 * Adds the current pref value (from pref editor) to a preference table
 *)
let save_pref add pref =
  add pref.resource_name (Textvariable.get pref.pref_variable)
@

<<function [[Prefs.bool_pref]]>>=
(*
 * Building the preference manager for predefined preference types
 *)


let bool_pref name r top = 
  let v = Textvariable.create_temporary top in
  (* The frame is just to avoid expanding *)
  let f = Frame.create top [] in
  let w = Checkbutton.create f [Text name; Variable v] in
   pack [w][Side Side_Left; Anchor W; Fill Fill_X];
  let p =
    { pref_type = Bool r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name } in
  (* Automatically perform the preference change when you trigger the button *)
  Checkbutton.configure w [Command (fun () -> set_pref p)];
  p
@

<<function [[Prefs.int_pref]]>>=
let int_pref name r top = 
  let v = Textvariable.create_temporary top in
  let f,_e = Frx_entry.new_labelm_entry top name v in
  let p =
    { pref_type = Int r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name } in
  (* Automatically perform the preference change when you edit the entry *)
  (* NOTE: we have to use a "tracer" on the variable, since the user does *)
  (* not necessarily type Enter when editing is finished. OTOH, this will *)
  (* cause additionnal invocations during load_pref and init_pref *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function [[Prefs.float_pref]]>>=
let float_pref name r top = 
  let v = Textvariable.create_temporary top in
  let f,_e = Frx_entry.new_labelm_entry top name v in
  let p = 
    { pref_type = Float r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name} in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function [[Prefs.string_pref]]>>=
let string_pref name r top = 
  let v = Textvariable.create_temporary top in
  let f,_e = Frx_entry.new_labelm_entry top name v in
  let p = 
    { pref_type = String r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name } in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function [[Prefs.option_pref]]>>=
let option_pref name (i, s, p) top =
  let v = Textvariable.create_temporary top in
  let f = Frame.create top [] in
  let l = Label.create f [Text name]
  and o,_ = Optionmenu.create f v p in
    pack [l;o][Side Side_Left];
  let p = {
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = name;
    resource_name = resource_name name} in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function [[Prefs.abstract_bool_pref]]>>=
(*
 * Like bool_pref, but with additional handling code
 *)

let abstract_bool_pref name i s top =
  let v = Textvariable.create_temporary top in
  (* The frame is just to avoid expanding *)
  let f = Frame.create top [] in
  let w = Checkbutton.create f [Text name; Variable v] in
   pack [w][Side Side_Left; Anchor W; Fill Fill_X];
  let p = {
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = name;
    resource_name = resource_name name} in
  (* Automatically perform the preference change when you trigger the button *)
  Checkbutton.configure w [Command (fun () -> set_pref p)];
  p
@

<<function [[Prefs.abstract_string_pref]]>>=
(*
 * Like string_pref, but with additional handling code
 *)
let abstract_string_pref name i s top =
  let v = Textvariable.create_temporary top in
  let f,_e = Frx_entry.new_labelm_entry top name v in
  let p ={
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = name;
    resource_name = resource_name name} in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function [[Prefs.option_handlers]]>>=
(*
 * Utility for option_pref
 *)

let option_handlers mapping read_internal write_internal =
  let rev_mapping = List.map (fun (x,v) -> (v,x)) mapping in
  let init v =
    let current = read_internal() in
    let s =
      try
    List.assoc current mapping
      with
    Not_found ->
      match mapping with
        [] -> "undefined"
      | (_x,v)::_l -> v
    in
    Textvariable.set v s
  and set v =
    let current = Textvariable.get v in
    let value =
      try
    List.assoc current rev_mapping
      with
    Not_found ->
      match mapping with
        [] -> assert false
      | (x,_v)::_l -> x
    in
    write_internal value
  in
  init, set, List.map snd mapping
@

<<function [[Prefs.load_file]]>>=
let load_file f =
  (* It just loads the file as resource *)
  try
    Tkresource.readfile f Interactive
  with
    Protocol.TkError _ -> 
      failwith (s_ "Can't open preference file: %s" f)
@

<<function [[Prefs.save_file]]>>=
let save_file prefmaps f =
  let delimiter = "!!! Don't edit below this line !!!" in
  try
    (* create $HOME/.mmm (by default) silently *)
    let prefdir = Filename.dirname f in 
    if not (Sys.file_exists prefdir) then Munix.digdir prefdir 0o755;
    let oc = open_out (f ^ ".tmp") in
    try
      let ic = open_in f in
      try
    while true do
      let l = input_line ic in
      if l = delimiter then raise End_of_file
      else output_string oc (l ^ "\n")
    done
      with
    End_of_file -> 
      close_in ic; 
      raise End_of_file
    with
      Sys_error _ 
    | End_of_file ->
   (* the delimiter is found, no delimiter in the file
      or no pref file is found *)
    output_string oc (delimiter ^ "\n");
    List.iter (
    PrefMap.iter (fun name data ->
      output_char oc '*'; output_string oc name; output_char oc ':'; 
      output_string oc data; output_char oc '\n'))
      prefmaps;
    close_out oc;
    Unix.rename (f ^ ".tmp") f
  with Sys_error s ->
    pref_error (s_ "Can't open preference file: %s (%s)" f s)
@
%$

<<type [[Prefs.pref_family]] ([[gui/prefs.ml]])>>=
(* Builds a family of preferences *)
type pref_family =
  {family_widget: Widget.widget;    (* the main widget for this family *)
   family_init : unit -> unit;	    (* init the display from memory *)
   family_save : unit -> string PrefMap.t; (* return current bindings *)
   family_load : unit -> unit;  (* loads from persistent storage *)
   family_title : string;
  }
@

<<function [[Prefs.family]]>>=
(* Computing a family from the predefined preference types *)
let family top title preff =
  let f = 
    Frame.create_named top (Mstring.gensym "family")
      [Relief Sunken; BorderWidth (Pixels 1)] in
  (* create the widgets *)
  let prefs = List.map (fun p -> p f) preff in
  (* define the functions for the family *) 
  let init _ = List.iter init_pref prefs
  and load () = List.iter load_pref prefs
  and save () = 
    List.fold_right 
      (fun pref map -> save_pref (fun k v -> PrefMap.add k v map) pref)
      prefs
      PrefMap.empty
  in
  (* initialize the text variables *)
  init();
  (* wrapping stuff *)
  let t = Label.create f [Text title] in
  pack [t][];
  pack (List.map (fun p -> p.packed_widget) prefs) 
       [Fill Fill_X; Expand true; Anchor W];
  {family_widget = f; family_init = init;
   family_load = load; family_save = save;
   family_title = title}
@

<<function [[Prefs.init]]>>=
(* This is the startup *)

let rec init filename status interactive mute =
  let top = Toplevel.create_named Widget.default_toplevel "prefs" 
                 [Class "MMMPrefs"] in
   Wm.title_set top (s_ "MMM Preferences");
   Wm.withdraw top;
   status := Some top;
   bind top [[], Destroy] 
     (BindSet ([Ev_Widget],
           (fun ei -> if ei.ev_Widget = top then status := None)));

  let preffilev = Textvariable.create_temporary top in

  (* The menu bar *)
  let mbar = Frame.create_named top "menubar" [] in
  let file = 
    Menubutton.create_named mbar "file" [Text (s_ "File"); UnderlinedChar 0] in
  pack [file][Side Side_Left];
  pack [mbar][Side Side_Top; Anchor W; Fill Fill_X];
  (* The window *)
  let hgroup = Frame.create_named top "panels" [] in
  (* section choice *)
  let sectionf = Frame.create_named hgroup "sections" [] in
  let buttonsf = Frame.create_named top "buttons" [] in
  pack [sectionf] [Side Side_Left; Fill Fill_Y];
  pack [hgroup] [Side Side_Top; Fill Fill_Both; Expand true];
  pack [buttonsf] [Side Side_Bottom];

  Textvariable.set preffilev !filename;	(* for the file selector *)

  (* We must load the file because some elements of the panel depend
     on resources defined in this file *)
  begin 
    try load_file !filename
    with Failure s -> pref_error s
  end;


  (* Then we must do the mute stuff *)
    List.iter (fun f -> f()) mute;

  (* Then we can build the families *)
  let families = List.map (fun f -> f hgroup) interactive in

  (* Then we do the interactive stuff *)
  List.iter (fun f -> f.family_load ()) families;

  let reset () =
    destroy top; status := None;
    init filename status interactive mute
  in

  (* select a preference file to load *)
  let rec load () =
    Fileselect.f (s_ "Load a preference file")
      (function [] -> ()
              | [s] -> 
         (* we must restart the panel, because resources
            may affect the displayed menus *)
          if Sys.file_exists s then begin
            destroy top;
            filename := s;
            init filename status interactive mute
          end
          else
            pref_error (s_ "%s : no such preference file" s)
              | _l -> raise (Failure "multiple selection"))
      (Filename.concat (Filename.dirname (Textvariable.get preffilev))
       "*")
      (Filename.basename (Textvariable.get preffilev))
      false
      false

  (* select a new preference file to save in *)
  and save_as () =
    Fileselect.f (s_ "Save preferences to file")
      (function 
      [] -> ()
        | [s] ->
        Textvariable.set preffilev s;
        filename := s;
       begin
              try 
        save_file (List.map (fun f -> f.family_save()) families) s;
        dismiss()
         with Failure s -> pref_error s
            end
        | _l -> raise (Failure "multiple selection"))
      (Filename.concat (Filename.dirname (Textvariable.get preffilev))
       "*")
      (Filename.basename (Textvariable.get preffilev))
      false
      false

  (* save in the last defined preference file *)
  and save () =
    try
      save_file (List.map (fun f -> f.family_save()) families) 
            (Textvariable.get preffilev);
      dismiss()
    with
      Failure s -> pref_error s

  and dismiss() = 
    Wm.withdraw top

  in

  (* Fill in the menu *)
  let mfile = Menu.create_named file "filemenu" [] in
    Menu.add_command mfile 
       [Label (s_ "Load"); Command load; UnderlinedChar 0];
    Menu.add_command mfile 
       [Label (s_ "Save"); Command save; UnderlinedChar 0];
    Menu.add_command mfile 
       [Label (s_ "Save As"); Command save_as; UnderlinedChar 0];
    Menu.add_command mfile 
        [Label (s_ "Dismiss"); Command dismiss; UnderlinedChar 0];
    Menubutton.configure file [Menu mfile];

  (* Define the buttons *)
    let saveb = Button.create_named buttonsf "save"
      [Text (s_ "Save"); Command save]
    and resetb = Button.create_named buttonsf "reset"
      [Text (s_ "Reset"); Command reset]
    and dismissb = Button.create_named buttonsf "dismiss"
      [Text (s_ "Dismiss"); Command dismiss]
    in
    pack [saveb;resetb;dismissb][Side Side_Left; PadX (Pixels 20)];


  let current = ref (List.hd families) in

  let set_current f =
    Pack.forget [!current.family_widget];
    f.family_init();
    pack [f.family_widget]
         [Side Side_Top; Fill Fill_Both; Expand true];
    current := f in

  let sectionv = Textvariable.create_temporary sectionf in
  let selectors =
    List.map (fun f ->
      Radiobutton.create sectionf [
        Variable sectionv; Text f.family_title; Value f.family_title;
        Command (fun () -> set_current f)]
      )
    families;
  in
  pack selectors [Anchor W];

  Textvariable.set sectionv !current.family_title;

  set_current (List.hd families)
@

<<function [[Prefs.define]]>>=
(* Define a preference panel *)
let define filename interactive mute =
  let inited = ref None 
  and current_file = ref filename in
  (function () -> 
    match !inited with
      Some w -> Wm.deiconify w
    | None -> (* we have been destroyed ! *)
    init current_file inited interactive mute)
@


%-------------------------------------------------------------

<<gui/prefs.ml>>=
(* Preferences *)
open I18n
open Tk
open Mstring


<<function [[Prefs.pref_error]]>>

<<function [[Prefs.resource_name]]>>

<<constant [[Prefs.class_name]]>>

<<type [[Prefs.pref_type]] ([[gui/prefs.ml]])>>

<<type [[Prefs.pref]] ([[gui/prefs.ml]])>>


<<function [[Prefs.init_pref]]>>

<<function [[Prefs.set_pref]]>>

<<function [[Prefs.load_pref]]>>

<<function [[Prefs.save_pref]]>>


<<function [[Prefs.bool_pref]]>>

<<function [[Prefs.int_pref]]>>

<<function [[Prefs.float_pref]]>>

<<function [[Prefs.string_pref]]>>

<<function [[Prefs.option_pref]]>>


<<function [[Prefs.abstract_bool_pref]]>>

<<function [[Prefs.abstract_string_pref]]>>


<<function [[Prefs.option_handlers]]>>


(*
 * Loading and saving preferences from a resource file
 *)

module PrefMap = Map.Make(struct type t = string let compare = compare end)

<<function [[Prefs.load_file]]>>

<<function [[Prefs.save_file]]>>
      
<<type [[Prefs.pref_family]] ([[gui/prefs.ml]])>>

<<function [[Prefs.family]]>>


<<function [[Prefs.init]]>>


<<function [[Prefs.define]]>>
@


\subsection*{[[gui/debug.ml]]}




%-------------------------------------------------------------

<<gui/debug.ml>>=

open Protocol
<<function [[Debug.active_cb]]>>

<<function [[Debug.init]]>>

@


\subsection*{[[gui/history.mli]]}

%-------------------------------------------------------------

<<gui/history.mli>>=

<<type [[History.history_entry]]>>

<<type [[History.t]]>>

val create: Document.document_id -> t

val add: t -> Document.document_id -> string option -> unit

val back: t -> (Document.document_id * string option) option
val forward: t -> (Document.document_id * string option) option

val contents: t -> history_entry list

val set_current: t -> history_entry -> unit

@

\subsection*{[[gui/history.ml]]}


<<function [[History.contents]]>>=
let contents h =
  let l = ref [] in
  let rec walk e =
    l := e :: !l;
    match e.h_next with
       None -> !l
      | Some e -> walk e
  in walk h.h_start
@

<<function [[History.obsolete]]>>=
(* Since a did may occur several times in the history, the list of
   obsolete entries is not simply the overwritten entries *)

let obsolete current next =
  let kept = ref DocumentIDSet.empty
  and forgotten = ref DocumentIDSet.empty in
  let rec back e =
    kept := DocumentIDSet.add e.h_did !kept;
    match e.h_prev with
      None -> ()
    | Some e -> back e in
  let rec forw e =
    forgotten := DocumentIDSet.add e.h_did !forgotten;
    match e.h_next with
      None -> ()
    | Some e -> forw e in
  back current;
  forw next;
  DocumentIDSet.diff !forgotten !kept
@

<<function [[History.add]]>>=
(* Add hinfo to the current point *)
let add h did frag =
  (* Hack for the initial document *)
  if h.h_first then begin
    let newe = {h_did = did;
        h_fragment = frag;
        h_prev = None;
        h_next = None} in
      h.h_start <- newe;
      h.h_current <- newe;
      h.h_first <- false
      end
  else
    match h.h_current.h_next with
      None -> (* last in the list *)
    (* the new entry *)
    let newe = {h_did = did;
            h_fragment = frag;
            h_prev = Some h.h_current;
            h_next = None} in
    (* fix the linked list *)
    h.h_current.h_next <- Some newe;
    (* set the new current *)
    h.h_current <- newe
   | Some e -> (* adding in the middle of the list *)
    let newe = {h_did = did;
            h_fragment = frag;
            h_prev = Some h.h_current;
            h_next = None} in
    let dropped = obsolete newe e in
    h.h_current.h_next <- Some newe;
    h.h_current <- newe;
    DocumentIDSet.iter (Gcache.remove h.h_key) dropped
@



<<function [[History.set_current]]>>=
let set_current h e =
  h.h_current <- e
@


%-------------------------------------------------------------

<<gui/history.ml>>=
(* History *)
open Document

<<type [[History.history_entry]]>>

<<type [[History.t]]>>

<<function [[History.contents]]>>

(* Did made obsolete by history overwriting *)
<<function [[History.obsolete]]>>

<<function [[History.add]]>>

<<constant [[History.create]]>>

<<function [[History.back]]>>

<<function [[History.forward]]>>

<<function [[History.set_current]]>>

@


\subsection*{[[gui/nav.mli]]}


<<signature [[Nav.display_headers]]>>=
val display_headers : Document.handle -> unit
@

<<signature [[Nav.copy_link]]>>=
val copy_link : t -> Hyper.link -> unit
@

<<signature [[Nav.save_link]]>>=
val save_link : t -> (Unix.file_descr * bool) option -> Hyper.link -> unit
@


<<signature [[Nav.add_user_navigation]]>>=
val add_user_navigation : string -> Viewers.hyper_func -> unit
@




<<signature [[Nav.update]]>>=
val update : t -> Document.document_id -> bool -> unit
@



%-------------------------------------------------------------

<<gui/nav.mli>>=
<<type [[Nav.t]]>>

<<signature [[Nav.request]]>>

<<signature [[Nav.display_headers]]>>

<<signature [[Nav.copy_link]]>>
<<signature [[Nav.save_link]]>>
<<signature [[Nav.follow_link]]>>

<<signature [[Nav.add_user_navigation]]>>

<<signature [[Nav.make_ctx]]>>

<<signature [[Nav.absolutegoto]]>>
<<signature [[Nav.historygoto]]>>
<<signature [[Nav.update]]>>

<<signature [[Nav.dont_check_cache]]>>
@


\subsection*{[[gui/nav.ml]]}


<<exception [[Nav.Duplicate]]>>=
exception Duplicate of Url.t
@



<<function [[Nav.nothing_specific]]>>=
(*
 * Three instances of this general mechanism : view, save, head
 *)
let nothing_specific _nav _did _wr = raise Not_found
@


<<function [[Nav.specific_viewer]]>>=
(* check the widget cache *)
let specific_viewer addhist = fun nav did wr ->
  let di = Gcache.find nav.nav_id did in
  if addhist then nav.nav_add_hist did wr.www_fragment;
  (* make it our current displayed document, since it is available *)
  nav.nav_show_current di wr.www_fragment
@

<<function [[Nav.process_save]]>>=
(* Specific handling of "save" requests *)
let process_save dest = fun _nav wr dh ->
  match dh.document_status with
    200 -> Save.transfer wr dh dest
  | n ->
    if wr.www_error#choose 
        (s_ "Request for %s\nreturned %d %s.\nDo you wish to save ?"
              (Url.string_of wr.www_url) n (status_msg dh.dh_headers))
    then Save.transfer wr dh dest
    else dclose true dh
@

<<function [[Nav.display_headers]]>>=
(* Simple implementation of HEAD *)

let display_headers dh =
  let mytop = Toplevel.create Widget.default_toplevel [] in
  Wm.title_set mytop 
      (sprintf "HEAD %s" (Url.string_of dh.document_id.document_url));
  let hs =
    dh.dh_headers |> List.map (fun h -> Label.create mytop [Text h; Anchor W])
  in
  pack (List.rev hs) [Fill Fill_X];
  let b = Button.create mytop
            [Command (fun _ -> destroy mytop); Text "Dismiss"] in
  pack [b] [Anchor Center]
@

<<constant [[Nav.process_head]]>>=
let process_head = fun _nav _wr dh ->
  dclose true dh;
  display_headers dh
@

<<function [[Nav.make_head]]>>=
(* But for head, we need to change the hlink *)
let make_head hlink =
  { hlink with h_method = HEAD; }
@

<<function [[Nav.copy_link]]>>=
(* Copying a link to the X Selection *)
let copy_link nav h =
  try 
    Frx_selection.set (Hyper.string_of h)
  with Invalid_link _msg ->
    nav.nav_error#f (s_ "Invalid link")
@

<<constant [[Nav.user_navigation]]>>=
let user_navigation = ref []
@

<<function [[Nav.add_user_navigation]]>>=
let add_user_navigation (s : string) (f : Viewers.hyper_func) =
  user_navigation := (s,f) :: !user_navigation
@



<<function [[Nav.save_link]]>>=
(* Simple wrappers *)
let save_link nav whereto =
  request nav (process_save whereto) (true, id_wr, nothing_specific)
@




<<function [[Nav.update]]>>=
let update nav did nocache =
  (* This gets called if answer is 200 but also 304 *)
  let process_update nav wr dh =
    match dh.document_status with
      304 -> 
    Cache.patch dh.document_id dh.dh_headers;
    dclose true dh;
    begin try
      let di = Gcache.find nav.nav_id did in
      di#di_update
    with
      Not_found -> () (* weird *)
    end;
    wr.www_error#ok 
      (s_ "Document %s has not changed.\n" (Url.string_of wr.www_url))
    | 200 | _ ->
        (* kill the previous displayed window *)
     Gcache.displace nav.nav_id did;
    (* we may have been redirected : check new did *)
    let oldurl = Url.string_of did.document_url in
    let newurl = Url.string_of dh.document_id.document_url in
    let add_hist = oldurl <> newurl in
    if add_hist then 
      wr.www_error#ok (s_ "Document %s is relocated to:\n%s" oldurl newurl);
     wr.www_logging <- nav.nav_log;
     process_viewer add_hist make_ctx nav wr dh
  in
  try
    let doc = Cache.find did in
    try
      (* find the date of previous download, (or last-modified ?) *)
      let date_received = get_header "date" doc.document_headers in
      let follow_link =
        request nav process_update
        (false, (* we don't want to use cache here *)
         (* setup additional headers *)
         (fun wr -> 
           wr.www_headers <- 
             ("If-Modified-Since: "^date_received) :: wr.www_headers;
           if nocache 
           then wr.www_headers <- "Pragma: no-cache" :: wr.www_headers;
           wr),
         nothing_specific)
      in
      follow_link (Hyper.default_link (Url.string_of did.document_url))
    with Not_found ->
      nav.nav_error#f ("Document has no Date: header.")
  with Not_found ->
   nav.nav_error#f (s_ "Document %s\nhas been flushed from cache"
                        (Url.string_of did.document_url))
@


%-------------------------------------------------------------

<<gui/nav.ml>>=
open I18n
open Printf
open Unix
open Tk
open Hyper
open Www
open Url

open Document
open Http_headers
open Viewers
open Embed

(* Navigation *)

<<type [[Nav.t]]>>

<<exception [[Nav.Duplicate]]>>

(* Important note: we assume two requests on the same url are identical
   (when we control emission of requests). This is not the case for 
   POST requests, because we would need to check the POST data.
   This means that you can't post twice *simultaneously* on the same
   url. Proper fix: change the equality semantics of active cnx
 *)

<<function [[Nav.dont_check_cache]]>>

<<function [[Nav.request]]>>

<<function [[Nav.nothing_specific]]>>

<<function [[Nav.process_viewer]]>>

<<function [[Nav.specific_viewer]]>>


<<function [[Nav.process_save]]>>

<<function [[Nav.display_headers]]>>
 
<<constant [[Nav.process_head]]>>

<<function [[Nav.make_head]]>>

(*
 *  Other handlers, less general
 *)

<<function [[Nav.copy_link]]>>

<<constant [[Nav.user_navigation]]>>
<<function [[Nav.add_user_navigation]]>>

<<function [[Nav.id_wr]]>>

<<class [[Nav.stdctx]]>>

<<function [[Nav.make_ctx]]>>

<<function [[Nav.save_link]]>>
<<function [[Nav.follow_link]]>>
    
(*
 * Other navigation functions
 *)

<<function [[Nav.absolutegoto]]>>
    
<<function [[Nav.historygoto]]>>


<<function [[Nav.update]]>>
@


\subsection*{[[gui/mmmprefs.mli]]}

<<signature [[Mmmprefs.plug_applets]]>>=
(* We need a more generic mechanism *)
val plug_applets : (Widget.widget -> pref_family) -> unit
@


<<signature [[Mmmprefs.f]]>>=
val f : string -> unit -> unit
@


%-------------------------------------------------------------

<<gui/mmmprefs.mli>>=
open Prefs

<<signature [[Mmmprefs.plug_applets]]>>

<<signature [[Mmmprefs.home]]>>

<<signature [[Mmmprefs.f]]>>
@


\subsection*{[[gui/mmmprefs.ml]]}

<<function [[Mmmprefs.font_pref]]>>=
(*
 * Font preference
 *)
let font_pref title name top = 
  let f = Frame.create top [] in
  let l = Label.create_named f "fontname" [Text title] in
  let f', v, i, s =
    Fontprefs.font_select f
      (fun () -> Styles.get_font name)  (* get from internal value *)
      (Styles.set_font name)		(* set internal value *)
  in
   pack [l;f'][Side Side_Left];
  (* map exceptions to error *)
  let i v = try i v with Failure s -> pref_error s
  and s v = try s v with Failure s -> pref_error s
  in
  let p = {
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = title;
    resource_name = resource_name title} in
  p
@

<<constant [[Mmmprefs.image_loading]]>>=
(*
 * Image loading mode
 *)
let image_loading =
  option_handlers 
    [ Imgload.AfterDocManual, "After document, manual"; 
      Imgload.AfterDocAuto, "After document, automatic";
      Imgload.DuringDoc, "During document loading"]
    (fun () -> !Imgload.mode)
    (fun v -> Imgload.mode := v)
@

<<function [[Mmmprefs.network]]>>=
let network top = 
  family top (s_ "Protocols") [
    string_pref "Proxy host" Http.proxy;
    int_pref "Proxy port" Http.proxy_port;
    bool_pref "Always Use Proxy" Http.always_proxy;
    bool_pref "HTTP Send Referer" Http.send_referer;
    string_pref "User Agent" Http.user_agent;
    int_pref "Timeout on headers (seconds)" Http.timeout;
    int_pref "Password lifetime (minutes)" Auth.lifetime;
    string_pref "Password save file" Auth.auth_file;
    abstract_string_pref "Local binaries path" 
      Tk_file.pref_init Tk_file.pref_set
    ]
@

<<function [[Mmmprefs.internal]]>>=
let internal top =
  family top (s_ "Internal settings and debugging") [
    bool_pref "Strict encoding of Form field names" Urlenc.strict_form_standard;
    bool_pref "HTTP Requests" Http.verbose;
    int_pref "Internal buffer" Textw_fo.internal_buffer;
(* always on for now    bool_pref "General trace" Log.debug_mode; *)
    bool_pref "Scheduler" Scheduler.debug;
    bool_pref "Cache debug" Cache.debug;
    bool_pref "Widget Cache debug" Gcache.debug;
    bool_pref  "HTML Display log" Html_disp.verbose;
    bool_pref "Table debug" Table.debug;
    bool_pref "Text fit debug" Fit.debug;
    bool_pref "Image loading debug" Img.ImageData.verbose;
    bool_pref "CamlTk Debug" Protocol.debug;
    ]
@

<<function [[Mmmprefs.html]]>>=
let html top = 
  family top (s_ "HTML parsing and display") [
    option_pref "DTD" (dtd_i, dtd_s, dtd_p);
    bool_pref "Strict HTML lexing" Lexhtml.strict;
    bool_pref "Attempt tables" Html_disp.attempt_tables;
    bool_pref "Ignore relative TD width" Table.strict_32;
    bool_pref "Attempt smooth scroll" Htmlw.pscrolling;
    bool_pref "Frames as links" Htmlw.frames_as_links;
    abstract_string_pref "Background color"
      (fun v -> Textvariable.set v !Textw_fo.html_bg)
      (fun v ->
     let color = Textvariable.get v in
        Textw_fo.html_bg := color;
      (* transparent GIF hack, for the initial images *)
        Textvariable.set (Textvariable.coerce "TRANSPARENT_GIF_COLOR")
                         color;
            (* set the resource for each possible class of embedded windows *)
        Resource.add "*Html*Text.background" color WidgetDefault;
            Resource.add "*Html*Message.background" color WidgetDefault;
            Resource.add "*Html*Label.background" color WidgetDefault;
            Resource.add "*Html*Listbox.background" color WidgetDefault;
            Resource.add "*Html*Button.background" color WidgetDefault;
            Resource.add "*Html*Entry.background" color WidgetDefault;
            Resource.add "*Html*Menubutton.background" color WidgetDefault;
            Resource.add "*Plain*Text.background" color WidgetDefault
        );
    string_pref "Entry and Textarea color" Form.form_bg;
    bool_pref "Follow document colors" Textw_fo.usecolors; 
    font_pref "Default font" "default";
    font_pref "<H1> font" "header1";
    font_pref "<H2> font" "header2";
    font_pref "<H3> font" "header3";
    font_pref "<H4> font" "header4";
    font_pref "<H5> font" "header5";
    font_pref "<H6> font" "header6";
    font_pref "Bold"   "bold";
    font_pref "Italic" "italic";
    font_pref "Fixed" "verbatim"
    ]
@

<<function [[Mmmprefs.i18n]]>>=
let i18n top =
  family top (s_ "Internationalization (Japanese)") [
    bool_pref "Ignore META charset" Htmlw.ignore_meta_charset
  ] 
@
%    (* bool_pref "Japanese mode" Version.japan; *)

<<function [[Mmmprefs.images]]>>=
let images top =
  family top (s_ "Images") [
    bool_pref "No images at all" Imgload.no_images;
    option_pref "Image loading" image_loading;
       (* image_loading_i image_loading_s image_loading_p; *)
    int_pref "Max image connections" Img.ImageScheduler.maxactive;
    int_pref "Max image connections (same host)" Img.ImageScheduler.maxsamehost;
    float_pref "Gamma correction" Img.ImageData.gamma;
    string_pref "JPEG converter"  Img.ImageData.jpeg_converter
    ]
@

<<function [[Mmmprefs.cache]]>>=
let cache top =
  family top (s_ "Cache settings") [
    int_pref "Max number of documents"  Cache.max_documents;
    int_pref "Delete how much when full" Cache.cleann;
    bool_pref "Keep only history" Cache.history_mode;
    int_pref "Max cached widgets per window" Gcache.max_keep
    ]
@

<<function [[Mmmprefs.progs]]>>=
let progs top =
  family top (s_ "External programs") [
    string_pref "Mailto program" Mailto.mailer;
    string_pref "Hotlist program" Hotlist.program;
    string_pref "Printing program" Save.print_command;
    ]
@

<<function [[Mmmprefs.misc]]>>=
let misc top =
  family top (s_ "Misc. settings") [
    bool_pref "Use balloon helps" Balloon.flag;
    bool_pref "Use GIF animation" Img.gif_anim_load;
    bool_pref "Automatic GIF animation display" Imgload.gif_anim_auto
    ]
@

<<constant [[Mmmprefs.appsys_plug]]>>=
(* The default appsys preference only keeps track of
   the preference values, but does not allow changes
 *)
let appsys_plug = ref (fun top -> 
  let f = Frame.create top [Relief Sunken; BorderWidth (Pixels 1)] in
  let t = Label.create f [Text (s_ "Applets")] in
  let msg =
   Message.create f [Text (s_ "Applets are not available \
                                         in the native version")] in
  pack [t][Side Side_Top];
  pack [msg][Side Side_Bottom];
  (* we must keep track of applet preferences in the 
     bytecode version : "Active" and "Paranoid" *)
  let active = ref false  and active_name = resource_name "Active"
  and paranoid = ref true and paranoid_name = resource_name "Paranoid" in
  let init () = ()  (* nothing special to be done *)
  and save () =
    List.fold_right 
      (fun (name,value) map -> PrefMap.add name value map)
      [active_name, (if !active then "1" else "0");
       paranoid_name, (if !paranoid then "1" else "0")]
      PrefMap.empty
  and load () = 
    List.iter (fun (name, setf) ->
      try
    let prefdata = Resource.get Widget.default_toplevel name name in
    setf prefdata
      with
    Not_found -> ())
      [active_name, (function data -> active := data = "1");
       paranoid_name, (function data -> paranoid := data = "1")]
  in
  {family_widget = f; family_init = init;
   family_save = save; family_load = load;
   family_title = s_ "Applets"})
@

<<function [[Mmmprefs.plug_applets]]>>=
let plug_applets f =
  appsys_plug := f
@

<<function [[Mmmprefs.applets]]>>=
let applets w = !appsys_plug w
@


<<function [[Mmmprefs.reset_home]]>>=
let reset_home () =
  home :=  Tkresource.string "wwwHome" 
       (try Sys.getenv "WWW_HOME"
       with Not_found -> (Version.initurl (Lang.lang ())))
@

<<constant [[Mmmprefs.mute]]>>=
(* Internal preferences *)
let mute = [
  reset_home;
  Fonts.reset;
  Viewers.reset;			(* viewers definition *)
  Glevents.reset;			(* bindings *)
  ]
@

<<constant [[Mmmprefs.families]]>>=
(* Interactive preferences *)
let families = [ network; html; i18n; images; progs; cache; applets;
         misc; internal ]
@

% ??? -> <>
<<function [[Mmmprefs.f]]>>=
let f preffile = 
  Prefs.define preffile families mute
@


%-------------------------------------------------------------

<<gui/mmmprefs.ml>>=
open I18n

open Tk
open Prefs

(* MMM Preferences *)

<<function [[Mmmprefs.font_pref]]>>


<<constant [[Mmmprefs.image_loading]]>>


(*
 * Choose from available DTDs for HTML parsing 
 *)
let dtd_i v =
  Textvariable.set v (Dtd.name !Dtd.current)
and dtd_s v =
  Dtd.current := 
    try
      Dtd.get (Textvariable.get v)
    with
      Not_found -> Dtd.dtd32
and dtd_p = Dtd.names()


<<function [[Mmmprefs.network]]>>

<<function [[Mmmprefs.internal]]>>

<<function [[Mmmprefs.html]]>>

<<function [[Mmmprefs.i18n]]>>

<<function [[Mmmprefs.images]]>>
    

<<function [[Mmmprefs.cache]]>>

<<function [[Mmmprefs.progs]]>>

<<function [[Mmmprefs.misc]]>>

<<constant [[Mmmprefs.appsys_plug]]>>

<<function [[Mmmprefs.plug_applets]]>>

<<function [[Mmmprefs.applets]]>>


<<constant [[Mmmprefs.home]]>>
<<function [[Mmmprefs.reset_home]]>>


<<constant [[Mmmprefs.mute]]>>

<<constant [[Mmmprefs.families]]>>

<<function [[Mmmprefs.f]]>>
@


\subsection*{[[gui/mmm.mli]]}


%-------------------------------------------------------------

<<gui/mmm.mli>>=
<<signature [[Mmm.user_file]]>>

<<signature [[Mmm.initial_navigator]]>>
<<signature [[Mmm.main_navigator]]>>

<<signature [[Mmm.helpurl]]>>
<<signature [[Mmm.initial_geom]]>>

<<signature [[Mmm.add_user_menu]]>>
<<signature [[Mmm.navigator]]>>
<<signature [[Mmm.new_window_initial]]>>
<<signature [[Mmm.new_window_sel]]>>
<<signature [[Mmm.change_tachy]]>>
@


\subsection*{[[gui/mmm.ml]]}

%<<constant Mmm.client_navigator>>=
%let client_navigator = navigator false
%@
% ???

%-------------------------------------------------------------

<<gui/mmm.ml>>=
open Common
open I18n

open Tk
open History
open Document
open Nav
open Www

(* The navigation window *)

<<constant [[Mmm.hotlist]]>>
<<constant [[Mmm.helpurl]]>>
<<constant [[Mmm.initial_page]]>>
<<constant [[Mmm.initial_geom]]>>

<<constant [[Mmm.home]]>>
      

<<function [[Mmm.user_file]]>>

<<constant [[Mmm.preferences]]>>

<<constant [[Mmm.container_frame]]>>
<<constant [[Mmm.tachy_maker]]>>

<<function [[Mmm.change_tachy]]>>

<<function [[Mmm.start_tachy]]>>

(* Switching current viewers in the browser *)
<<function [[Mmm.undisplay]]>>
<<function [[Mmm.display]]>>

<<function [[Mmm.quit]]>>

<<constant [[Mmm.user_menus]]>>
<<function [[Mmm.add_user_menu]]>>

<<constant [[Mmm.navigators]]>>

<<function [[Mmm.navigator]]>>


<<function [[Mmm.new_window_initial]]>>

<<function [[Mmm.new_window_set]]>>


<<constant [[Mmm.main_navigator]]>>

<<function [[Mmm.initial_navigator]]>>
@


\subsection*{[[gui/cci.ml]]}

<<function [[Cci.handler]]>>=
(* CCI was cool, but nobody implements it anymore. More over,
 * it's trivial to fork mmm_remote and let the protocol be managed
 * by it *)

let handler fd line =
  let len = String.length line in 
  if len > 4 && String.sub line 0 4 = "GET " then begin
    let url = String.sub line 4 (len - 4) in
    match !Mmm.main_navigator with
      None -> 
    Munix.write_string fd "No main navigator\n";
    close fd
    | Some nav ->
    Nav.save_link nav (Some (fd, true))
      {h_uri = url; h_context = None; h_method = GET; h_params = []}
  end else if len > 5 && String.sub line 0 5 = "GETB " then begin
    let url = String.sub line 5 (len - 5) in
    match !Mmm.main_navigator with
      None ->
    Munix.write_string fd "No main navigator\n";
    close fd
    | Some nav ->
    Nav.save_link nav (Some (fd, false))
      {h_uri = url; h_context = None; h_method = GET; h_params = []}
  end else if len > 5 && String.sub line 0 5 = "HEAD " then begin
    let url = String.sub line 5 (len - 5) in
    match !Mmm.main_navigator with
      None ->
    Munix.write_string fd "No main navigator\n";
    close fd
    | Some nav ->
    Nav.save_link nav (Some (fd, true))
      {h_uri = url; h_context = None; h_method = HEAD; h_params = []}
  end else if len > 8 && String.sub line 0 8 = "DISPLAY " then begin
    let url = String.sub line 8 (len - 8) in
    close fd;
    ignore (Mmm.navigator false (Lexurl.make url))
  end else begin (* assume DISPLAY (backward compatibility) *)
    close fd;
    ignore (Mmm.navigator false (Lexurl.make line))
  end
@

<<function [[Cci.init]]>>=
(* External requests *)
let init () =
 let file = Mmm.user_file "remote" in
 try
  let socket = socket PF_UNIX SOCK_STREAM 0 in
    begin try bind socket (ADDR_UNIX file) 
    with
      _ -> 
    if not (Sys.file_exists file) then raise Not_found;
    begin match 
      Frx_dialog.f Widget.default_toplevel 
        (Mstring.gensym "confirm")
        (s_ "Confirm")
        (s_ "%s already exists. This may mean that there is another MMM already running. Do you want to remove this file and create again ? (Note that you must be sure there is no other MMM with -external option)" file)
        (Predefined "question") 0
        [ s_ "Yes"; 
          s_ "No, I give up to use -external option"] 
    with
      0 -> 
        Unix.unlink file;  
        bind socket (ADDR_UNIX file) 
    | _ -> raise Exit
    end
    end;
    
    listen socket 5;
    Fileevent.add_fileinput socket
       (fun () -> 
      try 
          let fd,_ = accept socket in
       handler fd (Munix.read_line fd)
      with _ -> ());
    at_exit (fun () -> Msys.rm file)
 with e ->
   Error.f (s_ "Can't initialize %s\n%s" file (Printexc.to_string e))
@


%-------------------------------------------------------------

<<gui/cci.ml>>=
open I18n
open Tk
open Unix
open Hyper

<<function [[Cci.handler]]>>

<<function [[Cci.init]]>>

@


\section{[[]]}

\subsection*{[[main.ml]]}


%-------------------------------------------------------------

<<main.ml>>=
open Common

(*****************************************************************************)
(* Purpose *)
(*****************************************************************************)

(*****************************************************************************)
(* Flags *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Main.safe_loop]]>>
       
<<function [[Main.localize]]>>

(*****************************************************************************)
(* The options *)
(*****************************************************************************)

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

<<constant [[Main.usage_str]]>>

<<function [[Main.main]]>>
      
<<function [[Main.postmortem]]>>

<<toplevel [[Main._1]]>>
@


\subsection*{[[main_remote.ml]]}


%-------------------------------------------------------------

<<main_remote.ml>>=
(* Talk to an mmm master *)
open Unix

<<function [[Main_remote.request]]>>
    
<<function [[Main_remote.main]]>>

<<toplevel [[Main_remote._1]]>>
@


\section{[[extensions/]]}

\subsection*{[[extensions/audio.ml]]}


%-------------------------------------------------------------

<<extensions/audio.ml>>=
open Safe418mmm
open Tk
open Hyper
open Viewers
open Document

module Provide = struct
  let capabilities = Capabilities.get()
  end
module Mmm = Get(Provide)


<<function [[Audio.fake_embed]]>>
<<toplevel [[Audio._1]]>>
@


\subsection*{[[extensions/images.ml]]}

<<function [[Images.images]]>>=
let images lexbuf =
  let uris = ref [] in
  try
    let lexer = ParseHTML.sgml_lexer Dtd.dtd32 in
    while true do
      try 
        let _,_,tokens,loc = lexer lexbuf in
      List.iter (function
         OpenTag {tag_name = "img"; attributes = attrs} ->
           begin try
        uris := List.assoc "src" attrs :: !uris
           with Not_found -> ()
           end
       | EOF -> raise End_of_file
       | _ -> ())
          tokens
      with
        Html_Lexing _ -> ()
      | Invalid_Html _ -> ()
    done;
    !uris
  with
    End_of_file -> List.rev !uris
@

<<function [[Images.show_images]]>>=
(* Pops up a dialog box with the list of image URLs *)
let show_images ctx l =
  let w = Applets.get_toplevel_widget [] 
  and base = Url.string_of (ctx#base.document_url)
  in
  Wm.withdraw w;
  Frx_req.open_list "Display Images" l
    (fun uri -> 
      let link = 
    {h_uri = uri; h_context = Some base; h_method = GET; h_params = []} in
        ctx#goto link)
    (fun _ -> destroy w)
@

<<function [[Images.f]]>>=
(* When the menu item is activated, this function is called :
   we're interested mostly in the URL of the currently displayed document,
   but the ctx will be used later so we can trigger new navigation functions
   on the URLs of the in-lined images.
   What we do is request a copy of this document, on which we run an HTML
   lexer.
 *)
let f ctx =
  let cont = {
    document_process = (fun dh ->
      let lexbuf = Lexing.from_function
                   (fun buf n -> dh.document_feed.feed_read buf 0 n) in
      let l = images lexbuf in
        dclose true dh;
        show_images ctx l);
    document_finish = (fun _ -> ())
    } in
  let link = Hyper.default_link (Url.string_of ctx#base.document_url) in
  Net.retrieve link cont
@

<<toplevel [[Images._1]]>>=
let _ = Mmm.add_user_menu "In-lined images" f
@

<<toplevel [[Images._2]]>>=
let _ = Applets.register "main"
    (fun f ctx ->
      pack [Label.create f [Text "Menu User/images installed"]][])
@


%-------------------------------------------------------------

<<extensions/images.ml>>=
open Safe418mmm

(* This module demonstrates
    - how to add an user menu
    - how to call the HTML lexer
*)

module Provide = struct
  let capabilities = Capabilities.get()
  end

module Net = Retrieval(Provide)
module Mmm = Get(Provide)

open Tk
open Net
open Html
open Document
open Feed
open Hyper
open Viewers

<<function [[Images.images]]>>

<<function [[Images.show_images]]>>

<<function [[Images.f]]>>

<<toplevel [[Images._1]]>>


<<toplevel [[Images._2]]>>
@


\subsection*{[[extensions/remove_simple_table.ml]]}

<<function [[Remove_simple_table.log]]>>=
let log s = try prerr_endline s with _ -> () 
@

<<type [[Remove_simple_table.table_token]]>>=
type table_token =
    ChildTable of Html.token list
  | Token of Html.token 
@

<<type [[Remove_simple_table.rst_env]]>>=
type rst_env = {
    mutable tokens : table_token list;
    mutable trs : int;
    mutable tds : int 
  } 
@

<<function [[Remove_simple_table.remove_simple_table]]>>=
let remove_simple_table parentf = 
  let stack = ref [] in

  let push_tbl tbl = stack := tbl :: !stack in
  let pop_tbl () =
   match !stack with
   | t :: tl -> stack := tl; t
   | _ -> assert false in
  let head_stack () = List.hd !stack in
  let empty_stack () = !stack = [] in

  let flush_childtable tkns =
    if empty_stack () then List.iter parentf tkns
    else begin
      let top = head_stack () in
      top.tokens <- top.tokens @ [ChildTable tkns]
    end
  in

  fun tkn -> match tkn with
    EOF ->
      while not (empty_stack ()) do
    log "EOFflush";
    let tbl = pop_tbl () in
    flush_childtable 
      (List.fold_right (fun xtkn st ->
        match xtkn with 
          Token tkn -> tkn :: st
        | ChildTable tkns -> tkns @ st) tbl.tokens [])
      done;
      parentf EOF
  | OpenTag {tag_name = "table"} ->
      log "ENTER";
      let tbl = {tokens= [Token tkn]; trs= 0; tds= 0} in
      push_tbl tbl;
  | CloseTag "table" when not (empty_stack ()) -> 
      let tbl = pop_tbl () in
      log "REMOVE";
      let tokens = 
    if tbl.trs <= 1 && tbl.tds <= 1 then begin
      log "ERASE";
      let tokens = 
       (* remove table, tr, td *)
       List.fold_right (fun xtkn st ->
          match xtkn with
        Token tkn -> begin
          match tkn with
            OpenTag {tag_name= "table"}
          | OpenTag {tag_name= "tr"}
          | OpenTag {tag_name= "td"}
          | CloseTag "table"
          | CloseTag "tr"
          | CloseTag "td" -> st
          | _ -> tkn :: st
        end
          |	ChildTable tkns ->
          tkns @ st) tbl.tokens []
      in
      [OpenTag {tag_name="br"; attributes=[]};
        CloseTag "br"; 
        PCData "[[" ] @ tokens @
      [ PCData "]]";
        OpenTag {tag_name="br"; attributes=[]}; 
        CloseTag "br" ]
    end else begin
      tbl.tokens <- tbl.tokens @ [Token tkn];
      List.fold_right (fun xtkn st ->
        match xtkn with
          Token tkn -> tkn :: st
        | ChildTable tkns -> tkns @ st) tbl.tokens []
    end
      in
      flush_childtable tokens
  | _ when not (empty_stack ()) -> 
      let tbl = head_stack () in
      begin
    match tkn with
      OpenTag {tag_name = "td"} ->
        tbl.tds <- tbl.tds + 1
    | OpenTag {tag_name = "tr"} -> 
        tbl.trs <- tbl.trs + 1
    | _ -> ()
      end;
      tbl.tokens <- tbl.tokens @ [Token tkn]
  | _ ->  (* !stack = [] *)
      parentf tkn
@

<<toplevel [[Remove_simple_table._1]]>>=
let _ =
  Mmm.add_html_filter remove_simple_table
@


%-------------------------------------------------------------

<<extensions/remove_simple_table.ml>>=
open Safe418mmm

<<function [[Remove_simple_table.log]]>>

(* an example of html filter *)

(* This example removes the tables with atmost one <TD> (<TR> also) tag. *)
(* This reduces the widgets creations... *)
  
module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)

open Html

<<type [[Remove_simple_table.table_token]]>>

<<type [[Remove_simple_table.rst_env]]>>

<<function [[Remove_simple_table.remove_simple_table]]>>

<<toplevel [[Remove_simple_table._1]]>>
@


\subsection*{[[extensions/tachy_aftermmm.ml]]}

<<constant [[Tachy_aftermmm.tachy_data]]>>=
(* inside bitmap, circle is in +10+6 +47+43, radius 18.5 *)

let tachy_data = "GIF\056\055a\058\000\060\000\165\000\000\168\168\168\
\168\152\176\152\152\168\152\152\152\152\136\160\136\152\152\136\
\136\152\128\136\128\128t\152\144\172\200\136\152\184\144\132\
\168\128\132\152\136\136\136\000\000\000\248\252\248\216\216\216\
\040\040\040p\136\136\184\184\184\200\200\200XXX\128\
txht\152pt\136\040\044\040ptphd\
\144\232\232\232\096d\136\224pp\240xx\096dp\
\096\096h\096TpPdpHXxXTX\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\044\000\000\
\000\000\058\000\060\000\000\006\254\064\128\016\016\032\026\139\
\001\001R\201\020\052\007\004\168\148P\160Z\013W\002\
\214\096\056p\187\136\195\016\144\024\011\145\000\005\064\176\
n\179\005\010\167\160\048\159\091\011\139\042\190\096\224\243\
\191\006\012\129\006gCh\135JDJ\003I\002\003\
\142\142QVPzY\091\093\152\007aae\134G\
FjEjr\002\013\166\167\014\015\003\003\166\016\149\
\123\095\127\092\017\180\180\018\008\135G\137I\188N\172\
\167\192\013\169\171\196\019\020\174Z\092\201\094\179\155\018\
\016bf\159\163n\193\214\195\196\003c\016\125\221\128\
\018\017\130\183\220\185\136\189\214\193\019c\196\210\016\220\
\153\096\017\155\007\016\018\159h\161m\021\214\171\210\254\
\237\128\004\025\136pk\028\046\093Kx\057\216\215\224\
\215\191\135f\038L\128\006F\211\051w\238\236\009\201\
G\141\205\062\134\013\033\138\148\056\193A\061\003\018P\
\034\040\184\242\160\057\038\251\022\134\020\057\178d\003w\
\154r\174\180\032\129\231\254\180\053N\000\124\020V\129\
\166Q\000\013\000H\172\215\146\165\132\011\188\020\245\026\
j\234\232Q\137\020\142\021\228\185\019\003\040\055k\128\
i\179j\212XV\008MW\094\144\128\033a\147\096\
d\173f\061\203\179\046\006\011\094G\005u\034\054\174\
\220\179\005\215b\192\000\149I\163\095\167\252Z\053\155\
\017\239\096\188\096\229\000\051\154\161B\006\162E\043g\
\016\057\023\130\096\182l\123AB\156\148f\209\152B\
\133V\230\124\204\029\094\199\026\246J\062\053\022b\131\
\213\183\047\035\205\160\014\226D\140\131\217\014\062\012i\
\178\233\210\167\027TX\094T\036F\008\176\055x\037\
\053\199\184\200\125B\150\011e\222\220\057\004\014\194\007\
c\024\029\201\186b\185\192\053\096P\031\091\014\029\005\
\180\207\251\061\037\030C\007\012Q\034Aq\192\191\182\
\252\163\252\057\032\221\006\026\016\232\004\029\008\146T\026\
Y\020\040F\210\096\234\221\167\159\021\166\248\247\159Q\
\030d\184\030\129\004\254\190gG\001\236\092hU\134\
\030\220w\095\129\146T\146\141\136F\125\144\225\007\028\
\022\168\001\130w\172\200\162H\030\124\160\035\123\004\226\
\247J\020\033\222\248\208\139\048\202\216\225\029\147\244\035\
\228\063\057\234\184\161\145Hb\001\162\133K\142A\164\
\145\026h\000\130\030yP\177\128\146U\154\049\064\147\
E\174\215\001\138\063bAe\152\058\234\024c\150Y\
\190\146\007\023aJ\211\230\142\049\018\216\129\022\124\126\
\161E\131u\010q\167\140Zn\000\130\150\092\250\209\
\013\004CH\180\036\153\031\152\169\193\153g\130\096\201\
\050\006\048\042\145r\055\054\064\036\129Z\194y\232\150\
s\002\002\008\004\019\008\195\168\136\015\056\224b\145\049\
V\010\130\165\126r\161\147\038\020\152D\146\124\020p\
\224\171\171\160\142\170\229\172\179\202\194\135\064\040\037\139\
\042I\128\198\229\235\003\190B\160\231\164\212\018\171\037\
\001\007\044\019FE\059\045kV\179\052\245\234\235\184\
\193\134\042\236\172\254\033\152\250EJ\226\180\004\193\092\
\240be\198\092\227\214\203\193\180\211\018\171\239\023\183\
\058\211\020\094\238\192\219\171\059\037\061\128\145\189\028\064\
\064\232\185\250\130\016\130\008\233\014\034N\178N\053u\
\193\187\024cT\176\059\245\026\028\043\181\178\018\059\002\
\008\035W\196mO\091\161\252\218\093\024\060\183q\189\
\160\194i\238\176\163\058\012\177\195\223\012Rq\096\225\
\133\055\152\137O\230\009\050\008\033\207\058\178\209\034\204\
\227\239V\044\059\198\242\134\016\010\045\244\204\013\219\252\
\240\213\019\167\228\212Zj\129\134\129\207\246\133\045c\
\208\213\154\171\239\200h\147\012\194\201\092\245t\151\219\
\043\175\039\055\150o\202\204\176\190W\091\045\194\008\005\
\169\180\179\096\245\213\007\052\221\050RJ\052\205F\139\
\188\055\201I\091\244o\211\226E\135\129\212\132\046l\
\054\222\016g\254\240\008\123km\049h\128\127\029\054\
\132b\247\136e\165\151\039\158\054\218\123\039\141rW\
\043\199\061\054j\225\049\139\154\058\186\154g\206\249\230\
\059w\029\184\224\165\019\046k\209j\035\205\058\231\035\
\144\240x\220\245\209\142e\161YZ\091\245\213\173o\
\222\250\008\033\148\192\179\232\096\015\062\183\233\031\223\173\
\058\227\199\239MB\242\176C\030\029\143\132\203L\181\
\195\196RO\061\242\123g\159\253S\219\255N\250\137\
\148\135\140\184\218\229\163\095\242\146W\002\018\004\001\000\
\059\
"
@

<<constant [[Tachy_aftermmm.park_data]]>>=
let park_data =
"#define break_width 15
#define break_height 11
static char break_bits[] = {
   0x0c, 0x18, 0xf4, 0x17, 0x3a, 0x2e, 0xba, 0x2d, 0xb9, 0x4d, 0x3d, 0x5e,
   0xb9, 0x4f, 0xba, 0x2f, 0xba, 0x2f, 0xf4, 0x17, 0x08, 0x08};
"
@

<<constant [[Tachy_aftermmm.pi]]>>=
let pi = 3.1415926 
@

<<constant [[Tachy_aftermmm.log10]]>>=
let log10 = log 10.0 
@

<<function [[Tachy_aftermmm.create_tachy]]>>=
let create_tachy top = 
  let o = new default_tachy top in
  o#start;
@

<<toplevel [[Tachy_aftermmm._1]]>>=
let _ = 
  let top = Applets.get_toplevel_widget [] in
  Wm.withdraw top;
  begin match Frx_dialog.f top (Mstring.gensym "foo")
        "Tachy test" "Use this aftermmm tachymeter"
    (Tk.Predefined "question") 1 ["Yes"; "No"] with
    0 -> Mmm.set_tachy create_tachy
  | _ -> ()
  end;
  destroy top
@


%-------------------------------------------------------------

<<extensions/tachy_aftermmm.ml>>=
open Safe418mmm
open Tk

module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)

(* Tachymeter *)

(* gif is 58x60 *)
<<constant [[Tachy_aftermmm.tachy_data]]>>

<<constant [[Tachy_aftermmm.park_data]]>>


<<constant [[Tachy_aftermmm.pi]]>>
<<constant [[Tachy_aftermmm.log10]]>>

class default_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable canvas = top (* dummy initialisation *)
  val mutable alive = false

  (* Various components of the canvas, all with dummy init values *)
  val mutable i_park = Tag "none"
  val mutable kilos = Tag "none"
  val mutable aig = Tag "none"
  val mutable pendings = Tag "none"


  (* this one is private *)
  method start =
    let c =
      Canvas.create_named top "tachymeter"
       [Width (Pixels 56); Height (Pixels 60); 
         BorderWidth (Pixels 0);
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *)] in
    (* Use colors so that images are not transparent *)  
    (*
    let tachy_image = 
      begin
       try
      let bgc = Tk.cget c CBackground in
      Protocol.tkEval 
        [|Protocol.TkToken "set";
          Protocol.TkToken "TRANSPARENT_GIF_COLOR";
          Protocol.TkToken bgc |]; () 
       with _ -> ()
      end;
      *)
    let tachy_image = Frx_misc.create_photo [Data tachy_data]
    and park_image =
      Imagebitmap.create [Data park_data; Foreground Red] in

    i_park <-
      Canvas.create_rectangle c 
     (Pixels 50) (Pixels 4) 
     (Pixels 53) (Pixels 7) [FillColor Black];
    
    kilos <-
      Canvas.create_text c (Pixels 28) (Pixels 52) [Text "0"; Font "-adobe-helvetica-medium-r-*-*-8-*-*-*-*-*-*-*"];
    
    aig <-
      Canvas.create_line c [Pixels 27; Pixels 25; Pixels 27; Pixels 43]
                       [Width (Pixels 2)];
    pendings <-
      Canvas.create_text c (Pixels 52) (Pixels 39) [Text "0"; Font "-adobe-helvetica-medium-r-*-*-8-*-*-*-*-*-*-*"];

    let i_tachy =
      Canvas.create_image c (Pixels 56) (Pixels 0)
       [ImagePhoto tachy_image; Anchor NE]

    in

    Canvas.lower_bot c pendings;

    (* All other items must be put above the background image *)
    List.iter (fun i -> Canvas.raise_above c i i_tachy)
      [kilos; aig; i_park];

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));

    (* These bindings are specific to the applet version *)
    bind c [[], ButtonPressDetail 1] 
      (BindSet ([], (fun _ -> Mmm.new_window_initial (); ())));
    bind c [[], ButtonPressDetail 2] 
      (BindSet ([], (fun _ -> Mmm.new_window_sel (); ())));

    alive <- true;
    pack [c][];
    canvas <- c

  val mutable last_speed = 0.
  val mutable last_total = 0
  val mutable idle = false

  method update speed total =
    if speed = 0.0 then begin
      if not idle then begin
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black];
    idle <- true
      end
    end
    else begin
      Canvas.configure_rectangle canvas i_park [FillColor Green;
                         Outline Green];
      idle <- false
    end;
    if total <> last_total then
      Canvas.configure_text canvas kilos [Text (string_of_int total)];
    last_total <- total;
    let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
    let speeds = (last_speed +. speed) /. 2. in
    if abs_float (speeds -. last_speed) > 0.1 then begin
      last_speed <- speeds;
      let v = speeds /. log10 in
      let angle = v /. 4.0 *. pi in
      let angle = if angle < 0.1 then 0.0 else angle in
      let x = 27.0 -. (sin angle *. 18.5)
      and y = 25.0 +. (cos angle *. 18.5) in
      Canvas.coords_set canvas aig 
    [Pixels 27; Pixels 25;
      Pixels (truncate x); Pixels (truncate y)];
      update_idletasks()
    end

  method report_cnx n = 
    if Winfo.exists canvas then
      if n = 0 then begin
    Canvas.configure_text canvas pendings [Text ""];
       Canvas.lower_bot canvas pendings
      end
      else begin
    Canvas.configure_text canvas pendings 
      [Text (string_of_int n)];
       Canvas.raise_top canvas pendings
      end

  method report_busy busy =
    if Winfo.exists canvas then
      if busy then begin
       Canvas.lower_bot canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Red;
                          Outline Red];
    update_idletasks()
      end
      else begin
       Canvas.raise_top canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy canvas

end

<<function [[Tachy_aftermmm.create_tachy]]>>
  (o :> Mmm.tachymeter)

<<toplevel [[Tachy_aftermmm._1]]>>

@


\subsection*{[[extensions/tachy_space.ml]]}

<<constant [[Tachy_space.mpoly_data]]>>=
(* Tachymeter *)

let mpoly_data = 
[5.684359, -36.000000;
14.760086, -36.000000;
19.000000, -20.736308;
23.239914, -36.000000;
31.760086, -36.000000;
36.000000, -20.736308;
40.239914, -36.000000;
46.315641, -36.000000;
37.760086, -5.200000;
30.239914, -5.200000;
26.000000, -20.463692;
21.760086, -5.200000;
14.239914, -5.200000]
@

<<type [[Tachy_space.vector]]>>=
type vector = float * float * float
@

<<type [[Tachy_space.matrix]]>>=
type matrix = vector * vector * vector
@

<<function [[Tachy_space.matrix_vector]]>>=
let matrix_vector ((a11,a21,a31), (a12,a22,a32), (a13,a23,a33)) (x,y,z) =
  (a11*.x+.a12*.y+.a13*.z, a21*.x+.a22*.y+.a23*.z, a31*.x+.a32*.y+.a33*.z)
@

<<constant [[Tachy_space.pi]]>>=
let pi = 3.1415926 
@

<<constant [[Tachy_space.log10]]>>=
let log10 = log 10.0 
@

<<type [[Tachy_space.ball]]>>=
type ball = {
  tag : Tk.tagOrId;
  mutable x : float;
  mutable y : float;
  mutable z : float
 }
@

<<function [[Tachy_space.create_tachy]]>>=
let create_tachy top = 
  let o = new space_tachy top in
  o#start;
@

<<toplevel [[Tachy_space._1]]>>=
let _ = 
  let top = Applets.get_toplevel_widget [] in
  Wm.withdraw top;
  begin match Frx_dialog.f top (Mstring.gensym "foo")
        "Tachy test" "Use the space tachymeter"
    (Tk.Predefined "question") 1 ["Yes"; "No"] with
    0 -> Mmm.set_tachy create_tachy
  | _ -> ()
  end;
  destroy top
@


%-------------------------------------------------------------

<<extensions/tachy_space.ml>>=
open Safe418mmm
open Tk


module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)


<<constant [[Tachy_space.mpoly_data]]>>

<<type [[Tachy_space.vector]]>>
<<type [[Tachy_space.matrix]]>>

let x_rotation a = let c = cos a and s = sin a in
    ((1.0,0.0,0.0), (0.0,c,s), (0.0,-.s,c))
and y_rotation a = let c = cos a and s = sin a in
    ((c,0.0,-.s), (0.0,1.0,0.0), (s,0.0,c))

<<function [[Tachy_space.matrix_vector]]>>

<<constant [[Tachy_space.pi]]>>
<<constant [[Tachy_space.log10]]>>

<<type [[Tachy_space.ball]]>>

class space_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable fr = top (* dummy initialisation *)
  val mutable c = top (* dummy initialisation *)
  val mutable c2 = top (* dummy initialisation *)
  val mutable mpoly = Tag "none" (* dummy initialisation *)
  val mutable i_park = Tag "none" (* dummy initialisation *)
  val mutable kilos = Tag "none" (* dummy initialisation *)
  val mutable pendings = Tag "none" (* dummy initialisation *)
  val mutable alive = false

  val mutable balls = Array.create 32 {tag = Tag "none"; x = 0.; y = 0.; z = 0.}
  val spacewidth = 4.0

  (* this one is private *)
  method start =
    fr <- Frame.create_named top "tachymeter" [BorderWidth (Pixels 2)];
    c <- Canvas.create fr
       [ Width (Pixels 72); Height (Pixels 72); 
         BorderWidth (Pixels 1);
      Relief Sunken;
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *);
      Background Black];
    c2 <- Canvas.create fr [Width (Pixels 72); Height (Pixels 16)];
    pack [c; c2] [Side Side_Top; Fill Fill_X];

    i_park <- 
       Canvas.create_rectangle c2 
      (Pixels 1) (Pixels 1) 
      (Pixels 4) (Pixels 4) [FillColor Black];

    kilos <-
       Canvas.create_text c2
        (Pixels 36) (Pixels 8)
     [Text "0"; Font "variable"];

    pendings <-
       Canvas.create_text c2
        (Pixels 68) (Pixels 8)
     [Text "0"; Font "variable"];

    balls <-
       Array.map (fun _ -> 
     { tag = Canvas.create_line c [Pixels 100; Pixels 100; 
                                  Pixels 100; Pixels 100] 
                                  [FillColor (NamedColor "White")];
       x = Random.float spacewidth -. (spacewidth /. 2.0);
       y = Random.float spacewidth -. (spacewidth /. 2.0);
       z = Random.float 0.9 +. 0.1 }) balls;

    mpoly <- Canvas.create_polygon c (List.fold_right (fun (x,y) s ->  
      let x = truncate ((x -. 26.0) *. 1.3) + 36
      and y = 36 - truncate ((20.6 +. y) *. 1.3) 
      in [Pixels x; Pixels y] @ s) 
                       mpoly_data [])
       [Width (Pixels 2); FillColor Green; Outline White];

    for i = 0 to Array.length balls - 1 do
      self#ball_update balls.(i) 0.0
    done;
    
    Canvas.lower_bot c2 pendings;

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));
    (* These bindings are specific to the applet version *)
    bind c [[], ButtonPressDetail 1] 
      (BindSet ([], (fun _ -> Mmm.new_window_initial (); ())));
    bind c [[], ButtonPressDetail 2] 
      (BindSet ([], (fun _ -> Mmm.new_window_sel (); ())));

    alive <- true;
    pack [fr][]
    
  val mutable mx = 0.
  val mutable my = 0.
  val mutable last_speed = 0.
  val mutable last_speed2 = 0.
  val mutable last_total = 0
  val mutable idle = false

  method ball_update ball speed =
    let x = truncate (ball.x *. (0.2 /. ball.z) *. 32.0) + 36
    and y = truncate (ball.y *. (0.2 /. ball.z) *. 32.0) + 36
    and x' = truncate (ball.x *. (0.2 /. (ball.z +. speed)) *. 32.0) + 36
    and y' = truncate (ball.y *. (0.2 /. (ball.z +. speed)) *. 32.0) + 36
    in
    let x', y' = if (x,y) = (x',y') then x', y'+1 else x', y' in 
    Canvas.coords_set c ball.tag
      [Pixels x; Pixels y; Pixels x'; Pixels y'];
    let x =
      Printf.sprintf "%02X" (truncate ((1.0 -. ball.z) /. (1.0 -. 0.1) *. 255.0)) in
    Canvas.configure_line c ball.tag [FillColor (NamedColor ("#"^x^x^x))]

    
  method update speed total =
     Canvas.coords_set c mpoly 
       (List.fold_right (fun (x,y) s ->  
     let x = (x -. 26.0) *. 1.3
     and y = (20.6 +. y) *. 1.3
         in
     let (x,y,z) = matrix_vector (x_rotation mx) (matrix_vector (y_rotation my) (x,y,0.0)) in
       let r = (z +. 200.0) /. 200.0 in
       let x = truncate ( x *. r ) + 36
       and y = - truncate ( y *. r ) + 36
         in [Pixels x; Pixels y] @ s) mpoly_data []) ;
        mx <- mx +. 0.01;
        my <- my +. 0.02;
      if speed = 0.0 then begin
    if not idle then begin
      Canvas.configure_rectangle c2 i_park [FillColor Black;
                           Outline Black];
      idle <- true
    end
       end
      else begin
    Canvas.configure_rectangle c2 i_park [FillColor Green;
                         Outline Green];
        idle <- false
      end;
       if total <> last_total then
          Canvas.configure_text c2 kilos 
        [Text (if total > 1000000 then 
                 Printf.sprintf "%d.%02dM" (total/1000000)
                                         ((total mod 1000000)/10000)
               else if total > 1000 then
             Printf.sprintf "%d.%01dK" (total/1000)
                                             ((total mod 1000)/100)
           else string_of_int total)];
       last_total <- total;
       let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
       last_speed2 <-
      if last_speed2 > speed *. 0.8 +. last_speed2 *. 0.2
      then last_speed2 -. 0.1
      else speed;
       let speeds = 
     if last_speed2 -. last_speed > 0.2 then last_speed +. 0.2
     else if last_speed2 -. last_speed < (-0.1) then last_speed -. 0.1
     else last_speed
       in   
       (* let speeds = last_speed *. 0.5 +. speed *. 0.5 in *)
       if abs_float (speeds -. last_speed) > 0.05 then begin
         last_speed <- speeds;
     let v = speeds /. log10 *. 0.02 in

     for i = 0 to Array.length balls - 1 do
       balls.(i).z <- balls.(i).z -. v;
       if( balls.(i).z < 0.1 ) then begin
         balls.(i).z <- 1.0;
         balls.(i).x <- Random.float spacewidth -. (spacewidth /. 2.0);
         balls.(i).y <- Random.float spacewidth -. (spacewidth /. 2.0)
       end;
       self#ball_update balls.(i) v;
     done;
         update_idletasks()
        end


  method report_cnx n = 
    if Winfo.exists c2 then
      if n = 0 then begin
    Canvas.configure_text c2 pendings [Text ""];
       Canvas.lower_bot c2 pendings
      end
      else begin
    Canvas.configure_text c2 pendings 
      [Text (string_of_int n)];
       Canvas.raise_top c2 pendings
      end

  method report_busy busy =
    if Winfo.exists c2 then
      if busy then begin
       Canvas.lower_bot c2 pendings;
    Canvas.configure_rectangle c2 i_park [FillColor Red;
                          Outline Red];
    update_idletasks()
      end
      else begin
       Canvas.raise_top c2 pendings;
    Canvas.configure_rectangle c2 i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy fr

end

<<function [[Tachy_space.create_tachy]]>>
  (o :> Mmm.tachymeter)

<<toplevel [[Tachy_space._1]]>>

@


\subsection*{[[extensions/tachy_test.ml]]}

<<constant [[Tachy_test.tachy_data]]>>=
(* inside bitmap, circle is in +16+7 +66+57, radius 25 *)

let tachy_data = "GIF\056\057aP\000A\000\227\000\000\000\000\000\
\044\044\044\060\000\000YYY\138\138\138\154\154\154\170\
\170\170\186\186\186\203\203\203\219\219\219\231qq\235\235\
\235\243yy\255\255\255\000\000\000\000\000\000\033\249\004\
\001\000\000\009\000\044\000\000\000\000P\000A\000\000\004\
\255\048\201I\171\189\024H\157\056\199\096\040\142\164\213\
Hg\146\166e\235\190p\060\013\052\045\223DN\000\
M\225\223\148\001\133\005\020\233\142\187\158oY\184\009\
\039\196\162\005I\229\049\153\006\131E\032z\162\164\023\
\042\178\144\188\250\178\232J\180\226U\021\063\146\129\248\
\136\174c\235\233\009\220\212\232\175a\041\052sx\132\
\133\133P\096\033p\130H\134\142\143\006\007z\137\032\
\129rt\144\153x\007\156\136\148\147\051\151\058\154\164\
Y\156\156\004\160\159n\009\003\000\152\165\164\167I\158\
\171\173r\175\004\177\187\007I\157\018\092\171\140\059\187\
\197\060\167\146\095\148\195\186\197\197\200\008\008\182\173\176\
\206\188\007\209\210\194\213\214\187\217\209\171\141\221\206\223\
\218\137\226\227\228\223\148\220\233\222\217\231\237\238\165\229\
\096\242\143\001\001\003\001\006\174\053\006\249\000\210\131\039\
\229\158\035\125\253\250\001\232\055\064\033\141\129\230\054\196\
\064G\010\192\190\044\251\030fA\056\240\194\031\035\163\
\255b\185J\008\208\031\198\128\177\216\133\044\165\049\203\
\194\135\015\045\166\180\176\167\132AC\045\255\213\216\185\
\203\227\011\138\243\172\197\203\017t\030\205\018\031n\022\
\037u\164\150\136\020J\151f\002\064\181f\139\170\011\
\221\037\152\231\039\133\213\011\031\186J\029\167\160\172\002\
\167\033\160\046\025\219\205\236Y\025w\216\022s\043\241\
\197\021\185\187\220\190e\229\034\046\094Mt\129\248\253\
\011\041p\135\024\131\009\059\050\204\183\197\093\197\143\220\
\050\144\178\022r\228\178\147\041\023\176\092X\001\131\204\
E\054s\094\236\249s\162\209\139\063\131\150\130\186P\
i\211\148Z\215y\189\026\140l\052\170a\127\186M\
\123Z\029N\144\049\171\158\182\053R\175\172x\001\044\
\016N\092\002\170cx\023\044P\094\182\249\004\095\192\
\199J\151\174\220\250\016d\217\231m\031\239\253\176s\
\240\008\196\143\151\190\225k\034\022\208\178u\091\191\125\
\210G\091\156\202\201\039E\159\252\144\251\211\232\183N\
\045qxH\208\095\125\229\149\032\096\005\180Lp\096\
\130\048\012HA\131\009\244\007a\056\060\024\232\223\133\
\024\158\192\030\135\032\134\040\226\136\036\194\016\001\000\059\
"
@

<<constant [[Tachy_test.park_data]]>>=
let park_data =
"#define break_width 15
#define break_height 11
static char break_bits[] = {
   0x0c, 0x18, 0xf4, 0x17, 0x3a, 0x2e, 0xba, 0x2d, 0xb9, 0x4d, 0x3d, 0x5e,
   0xb9, 0x4f, 0xba, 0x2f, 0xba, 0x2f, 0xf4, 0x17, 0x08, 0x08};
"
@

<<constant [[Tachy_test.pi]]>>=
let pi = 3.1415926 
@

<<constant [[Tachy_test.log10]]>>=
let log10 = log 10.0 
@

<<function [[Tachy_test.create_tachy]]>>=
let create_tachy top = 
  let o = new default_tachy top in
  o#start;
@

<<toplevel [[Tachy_test._1]]>>=
let _ = 
  let top = Applets.get_toplevel_widget [] in
  Wm.withdraw top;
  begin match Frx_dialog.f top (Mstring.gensym "foo")
        "Tachy test" "Use this test tachymeter"
    (Tk.Predefined "question") 1 ["Yes"; "No"] with
    0 -> Mmm.set_tachy create_tachy
  | _ -> ()
  end;
  destroy top
@


%-------------------------------------------------------------

<<extensions/tachy_test.ml>>=
open Safe418mmm
open Tk

module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)

(* Tachymeter *)

(* gif is 80x65 *)
<<constant [[Tachy_test.tachy_data]]>>
<<constant [[Tachy_test.park_data]]>>


<<constant [[Tachy_test.pi]]>>
<<constant [[Tachy_test.log10]]>>

class default_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable canvas = top (* dummy initialisation *)
  val mutable alive = false

  (* Various components of the canvas, all with dummy init values *)
  val mutable i_park = Tag "none"
  val mutable kilos = Tag "none"
  val mutable aig = Tag "none"
  val mutable pendings = Tag "none"


  (* this one is private *)
  method start =
    let c =
      Canvas.create_named top "tachymeter"
       [Width (Pixels 80); Height (Pixels 80); 
         BorderWidth (Pixels 0);
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *)] in
    (* Use colors so that images are not transparent *)  
    (*
    let tachy_image = 
      begin
       try
      let bgc = Tk.cget c CBackground in
      Protocol.tkEval 
        [|Protocol.TkToken "set";
          Protocol.TkToken "TRANSPARENT_GIF_COLOR";
          Protocol.TkToken bgc |]; () 
       with _ -> ()
      end;
      *)
    let tachy_image = Frx_misc.create_photo [Data tachy_data]
    and park_image =
      Imagebitmap.create [Data park_data; Foreground Red] in

    i_park <-
      Canvas.create_rectangle c 
     (Pixels 72) (Pixels 3) 
     (Pixels 75) (Pixels 6) [FillColor Black];
    
    kilos <-
      Canvas.create_text c (Pixels 40) (Pixels 73) [Text "0"];
    
    aig <-
      Canvas.create_line c [Pixels 41; Pixels 32; Pixels 41; Pixels 57]
                       [Width (Pixels 2)];
    pendings <-
      Canvas.create_text c (Pixels 70) (Pixels 60) [Text "0"];

    let i_tachy =
      Canvas.create_image c (Pixels 0) (Pixels 0)
       [ImagePhoto tachy_image; Anchor NW]

    in

    Canvas.lower_bot c pendings;

    (* All other items must be put above the background image *)
    List.iter (fun i -> Canvas.raise_above c i i_tachy)
      [kilos; aig; i_park];

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));

    (* These bindings are specific to the applet version *)
    bind c [[], ButtonPressDetail 1] 
      (BindSet ([], (fun _ -> Mmm.new_window_initial ())));
    bind c [[], ButtonPressDetail 2] 
      (BindSet ([], (fun _ -> Mmm.new_window_sel ())));

    alive <- true;
    pack [c][];
    canvas <- c

  val mutable last_speed = 0.
  val mutable last_total = 0
  val mutable idle = false

  method update speed total =
    if speed = 0.0 then begin
      if not idle then begin
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black];
    idle <- true
      end
    end
    else begin
      Canvas.configure_rectangle canvas i_park [FillColor Green;
                         Outline Green];
      idle <- false
    end;
    if total <> last_total then
      Canvas.configure_text canvas kilos [Text (string_of_int total)];
    last_total <- total;
    let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
    let speeds = (last_speed +. speed) /. 2. in
    if abs_float (speeds -. last_speed) > 0.1 then begin
      last_speed <- speeds;
      let v = speeds /. log10 in
      let angle = v /. 4.0 *. pi in
      let angle = if angle < 0.1 then 0.0 else angle in
      let x = 41.0 -. (sin angle *. 25.0)
      and y = 32.0 +. (cos angle *. 25.0) in
      Canvas.coords_set canvas aig 
    [Pixels 41; Pixels 32;
      Pixels (truncate x); Pixels (truncate y)];
      update_idletasks()
    end

  method report_cnx n = 
    if Winfo.exists canvas then
      if n = 0 then begin
    Canvas.configure_text canvas pendings [Text ""];
       Canvas.lower_bot canvas pendings
      end
      else begin
    Canvas.configure_text canvas pendings 
      [Text (string_of_int n)];
       Canvas.raise_top canvas pendings
      end

  method report_busy busy =
    if Winfo.exists canvas then
      if busy then begin
       Canvas.lower_bot canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Red;
                          Outline Red];
    update_idletasks()
      end
      else begin
       Canvas.raise_top canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy canvas

end

<<function [[Tachy_test.create_tachy]]>>
  (o :> Mmm.tachymeter)

<<toplevel [[Tachy_test._1]]>>

@


