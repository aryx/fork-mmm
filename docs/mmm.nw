\documentclass[12pt]{report}

\input{latex/Packages}
\input{latex/Noweb}
\input{latex/Config}
\input{latex/Macros}

%******************************************************************************
% Prelude
%******************************************************************************

%recent:
% - charon browser in inferno, has jscript support!
% - https://browser.engineering/layout.html

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - deadcode?

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps (but ocaml linker enforces that),
%   and to reduce dependencies to graphic toolkit tk
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand web browsers?:
% - TODO encodings, accents, base64, iso8559, etc
% - SEMI better understand html
% - TODO better understand css
% - TODO better understand js

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%\allcodefalse
% used for redundant class decl, nested locals order, nested functions order

%\setcounter{tocdepth}{1}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Web Browser [[mmm]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Francois Rouaix
}

\maketitle 
%\onecolumn
\hrule
\begin{quote}
Copyright \copyright{} 2026 Yoann Padioleau \\
All rights reserved.
\end{quote}
\hrule
%\twocolumn

%CONFIG: \dominitoc

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
\chapter{Introduction}
%******************************************************************************

\section{Motivations}

The goal of this book is to present with full details the source code of
a web browser.
Why? Because I think you are a better programmer if
you fully understand how things work under the hood.


\section{[[mmm]]}

% chose mmm, written in ocaml, small, elegant.

\section{Other Web browsers}

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}

\item nexus
% original one, objective C, 8000 LOC?

\item mosaic
% maybe good. but 130 000 LOC (vs 30 000 LOC for mmm)
% added images (actually Viola added images first?)

\item gecko (firefox)
% descendant of mosaic, netscape
% huge now

\item khtml/webkit/blink (kconqueror, safari, chrome)
% started from scratch by kde people originally, now used by google/apple
% huge

\item netsurf
% with subprojects like hubhub, libcss, libdom, etc
%... was used originally by servo
% also recent js engine called duktape is maybe used with it

\item servo
% already lots of LOC actually
% https://github.com/servo/servo/wiki/Design

% elinks?

\end{itemize}

%other:
% - Qnx Voyager browser, 1.44MB demo disk! full GUI and web browser!
% - charon: inferno OS, support js and https
% - mothra, abaco: pretty small but no css, no js
%mini:
% - vado: very basic html rendering in haskell
%   https://github.com/chrisdone/vado


% see wikipedia page on history of web browser, pretty good, I have it printed.
%todo: my todo-browser/ somewhere

%todo:
%https://github.com/servo/servo/wiki/Relevant-spec-links
% 2015-servo-experience-report-draft1.pdf

%good: http://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html
%todo: http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/
% HBW

%todo: look at ocamlnet? more up to date web components?

%tutorial of android web browser internals (dead browser, but maybe interesting)
%https://medium.com/@camaelon/what-s-in-a-web-browser-83793b51df6c#.nblcubeka

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from MMM, so
those parts are copyright by INRIA.

<<copyright header v6>>=
(***********************************************************************)
(*                                                                     *)
(*                           The V6 Engine                             *)
(*                                                                     *)
(*          Francois Rouaix, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

I would like to thank of course Francois Rouaix
the main author of MMM.


%******************************************************************************
\chapter{Overview}
%******************************************************************************

\section{Web browser principles}

% before seing the browser, first expose web principles: world wide web.
% a "web" of interconnected machines with:
%  - "resources": html documents, images, plain text, music, video, flash
%  - URL to reference a resource; an html document contains itself
%    possible links to other documents or resources (e.g. images)
%    => it forms a "web" of documents
%  - http protocol to fetch the resources
%  - client/server around this protocol

% a web browser is then a special kind of interface on top of that:
% a navigator interface! (history, forward, click, multiple windows, etc).
% A few important things
% - it must provide feedback, especially
%    when fecth data from the network, you want to see if something is stucked
%    or is progressing (hence the complex passing of continuation,
%    error hooks, abort, etc)
% - it must be incremental, to display things as soon as possible
%   (so incremental html lexer/parser, incremental formatter, async
%    img fetching and incremental display, etc)
% - a bit like an OS you want to be "multitask" and that one web page
%   does not block every other things

% see mmm-gdr-fr.ps
% todo: see docs/website/tech.html


%"The main function of a browser is to present the web resource you
%choose, by requesting it from the server and displaying it in the
%browser window. The resource is usually an HTML document, but may also
%be a PDF, image, or some other type of content. The location of the
%resource is specified by the user using a URI (Uniform Resource
%Identifier)." HBW


\section{[[mmm]] services}

<<constant [[Main.usage_str]]>>=
let usage_str =
  "Usage: meuh <opts> <initial url>"
@
% meuh :)
% actually it's a URI no?

<<signature [[Version.http]]>>=
val http : string              (* the version in User-Agent field *)
@
% full_request -> std_request_headers -> user_agent (alias <>)
<<constant [[Version.http]]>>=
(* User-Agent field *)
let http = "MMM/0." ^ string_of_int number
@

<<signature [[Version.number]]>>=
(* Version and other builtin strings *)
val number : int
@
<<constant [[Version.number]]>>=
(* Version *)
let number = 418
@
% lol


<<signature [[Version.about]]>>=
val about : string -> string   (* dialog *)
@
% Mmm/About menu -> <>
<<function [[Version.about]]>>=
(* dialog uses an gigantic font ! *)
let about = function
  | "iso8859" ->
"MMM Version 0." ^ version_number ^
"\nWritten by Fran\231ois Rouaix
Contributions by Jun P. Furuse and Jacques Garrigue
Ported to O'Caml 3 by Jun P. Furuse and Pierre Weis
\169 Copyright INRIA

Projet Cristal
INRIA Rocquencourt
Domaine de Voluceau
78153 Le Chesnay Cedex
France

Francois.Rouaix@inria.fr
http://pauillac.inria.fr/~rouaix/
"
  | s -> failwith (Printf.sprintf "language not supported: %s" s)
@
%old: assert false



<<constant [[Version.version_number]]>>=
let version_number = 
  string_of_int number
@


\section{HTML document language}

\section{[[hello.html]]}


\section{CSS style language}

\section{[[hello.css]]}

\section{Javascript scripting language}

\section{[[hello.js]]}

\section{Code organization}

% commons/: utilities
% globals/: config
% www/: uri, url, request
% html/: html parsing
% http/: http protocol
% protocols/: protocol dispatcher, more protocols (file, mailto), and
%  document cache
% retrieve/: networking stuff, connexions
% viewers/: viewer dispatcher, and text/plain simpler viewer
% display/: rendering engine
% gui/: chrome

% skipped for now: 
% i18n/japan/ 
% applets/ sandbox/ crcs/ 
% extensions/
% demos/ 

\section{Software architecture}

% complicated archi in the end, because need to handle
% network error, user action such as abort, timeout,
% and want to have multiple requests going at the same time
% possibly (if have many tabs), so it's a mini OS in some sense,
% managing multiple tasks. Don't want a slow server
% to hang the whole thing, so need to manage async requests,
% and so have callbacks (called continuation here) when things
% are ready.

%todo: see docs/website/tech.html

\subsection{Trace of a web request}

% enter URL in address bar and type enter, what happens?
% lots of components involved I think

%https://github.com/alex/what-happens-when/blob/master/README.rst

\subsection{Trace of a mouse click}

% see mmm-gdr-fr.ps
% mouse click -> fetch doc (async), wait server, header parsing, 
%  adequat viewer, 

\section{Book structure}

%###############################################################################

%******************************************************************************
\chapter{Core Data Structures}
%******************************************************************************

% url -> uri -> link -> request, bigger and bigger structure
% and then
% request -> document -> data -> ast

\section{URLs and co}

% url -> uri -> link -> request, bigger and bigger structure

% URLs are URIs, who is more general?
% URL is uniform, URIs is universal, so URI is more general!

%https://eager.io/blog/the-history-of-the-url-domain-and-protocol/

\subsection{URLs and protocols}

<<type [[Url.t]]>>=
(* URLs as defined by RFC 1738. Not all components are used for all protocols.
 * The order of the fields below correspond to the actual order in the string:
 *   <protocol>://<user>:<password>@<host>:<port>/<path>?<search>
*)
type t = 
  { mutable protocol : protocol;

    mutable user : string option;
    mutable password: string option;

    mutable host : string option;
    mutable port : int option;

    mutable path : string option;
    mutable search: string option
  }
@
% search?
% "Relative adressing in anchors, fragments are NOT URLs, but URI" ???
%   to say that there is no fragment here, anchor = #xxx
%less: need to be mutable? really?

<<type [[Url.protocol]]>>=
type protocol =
 | HTTP | HTTPS
 | FILE | FTP
 | MAILTO | NNTP
 | GOPHER | NEWS | WAIS | PROSPERO
 | TELNET 
 | OtherProtocol of string
@

% will see later parsing function for URL: Lexurl.make()

% web browser not just for http, but it's true it's mainly
% for http

\subsection{URIs and fragments}
% =~ http://..../path/elements/foo.html#fragment
% =~ URL + fragment

<<type [[Uri.abs_uri]]>>=
(* URI utilities. RFC 1630 *)
type abs_uri = {
   uri_url : string;
   uri_fragment : string option
 }
@
%abs for absolute! we want those URI to have been "resolved"
%fragment is for the #xxx
%  "Relative adressing in anchors, fragments are NOT URLs, but URI" ???
% note that there will be www_fragment, document_fragment, #di_fragment, etc
%less: uri_url, hmmm should be uri_path no?
%less: why not parse uri_url and make it a Url.t?


<<signature [[Uri.is_absolute]]>>=
val is_absolute : string -> bool
   (* [is_absolute uri] determines if [uri] is absolute according to
      rules of RFC 1630 *)
@
<<function [[Uri.is_absolute]]>>=
(* RFC 1630, partial forms *)
let is_absolute uri =
  try
    let colonpos = String.index uri ':' in
    try 
      let slashpos = String.index uri '/' in
      colonpos < slashpos (* colon must occur before slash *)
    with
      Not_found -> true (* colon occurs before slash *)
  with
    Not_found -> false (* absolute must have a : *)
@
% ?? examples? 
% unit tests!

\subsection{Hypertext Links}
%=~ <a href="..."> with implicit METHOD=GET
%=~ URI + context + method + args

<<type [[Hyper.link]]>>=
(* An hypertext(media) link on the Web *)
type link = {
  h_uri : string;
  h_context: string option;

  h_method : link_method;		(* default is GET *)
  h_params : (string * string) list
}
@
% context? useful for relative uri, seems to be a URL too.
%  (usually the referring site)
%less: Why not parse h_uri? and make it a Uri.t?

<<type [[Hyper.link_method]]>>=
(* This is currently for HTTP and derived, but ... *)
(* Contains only the one we support *)
type link_method =
 | GET 
 | POST of string
 <<[[Hyper.link_method]] other cases>>
@

% the web server is like a set of functions! can call those
% functions! see my pfff/www/ endpoints, a bit like my -actions.

<<signature [[Hyper.default_link]]>>=
val default_link: string -> link
@
<<function [[Hyper.default_link]]>>=
let default_link uri = {
 h_uri = uri;
 h_context = None;
 h_method = GET;
 h_params = [];
}
@
%less: rename default to mk ?
%pad: I added this function to factorize boilerplate code

% when you click on a link, by default it's a GET without any params

\subsection{Web requests}
% =~ link + some state info in the browser (e.g. authentification, cookie?)
%  in a header

<<type [[Www.request]]>>=
(*
 * Requests
 *)
type request =  { 
    www_link : Hyper.link;        (* the link that produced this request *)
    mutable www_headers : string list;		  (* additional headers *)
    <<[[Www.request]] security field>>

    <<[[Www.request]] parsed link fields>>

    <<[[Www.request]] logging method>>
    <<[[Www.request]] error managment method>>
  }
@

%todo: why need pass the logger? can't just use a global
% logger always? which flexibility it brings?
% www_logging, document_logger, Log.f, too many no?
%it's ok though probably to have a www_error, because
% we may want to print the error message of the request at different
% places (e.x. if use different tabs)

<<[[Www.request]] parsed link fields>>=
www_url : Url.t;	          (* parsed version *)
www_fragment : string option; (* because viewer is passed down *)
@
%fragment is for the URI, the #xxx

% we start to have methods here! a request is something alive!
% it can have errors, and we need to log what is happening.
% will see in appendix those aspects though.

<<signature [[Www.make]]>>=
val make : Hyper.link -> request
  (* raises: Url_Lexing | Invalid_link *)
@
<<function [[Www.make]]>>=
let make (hlink : Hyper.link) : request =
  let absuri = Hyper.resolve hlink in 
  let url : Url.t = Lexurl.make absuri.uri_url in
  try (* search for space in network URI *)
    if List.mem url.protocol [FILE; MAILTO] 
    then raise Not_found
    else
      let n = 
        (* will raise Not_found if no space found *)
        Str.search_forward sp absuri.uri_url 0 
      in
      raise (Hyper.Invalid_link (Hyper.UrlLexing ("suspicious white space", n)))
  with Not_found -> 
    (* regular code path, everything is normal, we didn't find (bad) spaces *)
    { www_link = hlink;

      www_url = url; (* should not fail ? *)
      www_fragment = absuri.uri_fragment;

      www_auth = [];
      www_headers = [];

      www_logging = (fun _ -> ());
      www_error = !Error.default
    }
@
% abuse exn too much? the regular flow is actually the exceptional flow
% but true that lots of idioms/conventions using Not_found later so maybe ok.

<<constant [[Www.sp]]>>=
let sp = Str.regexp "[ \t\n]"
@

% will see later Hyper.resolve and Lexurl.make

%less: could put Plink.make here too

\section{Documents}

% seen the request, this is now what we get back!

<<type [[Document.document]]>>=
type t = {
  document_headers : string list; (* e.g. Content-type: text/html *)
  mutable document_data : data;
  document_address : Url.t;
}
@
%note that it's a mutable field!
%old: was document_info but it's really document_headers

% www_headers is for the request, document_headers is for the response!


% used by Protos.get
<<type [[Document.document_data]]>>=
(*
 * Information on a document, as could be requested by "other" clients,
 * that is clients not directly on the chain of processes dealing with
 * the handle
 *)
type data =
 | MemoryData of Ebuffer.t
 | FileData of Fpath.t * bool (* flag is true if file is temporary *)
@
%less: the comment is enigmatic

\subsection{Document ID}

<<type [[Document.document_id]]>>=
(* Document Id is a reference to a document in the browser.
   For some documents, e.g. results of POST queries, the URL is not a
   sufficient description. Stamp is 0 for unique documents.
*)
type id = {
  document_url : Url.t;
  document_stamp : int
}
@

<<signature [[Document.no_stamp]]>>=
val no_stamp : int
@
<<constant [[Document.no_stamp]]>>=
let no_stamp = 0
@



<<constant [[Document.stamp_counter]]>>=
let stamp_counter = ref 0
@
<<signature [[Document.new_stamp]]>>=
val new_stamp : unit -> int
@
<<function [[Document.new_stamp]]>>=
let new_stamp () =
  incr stamp_counter; !stamp_counter
@


% get a new document_id!
<<signature [[Document.document_id]]>>=
val document_id : Www.request -> id
@
<<function [[Document.document_id]]>>=
let document_id wwwr =
  match wwwr.www_link.h_method with
  | POST _  ->
         { document_url = wwwr.www_url; document_stamp = new_stamp()}
  | _ -> { document_url = wwwr.www_url; document_stamp = no_stamp}
@



<<module Document.DocumentIDSet>>=
module DocumentIDSet =
  Set.Make(struct type t = id let compare = compare end)
@
%TODO: remove functor, use Set_.t

\subsection{Document cache}

<<signature [[Cache.add]]>>=
val add : Document.id -> Document.t -> unit
@
<<signature [[Cache.find]]>>=
val find : Document.id -> Document.t
@
% see below
<<signature [[Cache.finished]]>>=
val finished : Document.id -> unit
@
% will see add and finished later in optimisation section.
<<signature [[Cache.touch]]>>=
val touch : Document.id -> unit
@
% refresh for cache


<<signature [[Cache.kill]]>>=
val kill : Document.id -> unit
@
%less: diff with finished?


<<constant [[Cache.memory]]>>=
let memory = ref ([] : (Document.id * entry) list)
@

<<type [[Cache.entry]]>>=
(* A cache entry *)
type entry = {
  mutable cache_document : Document.t;

  mutable cache_pending : bool;
  cache_condition : Condition.t;

  mutable cache_lastused : float
      (* TODO still valid comment in 2026? *)
      (* old? cache_lastused is specified as max_int (0x3fffffff) when we don't
       * want the entry to be flushed. This will break around
       * Sat Jan 10, 2004 13:37 GMT on 32 bits machines
       *) (* JPF: it is now float! max_int -> max_float *)
  }
@
%less: LP split?
%todo: hmm the comment seems to indicate it's a bad thing in 2015 :)

<<constant [[Cache.max_lastused]]>>=
(* Corresponding Date = year 5138, we should be fine *)
let max_lastused = 100000000000.0
@


<<function [[Cache.find]]>>=
(* Find a document*)
let find (did : Document.id) : Document.t =
  let entry = List.assoc did !memory in
  entry.cache_lastused <- Unix.time();
  if entry.cache_pending 
  then Condition.wait entry.cache_condition;
  entry.cache_document
@

% add, will see later

% hmm but what is the value of cache_document at first when we
% don't have the data yet, that the cache is pending?
% should be document option no?

\section{Protocols and document flow}
%alt: remove intermediate section, can fit well with Document above?
% hmm but Protos.protos is important! a bit like Viewers.viewers

% seen (generic) request, and (generic) data response,
% how connect(generically)? two steps, first retrieve, then view.
% below is the retriever.

% Nav.request -> Retrieve.f -> <>
<<signature [[Protos.get]]>>=
val get: Url.protocol ->
  (< Cap.network > -> Www.request -> Document.continuation -> Www.aborter) 
  *
  (Document.handle -> Document.data * Cache.cache_fill)
@
% will see below what are those Document.xxx
%less: define a record type?
%old: the unit -> unit is actually a returned aborter hook! so caller
%  can abort the request, so I did a type instead of having unit -> unit

\subsection{[[Protos.protos]]}

<<constant [[Protos.protos]]>>=
let protos : (Url.protocol, 
             (< Cap.network > -> Www.request -> Document.continuation -> Www.aborter) * 
             (Document.handle -> Document.data * Cache.cache_fill)) Hashtbl.t =
  Hashtbl_.create ()
@

<<constant [[Protos.get]]>>=
let get = Hashtbl.find protos
@

%will see code like:
%<<toplevel Protos._2>>=
%let _ = Hashtbl.add protos HTTP (Http.req, Cache.tobuffer)
%@

% Protos.get return a "retriever" and a "cacher"
%TODO: define record with those 2 names?

\subsection{Document continuation}

% this will be the viewer

% used by Protos.get
<<type [[Document.document_continuation]]>>=
type continuation = {
  document_process : handle -> unit;
    (* What to do one we have a dh on the real document *)

  document_finish :  bool -> unit
    (* What to do if a request does not yield a document. bool = ???? *)
}
@
%less: could defined a type abort = Abort and then
% transform the bool in abort option, then could also transform
% the aborter type as abort -> unit

% this is passed to the retriever, a callback to called
% when he got the data. Usually it's a viewer.
% bool is true when things were aborted

% note than the handle is built by the protocol! it's data filled
% by the protocol retriever, the caller just want to be called
% with something filled by the protocol retriever

% often build a serie of continuations for document_process
% where you add some intermediate processing.
% ex:
%  let foo doc_cont ... =
%     let req,cache = Protos.get request.www_url.protocol in
%      Started (req request
%        { doc_cont with
%          document_process = http_check cache retry doc_cont request})

\subsection{Document handle}

% the retriever asynchronous result, passed to the viewer

% used by Protos.get
<<type [[Document.handle]]>>=
(* This is passed around by request continuations. It represents a handle
   on a connexion for retrieving a document *)
type handle = {
  document_id : id;

  (* this should help to know what to do even if have not the data yet.
   * Those are response headers.
   *)
  mutable dh_headers : string list;
    (* HTTP headers of document, or faked ones *)

  document_feed : Feed.t;
    (* where to get the data *)

  <<[[Document.handle]] other fields>>
}
@
% the retriever does not actually completely retrieve the data,
% it opens a connexion and give a handler to the caller (usually
% a viewer) that can then fetch the data and process it)

%why not take Www.request and put it here? so less need to
% have document_headers? well this is the response header! not
% the request headers.

%less: typedef for document_status int?
%less: have xx_response_headers and xx_request_headers?

%note: this will be produced by the http_req, and then
% passed to the document_continuation.document_process,
% which then will pass it down to the Cache.tobuffer

% TODO: figure with the flow! who is building the handle, who
%  is consuming it


\section{HTTP}

% one of the protos is Http.req!

% previous section were generic request/response,
% here are the specifics for the http protocol

% apparently mmm handles http 1.0 and 0.9 (update: I've removed 0.9)
% there is also 1.1.
% 2.0 just got published I think

%(* HTTP messages: requests and responses
% *  What a client sends to a server is called a request 
% *  What a server answers is called a response
% *)

\subsection{Requests}

%less: rename messages.mli to http_messages.mli?

<<type [[Messages.request_message]]>>=
(* HTTP-Message *)
type request = {
  request : request_line;
  request_headers : header list;
  request_body : string;
  <<[[Messages.request_message]] other fields>>
}
@
% diff with Www.request? it also has _headers and _auth.
% but Www.request is the general case for any request (file://, mailto://)
% here request_message is the Www.request specialized for http:/
%what is body? Www.request didn't have that. It's a subpart of
% Www.www_headers?

<<type [[Messages.request]]>>=
(* Request-Line of a Request *)
type request_line = {
  request_version: string;	(* HTTP/1.0 *)
  request_method : string;	(* GET, POST, etc... *)

  request_uri : string		(* the uri *)
}
@
%less: why not use method type for request_method instead of a string?

\subsection{Responses}

<<type [[Messages.response_message]]>>=
type response = {
  status : status_line;

  response_headers : header list;
  response_body : string;        (* responde body is *not* the document body *)
}
@

% ok so we will get some response, and then we
% need to transform that into a document handle that then
% can be processed by the http independent core of mmm

<<type [[Messages.status]]>>=
(* Status-Line of a Response *)
type status_line =  { 
    status_version : string;	(* HTTP/1.0 *)
    status_code : int;		(* http return codes *)
    status_message : string	(* http return message *)
}
@

\subsection{Headers and content types}

% headers for request, and for response
% and in headers have lots of info,
% e.g. content type, encoding, etc.

% have seen also Www.request have some headers, and document
% also has some. They are all connected.

<<type [[Messages.header]]>>=
(* Other headers *)
type header = string
@


% http://en.wikipedia.org/wiki/Internet_media_type
% ex: "text/html", "text/plain"
<<type [[Http_headers.media_type]]>>=
(* type/sub, ex: text/html, images/gif, applications/postscript *)
type media_type = string * string
@

% ex: text/html; charset=UTF-8
<<type [[Http_headers.media_parameter]]>>=
(* ex: ?? *)
type media_parameter = string * string
@



\section{Viewers}

% have seen generic (multi protocol) Retrieve.f, 
% now see generic (multi content type) Viewer.f, which
% are usually the code is the document continuation
% that will get the document handle and do stuff

% to operate it will be passed a context to do its job
% (in addition to the document handle), and will return
% a display_info

<<type [[Viewers.t]]>>=
(* Definition of an internal viewer *)
type t = 
    Http_headers.media_parameter list -> 
    (Widget.widget -> context -> Document.handle -> display_info option)
@
% from document handle you'll be able to read the data

\subsection{[[Viewers.viewers]]}

<<constant [[Viewers.viewers]]>>=
let viewers : (Http_headers.media_type, spec) Hashtbl.t = 
  Hashtbl_.create ()
@

<<type [[Viewers.spec]]>>=
type spec =
  | Internal of t
  | External
  <<[[Viewers.spec]] other cases>>
@
% External     (* pass to metamail *)


\subsection{[[Viewers.context]]}

% again because want to be generic, define DS that will
% be used by different viewers and expose interface
% that will be needed by the viewer (and hide specifics).

% this context will usually be a subset of the navigator interface,
% hooks to the navigator.

<<signature class [[Viewers.context]]>>=
(* The context given to a viewer *)
class virtual context : (Document.id * vparams) -> object ('a)

  method base : Document.id

  <<[[Viewers.context]] hypertext methods signatures>>
  <<[[Viewers.context]] embedded methods signatures>>

  <<[[Viewers.context]] logging methods signatures>>
  <<[[Viewers.context]] other methods signatures>>
end
@
%(* Standard hyper functions are: "goto", "save", "gotonew" *)

% base to get Document.id, minimum so can set title based on url for example

TODO XXX ??? when is this called ? why need pass down in context to viewer?

<<[[Viewers.context]] hypertext methods signatures>>=
method goto    : Hyper.link -> unit
method gotonew : Hyper.link -> unit
method save    : Hyper.link -> unit
@

<<[[Viewers.context]] hypertext methods signatures>>=
method invoke  : string -> Hyper.link -> unit    
method add_nav    : string * hyper_func -> unit
method hyper_funs : (string * hyper_func) list
@



<<class [[Viewers.context]]>>=
(* The context given to a viewer *)
class virtual context ((did : Document.id), 
                       (v : vparams)) =
 object (self : 'a)

  val base = did
  method base = base

  val viewer_params = v
  method params = viewer_params

  val mutable (*private*) funs = ([] : (string * hyper_func ) list)
  method hyper_funs = funs

  val targets = []

  method goto hlink    = self#invoke "goto" hlink
  method gotonew hlink = self#invoke "gotonew" hlink
  method save hlink    = self#invoke "save" hlink

  method invoke name hlink =
    try (List.assoc name funs).hyper_func targets hlink
    with Not_found -> ()

  method add_nav (fname, hf) =
    funs <- (fname, hf) :: funs

  <<method [[Viewers.context.for_embed]]>>
  <<method [[Viewers.context.in_embed]]>>

  method virtual log : string -> unit
end
@
%(*
%    (* for debug *)
%    let _oldtargetsTODO = targets in
%    let res = 
%      match newtargets with 
%      | [] -> 
%          (* keep exactly the same environment *)
%          targets
%      | l -> 
%          (* assume I'm given new _self and _parent *)
%      l @ frame_fugue targets 
%    in
%     (self#with_target res)#with_viewer_params vparams
%*)
%    (* old:
%       {< 
%       targets = res;
%       viewer_params = vparams;       
%       >}
%    *)
%    (* pad: the code below works perfectly but when I want to do 
%     * make dotall I get an error because ocamldoc -pp camlp4o (which
%     * I need for certain files) has a type error on this file
%     * at this line. Indeed when run
%     * 
%     *   ocamldoc -pp camlp4o -I ../commons -I ../globals -I ../www -I ../http -I ../protocols -I ../retrieve -I /home/pad/packages/Linux/stow/ocaml-3.12/lib/ocaml/camltk viewers.ml
%     * 
%     * manually camlp4 geneate a weird thing for the code below.
%     * so I just introduced those ugly with_target and with_viewer
%     * to avoid the pb. UGLY
%     * 
%     *)
%
%
%  (* pad: this is just because of some bugs in camlp4o *)
%  method with_target: frame_targets -> 'a
%  method with_viewer_params: (string * string) list -> 'a




\subsection{[[Viewers.display_info]]}

% this is what will be returned by function like
% display_html given a Viewers.viewer_context and the actual document handle

<<signature class [[Viewers.display_info]]>>=
class  virtual display_info : (unit) -> object ('a)

  <<[[Viewers.display_info]] virtual methods signatures>>
  <<[[Viewers.display_info]] graphic cache methods signatures>>
end
@
%note: the <<[[Viewers.display_info]] virtual methods signatures>> chunk
% is used both for the .mli and the .ml, so don't extract
% anything from it otherwise it will not be copy pasted in the .mli and .ml
%later: transform in a regular record

<<[[Viewers.display_info]] virtual methods signatures>>=
method virtual di_title : string		(* some visible title *)

(* the created widget containing the graphics *)
method virtual di_widget : Widget.widget

<<[[Viewers.display_info]] images virtual methods signatures>>
<<[[Viewers.display_info]] embedded virtual methods signatures>>
<<[[Viewers.display_info]] fragment virtual method signature>>

<<[[Viewers.display_info]] lifecycle virtual methods signatures>>

<<[[Viewers.display_info]] graphic cache virtual methods signatures>>
<<[[Viewers.display_info]] other virtual methods signatures>>
@
% di_title is used by the caller to modify the window's title
% the widget that is packed in the top passed in, and
% that will be deleted in undisplay


%old: was in document.ml, dead, but I should use that instead of classes:
%type display_info = {
%    di_abort : Www.aborter;
%    di_destroy : unit -> unit;
%    di_fragment : string option -> unit;
%    di_redisplay: unit -> unit;
%    di_title : unit -> string;	      (* some title for bookmarks *)
%    di_source : unit -> unit;
%    di_load_images : unit -> unit
%}


\section{Abstract syntax trees}

% html
% css
% js

\subsection{HTML}

% actually not really a token because tag is complex with
%  attributes in it
<<type [[Html.token]]>>=
type token =
 | Doctype of string

 | OpenTag of tag
 | CloseTag of string

 | PCData of string
 | CData of string

 | Comment of string

 | EOF
@
% Doctype is usually at the top, and this will guide which dtd to use
%less: diff PCData and CData?

%where is the tree? the full AST? token is really the main thing returned
% by the lexer/parser. You have to rebuild the tree from it
% but it is easy since the tokens contain Opentag, Closetag, etc.
% I think they don't return a tree because things are processed
% incrementally, we fecth data and start to visualize it as soon
% as possible, which is important in a (often slow) network context.
%less: could do such a dumper, a la pfff

%https://html.spec.whatwg.org/multipage/introduction.html#a-quick-introduction-to-html

<<type [[Html.tag]]>>=
type tag = {
  tag_name : string;
  attributes: attributes
}
@

%concepts:
% - tags
% - attributes
% - entities
% - ???

<<type [[Html.attributes]]>>=
type attributes = (attribute_name * attribute_value) list
@

<<type [[Html.attribute_name]]>>=
type attribute_name = string 
@
<<type [[Html.attribute_value]]>>=
type attribute_value = string
@



\subsection{CSS}

\subsection{Javascript}





\section{DOM}

%https://dom.spec.whatwg.org/




\section{HTML display}

% we've seen the viewer interface, now we see the specifics,
% the html viewer machinery, which is splitted
% in different parts:
%  - the formatter
%  - the interpreter/machine parsing the stream of html tokens
%    and calling the appropriate formatter methods

\subsection{Formatter}

<<type [[Htmlfmt.gattr]]>>=
type gattr =
  <<[[Htmlfmt.gattr]] color cases>>
  <<[[Htmlfmt.gattr]] font cases>>
  <<[[Htmlfmt.gattr]] spacing cases>>
  <<[[Htmlfmt.gattr]] alignment cases>>
  <<[[Htmlfmt.gattr]] style cases>>
@
%e.g. Striked | Underlined | etc

<<type [[Htmlfmt.formatter]]>>=
type formatter = {

  (* Text primitives of the device *)
  <<[[Htmlfmt.formatter]] primitives methods>>

  (* Graphical attributes *)
  <<[[Htmlfmt.formatter]] graphical attributes methods>>

  <<[[Htmlfmt.formatter]] other methods>>

  flush : unit -> unit;			(* Flush the device *)
}
@


XXX
<<[[Htmlfmt.formatter]] other methods>>=
(* Predefined Images *)
<<[[Htmlfmt.formatter]] predefined images methods>>
(* Structure primitives *)
<<[[Htmlfmt.formatter]] structure primitives methods>>
(* Embedding primitives *)
<<[[Htmlfmt.formatter]] embedding primitives methods>>
(* Re-centering on a fragment *)
<<[[Htmlfmt.formatter]] fragment method>>
@



<<constant [[Html_disp.default_fo]]>>=
(* This is the default formatter *)
let default_fo = Htmlfmt.{
  (* Text primitives of the device *)
  new_paragraph   = (fun () -> ());
  close_paragraph = (fun () -> ());
  print_newline   = (fun _b -> ());
  print_verbatim  = (fun _s -> ());
  format_string   = (fun _s -> ());

  (* Graphical attributes *)
  push_attr       = (fun _l -> ());
  pop_attr        = (fun _l -> ());
  set_defaults    = (fun _s _l -> ());

  (* misc *)

  hr              = (fun _l _n _b -> ());
  bullet          = (fun _n -> ());


  isindex         = (fun _s _s' -> ());
  start_anchor    = (fun () -> ());
  end_anchor      = (fun _h -> ());
  add_mark        = (fun _ -> ());

  create_embedded = (fun _a _w _h -> assert false);

  see_frag        = (fun _ -> ());

  flush           = (fun () -> ());
} 
@


\subsection{Interpreter}
%less: rename, machine is very vague

<<signature class [[Html_disp.machine]]>>=
class  virtual machine : (unit) -> object
  <<[[Html_disp.machine]] virtual fields signatures>>
end
@
%note: the <<[[...]] virtual fields signatures>> chunk above
% is used both for the .mli and the .ml, so don't extract
% anything from it otherwise it will not be copy pasted in the .mli and .ml
%later: transform in a regular record
%less: why need this extra generic type where it looks really
% html specific anyway? anyway if I transform in a record
% I'll have to define first the interface of the methods.

<<[[Html_disp.machine]] virtual fields signatures>>=
(* context *)
method virtual ctx : Viewers.context

(* input *)
method virtual send : Html.token -> unit
<<[[Html_disp.machine]] html input other methods>>

(* semantic *)
method virtual add_tag: 
  string -> 
  (* open handler *)  (Htmlfmt.formatter -> Html.tag -> unit) -> 
  (* close handler *) (Htmlfmt.formatter -> unit) -> 
  unit
method virtual remove_tag : string -> unit
<<[[Html_disp.machine]] tags methods>>
<<[[Html_disp.machine]] action stack methods>>

(* backend *)
method virtual formatter : Htmlfmt.formatter
<<[[Html_disp.machine]] formatter stack methods>>
<<[[Html_disp.machine]] formatter misc methods>>

(* special tags *)
<<[[Html_disp.machine]] embedded fields>>
<<[[Html_disp.machine]] image methods>>
<<[[Html_disp.machine]] fragment method>>

(* misc *)
<<[[Html_disp.machine]] i18 methods>>
<<[[Html_disp.machine]] other fields>>
@
%todo: 
% base and target? why need that? ctx already have the base document
% anyway



<<class [[Html_disp.machine]]>>=
class  virtual machine (_unit : unit) =
 object
   <<[[Html_disp.machine]] virtual fields signatures>>
end
@




\section{Summary}

%type (async) retriever?
%type viewer?
 %type formatter?
 %type interpreter?

%type cacher




%******************************************************************************
\chapter{[[main()]]}
%******************************************************************************

<<type [[Main.caps]]>>=
(* Need:
 *  - Cap.network: obviously, this is a Web browser
 *  - open_in: for ??
 *)
type caps = < 
   Cap.open_in;
   Cap.network
 >
@

<<[[Main.main()]] locals>>=
let init_urls = ref [] in
@
% possible command line arguments, 
%   $ mmm http://www.google.com

% _ -> Main.postmortem -> <>
<<function [[Main.main]]>>=
let main (caps : < caps; Cap.stdout; Cap.stderr; .. >)
         (argv : string array) : Exit.t =
  <<[[Main.main()]] tk backends setup>>

  (* As always, we must parse argument first, using references... *)
  <<[[Main.main()]] locals>>
  let level = ref (Some Logs.Warning) in

  let options = ([
   <<[[Main.main()]] command line options>>
  ] @ Logs_.cli_flags level) |> Arg.align
  in
  Arg_.parse_argv caps argv options
    (fun s -> init_urls := s :: !init_urls)
    usage_str
  ;
  Logs_.setup !level ();
  Logs.info (fun m -> m "ran as %s from %s" argv.(0) (Sys.getcwd()));
  <<[[Main.main()]] signal handling>>
  <<[[Main.main()]] initialisation>>

  let url_opt = 
    match !init_urls with 
    | []     -> None 
    | x::_l -> Some x
  in
  let user_preferences_file : Fpath.t =
    <<[[Main.main()]] user preferences file>>
  in
  (* Start the initial navigator *)
  Mmm.initial_navigator caps user_preferences_file url_opt;

  safe_loop();
  <<[[Main.main()]] after event loop, if debug mode>>
  Exit.OK
@
%$


% file pref and url opt
<<signature [[Mmm.initial_navigator]]>>=
val initial_navigator : < Cap.network; .. > ->
  Fpath.t (* preference file *) -> string (* url *) option -> unit
@



XXX
<<[[Main.main()]] tk backends setup>>=
Error.default                    := new Tk_error.t Widget.default_toplevel;
Condition.backend                := Tk_condition.backend ();
Timer_.add_ref                   := (fun a b -> Timer.add a b |> ignore);
Timer_.set_ref                   := Timer.set;
Low.update_idletasks_backend     := Tk.update_idletasks;
Fileevent_.add_fileinput_ref     := Fileevent.add_fileinput;
Fileevent_.remove_fileinput_ref  := Fileevent.remove_fileinput;
Fileevent_.add_fileoutput_ref    := Fileevent.add_fileoutput;
Fileevent_.remove_fileoutput_ref := Fileevent.remove_fileoutput;
Document.add_log_backend         := Tk_document.add_log;
Maps.broadcast_backend           := Frx_synth.broadcast;
Auth.open_passwd_ref             := Frx_req.open_passwd;
Auth.edit_backend                := Tk_auth.edit;
Mailto.internal_backend          := Tk_mailto.internal;
@




\section{Initialisations}

<<[[Main.main()]] initialisation>>=
<<[[Main.main()]] tk initialisation>>
<<[[Main.main()]] resource initialisation>>
<<[[Main.main()]] tk libs initialisation>>
<<[[Main.main()]] local initialisation>>
<<[[Main.main()]] suffix initialisation>>
<<[[Main.main()]] misc initialisation>>
<<[[Main.main()]] html entities initialisation>>
<<[[Main.main()]] applet system initialisation>>
<<[[Main.main()]] mmm server initialisation>>
@
% for suffix, html entities, applet and mmm server, see
% in later chapters.

\subsection{Graphics initialisation}

<<[[Main.main()]] tk initialisation>>=
let top = Tk.openTkDisplayClass !display "mmm" in
Wm.withdraw top;
(* Load tkimg if available so Tk can handle JPEG (and TIFF) natively.
   On Debian/Ubuntu install: sudo apt-get install libtk-img *)
(try Protocol.tkCommand [|Protocol.TkToken "package";
                           Protocol.TkToken "require";
                           Protocol.TkToken "Img"|]
 with Protocol.TkError _ ->
   Logs.info (fun m -> m "tkimg not available; JPEG will use %s fallback"
     !Img.ImageData.jpeg_converter));
@
% withdraw??
% class? for preference file later?
% actually top is not passed around, the navigator will
% create the toplevel widget

%(*
%(* Just after the init. of Tk, we have to detect the Tk is under
% * Latin or Japanese mode at first. 
% *)
%Lang.japan := Jtk.is_japanese_mode () && Lang.is_japanese ();
%(* Run Tcl in JIS (ISO2022-jp) Mode *)
%if !Lang.japan 
%then Jtk.Kanji.internal_code_set Jtk.JIS;
%*)


% main -> Tk.openTkDisplayClass(<>)
<<[[Main.main()]] locals>>=
let display = ref (try Sys.getenv("DISPLAY") with Not_found -> "") in
@
<<[[Main.main()]] command line options>>=
"-d", Arg.String (fun s -> display := s),
" <foo:0> Display";
@
<<[[Main.main()]] command line options>>=
"-display", Arg.String (fun s -> display := s),
" <foo:0> Display";
@



<<[[Main.main()]] tk libs initialisation>>=
(* Initialisations in frx library : kbd navigation, search 
 * No prerequisite except Tk *)
Frx_text.init ();
(* Initialisations in jpf's balloon library *)
Balloon.init ();
(* Initialisations in jpf's GIF ANIMATION library *)
(* TODO: Tkaniminit.f (); linking problem *)
@
% Frx = francois rouaix extensions

\subsection{Resources initialisation}
% and localization

% site file
<<[[Main.main()]] resource initialisation>>=
(* Default values for navigator window 
 * old: was 640x480, but does not seem to fully work, xwininfo returns 
 * different values of the one specified below.
 *)
Resource.add "*MMM.Width" "2024" Tk.WidgetDefault;
Resource.add "*MMM.Height" "1768" Tk.WidgetDefault;

(* Resources *)
let site_resfile =
  localize (Fpath.v (Filename.dirname argv.(0)) / "data/MMM.ad") in
(* Site specific resource file usually in INSTALLDIR=/usr/local/lib/mmm *)
if Sys.file_exists !!site_resfile 
then  begin
    Logs.info (fun m -> m "loading resource startup file %s" !!site_resfile);
    Tkresource.readfile !!site_resfile Tk.StartupFile
end;
@

<<function [[Main.localize]]>>=
let localize (file : Fpath.t) : Fpath.t =
  let localized = spf "%s.%s" !!file !I18n.language in
  if Sys.file_exists localized 
  then Fpath.v localized 
  else file
@
% see more later in i18n chapter



\subsection{Local initialisation}
% bad section title

<<[[Main.main()]] local initialisation>>=
(* Local initialisations *)
Low.init();                         (* start regular tasks *)
Cache.init();                       (* builtin document *)
Auth.init();                        (* start expiration timer *)
Debug.init();                       (* debugging RPC *)
@
%Low.init(), see Concurrency chapter
%Cache.init(), see next section
%Auth.init(), see Security chapter
%Debug.init(), see Debugging in appendix

\subsection{Initial fake URL and HTML document}

% could maybe be moved earlier, but make connections with
% different structures we've seen in the core DS chapter.

<<signature [[Cache.init]]>>=
val init : unit -> unit
@
% main -> <>
<<function [[Cache.init]]>>=
let init () =
  let initurl = Lexurl.make (Version.initurl (Lang.lang ())) in

  let b = Ebuffer.create 128 in
  Ebuffer.output_string b (Version.inithtml (Lang.lang ()));

  let docid = { document_url = initurl; document_stamp = Document.no_stamp; } in
  let doc = { 
    document_headers = ["Content-Type: text/html"];
    document_data = MemoryData b;
    document_address = initurl;
  } in
  let docentry = { 
    cache_document = doc;
    cache_pending = false;
    cache_condition = Condition.create();
    cache_lastused = max_lastused;
  }
  in

  memory := [docid, docentry];
  current := 1
@
% not pending, it is there!

<<signature [[Version.initurl]]>>=
val initurl : string -> string (* fake initial url *)
@
% Help menu | Cache.init -> <>
<<function [[Version.initurl]]>>=
(* MUST BE NORMALIZED *)
let initurl = function
  | "iso8859" -> 
      Printf.sprintf "http://pauillac.inria.fr/mmm/v%d/about.html" number
  | s -> failwith (Printf.sprintf "language not supported: %s" s)
@
% comment? NORMALIZED?

% so Version.initurl and Version.html

<<signature [[Version.html]]>>=
val inithtml : string -> string    (* fake initial document *)
@
%old: I rename inithtml, to match initurl
%less: type language = string
<<function [[Version.html]]>>=
let inithtml = function
  | "iso8859" ->
"<HTML>
  <HEAD><TITLE>MMM 0." ^ version_number ^ "</TITLE></HEAD>
<BODY>
<H1> The MMM navigator Version 0." ^ version_number ^ "</H1>
<H2 ALIGN=CENTER> Written by Fran\231ois Rouaix </H2>
<H2 ALIGN=CENTER> Contributions by Jun P. Furuse and Jacques Garrigue</H2>
<H3 ALIGN=CENTER> Port to O'Caml V3.0 by Jun P. Furuse and Pierre Weis</H3>
<H2 ALIGN=CENTER> \169 Copyright INRIA </H2>

<H4 ALIGN=CENTER> Using Objective Caml \169 Copyright INRIA </H4>
<H4 ALIGN=CENTER> And Tcl8.0/Tk8.0 (John Ousterhout and al.)<BR>
 \169 Copyright The Regents of the University of California<BR>
 and Sun Microsystems, Inc </H4>
<BLOCKQUOTE>
Please note that the software is a product currently being developed.
INRIA shall not be responsible in any way concerning conformity, and in
particular shall not be liable should the software not comply with the
requirements of the user, INRIA not being obliged to repair any
possible direct or indirect damage.
</BLOCKQUOTE>
<P>
The MMM home page is 
<A HREF='http://pauillac.inria.fr/mmm/'>here</A>,
and there is also some
<A HREF='http://pauillac.inria.fr/mmm/doc.html'>documentation</A>
and
<A HREF='http://pauillac.inria.fr/mmm/releases.html'>release notes</A>.
<BR>
Join the author by clicking
<A HREF='mailto:Francois.Rouaix@inria.fr'>here.</A>
<P>
<BLOCKQUOTE>
This document is included in your browser. Click on <TT>Reload</TT> to
get an updated copy.
</BLOCKQUOTE>
</BODY>
</HTML>
"
  |  s -> failwith (Printf.sprintf "language %s not supported here" s)
@
%$




\section{[[Mmm.initial_navigator()]]}

% in main():
%  (* Start the initial navigator *)
%  Mmm.initial_navigator user_preferences_file url_opt |> ignore;

% main -> <>
<<function [[Mmm.initial_navigator]]>>=
(* main -> <> -> navigator *)
let initial_navigator (caps : < Cap.network; ..>)
    (preffile : Fpath.t) (init_url : string option) : unit =
  <<[[Mmm.initial_navigator()]] set preferences>>
  <<[[Mmm.initial_navigator()]] set initial page based on [[init_url]]>>
  main_navigator :=
     navigator caps true 
       (match !initial_page with Some u -> u | None -> assert false)
@
%old: used to return !main_navigator, but it was ignored anyway
% so I simplified the code

% main_navigator will be described far later, it's for multi windows
% navigator

<<signature [[Mmm.navigator]]>>=
val navigator : < Cap.network; .. > ->
  bool (* is_main_window *) -> Url.t -> Nav.t option
@
% bool is for main_window (was called has_tachy)


% the set preferences will be exposed in extra features,
% let's focus for now on initial URL and navigator call

\subsection{Initial URL}

<<constant [[Mmm.initial_page]]>>=
let initial_page : Url.t option ref = ref None
@
% why need to store? if create a new window?

<<[[Mmm.initial_navigator()]] set initial page based on [[init_url]]>>=
initial_page := Some (
   match init_url with
   | None -> Lexurl.make !Mmmprefs.home
   | Some x -> 
       (try Lexurl.make x 
        with _ -> (* If fails, try to use file: *)
         <<[[Mmm.initial_navigator()]] if cannot parse [[init_url]]>>
       )
);
@
% why need to store that? can't just be a let?
% again I think it's because of the multi windows

<<[[Mmm.initial_navigator()]] if cannot parse [[init_url]]>>=
let path = 
  if x.[0] = '/' 
  then x
  else Filename.concat (Unix.getcwd ()) x
in
Lexurl.make ("file://localhost" ^ path)
@
% so can do
%    $ ./mmm docs/website/tech.html
% cool :)

% will trigger the FILE protocol and protocols/File.ml proto retriever

\subsection{[[Mmm.navigator()]] and [[Nav.t]]}


% main -> Mmm.initial_navigator -> <>(, true, )
<<function [[Mmm.navigator]]>>=
(* (main -> initial_navigator) | navigator -> <> -> Nav.absolutegoto *)
let rec navigator (caps: < Cap.network; ..>)
        (is_main_window: bool) (initial_url : Url.t) : Nav.t option =
  <<[[Mmm.navigator()]] new navigator hook>>

  (* The first navigator is named, so we can put special information in
   * window manager configurations, such as sticky (??)
   *)
  let top = 
    if is_main_window
    then Toplevel.create_named Widget.default_toplevel "mmm" [Class "MMM"]
    else Toplevel.create       Widget.default_toplevel       [Class "MMM"]
  in
  Wm.title_set top (s_ "MMM Browser");
  <<[[Mmm.navigator()]] setup top packing>>

  <<[[Mmm.navigator()]] locals>>

  (* protect all the other initialisations *)
  try 
    (* The frame in which a viewer might want to display *)
    let viewer_frame = Frame.create_named top "viewer" [] in
    
    <<[[Mmm.navigator()]] locals before nav setting>>
    let nav = Nav.{ 
      <<[[Mmm.navigator()]] set nav fields>>
    }
    in
    <<[[Mmm.navigator()]] nested functions>>
    <<[[Mmm.navigator()]] keyboard shortcuts setting>>
    <<[[Mmm.navigator()]] widgets setting>>

    Nav.absolutegoto caps nav (Url.string_of initial_url);
    Some nav

  with e -> 
    Error.f (s_ "Can't view initial document: %s\n%s"
                           (Url.string_of initial_url)
                           (Printexc.to_string e));
    if !navigators = 1 then begin
      Tk.destroy Widget.default_toplevel;
      raise e
    end 
    <<[[Mmm.navigator()]] exn handler, when multiple navigators>>
@
% => top widget

% will see s_ later in i18 chapter.

% absolutegoto!! initiate the whole thing!

<<signature [[Nav.absolutegoto]]>>=
val absolutegoto : < Cap.network; ..> ->
  t -> string (* url *) -> unit
@



<<[[Mmm.navigator()]] locals before nav setting>>=
<<local [[Mmm.navigator.hist]]>>
<<local function [[Mmm.navigator.show_current]]>>
<<local function [[Mmm.navigator.add_hist]]>>
<<local object [[Mmm.navigator.error]]>>
<<local [[Mmm.navigator.loggingv]]>>
<<local [[Mmm.navigator.actives]]>>
@


<<[[Mmm.navigator()]] nested functions>>=
(* The navigation functions *)

<<function [[Mmm.navigator.back]]>>
<<function [[Mmm.navigator.forward]]>>
<<function [[Mmm.navigator.reload]]>>
<<function [[Mmm.navigator.update]]>>

(* A bunch of other functions *)

<<function [[Mmm.navigator.abort]]>>
<<function [[Mmm.navigator.open_sel]]>>
<<function [[Mmm.navigator.open_file]]>>
<<function [[Mmm.navigator.save]]>>
<<function [[Mmm.navigator.print]]>>
<<function [[Mmm.navigator.close]]>>
<<function [[Mmm.navigator.really_quit]]>>
<<function [[Mmm.navigator.gohome]]>>
<<function [[Mmm.navigator.redisplay]]>>
<<function [[Mmm.navigator.add_to_hotlist]]>>
<<function [[Mmm.navigator.load_images]]>>
<<function [[Mmm.navigator.view_source]]>>
@



%\subsection{[[Nav.t]]}

% this will be passed down to the viewer, so that the viewer callbacks
% can call callbacks/methods from the navigator
<<type [[Nav.t]]>>=
type t = {
  nav_viewer_frame : Widget.widget;

  (* Nav.absolutegoto -> request -> process_viewer -> <> *)
  nav_show_current: Viewers.display_info -> string option (* frag *) -> unit;

  <<[[Nav.t]] manage history methods>>
  <<[[Nav.t]] manage active connections methods>>

  <<[[Nav.t]] graphic cache related methods>>
  <<[[Nav.t]] error methods>>
  <<[[Nav.t]] logging method>>

  <<[[Nav.t]] other fields>>
 }
@
% this will be full of hooks. It's a form of context, but
% general context. There will be also a viewer_context which
% will be a subset of Nav.t

<<[[Mmm.navigator()]] set nav fields>>=
nav_viewer_frame = viewer_frame;
@
% viewer_frame created before



\subsection{[[Nav.absolutegoto()]]}

% navigator -> (enter on URL entry | explicit call)  -> <>
<<function [[Nav.absolutegoto]]>>=
(* Used outside an hyperlink *)
(* main -> Mmm.initial_navigator -> Mmm.navigator -> <> -> follow_link -> 
 *  request -> Retrieve.f -> Http.req (via protos) -> 
 *   process_viewer (via cont) -> 
 *    Viewer.f (as di); nav.nav_show_current di -> Mmm.show_current
 * 'open URL:' entry | Mmm.navigator.open_sel | ... -> <>
 *)
let absolutegoto (caps : < Cap.network; ..>) (nav : t) (uri : string) =
  follow_link caps nav (Hyper.default_link uri)
@
%old: duplicated code
%  let follow_link = 
%    request nav true id_wr 
%      (process_viewer true make_ctx) (specific_viewer true)
%  in

<<signature [[Nav.follow_link]]>>=
val follow_link : < Cap.network; ..> ->
  t -> Hyper.link -> unit
@
<<function [[Nav.follow_link]]>>=
let follow_link (caps : < Cap.network; ..>)
     (nav : t) (lk : Hyper.link) : unit =
  lk |> request caps nav (fun (nav : t) (wr : Www.request) (dh : Document.handle) -> 
      process_viewer true (make_ctx caps) nav wr dh
    )
    <<[[Nav.follow_link]] extra arguments to Nav.request>>
@
% true is to add in history, but when we don't want to history?
% when we actually go back and do a historygoto!
%less: when process_viewer is passed another make_ctx? could inline then?

%toc:
% Fundamental functions: 
%  - request (ultimately Retrieve.f),
%  - process_viewer (ultimately Viewers.f)
%    and make_ctx

<<signature [[Nav.request]]>>=
val request : < Cap.network; ..> ->
  t -> (t -> Www.request -> Document.handle -> unit) ->
  <<[[Nav.request]] signature, extra arguments>>
  Hyper.link -> 
  unit
@
%old: wow, complicated type, so I changed order and LP aspectize the hooks!

<<signature [[Nav.make_ctx]]>>=
val make_ctx : < Cap.network; ..> ->
  t -> Document.id -> Viewers.context
@

\subsection{[[Nav.request()]]}


% so take a callback taking 
%  - a context (Nav.t), 
%  - question (Www.request), 
%  - and answer (Document.handle)
% but to be able to call this callback, we need some glue around,
%  because we have retrievers, and viewers, but here we connect them.

<<function [[Nav.request]]>>=
(* [request nav usecache wrapwr process specific] produces a function that
   takes an hyperlink, and apply the given behavior to it.
   [usecache] : do we look in the cache to see if we have it already
   [process nav wr dh] : what to to with the retrieved document
   [specific nav did wr] : some specific behavior, checked before we
     look in the cache. Must either raise Not_found or process completely
     the link
   [wrapwr wr] : returns a modified wr
 *)
let request (caps : < Cap.network; ..>) (nav : t)
     process (usecache, wrapwr, specific) = 
  fun (lk : Hyper.link) ->

  <<function [[Nav.request.retrieve_and_handle]]>>
  <<function [[Nav.request.handle_wr]]>>
  <<function [[Nav.request.handle_link]]>>
  handle_link lk
@
%old: I eta expanded with lk, again


% link -> wr -> ...
<<function [[Nav.request.handle_link]]>>=
and handle_link (h : Hyper.link) : unit =
  try (* Convert the link into a request *)
    let wr = Plink.make h in
    wr.www_error <- nav.nav_error;
    wr |> wrapwr |> handle_wr
  with
  | Hyper.Invalid_link _msg ->
      nav.nav_error#f (s_ "Invalid link")
  | Www.Invalid_request (wr, msg) ->
      nav.nav_error#f (s_ "Invalid request %s\n%s"(Url.string_of wr.www_url)msg)
in
@

<<signature [[Plink.make]]>>=
val make : Hyper.link -> Www.request
    (* [make hlink] is an error correcting version of Www.make
       For invalid links, a dialog box is displayed and offers
       edition facilities
     *)
@


% wr (-> cache) -> ...
<<function [[Nav.request.handle_wr]]>>=
(* Wrapper to deal with general/specific cache *)
and handle_wr (wr : Www.request) : unit =
  try
    match wr.www_url.protocol with
    <<[[Nav.request.handle_wr()]] match protocol special cases>>
    | _ ->
       if (not usecache) || dont_check_cache wr 
       then retrieve_and_handle wr
       else
         <<[[Nav.request.handle_wr()]] if use cache>>
  with Duplicate url ->
    wr.www_error#f (s_ "The document %s\nis currently being retrieved for some other purpose.\nMMM cannot process your request until retrieval is completed." (Url.string_of url))
@
% you want exception analysis ... this gets tricky

<<function [[Nav.request.retrieve_and_handle]]>>=
(* Normally execute the request and process its answer (dh) *)
(* handle_link -> handle_wr -> <> *)
let rec retrieve_and_handle (wr : Www.request) =
  let cont = 
    Document.{ document_process = (fun dh ->
        process nav wr dh;
        nav.nav_rem_active wr.www_url
      );
      document_finish = (fun _ -> 
        nav.nav_rem_active wr.www_url
      );
    }
  in
  (* ! Retrieve ! *)
  match Retrieve.f caps wr handle_link cont with
  | Retrieve.Started aborter -> 
      nav.nav_add_active wr.www_url aborter
  | Retrieve.InUse -> 
      raise (Duplicate wr.www_url)
@
% will see Retrieve.f later      
% will see the nave_rem_active later? or put it here maybe?

% pass down handle_link again?? it's for retry_link, which
% is useful for ?? for redirect?

%todo: why pass process to Nav.request? it changes? It's not
% always process_viewer?

\subsection{[[Nav.process_viewer()]]}

% Nav.absolutegoto | ... -> Nav.request -> <> 
%  (as Nav.request.process <- follow_link (<>) <- Nav.absolutegoto )
% control-flow and data-flow to fully understand with those callbacks and continuations
<<function [[Nav.process_viewer]]>>=
(* Specific handling of "view" requests 
 * Nav.absolutegoto -> Nav.follow_link -> Nav.request <> -> <> (via process)
 *  -> Viewers.f -> Htmlw.viewer | Plan.viewer
*)
let process_viewer (addhist : bool) make_ctx = 
 fun nav _wr (dh : Document.handle) ->
  let ctx = make_ctx nav dh.document_id in
  (* ! Viewers ! *)
  match Viewers.f nav.nav_viewer_frame ctx dh with
  | None -> () (* external viewer *)
  | Some di ->
      <<[[Nav.process_viewer()]] add in cache and history the document>>
      nav.nav_show_current di dh.document_fragment
@
% using dh.document_headers, we can dispatch to the appropriate
% viewer and get the graphic! Then we can show it in the nav at the right
% place. 
% We Finally made the link from a user URL request -> graphic display!

% so request -> retriever -> viewer -> display_info

% will see viewer later, Viewers.view, and make_ctx
% will see nav.nav_show_current later

%less: _wr is not used, anyway info is in dh no?

\subsection{[[Mmm.show_current()]]}

% Nav.absolutegoto -> request -async-> process_viewer -> <>
% second argument is fragment
<<[[Mmm.navigator()]] set nav fields>>=
nav_show_current = show_current;
@
<<local function [[Mmm.navigator.show_current]]>>=
(* Change view, independently of history manip *)
(* Nav.absolutegoto -> Nav.request -> Nav.process_viewer -> <>
 *   (as Nav.nav_show_current) 
 *)
let show_current (di : Viewers.display_info) (frag : string option) =
  <<[[Mmm.navigator.show_current()]] start hook>>
  <<[[Mmm.navigator.show_current()]] possibly undisplay previous displayinfo>>
  display di;
  <<[[Mmm.navigator.show_current()]] goto fragment>>
  <<[[Mmm.navigator.show_current()]] end hook>>
in
@
%less: need to set entryv? should be good already no?
% or is it if we switch?

<<function [[Mmm.display]]>>=
let display (di : Viewers.display_info) = 
  if Winfo.exists di#di_widget
  then pack [di#di_widget][Fill Fill_Both; Expand true]
  else Error.f "fatal error: window was destroyed";

  <<[[Mmm.display()]] adjust title toplevel>>
@

% but where trigger actual display? ?? when build the display_info
%  it will create the widget and the graphics are in di#di_widget!


<<[[Mmm.display()]] adjust title toplevel>>=
let tl = Winfo.toplevel di#di_widget in
let title = s_ "MMM Browser@%s" di#di_title in
if Widget.known_class tl = "toplevel" 
then begin 
  Wm.title_set tl title; 
  Wm.iconname_set tl title
end
@

<<[[Mmm.navigator()]] locals>>=
let current_di : Viewers.display_info option ref = ref None in
@

<<[[Mmm.navigator.show_current()]] possibly undisplay previous displayinfo>>=
(match !current_di with
| Some olddi when olddi != di -> undisplay olddi
| _ -> ()
);
current_di := Some di;
@

<<function [[Mmm.undisplay]]>>=
let undisplay (di : Viewers.display_info) = 
  if Winfo.exists di#di_widget 
  then Pack.forget [di#di_widget]
@

XXX
<<[[Mmm.navigator.show_current()]] end hook>>=
(* Bof *)
Textvariable.set entryv (Url.string_of hist.h_current.h_did.document_url)
@


\subsection{[[make_ctx()]]}

<<function [[Nav.make_ctx]]>>=
let make_ctx (caps : < Cap.network; ..>)
     (nav : t) (did : Document.id) : Viewers.context = 
  ((new stdctx caps (did, nav))#init :> Viewers.context)
@



% who does not use a standard context?
% pass empty list empty vparams?
<<class [[Nav.stdctx]]>>=
(* WARNING: we take copies of these objects, so "self" must *not* be
 * captured in a closure (it would always point to the old object).
 * A new object is created for each new top viewer (follow_link).
 * AND for each frame_goto operation.
 *)
class stdctx (caps : < Cap.network; ..>) (did, nav) =
 object (self)
  inherit Viewers.context (did, []) as super
  (* val did = did *)
  (* val nav = nav *)  

  method log = nav.nav_log
  method init =

    (* a new context for a toplevel window *)
    let make_ctx (caps : < Cap.network; ..>) nav did = 
      ((new stdctx caps (did, nav))#init :> Viewers.context)
    in

    <<nested function [[Nav.stdctx.init.make_embed]]>>

    (* by default, use the cache, don't touch the request *)
    let follow_link (caps : < Cap.network; ..>) _ = 
      request caps nav (process_viewer true (make_ctx caps))
        (true, id_wr, specific_viewer true)

    and save_link (caps : < Cap.network; ..>) _ =
      request caps nav (process_save None)
         (true, id_wr, nothing_specific)

    and copy_link _ = 
      copy_link nav

    and head_link (caps : < Cap.network; ..>) = 
      let f = request caps nav process_head (true, id_wr, nothing_specific) in
      (fun _ hlink -> f (make_head hlink))

    and new_link _ = nav.nav_new

    in 

    <<nested function [[Nav.stdctx.init.frame_goto]]>>

    !user_navigation |> List.iter super#add_nav;

    ["copy", copy_link, s_ "Copy this Link to clipboard";
     "head", head_link caps, s_ "Headers of document";
     "save", save_link caps, s_ "Save this Link";
     "gotonew", new_link, s_ "New window with this Link";
     "goto", frame_goto caps, s_ "Open this Link";
    ] |> List.iter (fun (name, f, txt) ->
        self#add_nav (name, { hyper_visible = true; 
                              hyper_func = f; 
                              hyper_title = txt })
    );
    self

end
@

% user_navigation?

% what if comment this List.iter and add_nav? can't click on links?
% how can I activate save? right click on link?
% then could be moved to advanced features?



\subsection{XXX}

<<[[Nav.follow_link]] extra arguments to Nav.request>>=
(true, id_wr, specific_viewer true)
@
% all those true booleans ... hard to read
% specific_viewer is passed false when from historygoto

<<function [[Nav.id_wr]]>>=
let id_wr wr = wr
@
%todo: when want to pass something else? and want to transform the wr?

<<[[Nav.request]] signature, extra arguments>>=
( bool * 
  (Www.request -> Www.request) * 
  (t -> Document.id -> Www.request -> unit)
) ->
@



\section{The event loop}

<<function [[Main.safe_loop]]>>=
let rec safe_loop () =
  try
    Printexc.print Tk.mainLoop () (* prints and reraises *)
  with
  | Out_of_memory -> raise Out_of_memory
  | Sys.Break -> raise Sys.Break
  | Stack_overflow -> raise Stack_overflow
  | _e -> 
      flush Stdlib.stderr; 
      safe_loop()
@


%******************************************************************************
\chapter{Navigator Interface}
%******************************************************************************
% The chrome

\section{Layout}

% have seen before 
%  - top, Toplevel.create_named Widget.default_toplevel "mmm" [Class "MMM"]
%  - viewer_frame, Frame.create_named top "viewer" []

% top
%  hgroup
%   vgroup
%    menubar
%    entry
%    buttons
%  viewer_frame

<<[[Mmm.navigator()]] widgets setting>>=

(* Invariable part (the rest being the di stuff)
   hgroup: blah and tachymeter
 *)
let hgroup = Frame.create_named top "hgroup" [] in
let vgroup = Frame.create_named hgroup "vgroup" [] in (* Menus, open entry *)

(* Menus *)
let mbar = Frame.create_named vgroup "menubar" [] in
<<[[Mmm.navigator()]] setup menu>>
<<[[Mmm.navigator()]] setup open url entry>>

(* Navigation buttons *)
let buttons = Frame.create_named vgroup "buttons" [] in
<<[[Mmm.navigator()]] navigation buttons>>

<<[[Mmm.navigator()]] packing part one>>
(* Initial window only *)
if is_main_window then begin
  <<[[Mmm.navigator()]] set geometry if specified>>
  <<[[Mmm.navigator()]] set tachymeter>>
end;
<<[[Mmm.navigator()]] packing part two>>

<<[[Mmm.navigator()]] handling destroy event>>
Tkwait.visibility hgroup;

<<[[Mmm.navigator()]] call [[update_vhistory]]>>
<<[[Mmm.navigator()]] call [[touch_current]] to not swap displayed documents>>
@
%less: put call to update_vhistory close to absolutegoto? can
% exchange with touch_current? in both case they initialize things
% and initiate the "big bang"


<<[[Mmm.navigator()]] setup top packing>>=
(* the size of the navigator MUST NOT depend on what is displayed inside *)
(* Instead, we rely on defaults for class MMM, *MMM.Width, *MMM.Height   *)
Pack.propagate_set top false;
@

% menubar, buttons, entry, buttons
<<[[Mmm.navigator()]] packing part one>>=
pack [mbar][Anchor NW; Side Side_Top; Fill Fill_X];
pack [backb;homeb;forwardb;reloadb;abortb; loggingb]
       [Side Side_Left; Fill Fill_X];
pack [entry][Fill Fill_X; Expand true; Side Side_Bottom; Anchor SW];
pack [buttons][Fill Fill_X];
@

<<[[Mmm.navigator()]] packing part two>>=
(* Pack last to avoid lossage when resizing *)
pack [vgroup][Fill Fill_X; Expand true; Side Side_Left];
pack [hgroup][Fill Fill_X];
pack [viewer_frame][Fill Fill_Both; Expand true];
@


%\subsection{Destroy event}

<<[[Mmm.navigator()]] handling destroy event>>=
(* We receive this event for each children destroyed because we are
   a toplevel *)
bind top [[], Destroy] (BindSet ([Ev_Widget], (fun ei -> 
  if ei.ev_Widget = top then begin
    <<[[Mmm.navigator()]] destroy navigator hook>>
    (* we were destroyed by wm *)
    if !navigators = 0 && Winfo.exists Widget.default_toplevel
    then Tk.destroy Widget.default_toplevel
  end
)));
@


\section{Address bar}

<<[[Mmm.navigator()]] locals>>=
let entryv = Textvariable.create_temporary top in
@

<<[[Mmm.navigator()]] setup open url entry>>=
(* URL display and edit *)
let entry,e = 
  Frx_entry.new_label_entry vgroup (s_ "Open URL:") 
    (fun url -> Nav.absolutegoto caps nav url)
in
Entry.configure e [TextVariable entryv; TextWidth 40];
@
% Nav.absolutegoto()!!! fundamental feature of Web browser


\section{Canvas}


\section{History}

<<[[Nav.process_viewer()]] add in cache and history the document>>=
if addhist 
then nav.nav_add_hist dh.document_id dh.document_fragment;
@
% we add to hist when process_viewer is pass true to addhist,
% when we go forward. But when we explore history, we don't
% want to consider it as part of history

<<[[Nav.t]] manage history methods>>=
nav_add_hist : Document.id -> string (* fragment *) option -> unit;
@
<<[[Mmm.navigator()]] set nav fields>>=
nav_add_hist = add_hist;
@
% Nav.process_viewer -> <> (as nav.nav_add_hist <- Mmm.navigator)
<<local function [[Mmm.navigator.add_hist]]>>=
let add_hist (did : Document.id) (frag : string option) =
  History.add hist did frag;
  !update_vhistory ()
in
@

% this is a local because each navigator will have its own
% history
<<local [[Mmm.navigator.hist]]>>=
let hist = History.create 
  { document_url = initial_url; document_stamp = Document.no_stamp } in
@



\subsection{Back button}

<<[[Mmm.navigator()]] navigation buttons>>=
let backb = Button.create_named buttons 
  "back" [Text (s_ "Back"); Command back ] in
@

<<function [[Mmm.navigator.back]]>>=
(*  The cache may have been cleared, so the document may be lost.
 *  historygoto implements the proper logic for this, taking care
 *  of non-unique documents.
 *)
let back () = 
  match History.back hist with
  | None -> ()
  | Some (did, frag) -> 
      if not (Nav.historygoto caps nav did frag true) 
      then History.forward hist |> ignore
in
@

% see historygoto later in advanced feature chapter


\subsection{Forward button}

<<[[Mmm.navigator()]] navigation buttons>>=
let forwardb = Button.create_named buttons 
  "forward" [Text (s_ "Forward"); Command forward] in
@

<<function [[Mmm.navigator.forward]]>>=
let forward () =
  match History.forward hist with
  | None -> ()
  | Some (did, frag) -> 
      if not (Nav.historygoto caps nav did frag true) 
      then History.back hist |> ignore
in
@

% will see the code for history later

% see the history menu also later

\section{Home}

<<[[Mmm.navigator()]] navigation buttons>>=
let homeb = Button.create_named buttons "home"
  [ Text (s_ "Home"); Command gohome] in
@

<<function [[Mmm.navigator.gohome]]>>=
let gohome () = 
  Nav.absolutegoto caps nav !Mmmprefs.home
in
@
% Mmmprefs.home also used for init_url if not specified by user

<<signature [[Mmmprefs.home]]>>=
val home : string ref
@
<<constant [[Mmmprefs.home]]>>=
(* There is no right place for this *)
let home = ref ""
@

TODO: so why go to mmm homepage by default???
special magic somewhere?

 
\section{Menus}

<<[[Mmm.navigator()]] setup menu>>=
<<function [[Mmm.navigator.configure_menu_elements]]>>

<<[[Mmm.navigator()]] MMM menu>>
<<[[Mmm.navigator()]] Navigation menu>>
<<[[Mmm.navigator()]] History menu>>
<<[[Mmm.navigator()]] Document menu>>
<<[[Mmm.navigator()]] Other menu>>
<<[[Mmm.navigator()]] Help menu>>
<<[[Mmm.navigator()]] User menu>>

pack [mmm; navb; docb; othersb][Side Side_Left];
pack [helpb; userb] [Side Side_Right];
@


\subsection{MMM menu}

<<[[Mmm.navigator()]] MMM menu>>=
(* MMM menu *)
let mmm = Menubutton.create_named mbar "mmm" [Text (s_ "MMM")] in
let mmmm = Menu.create_named mmm "menu" [] in
Menubutton.configure mmm [Menu mmmm];

configure_menu_elements mmmm [
  [Label (s_ "About")            ; Command About.f];
  [];
  [Label (s_ "New Window")       ; Command new_window];
  [Label (s_ "Open Selection")   ; Command open_sel];
  [Label (s_ "Open File...")     ; Command open_file];
  [Label (s_ "Save document...") ; Command save];
  [Label (s_ "Print document")   ; Command print];
  [Label (s_ "Preferences...")   ; Command !preferences];
  [];
  [Label (s_ "Close Window")     ; Command close];
  [];
  [Label (s_ "Quit")             ; Command really_quit]
];
@

<<signature [[About.f]]>>=
val f : unit -> unit
@
<<function [[About.f]]>>=
let f () =
  Frx_dialog.f Widget.default_toplevel 
    (Mstring.gensym "about") "About MMM" 
    (Version.about (Lang.lang ()))
    (Tk.Predefined "info") 
    0 
    ["Thanks"] |> ignore
@

<<function [[Mmm.navigator.open_sel]]>>=
let open_sel () =
  try 
    let url = Selection.get [] in
    Nav.absolutegoto caps nav url
  with _ -> ()
in
@

<<function [[Mmm.navigator.open_file]]>>=
let open_file () =
  Fileselect.f (s_ "Open File") (function
    | [] -> ()
    | [s] -> 
        let path = Msys.tilde_subst s in
        Nav.absolutegoto caps nav ("file://localhost/"^path)
    | _l -> raise (Failure "multiple selection")
   )
     "*" 
     ""
     false
     false
in
@

<<function [[Mmm.navigator.save]]>>=
let save () = 
  Save.document hist.h_current.h_did None 
in
@
% None??

<<signature [[Save.document]]>>=
val document : Document.id -> string option -> unit
@


% printing
<<function [[Mmm.navigator.print]]>>=
let print () = 
  Save.document hist.h_current.h_did (Some (sprintf "|%s" !Save.print_command))
in
@



<<function [[Mmm.navigator.close]]>>=
let close () =
  if !navigators = 1 
  then quit true
  else Tk.destroy top
in
@

<<function [[Mmm.navigator.really_quit]]>>=
let really_quit () = 
  quit false
in
@

<<function [[Mmm.quit]]>>=
let quit (confirm : bool) =
  if confirm then
    match 
     Frx_dialog.f Widget.default_toplevel (Mstring.gensym "quit")
      (s_ "Confirm") 
      (s_ "Do you really want to quit ?")
      (Predefined "question") 
      0 
      [s_ "Yep"; s_ "Nope"] 
    with
    | 0 -> Tk.destroy Widget.default_toplevel
    | _ -> ()
  else Tk.destroy Widget.default_toplevel
@

\subsection{Navigation menu}

<<[[Mmm.navigator()]] Navigation menu>>=
(* Navigation menu *)
let navb = Menubutton.create_named mbar "navigate" [Text (s_ "Navigate")] in
let navm = Menu.create_named navb "menu" [] in
Menubutton.configure navb [Menu navm];

configure_menu_elements navm [ 
  [Label (s_ "Home");    Command gohome];
  [Label (s_ "Back");    Command back];
  [Label (s_ "Forward"); Command forward];
  []
];
@
% we've seen those functions before

%\subsection{History submenu}

% because of mutual deps, needed for nav
<<[[Mmm.navigator()]] History menu>>=
(* The history menu is destroyed and rebuild each time. 
 * Deleting all entries will cause a callback leak since
 * entries are associated to the menu itself 
 *)
Menu.add_cascade navm [Label (s_ "History")];

let hmenu = ref (Menu.create_named navm "history" []) in 
update_vhistory := (fun () ->
  Tk.destroy !hmenu;
  hmenu := Menu.create_named navm "history" [];
  History.contents hist |> List.iter (fun (e : History.entry) ->
    let label = 
       Url.string_of e.h_did.document_url ^
       (match e.h_fragment with None -> "" | Some f -> "#"^f) ^
       (match e.h_did.document_stamp with 0 -> "" | n ->"("^string_of_int n^")")
    in
    Menu.add_command !hmenu 
       [Label label;
        Command (fun () ->
          let current = hist.h_current in
          History.set_current hist e;
          if not (Nav.historygoto caps nav e.h_did e.h_fragment true)
          then History.set_current hist current
         )
        ]
    );
    Menu.configure_cascade navm (Pattern (s_ "History")) [Menu !hmenu]
);
@
% why use ref for update_vhistory ?

% use forward ref because this will be called later
% navigator | ... -> <>
<<[[Mmm.navigator()]] locals>>=
let update_vhistory = ref (fun () -> ()) (* duh *) in
@

<<[[Mmm.navigator()]] call [[update_vhistory]]>>=
!update_vhistory();
@



\subsection{Document menu}

<<[[Mmm.navigator()]] Document menu>>=
let docb = Menubutton.create_named mbar "document" [Text (s_ "Document")] in
let docm = Menu.create_named docb "menu" [] in
Menubutton.configure docb [Menu docm];

configure_menu_elements docm [	    
  [Label (s_ "Abort")          ; Command abort];
  [Label (s_ "Reload")         ; Command reload];
  [Label (s_ "Update")         ; Command update_true];
  <<Document menu elements>>
];
@
% diff between update and reload?
% use update_true instead of a closure because of trick in 'shortcuts', see
%  below

% will see those features in Extra features chapter
% in Lifecycle control



\subsection{Other menu}

<<[[Mmm.navigator()]] Other menu>>=
(* Other stuff *)
let othersb = Menubutton.create_named mbar "others" [Text (s_ "Others")] in
let othersm = Menu.create_named othersb "menu" [] in
Menubutton.configure othersb [Menu othersm];

<<Other menu elements>>
@
% ???

\subsection{Help menu}

<<[[Mmm.navigator()]] Help menu>>=
(* Help menu *)
let helpb = Menubutton.create_named mbar "help" [Text (s_ "Help")] in
let helpm = Menu.create_named helpb "menu" [] in
Menubutton.configure helpb [Menu helpm];

<<Help menu elements>>
@


<<Help menu elements>>=
Menu.add_command helpm
  [Label (s_ "Version information");
   Command (fun () -> 
      Nav.absolutegoto caps nav (Version.initurl (Lang.lang ())))];
@
<<Help menu elements>>=
Menu.add_command helpm
  [Label (s_ "Home Page of MMM");
   Command (fun () -> 
     navigator caps false (Lexurl.make (Version.home_mmm (Lang.lang ()))) |>ignore)];
@
% false because not top_window this time

<<signature [[Version.home]]>>=
val home_mmm : string -> string    (* MMM home page *)
@
<<function [[Version.home]]>>=
let home_mmm = function 
  | "iso8859" -> "http://pauillac.inria.fr/mmm/"
  | _ -> assert false
@


\section{Status bar}
%less: it's actually on the right of the buttons for now,
% but should be in status bar I think

% important to give feedback to the user!
% not just progress bar but also what is done
% also allows to see what is under the cursor if click

<<[[Mmm.navigator()]] navigation buttons>>=
let loggingb = Label.create_named buttons "logging"
  [TextWidth 40; TextVariable loggingv; Anchor W] in
@

<<local [[Mmm.navigator.loggingv]]>>=
let loggingv = Textvariable.create_temporary top in
@


<<[[Nav.t]] logging method>>=
nav_log : string -> unit;
@
<<[[Mmm.navigator()]] set nav fields>>=
nav_log = (fun s -> 
  Logs.info (fun m -> m "%s" s);
  Textvariable.set loggingv s
);
@



<<[[Nav.t]] error methods>>=
nav_error : Error.t;			(* popping error dialogs *)
@
<<local object [[Mmm.navigator.error]]>>=
let error = new Tk_error.t top in
@
<<[[Mmm.navigator()]] set nav fields>>=
nav_error = error;
@
%Tk_error is really Mmm_tk_error.ml

\section{Keyboard shortcuts}

<<[[Mmm.navigator()]] keyboard shortcuts setting>>=
(* Short cuts *)

(* All the available shortcuts functions and their short cut keys. *)
(* If you put a new function with its short cut key here, then *)
(* Short cut string will be displayed automatically, when these *)
(* functions are added as menu elements. *)

(* Sorry, we use function equality, so we cannot use lambdas in the list *)
let update_true = fun () -> update true in

(* The shortcuts and the default settings *)
let all_short_cuts = [
  (* function    resource name      default key sequence *)
  About.f,       "About",           [[], KeyPressDetail "F1"]; 
  new_window,    "NewWindow",       [[Alt], KeyPressDetail "n"];
  open_sel,      "OpenSelection",   [[Alt], KeyPressDetail "y"];
  open_file,     "OpenFile",        [[Alt], KeyPressDetail "o"];
  save,          "Save",            [[Alt], KeyPressDetail "s"];
  print,         "Print",           [];
  !preferences,  "Preference",      [[Alt], KeyPressDetail "p"];
  close,         "Close",           [[Alt], KeyPressDetail "c"];
  really_quit,   "Quit",            [[Alt], KeyPressDetail "q"];

  gohome,        "Home",            [];
  back,          "Back",            [[Alt], KeyPressDetail "Left"];
  forward,       "Forward",         [[Alt], KeyPressDetail "Right"];
  reload,        "Reload",          [[Alt], KeyPressDetail "r"];
  abort,         "Abort",           [[], KeyPressDetail "Escape"];

  update_true,   "Update",          [[Alt], KeyPressDetail "u"];
  redisplay,     "Redisplay",       [[Control], KeyPressDetail "l"];
  add_to_hotlist, "AddToHotlist",   [[Alt], KeyPressDetail "a"];
  load_images,   "LoadImages",      [[Alt], KeyPressDetail "i"];
  view_source,   "ViewSource",      [[Alt], KeyPressDetail "e"]
] 
in

(* Real shortcuts information actually used *)
let my_short_cuts = 
 all_short_cuts |> List.map (fun (f,r,d) ->
  f, Tkresource.event_sequence ("shortcut" ^ r) d
 )
in

(* we break after each event so that All bindings, such as menu traversal,
 * dont get invoked if we destroyed the window for some reason
 * may be required only for things like reload
 *)
my_short_cuts |> List.iter (fun (f, eventl) -> 
  if eventl <> [] 
  then bind top eventl (BindSetBreakable ([], fun _ -> f(); break()))
);
@


<<function [[Mmm.navigator.configure_menu_elements]]>>=
let configure_menu_elements menu xs =
  let rec list_assoc_address k = function
    | [] -> raise Not_found
    | (k',v)::_ when k == k' -> v
    | _::xs -> list_assoc_address k xs
  in
  xs |> List.iter (fun l ->
    let opts = 
     List.fold_right (fun opt st ->
       (match opt with
       | Command f -> 
            Command f :: 
              (try
                [Accelerator (Tkresource.short_event_sequence
                               (list_assoc_address f my_short_cuts))]
              with Not_found -> []
              )
       | _ -> [opt])
       @ st
     ) l []
    in
    match opts with
    | [] -> Menu.add_separator menu
    | _  -> Menu.add_command menu opts
 )
in
@
% it's to associate shortcuts?

\section{Events}

XXX ???

<<signature [[Glevents.get]]>>=
val get : string -> (modifier list * xEvent) list 
@

<<signature [[Glevents.reset]]>>=
val reset : unit -> unit
@

<<constant [[Glevents.events]]>>=
(* A global table for describing events
 * TODO: use virtual events because here we don't change bindings in 
 * place after a preference reload
 *)
let events = Hashtbl.create 37
@

<<constant [[Glevents.builtin_defaults]]>>=
let builtin_defaults = [

  (* tachymeter bindings *)
  "tachy_about", [[], ButtonPressDetail 3];
  "tachy_gc",[[], KeyPressDetail "g"; [], KeyPressDetail "c"];
  "tachy_new", [[], ButtonPressDetail 1];
  "tachy_sel", [[], ButtonPressDetail 2];

  (* bindings on inlined images *)
  "loadimage", [[Control], ButtonPressDetail 1];
  "alt_imap", [[],ButtonPressDetail 1];	(* alt mode client side img map *)
  "stopanim",  [[], ButtonPressDetail 2];
  "restartanim", [[Shift], ButtonPressDetail 2];
  "copyimgurl", [[], ButtonPressDetail 2];
  "updateimage", [[Shift], ButtonPressDetail 2];

  (* anchor bindings *)
  "goto", [[], ButtonPressDetail 1];
  "save", [[Shift], ButtonPressDetail 1];
  "gotonew", [[], ButtonPressDetail 3];
  "hypermenu", [[Control], ButtonPressDetail 1];
]
@
% ???

<<constant [[Glevents.get]]>>=
let get = Hashtbl.find events
@

<<function [[Glevents.reset]]>>=
(* This is for preferences *)
let reset () =
  Hashtbl.clear events;
  (* Now: for all names defined in defaults, check a possible overriding value
     in resources *)
  List.iter (fun (name,default) ->
    Hashtbl.add events 
      name (Tkresource.event_sequence (sprintf "bind<%s>" name) default))
    builtin_defaults
@


%******************************************************************************
\chapter{Parsing}
%******************************************************************************
% www/ html/ http/

\section{URLs}

<<signature [[Lexurl.f]]>>=
val f : Lexing.lexbuf -> Url.t
@
%todo: rename?

<<signature [[Lexurl.make]]>>=
val make : string -> Url.t
   (* raise Url_Lexing(msg,pos) *)
@
<<function [[Lexurl.make]]>>=
let make s = 
  f (Lexing.from_string s)
@



% =~ protocol://user@host:port/paths?search

\subsection{Protocol}

<<function [[Lexurl.f]]>>=
(* We don't actually need all of this *)
rule f = parse
  [ 'a'-'z' 'A'-'Z' '0'-'9' '+' '.' '-' ]+ ":" 	(* absolute url *)
    { let lexeme = Lexing.lexeme lexbuf in
      let result =
        { protocol = HTTP; (* will be adjusted later *)
          user = None; password = None;
          host = None; port = None;
          path = None; search = None
         } 
      in
      let protocol =
        String.uppercase_ascii (String.sub lexeme 0 (String.length lexeme - 1)) in
      (match protocol with
      <<[[Lexurl.f]] protocol cases>>
      | s ->
          result.protocol <- OtherProtocol s;
          result.path <- any lexbuf
      );
      result
    }
 | _ { raise (Url_Lexing ("not an URL", Lexing.lexeme_start lexbuf)) }
@
% less: use 'as' of ocamllex so less need String.sub
% less: could have a Url.default()

<<[[Lexurl.f]] protocol cases>>=
| "HTTP" | "HTTPS" ->
    slashslash lexbuf;
    let h, po = hostport lexbuf in
    let pa, se = pathsearch lexbuf in
    let proto = 
      match protocol with 
      | "HTTP" -> HTTP
      | "HTTPS" -> HTTPS
      | _ -> raise (Impossible "see match cases above")
    in
    result.protocol <- proto;
    result.host <- h;
    result.port <- normalize_port (proto, po);
    result.path <- pa;
    result.search <- se
@
% no user?
% can see other protocols in section in advanced topics
%less: rewrite so less need to use <- and have mutable fields

<<function [[Lexurl.slashslash]]>>=
and slashslash =  parse
  "//" { () } 
| ""   { raise (Url_Lexing ("// expected", Lexing.lexeme_start lexbuf)) }
@

<<function [[Lexurl.normalize_port]]>>=
let normalize_port = function
  | HTTP, Some 80 -> None
  | HTTPS, Some 443 -> None
  | FTP, Some 21 -> None
  (* incomplete, but we don't care yet *)
  | _, p -> p
@

\subsection{Host, port}

<<function [[Lexurl.hostport]]>>=
(* _ is not legal in hostnames, but some people use it. *)
and hostport = parse
| ['A'-'Z' 'a'-'z' '0'-'9' '.' '-' '_']+ ':' ['0'-'9']+
    { let lexeme = Lexing.lexeme lexbuf in
      let pos = String.index lexeme ':' in
      let portstring =
        String.sub lexeme (succ pos) (String.length lexeme - 1 - pos) in
      Some (normalize_host (String.sub lexeme 0 pos)),
      Some (int_of_string portstring)
    }
| ['A'-'Z' 'a'-'z' '0'-'9' '.' '-' '_']+ 
    { Some (normalize_host (Lexing.lexeme lexbuf)), None }
| "" (* file:///home/... *)
    { None, None }
@
%less: use 'as' again

<<function [[Lexurl.normalize_host]]>>=
(* lowercase, don't use final . in FQDN *)
let normalize_host s = 
  let s = String.lowercase_ascii s in
  let l = String.length s in
  if s.[l-1] = '.' 
  then String.sub s 0 (l-1)
  else s
@

\subsection{Path, search}

<<function [[Lexurl.pathsearch]]>>=
(* /<path>?<search> *)
and pathsearch = parse
| "/" [^ '?']* '?' 
    { let lexeme = Lexing.lexeme lexbuf in
      let search = any lexbuf in
      Some (String.sub lexeme 1 (String.length lexeme - 2)), search 
    }
| "/" [^ '?']*
    { let lexeme = Lexing.lexeme lexbuf in
      Some (String.sub lexeme 1 (String.length lexeme - 1)), None 
    }
| "" 
    { None, None }
@
%less: use 'as'

<<functions [[Lexurl.xxx]]>>=
and any = parse
  [^ '\n']*  { Some (Lexing.lexeme lexbuf) }    (* in fact any char *)
@



\subsection{Normalization}

% how this normalize? because make() does a few normalization?
%  like normalize_host, normalize_port?
<<signature [[Lexurl.normalize]]>>=
val normalize : string -> string
@
<<function [[Lexurl.normalize]]>>=
let normalize (url : string) : string =
  let urlp = make url in
  Url.string_of urlp
@
%less: could rename make to of_string
%todo: rename normalize_host_and_port?



% make normalize
% for context parsing?
<<signature [[Lexurl.maken]]>>=
val maken : string -> Url.t
   (* raise Url_Lexing(msg,pos) *)
@
%todo: rename to make_normalize_host_port_path?
% Hyper.resolve -> <> (for the h_context for relative URI)
<<function [[Lexurl.maken]]>>=
(* Extra normalisation at lexing time 
 *  remove ../ and /. as in RFC 1630
 *  unquote %
 *)
let maken s =
  let url = make s in
  (match url.protocol with
  | HTTP ->  
      (match url.path with
      | None -> ()
      | Some p -> url.path <- Some (Urlenc.unquote (remove_dots p))
      )
  | _ -> ()
  );
  url
@

% it can not contain '#' because it's the fragment marker
% so at least need # to be escaped


\subsubsection{dots}

<<signature [[Lexurl.remove_dots]]>>=
val remove_dots : string -> string
@
% Lexurl.maken -> <>
<<function [[Lexurl.remove_dots]]>>=
let remove_dots s =
  let b = Ebuffer.create 32 in
  rev_do_list 
    (Ebuffer.output_string b)
    (pathcomponents (Lexing.from_string s) []);
  Ebuffer.get b
@

<<functions [[Lexurl.xxx]]>>=
and pathcomponents = parse
  [ ^ '/']* '/'
    { (fun l ->
         let newl = 
           match Lexing.lexeme lexbuf with
          | "./" -> l
           | "../" -> (match l with | [] -> [] | _ :: tl -> tl)
           | p -> (p :: l)
          in
        pathcomponents lexbuf newl)
     }
| [ ^ '/']+
    { (fun l -> 
        match Lexing.lexeme lexbuf with
        | "." -> l
        | ".." -> (match l with [] -> [] | _ :: tl -> tl)
        | p -> p :: l 
       )
    }
| "" { (fun l -> l) }
@
% why want to normalize? anyway the server will resolve no?


\subsubsection{Percents}

<<signature [[Urlenc.unquote]]>>=
(*-*)
val unquote : string -> string
@

<<function [[Urlenc.unquote]]>>=
let unquote s =
  try
    (* optim *)
    let _ = String.index s '%' in
    let l = String.length s in
    let target = Ebuffer.create l in
    let pos = ref 0 in
    (try
      while !pos < l do
       let perpos = String.index_from s !pos '%' in
       if perpos > !pos 
       then Ebuffer.output target s !pos (perpos - !pos);
       pos := perpos;
       if s.[!pos] = '%' && !pos + 2 < l  
       then begin
         let c = 16 * hex_to_dec s.[!pos+1] + hex_to_dec s.[!pos+2] in
         let substc = Char.chr c in
         if List.mem substc keep_quoted 
         then
           for _i = 0 to 2 do
             Ebuffer.output_char target s.[!pos];
             incr pos
           done
         else begin
             Ebuffer.output_char target (Char.chr c);
             pos := !pos + 3
         end
       end else begin
        Ebuffer.output_char target s.[!pos];
        incr pos
       end
     done;
     Ebuffer.get target
   with Not_found -> (* no more substitutions *)
     Ebuffer.output target s !pos (l - !pos);
     Ebuffer.get target
   )
  with Not_found -> s
@

<<constant [[Urlenc.keep_quoted]]>>=
(* Unquote an url path:
   We decode all % except those corresponding to significative
   characters for parsing: /, ?, #, sp, :
 *)
let keep_quoted = 
  ['/'; '?'; '#'; ' '; '\t'; '\r'; '\n'; ':'; '%'; '&'; '='; '+']
@


\subsection{Encoding}
% unparsing? escaping?

\subsubsection{Decoding}

% ??? -> <>
<<signature [[Urlenc.decode]]>>=
(* URL encoding *)
val decode : string -> string
@
<<function [[Urlenc.decode]]>>=
(* Decode escaped characters *)
(* Note: beware of order of splitting wrt '&' and decoding *)
let decode s =
  let l = String.length s in
  let target = Ebuffer.create l in
  let pos = ref 0 in
  while !pos < l do
    if s.[!pos] = '%' && !pos + 2 < l  then begin
       let c = 16 * hex_to_dec s.[!pos+1] + hex_to_dec s.[!pos+2] in
       Ebuffer.output_char target (Char.chr c);
    pos := !pos + 3
    end else if s.[!pos] = '+' then begin
      Ebuffer.output_char target ' ';
      incr pos
    end else begin
      Ebuffer.output_char target s.[!pos];
      incr pos
      end
  done;
  Ebuffer.get target
@
%less: rewrite match ()

\subsubsection{Encoding}

% ??? -> <>
<<signature [[Urlenc.encode]]>>=
val encode : string -> string
    (* encoding and decoding for an arbitrary string *)
@
<<function [[Urlenc.encode]]>>=
let encode s =
  let target = Ebuffer.create (String.length s) in
  for pos = 0 to String.length s - 1 do
    match s.[pos] with
      ' ' -> Ebuffer.output_char target '+'
    | '0'..'9' | 'a'..'z' | 'A'..'Z' as c -> Ebuffer.output_char target c
    | '\n' -> Ebuffer.output_string target "%0D%0A"
    | c -> Ebuffer.output_string target (hexchar c)
    done;
  Ebuffer.get target
@

<<function [[Urlenc.hexchar]]>>=
let hexchar c = 
  let s = Bytes.make 3 '%'
  and i = Char.code c in
  Bytes.set s 1 (dec_to_hex (i/16));
  Bytes.set s 2 (dec_to_hex (i mod 16));
  Bytes.to_string s
@


\subsubsection{Forms}
% see more in next chapter

<<signature [[Urlenc.form_decode]]>>=
val form_decode : string -> (string * string) list
    (* application/x-www-form-urlencoded encoding *)
@
<<constant [[Urlenc.form_decode]]>>=
let form_decode =
  let ampersand c = c = '&' and equals c = c = '=' in
  (function  s ->
     List.map (fun encp ->
       match split_str equals encp with
       [x;y] -> (decode x, decode y)
     | [x] -> (decode x, "")
     | _ -> invalid_arg "form_decode")
       (split_str ampersand s))
@



<<signature [[Urlenc.form_encode]]>>=
val form_encode : (string * string) list -> string
@
<<function [[Urlenc.form_encode]]>>=
let form_encode = function 
 | [] -> ""
 | (e,v)::l ->
    let b = Ebuffer.create 512 in
    Ebuffer.reset b;
    Ebuffer.output_string b (encode e);
    Ebuffer.output_char b '=';
    Ebuffer.output_string b (encode v);
    l |> List.iter (fun (e,v) ->
         Ebuffer.output_char b '&';
         Ebuffer.output_string b 
            (if !strict_form_standard 
             then encode e
             else e
             );
         Ebuffer.output_char b '=';
         Ebuffer.output_string b (encode v)
    ) ;
    Ebuffer.get b
@

<<signature [[Urlenc.strict_form_standard]]>>=
val strict_form_standard : bool ref
    (* if true, we take RFC1866 8.2.1 case 1 strictly, and encode any 
       non-alphanumeric character in the field name
       else, we encode only values, but not field names *)
@
<<constant [[Urlenc.strict_form_standard]]>>=
let strict_form_standard = ref true
@




\section{Links}

% Www.make -> <>
<<signature [[Hyper.resolve]]>>=
val resolve : link -> Uri.abs_uri
  (* raises Invalid_link(msg) *)
@
<<function [[Hyper.resolve]]>>=
(* Produces an URI *)
let resolve (link : link) : Uri.abs_uri =
  (* First remove the possible fragment of the uri *)
  let newuri, frag =
    try
       let pos = String.index link.h_uri '#' in
       String.sub link.h_uri 0 pos, 
       Some (String.sub link.h_uri (succ pos) 
                        (String.length link.h_uri - pos - 1))
    with Not_found -> link.h_uri, None 
  in
  if Uri.is_absolute newuri 
  then
    try
      { uri_url = Lexurl.normalize newuri;
        uri_fragment = frag 
      }
    with Url_Lexing _ ->
      raise (Invalid_link (LinkResolve (s_ "not a legal absolute uri")))

  else begin (* It is a relative uri *)
    let context =
      match link.h_context with 
      | None -> 
         raise (Invalid_link 
                 (LinkResolve (s_ "no context and not an absolute url")))
      | Some c -> c 
    in
    let contextp = 
       try Lexurl.maken context
       with Url_Lexing (err,pos) ->
             raise (Invalid_link (UrlLexing (err,pos)))
    in
    { uri_url = urlconcat contextp newuri;
      uri_fragment = frag
    }
  end
@
% will se urlconcat later
%old: (* Produces an URL *) but it's actually really an URI!


% Hyper.resolve -> <> (for relative links)
<<signature [[Hyper.urlconcat]]>>=
val urlconcat: Url.t -> string -> string
   (* [urlconcat url relurl] resolves the relative URL [relurl] in the
       context of the URL [url]
      Doesn't handle fragments
    *)
@
<<function [[Hyper.urlconcat]]>>=
(* parsed Absolute URL + URL -> Absolute URL *)
(* NO FRAGMENT HANDLING *)

let urlconcat (contextp : Url.t) (newuri : string) : string =
  let l = String.length newuri in 
  if l = 0 
  then string_of contextp 
  else 
   if l > 2 && newuri.[0] = '/' && newuri.[1] = '/' 
   then
      (* this is probably a gopher relative uri *)
      sprintf "%s:%s" (string_of_protocol contextp.protocol) newuri
   else 
     if newuri.[0] = '/' 
     then (* start from root *)
       string_of { contextp with 
                   path = Some (Urlenc.unquote 
                      (String.sub newuri 1 (String.length newuri - 1)));
                   search = None }
     else 
       if newuri.[0] = '?' 
       then (* change only search part *)
         string_of { contextp with
                     search = Some(String.sub newuri 1(String.length newuri-1))}
       else 
        let pathpart,searchpart =
         try
           let n = String.index newuri '?' in
           String.sub newuri 0 n,
           Some (String.sub newuri (n+1) (l - n - 1))
         with Not_found -> newuri, None
        in
        match contextp.path with
        | None | Some "" -> 
            string_of { contextp with
                        path=Some(Urlenc.unquote(Lexurl.remove_dots pathpart));
                        search = searchpart }
        | Some old ->
            (* only the "dirname" part of the context path is important *)
            (* e.g  .../d/e/f becomes /d/e/ *)
            let path = sprintf "%s/%s" (Filename.dirname old) pathpart in
            (* we then have to remove dots *)
            let reduced = Lexurl.remove_dots path in
            string_of { contextp with
                        path = Some (Urlenc.unquote reduced);
                        search = searchpart }
@
% todo: rewrite in match () with


% ??? -> <>
<<signature [[Hyper.parse_method]]>>=
val parse_method : string -> link_method
@
<<function [[Hyper.parse_method]]>>=
let parse_method = function
 | "GET" -> GET
 | "POST" -> POST ""
 | "HEAD" -> HEAD
 | _ -> raise Not_found (* other cases should be caught by caller ! *)
@



\section{HTML}

%https://html.spec.whatwg.org/multipage/syntax.html#parsing

\subsection{Lexing}

% see type Html.token in core DS

% ??? -> <>
<<signature [[Lexhtml.html]]>>=
val html : Lexing.lexbuf -> t -> warnings * Html.token * Html.location
@
% ??? -> <>
<<signature [[Lexhtml.cdata]]>>=
val cdata : Lexing.lexbuf -> t -> warnings * Html.token * Html.location
@

<<type [[Html.location]]>>=
type location = Loc of int * int
@
% start x end  charpos, classic
<<type [[Lexhtml.warnings]]>>=
type warnings = (string * int) list
@
% charpos



\subsubsection{Reentrant lexers}
% need that?
% put in concurrency section?

<<signature type Lexhtml.t>>=
type t
@
<<signature [[Lexhtml.new_data]]>>=
val new_data : unit -> t
    (* instance data for a lexer; must be allocated for each instance, in
       order to get reentrant lexers
     *)
@


<<type [[Lexhtml.t]]>>=
(* Smart hack to make lexers reentrant.
 * Make each action a function taking "private" data as argument.
 * Invoke each action with additionnal argument.
 *  
 * This works only because calls to actions in csllex generated code
 * are terminal.
 *)
type t = {
  buffer : Ebuffer.t;
  mutable start : int;
  (*mutable*) pos_fix : int
}
@

<<function [[Lexhtml.new_data]]>>=
let new_data () = {
  buffer = Ebuffer.create 512;
  start = 0;
  pos_fix = 0 
}
@
% only way to build abstract type t
% who change pos_fix??


\subsubsection{Helpers}

<<helper functions [[Lexhtml.xxx]]>>=
let noerr = []
@

<<helper functions [[Lexhtml.xxx]]>>=
let mk_start lexbuf lexdata =
  Lexing.lexeme_start lexbuf - lexdata.pos_fix
let mk_end lexbuf lexdata =
  Lexing.lexeme_end lexbuf - lexdata.pos_fix
let mk_loc lexbuf lexdata =
  Loc (mk_start lexbuf lexdata, mk_end lexbuf lexdata)
@





%japan
%and kanji = parse
%  | ['\033' - '\126']+ 
%    { (fun lexdata charset ->
%      match charset with
%    '\064' | '\066' | '\068' (* JISX0208/JISX0212 *) ->
%      let lexeme = Lexing.lexeme lexbuf in
%      let rawlength = String.length lexeme in
%      if rawlength mod 2 = 1 then 
%        Log.f ("Warning: Lexhtml: Odd bytes Kanji string length");
%      let klength = rawlength / 2 in
%      lexdata.pos_fix <- lexdata.pos_fix + klength;
%      Ebuffer.output_string lexdata.buffer lexeme;
%      kanji lexbuf lexdata charset
%      | _ -> raise (Failure (Printf.sprintf "Lexhtml: Unknown charset %d" 
%                   (Char.code charset))) 
%    )}
%  | ['\000' - '\026' '\028' - '\032' '\127'] (* Control codes *) 
%    { (fun lexdata charset ->
%      Ebuffer.output_char lexdata.buffer (Lexing.lexeme_char lexbuf 0);
%      kanji lexbuf lexdata charset )}
%  | ['\128' - '\255'] (* Right side *)
%    { (fun lexdata charset ->
%        raise (Failure "Lexhtml: Unexpected right side character") )}
%  | "" (* Must be escape *)
%    { (fun lexdata charset -> () )}


<<function [[Lexhtml.html]]>>=
rule html = parse
<<[[Lexhtml.html()]] rule cases>>
 | "\r\n" 
    { (fun lexdata ->
       lexdata.start <- mk_start lexbuf lexdata;
       Ebuffer.reset lexdata.buffer;
       Ebuffer.output_char lexdata.buffer '\n'; 
       text lexbuf lexdata )}
 | "\r" 
    { (fun lexdata ->
       lexdata.start <- mk_start lexbuf lexdata;
       Ebuffer.reset lexdata.buffer;
       Ebuffer.output_char lexdata.buffer '\n'; 
       text lexbuf lexdata )}
| eof 
    { (fun lexdata -> 
        (noerr, EOF, mk_loc lexbuf lexdata)) }
| _ { (fun lexdata ->
       lexdata.start <- mk_start lexbuf lexdata;
       Ebuffer.reset lexdata.buffer;
       Ebuffer.output_char lexdata.buffer (Lexing.lexeme_char lexbuf 0); 
       text lexbuf lexdata )}
@
%(*
% | "\027\036" '\040'? ['\064' - '\068'] (* KANJI *)
%     {(fun lexdata ->
%       let lexeme = Lexing.lexeme lexbuf in
%       let len = String.length lexeme in
%       lexdata.start <- Lexing.lexeme_start lexbuf - lexdata.pos_fix;
%       lexdata.pos_fix <- lexdata.pos_fix + len;
%       Ebuffer.reset lexdata.buffer;
%       Ebuffer.output_string lexdata.buffer lexeme;
%       let c = Lexing.lexeme_char lexbuf (len - 1) in
%       if !Lang.japan then kanji lexbuf lexdata c;
%       text lexbuf lexdata )}
%*)
% need all those \027\040\066 cases? japanese stuff?
% | "\027\040\066" (* ASCII *)
%    { (fun lexdata ->
%       lexdata.start <- mk_start lexbuf lexdata;
%       lexdata.pos_fix <- lexdata.pos_fix + 3;
%       Ebuffer.reset lexdata.buffer;
%       text lexbuf lexdata )}


\subsubsection{Comments}

<<[[Lexhtml.html()]] rule cases>>=
| "<!>" 
    { (fun lexdata ->
       noerr, Comment "", mk_loc lexbuf lexdata)}
@

<<[[Lexhtml.html()]] rule cases>>=
(* If you think it is possible to deal with malformed comments adaptatively,
   that is switching to lenient mode only after we detected an error
   in comment syntax, then ponder the following example: <!-- -- --> *)
 | "<!--"
    { (fun lexdata ->
       lexdata.start <- mk_start lexbuf lexdata;
       Ebuffer.reset lexdata.buffer;
       if !strict 
       then comment lexbuf lexdata
       else lenient_end_comment lexbuf lexdata
       )
    } 
@


<<function [[Lexhtml.lenient_end_comment]]>>=
(* call this ONLY if we are not in strict mode *)
and lenient_end_comment = parse
| "-->"
    {(fun lexdata -> 
      noerr, Comment (Ebuffer.get lexdata.buffer),
      Loc(lexdata.start, mk_end lexbuf lexdata))}
| _
    {(fun lexdata ->
      Ebuffer.output_char lexdata.buffer (Lexing.lexeme_char lexbuf 0);
      lenient_end_comment lexbuf lexdata )}
| ""
    {(fun lexdata ->
       raise (Html_Lexing ("unterminated comment", mk_start lexbuf lexdata))
    )}
@
%| "\027\040\066" (* ASCII *)
%    {(fun lexdata ->
%      lexdata.pos_fix <- lexdata.pos_fix + 3;
%      Ebuffer.output_string lexdata.buffer (Lexing.lexeme lexbuf);
%      lenient_end_comment lexbuf lexdata )}
%(*
%  | "\027\036" '\040'? ['\064' - '\068'] (* KANJI *)
%      {(fun lexdata ->
%    let lexeme = Lexing.lexeme lexbuf in
%    Ebuffer.output_string lexdata.buffer lexeme;
%    let len = String.length lexeme in
%    lexdata.pos_fix <- lexdata.pos_fix + len; 
%    let c = Lexing.lexeme_char lexbuf (len - 1) in
%    if !Lang.japan then kanji lexbuf lexdata c; 
%    lenient_end_comment lexbuf lexdata )}
%*)


<<function [[Lexhtml.comment]]>>=
(* we're looking for the end of a comment : skip all characters until next   *)
(*  -- included, and then look for next -- or > *)
and comment = parse
  (* normal case *)
| "--"
    { (fun lexdata -> 
       next_comment lexbuf lexdata)}
| _  
    { (fun lexdata ->
       Ebuffer.output_char lexdata.buffer (Lexing.lexeme_char lexbuf 0);
       comment lexbuf lexdata )}
| ""
    { (fun lexdata ->
       raise (Html_Lexing ("unterminated comment", mk_start lexbuf lexdata))
    )}
@
%| "\027\040\066" (* ASCII *)
%    { (fun lexdata ->
%       Ebuffer.output_string lexdata.buffer (Lexing.lexeme lexbuf);
%       lexdata.pos_fix <- lexdata.pos_fix + 3;
%       (* do nothing except position fix *)
%       comment lexbuf lexdata )}
%(*
%  | "\027\036" '\040'? ['\064' - '\068'] (* KANJI *)
%      {(fun lexdata ->
%    let lexeme = Lexing.lexeme lexbuf in
%    Ebuffer.output_string lexdata.buffer lexeme;
%    let len = String.length lexeme in
%    lexdata.pos_fix <- lexdata.pos_fix + len; 
%    let c = Lexing.lexeme_char lexbuf (len - 1) in
%    if !Lang.japan then kanji lexbuf lexdata c; 
%    comment lexbuf lexdata )}
%*)


<<function [[Lexhtml.next_comment]]>>=
(* the normal next comment search *)      
and next_comment = parse
    [' ' '\t' '\r' '\n']* "--"
    { (fun lexdata -> comment lexbuf lexdata )}
  | [' ' '\t' '\r' '\n']* '>'
    { (fun lexdata ->
      [],
      Comment (Ebuffer.get lexdata.buffer),
      Loc(lexdata.start, mk_end lexbuf lexdata))}
  | "" 
    { (fun lexdata ->
      raise (Html_Lexing ("invalid comment", mk_start lexbuf lexdata)))
     }
@



\subsubsection{Tags}

<<type [[Lexhtml.tagtoken]]>>=
type tagtoken =
 | Attribute of string * string
 | Closetag of int
 | Bogus of string * int   (* Bogus(s,n) == bug at pos [n] for reason [s] *)
@

% opening tags
<<[[Lexhtml.html()]] rule cases>>=
| '<' 
    { (fun lexdata ->
       lexdata.start <- mk_start lexbuf lexdata;
       opentag lexbuf lexdata
     )}
@

<<function [[Lexhtml.opentag]]>>=
(* TODO 2.0: 
 *   syntax for SHORTTAG YES (need to know the DTD for this !).
 *
 *)
and opentag = parse
| ['a'-'z' 'A'-'Z' '0'-'9' '.' '-']+
    { (fun lexdata ->
       let tagname = String.lowercase_ascii (Lexing.lexeme lexbuf) in
       let attribs = ref [] in
       let bugs = ref [] in
       let rec read_attribs () =
         match attrib lexbuf lexdata with
         | Closetag n -> 
             n
         | Attribute(p1, p2) ->
             attribs := (p1, p2) :: !attribs; 
             read_attribs()
         | Bogus (reason,pos) ->
             bugs := (reason,pos) :: !bugs; 
             read_attribs() 
       in
       let e = read_attribs() in
       (!bugs, 
       OpenTag {tag_name = tagname; attributes = List.rev !attribs },
       Loc(lexdata.start, e)
       )
      )}
  
(* Tolerance *)
| ""  
    { (fun lexdata ->
       Ebuffer.reset lexdata.buffer;
       Ebuffer.output_char lexdata.buffer '<';
       text lexbuf lexdata )}
@


% closing tags

<<[[Lexhtml.html()]] rule cases>>=
| '\n'? "</"
    { (fun lexdata ->
       lexdata.start <- mk_start lexbuf lexdata;
       closetag lexbuf lexdata
      )}
@

<<function [[Lexhtml.closetag]]>>=
and closetag = parse
  | ['a'-'z' 'A'-'Z' '0'-'9' '.' '-']+
    { (fun lexdata ->
        let lexeme = Lexing.lexeme lexbuf in
    let e = skip_to_close lexbuf lexdata in
    [],
    CloseTag (String.lowercase_ascii lexeme), Loc(lexdata.start,e))}
(* Tolerance *)
  | ""  
    { (fun lexdata ->
          Ebuffer.reset lexdata.buffer;
          Ebuffer.output_string lexdata.buffer "</";
          text lexbuf lexdata)}
@

<<function [[Lexhtml.skip_to_close]]>>=
and skip_to_close = parse
   [^'>']* '>' { (fun lexdata -> mk_end lexbuf lexdata)}
  | "" { (fun lexdata -> 
      raise (Html_Lexing ("unterminated tag", 
              mk_start lexbuf lexdata)) )}
@

\subsubsection{Attributes}

% opentag -> <>
<<function [[Lexhtml.attrib]]>>=
and attrib = parse
| [' ' '\t' '\n' '\r']+ 
    { (fun lexdata -> attrib lexbuf lexdata )}
| ['a'-'z' 'A'-'Z' '0'-'9' '.' '-']+ 
    { (fun lexdata ->
        let name = String.lowercase_ascii (Lexing.lexeme lexbuf) in
        try
          match tagattrib lexbuf lexdata with
          | Some s -> Attribute (name, s)
          | None -> Attribute (name, name)
        with Html_Lexing(reason,pos) -> 
          if !strict 
          then raise (Html_Lexing(reason,pos));
          Bogus(reason,pos)
      )}
  (* added '_' so we can parse Netscape bookmark files, 
      but it should NOT be there *)
| ['a'-'z' 'A'-'Z' '0'-'9' '.' '-' '_']+ 
    { (fun lexdata ->
       let name = String.lowercase_ascii (Lexing.lexeme lexbuf) in
       if !strict 
       then raise (Html_Lexing ("illegal attribute name: " ^ name,
                                 mk_start lexbuf lexdata))
       else
         try
           match tagattrib lexbuf lexdata with
           | Some s -> Attribute (name, s)
           | None -> Attribute (name, name)
         with Html_Lexing(reason,pos) -> Bogus(reason,pos)
      )}
| '>' '\n'?
    { (fun lexdata -> Closetag (mk_end lexbuf lexdata) )}
| eof 
    { (fun lexdata -> raise (Html_Lexing ("unclosed tag",
                               mk_start lexbuf lexdata)))}

(* tolerance: we are expecting an attribute name, but can't get any *)
(* skip the char and try again. (The char cannot be > !) *)
| _
    { (fun lexdata ->
        if !strict 
        then raise (Html_Lexing ("invalid attribute name",
                                  mk_start lexbuf lexdata));
        Bogus ("invalid attribute name", mk_start lexbuf lexdata)
    )}
@

% attrib -> <>
<<function [[Lexhtml.tagattrib]]>>=
and tagattrib = parse
| [' ' '\t' '\n' '\r']* '=' [' ' '\t' '\n' '\r']*
    { (fun lexdata -> Some (attribvalue lexbuf lexdata) )}
| "" 
    { (fun _lexdata -> None )}
@  

% opentag -> attrib -> tagattrib -> <>
<<function [[Lexhtml.attribvalue]]>>=
(* This should be dependent on the attribute name *)
(* people often forget to quote, so try to do something about it *)
(* but if a quote is not closed, you are dead *)
and attribvalue = parse
| ['a'-'z' 'A'-'Z' '0'-'9' '.' '-']+ 
    { (fun _lexdata -> Lexing.lexeme lexbuf )}
| '"' 
    { (fun lexdata ->
       Ebuffer.reset lexdata.buffer; 
       inquote lexbuf lexdata )}
| '\''
    { (fun lexdata ->
       Ebuffer.reset lexdata.buffer; 
       insingle lexbuf lexdata )}
| "" 
    { (fun _lexdata ->
        raise (Html_Lexing ("illegal attribute val",
                              Lexing.lexeme_start lexbuf)) )}
@
%  | ("\027\036" '\040'? ['\064' - '\068'] (* remove control codes *)
%        ['\033' - '\126']+ | (* suppose we have no empty KANJI seq *)
%     [^ '"' '\'' '>' '\027']) 
%    ("\027\036" '\040'? ['\064' - '\068'] ['\033' - '\126']+ |
%     "\027\040\066" |
%     [^ ' ' '\t' '\n' '\r' '>' '\027']*)
%    { (fun lexdata ->
%       let lexeme = Lexing.lexeme lexbuf in
%       lexdata.pos_fix <- String.length lexeme - Lexkanji.length lexeme;
%       lexeme )}


<<function [[Lexhtml.inquote]]>>=
and inquote = parse
| [^ '"' '&' '\027']+
    { (fun lexdata ->
       Ebuffer.output_string lexdata.buffer (Lexing.lexeme lexbuf);
       inquote lexbuf lexdata )}
| '"'
    { (fun lexdata ->
       Html.beautify true (Ebuffer.get lexdata.buffer) )}
| '&'
    { (fun lexdata ->
       Ebuffer.output_string lexdata.buffer (ampersand lexbuf lexdata);
       inquote lexbuf lexdata )}
| ""
    { (fun lexdata ->
       raise (Html_Lexing ("unclosed \"", mk_start lexbuf lexdata))
     )}
@
%  | "\027\040\066" (* ASCII *)
%      { (fun lexdata ->
%    lexdata.pos_fix <- lexdata.pos_fix + 3;
%    Ebuffer.output_string lexdata.buffer (Lexing.lexeme lexbuf);
%    inquote lexbuf lexdata )}
%(*
%  | "\027\036" '\040'? ['\064' - '\068'] (* KANJI *)
%      {(fun lexdata ->
%    let lexeme = Lexing.lexeme lexbuf in
%    Ebuffer.output_string lexdata.buffer lexeme;
%    let len = String.length lexeme in
%    lexdata.pos_fix <- lexdata.pos_fix + len; 
%    let c = Lexing.lexeme_char lexbuf (len - 1) in
%    if !Lang.japan then kanji lexbuf lexdata c;
%    inquote lexbuf lexdata )}
%*)

<<function [[Lexhtml.insingle]]>>=
and insingle = parse
| [^ '\'' '&']+
    { (fun lexdata ->
       Ebuffer.output_string lexdata.buffer (Lexing.lexeme lexbuf);
       insingle lexbuf lexdata )}
| '\''
    { (fun lexdata -> 
       Html.beautify true (Ebuffer.get lexdata.buffer) )}
| '&'
    { (fun lexdata ->
       Ebuffer.output_string lexdata.buffer (ampersand lexbuf lexdata);
       insingle lexbuf lexdata )}
| ""
    { (fun lexdata ->
       raise (Html_Lexing ("unclosed '", mk_start lexbuf lexdata))
    )}
@



<<signature [[Html.beautify]]>>=
val beautify: bool -> string -> string
  (* [beautify remove_leading_space s] removes sequences of SP *)
@

% (attrib -> insingle) | ...  -> <> 
<<function [[Html.beautify]]>>=
(*
 * Remove sequences of white
 *   turns out to be faster than global_replace in libstr
 *   could use String.blit to avoid char copying
 * NOTE: add \0 detection here (we need it for Tk)
 *)
let beautify remove_leading (s : string) =
  let s2 = Bytes.of_string s in
  let j = ref 0 in
  let white = ref remove_leading in
  for i = 0 to String.length s - 1 do
    match s.[i] with
    | ' ' | '\t' | '\r' | '\n' | '\000' -> 
       if not !white 
       then begin
         Bytes.set s2 !j ' '; 
         incr j; 
         white := true
       end
    | c -> 
       Bytes.set s2 !j c; 
       white := false; 
       incr j
  done;
  Bytes.sub_string s2 0 !j
@


\subsubsection{Doctype}

% doctype indeed
<<[[Lexhtml.html()]] rule cases>>=
| "<!" ['D''d']['O''o']['C''c']['T''t']['Y''y']['P''p']['E''e'] [^ '>']* '>'
    { (fun lexdata ->
       noerr, Doctype (Lexing.lexeme lexbuf), mk_loc lexbuf lexdata )}
@

\subsubsection{Text}

<<function [[Lexhtml.text]]>>=
and text = parse
| [^ '<' '&' '\r' '\027']+
    { (fun lexdata ->
      let _sTODO = Lexing.lexeme lexbuf in
      Ebuffer.output_string lexdata.buffer (Lexing.lexeme lexbuf);  
      text lexbuf lexdata )}
| [^ '<' '&' '\r' '\027']* '&'
    { (fun lexdata ->
       let lexeme = Lexing.lexeme lexbuf in
       Ebuffer.output lexdata.buffer lexeme 0 (String.length lexeme -1) ;
       Ebuffer.output_string lexdata.buffer (ampersand lexbuf lexdata); 
       text lexbuf lexdata )}
| [^ '<' '&' '\r' '\027']* '\r' '\n'
    { (fun lexdata ->
       let lexeme = Lexing.lexeme lexbuf in
       Ebuffer.output lexdata.buffer lexeme 0 (String.length lexeme - 2);
       Ebuffer.output_char lexdata.buffer '\n';
       text lexbuf lexdata )}
| [^ '<' '&' '\r' '\027']* '\r'
    { (fun lexdata ->
       let lexeme = Lexing.lexeme lexbuf in
       Ebuffer.output lexdata.buffer lexeme 0 (String.length lexeme - 1);
       Ebuffer.output_char lexdata.buffer '\n';
       text lexbuf lexdata )}
| ""
    { (fun lexdata ->    
       noerr, 
       PCData (Ebuffer.get lexdata.buffer), 
       Loc(lexdata.start, mk_end lexbuf lexdata)
      )}
 (* no default case needed *)
@
% | "\027\040\066" (* ASCII *)
%     { (fun lexdata ->
%     lexdata.start <- mk_start lexbuf lexdata;
%     lexdata.pos_fix <- lexdata.pos_fix + 3;
%     Ebuffer.output_string lexdata.buffer (Lexing.lexeme lexbuf);
%     text lexbuf lexdata )}
%(*
% | "\027\036" '\040'? ['\064' - '\068'] (* KANJI *)
%     {(fun lexdata ->
%       let lexeme = Lexing.lexeme lexbuf in
%       let len = String.length lexeme in
%       lexdata.start <- mk_start lexbuf lexdata;
%       lexdata.pos_fix <- lexdata.pos_fix + len;
%       Ebuffer.output_string lexdata.buffer lexeme;
%       let c = Lexing.lexeme_char lexbuf (len - 1) in
%       if !Lang.japan then kanji lexbuf lexdata c;
%       text lexbuf lexdata )}
%*)

\subsubsection{Data}

% ??? -> <>
<<function [[Lexhtml.cdata]]>>=
and cdata = parse
| [^ '<']* (['<']+ [^ '/']) ? 
    { (fun lexdata ->
        noerr, CData(Lexing.lexeme lexbuf), mk_loc lexbuf lexdata)}
      
| "</" ['a'-'z' 'A'-'Z' '0'-'9' '.' '-']+
    { (fun lexdata ->
        let lexeme = Lexing.lexeme lexbuf in
        let _eTODO = skip_to_close lexbuf lexdata in
        noerr,
        CloseTag (String.lowercase_ascii 
                      (String.sub lexeme 2 (String.length lexeme - 2))),
        mk_loc lexbuf lexdata)}
| "</" 
    { (fun lexdata ->
        noerr, CData(Lexing.lexeme lexbuf), mk_loc lexbuf lexdata) }

| eof
    { (fun lexdata ->
        noerr, EOF, mk_loc lexbuf lexdata) }
@

\subsubsection{Entities, [[&xxx;]]}

<<[[Lexhtml.html()]] rule cases>>=
 | '&' 
    { (fun lexdata ->
       lexdata.start <- mk_start lexbuf lexdata;
       Ebuffer.reset lexdata.buffer;
       Ebuffer.output_string lexdata.buffer 
         (ampersand lexbuf lexdata);
       text lexbuf lexdata )}
@


<<function [[Lexhtml.ampersand]]>>=
and ampersand = parse
| '#' ['0'-'9']+ ';'
    { (fun _lexdata ->
        let lexeme = Lexing.lexeme lexbuf in
        numeric_entity_to_utf8 (String.sub lexeme 1 (String.length lexeme - 2))
      )}
| ['a'-'z' 'A'-'Z'] ['a'-'z' 'A'-'Z' '0'-'9']* ';'
    { (fun _lexdata ->
        let lexeme = Lexing.lexeme lexbuf in
        let entity = String.sub lexeme 0 (String.length lexeme - 1) in
        try 
          get_entity entity
        with (* 4.2.1 undeclared markup error handling *) Not_found ->
          ("&" ^ lexeme)
      )}
  (* terminating ; is not required if next character could not be 
     part of the lexeme *)
| '#' ['0'-'9']+
    { (fun _lexdata ->
        let lexeme = Lexing.lexeme lexbuf in
        numeric_entity_to_utf8 (String.sub lexeme 1 (String.length lexeme - 1))
      )}
 | ['a'-'z' 'A'-'Z'] ['a'-'z' 'A'-'Z' '0'-'9']*
    { (fun _lexdata ->
        let lexeme = Lexing.lexeme lexbuf in
        try 
          get_entity lexeme
        with (* 4.2.1 undeclared markup error handling *) Not_found -> 
          ("&"^lexeme)
      )}
  (* Tolerance ... *)
| ""
    { (fun _lexdata -> "&" )}
@
%        (*if !Lang.japan then
%         "\027\040\066" ^ String.make 1 (Char.chr (int_of_string code))
%        else
%         *)
%      (*if !Lang.japan then
%        "\027\040\066" ^ String.make 1 (Char.chr (int_of_string code))
%      else
%      *)







% Lexhtml.html -> ampersand -> <>
<<signature [[Html.get_entity]]>>=
val get_entity : string -> string
  (* [get_entity "amp"] returns "&" *)
@

<<constant [[Html.get_entity]]>>=
let get_entity = Hashtbl.find ampersand_table
@


<<constant [[Html.ampersand_table]]>>=
(*
 * HTML named character entities, values encoded as UTF-8
 *  cf Appendix B - Proposed Entities
 *)

let ampersand_table =
  (Hashtbl.create 101: (string , string) Hashtbl.t)
@





%\subsection{HTML initialisation}

<<[[Main.main()]] html entities initialisation>>=
(* Initialization of HTML entities *)
Html.init (Lang.lang());
@

<<signature [[Html.init]]>>=
val init : string -> unit 
@

<<function [[Html.init]]>>=
let init _lang =
  named_entities |> List.iter (fun (str, c) ->
    Hashtbl.add ampersand_table str c)
@
%  (* (if japan then latin1_japan else latin1_normal)  *)

<<constant [[Html.latin1_normal]]>>=
let named_entities = [
  "amp", 	"&";
  "gt", 	">";
  "lt" , 	"<";
  "quot", 	"\"";

  <<[[latin1_normal]] elements>>
]
@
% see more in language or special chars section

\subsubsection{Strict mode}

<<signature [[Lexhtml.strict]]>>=
val strict : bool ref
    (* if true, use strict parsing; else, activate leniency on some
       lexing decisisons such as: comments, attribute names and values
     *)
@
<<global [[Lexhtml.strict]]>>=
let strict = ref false
@

%todo: aspectize strict

\subsection{Parsing part 1, the DTD}
% it's not really parsing though, it's really more adjusted lexing no?

% for 3.2
% html 4.0 and 5.0 has been published
% TODO: add 4.0 with span element


<<module Dtd.elements>>=
module Elements = Set.Make(struct type t = string let compare = compare end)
@

<<type [[Dtd.t]]>>=
type t = {
  dtd_name : string;
  contents : (string, Elements.t) Hashtbl.t;
    (* for each element, give the set of included elements *)

  mutable open_omitted : Elements.t;
    (* set of elements for which opening tag may be omitted *)
  mutable close_omitted : Elements.t
    (* set of elements for which closing tag may be omitted *)
 } 
@

<<signature [[Dtd.dtd20]]>>=
val dtd20 : t
@
<<signature [[Dtd.dtd32]]>>=
val dtd32 : t
@

<<signature [[Dtd.name]]>>=
val name : t -> string
@
<<function [[Dtd.name]]>>=
let name t = 
  t.dtd_name
@


<<function [[Dtd.sol]]>>=
(* Utils *)
let sol l =
  List.fold_right Elements.add l Elements.empty
@

<<function [[Dtd.sos]]>>=
let sos l =
  List.fold_right Elements.union l Elements.empty
@


<<constant [[Dtd.dtd20]]>>=
(* #PCDATA and #CDATA are considered as elements, but they will never
   be pushed on the stack during evaluation. Moreover, since they are
   not in open_omitted/close_omitted, minimization algorithm will not
   attempt to choose them
 *)

let dtd20 =
  let dtd = {
    dtd_name = "HTML 2.0";

    contents = Hashtbl.create 53;
    open_omitted = Elements.empty;
    close_omitted = Elements.empty
  } in

  let omit_open el =
    dtd.open_omitted <- Elements.add el dtd.open_omitted in
  let omit_close el =
    dtd.close_omitted <- Elements.add el dtd.close_omitted in
  let add_elem = 
    Hashtbl.add dtd.contents in

  (* Some entities *)
  (* <!ENTITY % heading "H1|H2|H3|H4|H5|H6"> *)
  let heading_E = sol ["h1"; "h2"; "h3"; "h4"; "h5"; "h6"]
  (* <!ENTITY % list " UL | OL | DIR | MENU " > *)
  and list_E = sol ["ul"; "ol"; "dir"; "menu"] in
  (* <!ENTITY % font " TT | B | I "> *)
  let font_E = sol ["tt"; "b"; "i"]
  (* <!ENTITY % phrase "EM | STRONG | CODE | SAMP | KBD | VAR | CITE "> *)
  and phrase_E = sol ["em"; "strong"; "code"; "samp"; "kbd"; "var"; "cite"] in
  (* <!ENTITY % text "#PCDATA | A | IMG | BR | %phrase | %font"> *)
  (* EMBED added *)
  let text_E =
    sos [sol ["#pcdata"; "a"; "img"; "br"; "embed"]; font_E; phrase_E] in

  (* <!ELEMENT (%font;|%phrase) - - (%text)*> *)
  Elements.iter (fun e -> add_elem e text_E) font_E;
  Elements.iter (fun e -> add_elem e text_E) phrase_E;

  (* <!ENTITY % pre.content "#PCDATA | A | HR | BR | %font | %phrase"> *)
  let pre_content_E = 
       sos [sol ["#pcdata"; "a"; "hr"; "br"]; font_E; phrase_E] in

  (* <!ELEMENT BR    - O EMPTY> *)
  add_elem "br" Elements.empty;
  omit_close "br";

  (* <!ENTITY % A.content   "(%heading|%text)*"> *)
  let a_content_E = sos [heading_E; text_E] in

  (* <!ELEMENT A     - - %A.content -(A)> *)
  add_elem "a" (Elements.remove "a" a_content_E);

  (* <!ELEMENT IMG    - O EMPTY> *)
  add_elem "img" Elements.empty;
  omit_close "img";

  (* <!ELEMENT P     - O (%text)*> *)
  add_elem "p" text_E;
  omit_close "p";

  (* <!ELEMENT HR    - O EMPTY> *)
  add_elem "hr" Elements.empty;
  omit_close "hr";

  (* <!ELEMENT ( %heading )  - -  (%text;)*> *)
  Elements.iter (fun e -> add_elem e text_E) heading_E;

  (* <!ENTITY % block.forms "BLOCKQUOTE | FORM | ISINDEX"> *)
  let block_forms_E = sol ["blockquote"; "form"; "isindex"] in

  (* <!ENTITY % preformatted "PRE"> *)
  let preformatted_E = sol ["pre"] in

  (* <!ENTITY % block "P | %list | DL
      | %preformatted
      | %block.forms"> *)
  let block_E = sos [sol ["p"; "dl"]; list_E; preformatted_E; block_forms_E] in

  (* <!ENTITY % flow "(%text|%block)*"> *)
  let flow_E = sos [text_E; block_E] in

  (* <!ELEMENT PRE - - (%pre.content)*> *)
  add_elem "pre" pre_content_E;


  (* Deprecated but used <!ELEMENT (XMP|LISTING) - -  %literal> *)
  List.iter (fun e -> add_elem e (sol ["#cdata"])) ["xmp"; "listing"];

  (* <!ELEMENT DL    - -  (DT | DD)+> *)
  add_elem "dl" (sol ["dt"; "dd"]);

  (* <!ELEMENT DT    - O (%text)*> *)
  add_elem "dt" text_E;
  omit_close "dt";

  (* <!ELEMENT DD    - O %flow> *)
  add_elem "dd" flow_E;
  omit_close "dd";

  (* <!ELEMENT (OL|UL) - -  (LI)+> *)
  List.iter (fun e -> add_elem e (sol ["li"])) ["ol"; "ul"];

  (* <!ELEMENT (DIR|MENU) - -  (LI)+ -(%block)> *)
  (* isn't that stupid ? *)
  List.iter (fun e -> add_elem e (sol ["li"])) ["dir"; "menu"];

  (* <!ELEMENT LI    - O %flow> *)
  add_elem "li" flow_E;
  omit_close "li";

  (* <!ENTITY % body.content "(%heading | %text | %block |
                 HR | ADDRESS)*"> *)
  let body_content_E =
     sos [heading_E; text_E; block_E; sol ["hr"; "address"]] in
  
  (* <!ELEMENT BODY O O  %body.content> *)
  add_elem "body" body_content_E;
  omit_open "body";
  omit_close "body";

  (* <!ELEMENT BLOCKQUOTE - - %body.content> *)
  add_elem "blockquote" body_content_E;

  (* <!ELEMENT ADDRESS - - (%text|P)*> *)
  add_elem "address" (Elements.add "p" text_E);

  (* <!ELEMENT FORM - - %body.content -(FORM) +(INPUT|SELECT|TEXTAREA)> *)
  add_elem "form"
    (sos [Elements.remove "form" body_content_E;
      sol ["input";"select";"textarea"]]);

  (* <!ELEMENT INPUT - O EMPTY> *)
  add_elem "input" Elements.empty;
  omit_close "input";

  (* <!ELEMENT SELECT - - (OPTION+) -(INPUT|SELECT|TEXTAREA)> *)
  add_elem "select" (sol ["option"]);

  (* <!ELEMENT OPTION - O (#PCDATA)*> *)
  add_elem "option" (sol ["#pcdata"]);
  omit_close "option";

  (* <!ELEMENT TEXTAREA - - (#PCDATA)* -(INPUT|SELECT|TEXTAREA)> *)
  add_elem "textarea" (sol ["#pcdata"]);

  (* <!ENTITY % head.extra "NEXTID? & META* & LINK*">

     <!ENTITY % head.content "TITLE & ISINDEX? & BASE? &
             (%head.extra)"> *)

  let head_extra_E = sol ["nextid"; "meta"; "link"] in
  let head_content_E = 
    sos [sol ["title"; "isindex"; "base"]; head_extra_E] in
  
  (* <!ELEMENT HEAD O O  (%head.content)> *)
  add_elem "head" head_content_E;
  omit_open "head";
  omit_close "head";

  (* <!ELEMENT TITLE - -  (#PCDATA)*> *)
  add_elem "title" (sol ["#pcdata"]);

  (* <!ELEMENT LINK - O EMPTY> *)
  add_elem "link" Elements.empty;
  omit_close "link";

  (* <!ELEMENT ISINDEX - O EMPTY> *)
  add_elem "isindex" Elements.empty;
  omit_close "isindex";

  (* <!ELEMENT BASE - O EMPTY> *)
  add_elem "base" Elements.empty;
  omit_close "base";

  (* <!ELEMENT NEXTID - O EMPTY> *)
  add_elem "nextid" Elements.empty;
  omit_close "nextid";

  (* <!ELEMENT META - O EMPTY> *)
  add_elem "meta" Elements.empty;
  omit_close "meta";

  (* <!ENTITY % html.content "HEAD, BODY"> *)
  let html_content_E = sol ["head"; "body"] in

  (* <!ELEMENT HTML O O  (%html.content)> *)
  add_elem "html" html_content_E;
  omit_open "html";
  omit_close "html";

  (* fake element PCDATA for minimisation rules *)
  add_elem "#pcdata" Elements.empty;

  (* EMBED is an extension *)
  add_elem "embed" Elements.empty;
  omit_close "embed";
  
  dtd
@



%(* #PCDATA and #CDATA are considered as elements, but they will never
%   be pushed on the stack during evaluation. Moreover, since they are
%   not in open_omitted/close_omitted, minimization algorithm will not
%   attempt to choose them
% *)

% less: copy comments of dtd 2.0 here? and LP split?
<<constant [[Dtd.dtd32]]>>=
let dtd32 =
  let dtd = {
    dtd_name = "HTML 3.2";
    contents = Hashtbl.create 53;
    open_omitted = Elements.empty;
    close_omitted = Elements.empty
   } in
  let omit_open el =
    dtd.open_omitted <- Elements.add el dtd.open_omitted in
  let omit_close el =
    dtd.close_omitted <- Elements.add el dtd.close_omitted in
  let add_elem = 
    Hashtbl.add dtd.contents in

  let head_misc_E = sol ["script"; "style"; "meta"; "link"]
  and heading_E = sol ["h1"; "h2"; "h3"; "h4"; "h5"; "h6"]
  and list_E = sol ["ul"; "ol"; "dir"; "menu"]
  and preformatted_E = sol ["pre"; "xmp"; "listing"]
  and font_E =
     sol ["tt"; "i"; "b"; "u"; "strike"; "big"; "small"; "sub"; "sup"]
  and phrase_E =
     sol ["em"; "strong"; "dfn"; "code"; "samp"; "kbd"; "var"; "cite"]
  and special_E =
     sol ["a"; "img"; "applet"; "font"; "basefont"; "br"; "script"; "map"]
  and form_E =
     sol ["input"; "select"; "textarea"]
  in
  (* EMBED is not in the original DTD ! *)
  let text_E =
     sos [sol ["#pcdata"; "embed"]; font_E; phrase_E; special_E; form_E]
  in
  Elements.iter (fun e -> add_elem e text_E) font_E;
  Elements.iter (fun e -> add_elem e text_E) phrase_E;
  add_elem "font" text_E;
  add_elem "basefont" Elements.empty;
  omit_close "basefont";
  add_elem "br" Elements.empty;
  omit_close "br";

  let block_E =
    sos [sol ["p"; "dl"; "div"; "center"; "blockquote"; "form"; "isindex";
              "hr"; "table"];
         list_E; preformatted_E]
  in
  let flow_E = sos [text_E; block_E] in
  let body_content_E = sos [sol ["address"]; heading_E; text_E; block_E] in
  add_elem "body" body_content_E;
  omit_open "body";
  omit_close "body";

  let address_content_E = sos [sol ["p"]; text_E] in
  add_elem "address" address_content_E;
  
  add_elem "div" body_content_E;
  add_elem "center" body_content_E;

  add_elem "a" (Elements.remove "a" text_E);
  
  add_elem "map" (sol ["area"]);
  add_elem "area" Elements.empty;
  omit_close "area";

  add_elem "link" Elements.empty;
  omit_close "link";
   
  add_elem "img" Elements.empty;
  omit_close "img";

  add_elem "applet" (Elements.add "param" text_E);
  add_elem "param" Elements.empty;
  omit_close "param";

  add_elem "hr" Elements.empty;
  omit_close "hr";

  add_elem "p" text_E;
  omit_close "p";

  Elements.iter (fun e -> add_elem e text_E) heading_E;

  let pre_exclusion_E = sol ["img"; "big"; "small"; "sub"; "sup"; "font"]
  in
  add_elem "pre" (Elements.diff text_E pre_exclusion_E);

  List.iter (fun e -> add_elem e (sol ["#cdata"])) ["xmp"; "listing"];

  add_elem "blockquote" body_content_E;

  add_elem "dl" (sol ["dt"; "dd"]);
  add_elem "dt" text_E; omit_close "dt";
  add_elem "dd" flow_E; omit_close "dd";

  List.iter (fun e -> add_elem e (sol ["li"])) ["ol"; "ul"];
  List.iter (fun e -> add_elem e (sol ["li"])) ["dir"; "menu"];

  add_elem "li" flow_E;
  omit_close "li";


  add_elem "form" (Elements.remove "form" body_content_E);
  add_elem "input" Elements.empty;
  omit_close "input";
  add_elem "select" (sol ["option"]);
  add_elem "option" (sol ["#pcdata"]);
  omit_close "option";
  add_elem "textarea" (sol ["#pcdata"]);


  add_elem "table" (sol ["caption"; "tr"]);
  add_elem "tr" (sol ["th"; "td"]);
  omit_close "tr";
  List.iter (fun e -> add_elem e body_content_E; omit_close e) ["th"; "td"];
  add_elem "caption" text_E;

  let head_content_E = sol ["title"; "isindex"; "base"] in

  add_elem "head" (Elements.union head_content_E head_misc_E);
  omit_close "head";
  omit_open "head";

  add_elem "title" (sol ["#pcdata"]);
  add_elem "isindex" Elements.empty;
  omit_close "isindex";
  add_elem "base" Elements.empty;
  omit_close "base";
  add_elem "meta" Elements.empty;
  omit_close "meta";

  add_elem "script" (sol ["#cdata"]);
  add_elem "style" (sol ["#cdata"]);

  let html_content_E = sol ["head"; "body"] in

  add_elem "html" html_content_E;
  omit_open "html";
  omit_close "html";

  (* fake element PCDATA for minimisation rules *)
  add_elem "#pcdata" Elements.empty;

  (* embed is an extension *)
  add_elem "embed" Elements.empty;
  omit_close "embed";

  dtd
@



<<constant [[Dtd.table]]>>=
let table = Hashtbl.create 11
@

<<signature [[Dtd.add]]>>=
val add : t -> unit
@

<<signature [[Dtd.get]]>>=
(* A table of DTDs for preferences *)
val get : string -> t
@

<<signature [[Dtd.names]]>>=
val names : unit -> string list
@

<<signature [[Dtd.current]]>>=
val current : t ref 
@
<<constant [[Dtd.current]]>>=
let current = ref dtd32
@



<<function [[Dtd.add]]>>=
let add t = 
  Hashtbl.add table t.dtd_name t
@

<<constant [[Dtd.get]]>>=
let get = 
  Hashtbl.find table
@

<<function [[Dtd.names]]>>=
let names () =
  let names = ref [] in
   Hashtbl.iter (fun name _ -> names := name :: !names) table;
   !names
@


<<toplevel [[Dtd._1]]>>=
let _ = add dtd20; add dtd32
@


\subsection{Parsing part 2, the SGML evaluator}

\subsubsection{[[automat()]]}

% Htparse.html_lex | ???? -> <>
<<signature [[Html_eval.automat]]>>=
val automat : 
  Dtd.t -> Lexing.lexbuf -> 
  (Html.location -> Html.token -> unit) -> (* action callback *)
  (Html.location -> string -> unit) -> (* error callback *)
  unit
@
% main parsing function apparently

<<function [[Html_eval.automat]]>>=
let automat dtd lexbuf action error =
  try
    let lexer = sgml_lexer dtd in
    while true do
      try 
        let warnings, correct, tokens, loc = lexer lexbuf in
        warnings |> List.iter (fun (reason, pos) -> 
          error (Loc(pos,succ pos)) reason
        );
        (match correct with
        | Legal -> ()
        | Illegal reason -> error loc reason
        );
        tokens |> List.iter (function token -> 
          (try 
            (* calling the callback *)
            action loc token
          with Invalid_Html s -> error loc s
          );
          if token = EOF 
          then failwith "quit_html_eval"
        )
      with Html_Lexing (s,n) -> error (Loc(n,n+1)) s
    done
  with Failure "quit_html_eval" -> ()
@



\subsubsection{[[sgml_lexer()]]}

<<type [[Html_eval.minimization]]>>=
(* Wrapped up lexer to insert open/close tags in the stream of "normal"
   tokens, according to some DTD, in order to always get fully parenthesized
   streams *)

type minimization =
  Legal | Illegal of string
@

<<signature [[Html_eval.sgml_lexer]]>>=
val sgml_lexer :
  Dtd.t -> Lexing.lexbuf -> 
  (Lexhtml.warnings * minimization * Html.token list * Html.location)
@



<<function [[Html_eval.sgml_lexer]]>>=
let sgml_lexer dtd =
  let current_lex = ref Lexhtml.html in
  let stack = ref [] in
  let lexdata = Lexhtml.new_data () in

  (* currently allowed elements *)
  let allowed () = 
    match !stack with
    | [] -> initial
    | (_elem, cts)::_ -> cts 
  in
  (* whatever the situation (but close), if the previous element is empty
     with an omittable close, close it *)
  let close_empty () = 
    match !stack with
    | [] -> []
    | (elem, ctx)::l ->
        if Elements.is_empty ctx && Elements.mem elem dtd.close_omitted
        then (stack := l; [CloseTag elem])
        else []
  in  
  (fun lexbuf ->
    let warnings, token, loc = !current_lex lexbuf lexdata in
    if !debug 
    then begin prerr_string "got "; Html.print token; prerr_newline() end;
    let status, tokens = 
      match token with
      | OpenTag t ->
          begin try (* first check that we know this element *)
            let contents = Hashtbl.find dtd.contents t.tag_name in
            let extraclose = close_empty() in    
            (* check changing of lexers; this works only if error recovery
               rules imply that the tag will *always* be open
             *)
            if is_cdata contents 
            then current_lex := Lexhtml.cdata
            else current_lex := Lexhtml.html;

            (* is it allowed in here ? *)
            if Elements.mem t.tag_name (allowed()) then begin
              (* push on the stack *)
              stack := (t.tag_name, contents) :: !stack;
              Legal, extraclose @ [token]
            end else begin (* minimisation or error *)
              let flag, (res, l) = ominimize dtd t !stack in
              stack := l;
              flag, extraclose @ res
            end
          with Not_found -> 
            (* Not in the DTD ! We return it, but don't change our state
               or stack. An applet extension to the HTML display machine
               can attempt to do something with it *)
            Illegal (sprintf "Element %s not in DTD" t.tag_name),
            [token]
         end
        
      | CloseTag t ->
          begin try (* do we know this element *)
            let _ = Hashtbl.find dtd.contents t in
            match !stack with
            | [] -> 
              Illegal(sprintf "Unmatched closing </%s>" t), []
            | (elem, _cts)::l when elem = t -> (* matching close *)
                 stack := l; (* pop the stack *)
                 (* the lexer has to be "normal" again, because CDATA
                    can't be nested anyway *)
                 current_lex := Lexhtml.html;
                 Legal, [token]
            | (_elem, cts)::_l -> (* unmatched close ! *)
                (* if we were in cdata, change the token to cdata *)
                 if is_cdata cts 
                 then Legal, [CData (sprintf "</%s>" t)]
                 else begin
                   current_lex := Lexhtml.html;
                   let flag, (res, l) = cminimize dtd t !stack in
                   stack := l;
                   flag, res
                 end
        with Not_found ->
          Illegal (sprintf "Element %s not in DTD" t),
          [token]
        end
     | PCData s ->
         let extraclose = close_empty() in    
         (* is it allowed in here ? *)
         if Elements.mem "#pcdata" (allowed()) 
         then  Legal, extraclose @ [token]
          (* ignore PCData made of spaces if not relevant to the context *)
         else 
           if issp s 
           then Legal, extraclose
           else begin	    
              (* bad hack. make believe that we try to open the #pcdata element *)
             let flag, (res, l) = 
             ominimize dtd {tag_name = "#pcdata"; attributes = []} !stack in
             stack := l;
             flag,  extraclose @ res @ [token]
           end

    (* CData never happens with an empty stack *)
    | CData _s ->
        let extraclose = close_empty() in    
        if Elements.mem "#cdata" (allowed()) 
        then Legal, extraclose @ [token]
        else
           Illegal(sprintf "Unexpected CDATA in %a" dump_stack !stack),
           extraclose @ [token]
        
    (* See if the stack is empty *)
    | EOF ->
       begin 
        match !stack with
        | [] -> Legal, [EOF]
        | l ->
           (* we must be able to close all remaining tags *)
           let rec closethem tokens = function
           | [] -> None, EOF :: tokens
           | (last,_) :: l ->
               if Elements.mem last dtd.close_omitted 
               then closethem (CloseTag last::tokens) l
               else
                 let status, tokens = 
                   closethem (CloseTag last::tokens) l in
                 let err = sprintf "</%s>" last in
                 let newstatus = 
                   match status with
                   | Some s -> Some (err^s)
                   | None -> Some err 
                 in
                 newstatus, tokens
         in
         match closethem [] l with
         | None, tokens -> Legal, List.rev tokens
         | Some s, tokens -> Illegal ("Missing "^s), List.rev tokens
       end

    | _ ->  Legal, [token] (* ignore all other cases *)
      
  in
  warnings, status, tokens, loc)
@


<<function [[Html_eval.dump_stack]]>>=
let dump_stack () = function
    (x,_)::(y,_)::(z,_)::_ -> sprintf "..<%s><%s><%s>" z y x
  | [x,_;y,_] -> sprintf "<%s><%s>" y x
  | [x,_] -> sprintf "<%s>" x
  | [] -> "empty stack"
@

<<constant [[Html_eval.initial]]>>=
(* initial element of the DTD *)
let initial = Elements.add "html" Elements.empty
@

<<function [[Html_eval.is_cdata]]>>=
let is_cdata cts =
  Elements.cardinal cts = 1 && Elements.mem "#cdata" cts
@

\subsubsection{Minimizations}

<<function [[Html_eval.ominimize]]>>=
(* open minimize 
   [ominimize dtd open_tag current_stack]
   returns a list of inferred open/close tags and the new stack
 *)
let ominimize dtd t stack =
  let elem = t.tag_name in

  (* Is elem allowed for the given stack ? *)
  let goodpos = function
      [] -> Elements.mem elem initial
    | (_, cts)::_l -> Elements.mem elem cts

  (* Return with inferred and stack.
     The stack has been reduced during the inference, so it is enough
     to push the opened element *)
  (* Special hack when t is fake #pcdata... *)
  and return inferred stack =
    if elem = "#pcdata" then
      List.rev inferred, stack
    else
      List.rev ((OpenTag t) :: inferred),
      (elem, Hashtbl.find dtd.contents elem) :: stack
      
  in
  (* [attempt_close mods_so_far current_stack] *)
  let rec attempt_close accu = function
     [] -> (* reached all the possible closing, attempt to open again *)
        attempt_open accu []
   | ((last, _)::l) as stack ->
       if Elements.mem last dtd.close_omitted then
          (* we can attempt to close the previous element *)
      if goodpos l then 
        (* good position, we're done *)
        return ((CloseTag last) :: accu) l
          else (* attempt to open in this new position *)
        try 
              attempt_open ((CloseTag last) :: accu) l
            with
          CantMinimize -> (* try once more to close *)
             attempt_close ((CloseTag last)::accu) l
       else begin (* since we can't close, try to open *)
      attempt_open accu stack
       end

   (* [attempt_open mods_so_far currentstack] *)
   and attempt_open accu = function
     [] -> 
       (* open HTML, and retry from there *)
       (* should actually iterate on all elements in initial *)
       let newstack = ["html", Hashtbl.find dtd.contents "html"]
       and newaccu = (OpenTag {tag_name = "html"; attributes = []}) :: accu
       in
      if goodpos newstack then return newaccu newstack
          else attempt_open newaccu newstack

   | ((_, cts)::_l ) as stack ->
       (* check if, in contents, there is an element with implicit omission
          that would help *)
       let possible = Elements.inter cts dtd.open_omitted in
        match Elements.cardinal possible with
      0 -> (* argh *) raise CantMinimize
        | 1 -> 
      (* open this element and try from there *)
      let newelem = Elements.choose possible in
      let newaccu = (OpenTag {tag_name = newelem; attributes = []})::accu
          and newstack = (newelem, Hashtbl.find dtd.contents newelem)::stack
          in
        if goodpos newstack 
        then return newaccu newstack
        else attempt_open newaccu newstack (* maybe more ? *)
        | _n -> (* since we have the choice, examine all possibilities *)
       let elems = Elements.elements possible in
       let rec backtrack = function 
             [] -> raise CantMinimize
        | x::l -> 
        try
          let newaccu = (OpenTag {tag_name = x; attributes = []})::accu
          and newstack = (x, Hashtbl.find dtd.contents x)::stack
                  in
            if goodpos newstack then return newaccu newstack 
            else attempt_open newaccu newstack
        with
         CantMinimize -> backtrack l
           in 
       backtrack elems
  in
   (* now do some error recovery *)   
   try Legal, attempt_close [] stack
   with
     CantMinimize ->
       (* what the hell, dammit, open it anyway, who cares, duh *)
       let _currentTODO = match stack with (x,_)::_l -> x | [] -> "" in
       Illegal (sprintf "illegal <%s> in %a, keep it though"
                t.tag_name dump_stack stack),
       return [] stack
@

<<function [[Html_eval.cminimize]]>>=
(* close minimize
   [cminimize dtd elem current_stack]
   returns a list of inferred open/close tags and the new stack
 *)
let cminimize dtd tagname stack =
  (* Is elem allowed for the given stack ? *)
  let goodpos = function
      [] -> false
    | (elem, _cts)::_l -> tagname = elem

  and return inferred stack =
     List.rev ((CloseTag tagname) :: inferred), stack

  in
  (* [attempt_close mods_so_far current_stack] *)
  let rec attempt_close accu = function
     [] -> raise CantMinimize
   | ((last, _)::l) as _stackTODO ->
       if Elements.mem last dtd.close_omitted then
          (* we can attempt to close the previous element *)
      if goodpos l then 
        (* good position, we're done *)
        return (CloseTag last :: accu) (List.tl l)
          else (* close a bit more ? *)
        attempt_close ((CloseTag last)::accu) l
       else 
     (* there's no reason we should have to open a new element in order
        to close the current one, is it ? *)
          raise CantMinimize
  in
  (* error recovery strategy *)
  let rec attempt_matching accu = function
     [] -> raise Not_found (* didn't find a matching open at all ! *)
   | (curelem,_):: l when curelem = tagname ->
     (* so, consider we match this open, and close them all *)
     return accu l
   | (curelem,_):: l  -> (* otherwise, find something up there *)
     attempt_matching (CloseTag curelem :: accu) l
   in
   (* now do some error recovery *)   
   try Legal, attempt_close [] stack
   with
     CantMinimize ->
       try
     Illegal (sprintf "unmatched </%s> in %a, close closest match"
                  tagname dump_stack stack),
         attempt_matching [] stack 
       with
     Not_found -> 
       Illegal (sprintf "unmatched </%s> in %a, skipped"
                    tagname dump_stack stack),
           ([], stack) (* just skip the damn thing *)
@

<<exception [[Html_eval.CantMinimize]]>>=
exception CantMinimize			            (* bogus HTML *)
@

\subsubsection{Filters}

<<signature [[Html_eval.add_html_filter]]>>=
(* test suit *)
val add_html_filter : ((Html.token -> unit) -> Html.token -> unit) -> unit
(* [add_html_filter filter] adds an HTML filter between the lexing and
  displaying of HTML. So, the filters do not affect the source (and
  the source display), change the content of HTML silently, and affect
  the display. The filter function [filter pfilter] receives a HTML token
  for each time, and do some job, and send a token to the parent filter 
  pfilter if possible. The filters will receive a correct HTML token
  stream (all the tags are placed and closed correctly due to the DTD),
  and they must send the correct stream to the parent filter also. 
*)
@
<<function [[Html_eval.add_html_filter]]>>=
let add_html_filter f =
  filters := f :: !filters
@


<<constant [[Html_eval.filters]]>>=
let filters = ref []
@


<<function [[Html_eval.sgml_lexer]] ([[html/html_eval.ml]])>>=
(* Redefine sgml_lexer with filters *)
let sgml_lexer dtd = 
  let org_lexer = sgml_lexer dtd in
  let buf = ref [] in
  let allfilter = 
    List.fold_right (fun f st -> f st) !filters 
      (fun tkn -> buf := !buf @ [tkn]) 
  in
  function lexbuf ->
    let warnings, correct, tokens, loc = org_lexer lexbuf in
    tokens |> List.iter allfilter; (* inefficient *)
    let tokens = !buf in 
    buf := [];
    warnings, correct, tokens, loc
@



\subsection{[[htparse]]}

%(* Testing the HTML Lexer/evaluator *)

<<type [[Htparse.mode]]>>=
type mode =
 | Check 
 | Indent of int 
 | Nesting
@
% Check =~ token dump
% Ident =~ use stack so more balancing parsing
% Nesting =~ ?
<<constant [[Htparse.mode]]>>=
let mode = ref Check
@
% indent? nesting? what for?

<<function [[Htparse.main]]>>=
let main () =
  Html.init (Lang.lang());

  let options = [
     "-struct", Arg.Int   (function n -> mode := Indent n), "Parse Tree";
     "-nesting", Arg.Unit (function () -> mode := Nesting), "Check nesting";

     "-debug", Arg.Unit (function () -> Html_eval.debug := true), "Debug mode";
     "-strict", Arg.Set Lexhtml.strict, "Strict mode";
     "-v", Arg.Unit (function () -> verbose := true), "Verbose mode";

     "-dtd", Arg.Unit (function () -> Dtd.dump Dtd.dtd32f), "Dump DTD";
     "-depth", Arg.Int (function n -> Format.set_max_boxes n), "Max print depth"
     ] |> Arg.align in
    Arg.parse options
     (fun s -> 
       match !mode with
       | Check -> html_lex s
       | Indent n -> html_indent s n
       | Nesting -> html_nest s
       )
     "Usage: htparse <opts> file1.html ... filen.html"
@

<<toplevel [[Htparse._2]]>>=
let _ = Printexc.catch main ()
@


<<function [[Htparse.html_lex]]>>=
let html_lex name =
  let ic = open_in name in
  let lexbuf, find_line = line_reporting ic in
  Html_eval.automat Dtd.dtd32f lexbuf
     (fun _loc token ->
        match token with
        | EOF -> close_in ic
        | t -> 
            <<[[Htparse.html_lex()]] print token t if verbose>>
     )
     (error name find_line)
@
% token dumper

<<toplevel [[Htparse._1]]>>=
let _ = 
  Html.verbose := false (* we do our own error report *)
@
<<constant [[Htparse.verbose]]>>=
let verbose = ref false
@



<<function [[Htparse.error]]>>=
let error name find_line (Loc(n,n')) msg =
  let linenum, linestart = find_line n in
  printf "File \"%s\", line %d, characters %d-%d:\n%s\n"
         name linenum (n - linestart) (n' - linestart) msg
@

<<function [[Htparse.line_reporting]]>>=
(* lines: start at 1 *)
(* pos: start at 0 as in caml *)
let line_reporting ic =
  let lines = ref [] in
  let current_line = ref 1 in
  let current_pos = ref 0 in
  let read = input ic in
  Lexing.from_function (fun buf len ->
     let n = read buf 0 len in
       for i = 0 to n - 1 do
     match Bytes.get buf i with
       '\n' -> incr current_pos; incr current_line;
               lines := (!current_pos, !current_line) :: !lines
         | _ -> incr current_pos
         done; 
         n),
  (fun pos ->
    let rec find_line = function
      [] -> 1, 0
    | (linestart, _linenum)::l when pos < linestart -> find_line l
    | (linestart, linenum)::_l -> linenum, linestart
    in
     find_line !lines)
@
%  let read = 
%    if !Lang.japan 
%    then 
%      (Japan.create_read_japanese (input ic) (Japan.default_config ()))#read
%    else input ic 




<<function [[Htparse.html_nest]]>>=
let html_nest name =
  let ic = open_in name in
  let lexbuf = Lexing.from_channel ic in
  let stack = ref [] in
  Html_eval.automat Dtd.dtd32f lexbuf
    (fun (Loc(n,n')) tok ->
       match tok with
       | EOF -> close_in ic
       | OpenTag t ->
           stack := t.tag_name :: !stack
       | CloseTag t ->
           (match !stack with
            | hd::tl when hd = t -> stack := tl
            | hd::_tl -> eprintf "Unmatched closing tag %s (expected %s) at 
                            pos %d - %d" t hd n n'
            | [] -> eprintf "Unmatched closing tag %s (Empty stack) at
                            pos %d - %d" t n n'
            )
       | _ -> ()
     )
     (fun _ _ -> ())
@

<<function [[Htparse.html_indent]]>>=
let html_indent name level =
  let box = 
    match level with
    | 0 -> Format.open_box
    | 1 -> Format.open_hvbox
    | _n -> Format.open_vbox 
  in
  let ic = open_in name in
  let lexbuf  = Lexing.from_channel ic in
  box 0;
  Html_eval.automat Dtd.dtd32f lexbuf
    (fun _loc token ->
      match token with
      | EOF -> 
          Format.print_newline();
          close_in ic
       | OpenTag t ->
          Format.print_cut();
          box 0;
          box 2;
          Format.print_string (sprintf "<%s>" t.tag_name)
       | CloseTag t ->
          Format.close_box();
          Format.print_cut();
          Format.print_string (sprintf "</%s>" t);
          Format.close_box()
      | PCData _ -> 
          Format.print_string "*"
      | _ -> ()
      )
      (fun _ msg -> Format.print_string (sprintf "ERROR(%s)" msg))
@



\section{HTTP}

\subsection{Request}

% ??? -> <>
<<signature [[Http_headers.parse_request]]>>=
val parse_request : string -> Messages.request_line
  (* Parses a Request-Line
     Request-Line = Method SP Request-URI SP HTTP-Version CRLF
     Raises [Invalid_HTTP_header "Request-Line"] *)
@
%less: why need to parse a request in a client?
% we need to parse response, not request 

<<function [[Http_headers.parse_request]]>>=
(* CHECK: Normally the URI should be encoded (no spaces ?) *)
let parse_request s =
 try
  match Str.bounded_split (regexp "[ ]") s 3 with
    [m;r;v] ->
         { request_version = v;
           request_method = m;
           request_uri = r }
  | ["GET"; uri] ->
         { request_version = "HTTP/0.9";
           request_method = "GET";
           request_uri = uri }
  | [m;s] -> (* uri omitted ? *)
         { request_version = s;
           request_method = m;
           request_uri = "/" }
  | _ -> raise (Invalid_header "Request-Line")
 with
   Failure "int_of_string" -> raise (Invalid_header "Request-Line")
@
%less: could call parse_method here no? and have typed request_method
%less: aspectize http 0.9?

\subsection{Status}

% Http.process_response -> <>
<<signature [[Http_headers.parse_status]]>>=
val parse_status : string -> Messages.status_line
  (* Parses a Status-Line
     Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
     Raises [Invalid_HTTP_header "Status-Line"] 
     or [Not_found] if the string is not a Status-Line at all *)
@
<<function [[Http_headers.parse_status]]>>=
(* Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF *)
let parse_status s =
 if String.length s > 5 && String.sub s 0 5 = "HTTP/" 
 then
   try
    match Str.bounded_split (regexp "[ ]") s 3 with
      [v;c;m] ->
           { status_version = v;
             status_code = int_of_string c;
             status_message = m }
    (* it happened once with Server: Netscape-Commerce/1.1 *)
    (* where the Status Line was: HTTP/1.0 302 *)
    | [v;c] ->
           { status_version = v;
             status_code = int_of_string c;
             status_message = "empty" }
    | _ -> raise (Invalid_header "Status-Line")
   with Failure "int_of_string" -> raise (Invalid_header "Status-Line")
 else (* 0.9, dammit *)
   raise Not_found
@

%less: aspectize old stuff once we know it works on most of our websites







<<signature [[Http_headers.http_status]]>>=
(* Common headers *)
val http_status : int -> Messages.status_line
  (* [http_status n] returns Status-Line for code [n] *)
@
%less: when need to build a status ourselves? parse_status I understand
% but this?
<<function [[Http_headers.http_status]]>>=
(* A typical status line *)
let http_status code =
  {
   status_version = "HTTP/1.0";
   status_code = code;
   status_message = status_message code
  }
@
%less: rename mk_http_status ?

% mk_http_status -> <>, for debugging or error reporting?
<<function [[Http_headers.status_message]]>>=
let status_message code =  
  try Hashtbl.find status_messages code
  with Not_found -> " "
@

<<constant [[Http_headers.status_messages]]>>=
(* Messages in Status-Line *)
let status_messages = Hashtbl.create 101
@
<<toplevel [[Http_headers._2]]>>=
let _ = 
  [ 200, "OK";

    201, "Created";
    202, "Accepted";
    204, "No Content";

    301, "Moved Permanently";
    302, "Moved Temporarily";
    304, "Not Modified";

    400, "Bad Request";
    401, "Unauthorized";
    403, "Forbidden";
    404, "Not Found";

    500, "Internal Server Error";
    501, "Not Implemented";
    502, "Bad Gateway";
    503, "Service Unavailable";

    (* These are proposed for HTTP1.1 *)
    407, "Proxy Authentication Required"
  ] |> List.iter (function (code, msg) -> Hashtbl.add status_messages code msg)
@
%404!! :)
%less: could use Hashtbl.of_list




\subsection{Headers}

% generic function
<<signature [[Http_headers.get_header]]>>=
val get_header : string -> Messages.header list -> string
  (* [get_header field_name hs] returns the field_value, if any, of
     the headers, or raises [Not_found].
     [field_name] is the token is lowercase (e.g. "content-type") *)
@
<<function [[Http_headers.get_header]]>>=
(* [get_header field-name headers]
 *   returns, if it exists the field value of the header field-name
 * This is a bit costly though, but we keep headers as plain strings.
 * CHECK: speed up with some regexp matching.
 * HYP: field-name in lower-case
 *)
let get_header field_name = 
  let size = String.length field_name in
  let rec search = function
   | [] -> raise Not_found
   | s::l ->
      if String.length s >= size + 2 (* : SP *) && 
         String.lowercase_ascii (String.sub s 0 size) = field_name
      then String.sub s (size + 2) (String.length s - size - 2)
      else search l 
  in
  search
@


<<signature [[Http_headers.get_multi_header]]>>=
val get_multi_header : string -> Messages.header list -> string list
  (* [get_multi_header field_name hs] returns the list of field_value
     of the headers.
     [field_name] is the token is lowercase (e.g. "content-type") *)
@

<<function [[Http_headers.get_multi_header]]>>=
(* [get_multi_header field_name headers]
 *   get all values of the header
 *)
let get_multi_header field_name =
  let size = String.length field_name in (* :SP *)
  let rec search = function
     [] -> []
   | s::l ->
    if   String.length s >= size + 2 (* : SP *)
       && String.lowercase_ascii (String.sub s 0 size) = field_name
    then (String.sub s (size + 2) (String.length s - size - 2)) :: search l
    else search l in
  search
@




\subsubsection{Content type}

<<signature [[Http_headers.contenttype]]>>=
(* Predefined access functions *)
val contenttype : Messages.header list -> string
  (* Content-Type *)
@
<<functions [[Http_headers.xxx]] [[get_header]] applications>>=
let contenttype = 
  get_header "content-type"
@


<<signature [[Lexheaders.media_type]]>>=
val media_type : 
  string -> Http_headers.media_type * Http_headers.media_parameter list
@
<<function [[Lexheaders.media_type]]>>=
let media_type s =
  let lexbuf = Lexing.from_string s in
  let mtyp = media_type lexbuf in
  let l = media_parameters lexbuf in
  mtyp, l 
@

<<function [[Lexheaders.media_type]] lexer>>=
(* ex: token/token *)
and media_type = parse
| [' ' '\t']+ {
      let _ = starlws lexbuf in
      let typ = String.lowercase_ascii (token lexbuf) in
      let _ = lit_slash lexbuf in
      let subtyp = String.lowercase_ascii (token lexbuf) in
      let _ = starlws lexbuf in (* word based *)
      typ, subtyp
    }

| "" {
      let _ = starlws lexbuf in
      let typ = String.lowercase_ascii (token lexbuf) in
      let _ = lit_slash lexbuf in
      let subtyp = String.lowercase_ascii (token lexbuf) in
      let _ = starlws lexbuf in (* word based *)
        typ, subtyp
      }
@

<<function [[Lexheaders.token]]>>=
and token = parse
   [^ '\127'-'\255' 
      '\000'-'\031'
      '(' ')' '<' '>' '@' ',' ';' ':' '\\' '"' '/' '[' ']' '?' '=' ' ' '\t']+
      { Lexing.lexeme lexbuf }
  | _ { raise (Invalid_header "token expected") }
@
<<function [[Lexheaders.starlws]]>>=
(* *LWS *)
and starlws = parse
   ("\r\n")? [' ' '\t']+ { starlws lexbuf }
  | "" { () }   
@



<<function [[Lexheaders.media_parameters]]>>=
and media_parameters = parse
| "" { [] }
| ";" { 
     let _ = starlws lexbuf in
     let attr = String.lowercase_ascii (token lexbuf) in
     let _ = lit_equal lexbuf in (* no space allowed *)
     let v = value lexbuf in
     let _ = starlws lexbuf in
     let rest = media_parameters lexbuf in
     (attr,v)::rest
 }
@

<<function [[Lexheaders.lit_equal]]>>=
and lit_equal = parse
| '=' { () }
|  _  { raise (Invalid_header "= expected") }
@

<<function [[Lexheaders.value]]>>=
(* value = token | quoted-string *)
and value = parse
| '"' [^ '"' '\000'-'\031' '\127'-'\255' ]* '"'
    { let t = Lexing.lexeme lexbuf in
       String.sub t 1 (String.length t - 2)
    }
| [^ '\127'-'\255' 
      '\000'-'\031'
      '(' ')' '<' '>' '@' ',' ';' ':' '\\' '"' '/' '[' ']' '?' '=' ' ' '\t']+
   { Lexing.lexeme lexbuf }
| _ { raise (Invalid_header "value expected") }
@

\subsubsection{Content length}

<<signature [[Http_headers.contentlength]]>>=
val contentlength : Messages.header list -> int
  (* Content-Length *)
@
% Plain.display_plain#init -> <>
<<functions [[Http_headers.xxx]] [[get_header]] applications>>=
let contentlength l = 
  let h = get_header "content-length" l in
  try int_of_string h 
  with _ -> raise Not_found
@

% but for plain text, who retype the length and add it in the header?
% File.request does that! (the file:/// protocol)

\subsubsection{Content encoding}

<<signature [[Http_headers.contentencoding]]>>=
val contentencoding : Messages.header list -> string
  (* Content-Encoding *)
@
<<functions [[Http_headers.xxx]] [[get_header]] applications>>=
let contentencoding = 
  get_header "content-encoding"
@
% UTF-8!!??



%******************************************************************************
\chapter{Retrieving}
%******************************************************************************
%Retrieving Documents
% retrieve/
% put before http

% Nav.request.retrieve_and_handle -> <>
<<signature [[Retrieve.f]]>>=
(* f is supposed to raise only Invalid_url *)
val f : < Cap.network; .. > ->
   Www.request ->  (* the request *)
   (Hyper.link -> unit) -> (* the retry function *)
   Document.continuation -> (* the handlers *)
   status
@

<<type [[Retrieve.retrievalStatus]]>>=
type status =
 | Started of Www.aborter
 | InUse
@

% so close to the retriever protocol type,
% which was request -> continuation -> aborter

\section{[[Retrieve.f()]]}

<<function [[Retrieve.f]]>>=
(*
 * Emitting a request:
 *   we must catch here all errors due to protocols and remove the
 *   cnx from the set of active cnx.
 *)
(* Nav.request -> <> -> Http.req (via Protos.get) -> Http.tcp_connect *)
and f (caps : < Cap.network; ..>) 
    (request : Www.request)
    (retry : Hyper.link -> unit) 
    (cont : Document.continuation) : status = 
  Logs.debug (fun m -> m "Retrieve.f on %s" (Url.string_of request.www_url));
  if Www.is_active_cnx request.www_url
  then InUse
  else begin
    Www.add_active_cnx request.www_url;
    try 
      let (reqf, cachef) = Protos.get request.www_url.protocol in
      Started (reqf (caps :> < Cap.network >) request
                 { cont with
                   document_process = http_check caps cachef retry cont request})

   with 
   | Not_found ->
       Www.rem_active_cnx request.www_url;
       raise (Www.Invalid_request (request, s_ "unknown protocol"))
   | Http.HTTP_error s ->
       Www.rem_active_cnx request.www_url;
       raise (Www.Invalid_request (request, s_ "HTTP Error \"%s\"" s))
   | File.File_error s ->
       Www.rem_active_cnx request.www_url;
       raise (Www.Invalid_request (request, s))
   end
@

% http_check intermediate continuation!

\section{Behaviour}

<<type [[Retrieve.behaviour]]>>=
(* We should implement the proper behaviours for all return codes
 * defined in the HTTP/1.0 protocol draft. 
 * Return codes are HTTP specific, but since all protocols are more or
 * less mapped to http, we deal with them at the retrieval level.
 *)
type behaviour =
 | Ok 			              (* process the document *)
 | Stop of string             (* stop (no document) and display message *)
 | Retry of Hyper.link        (* restart with a new link *)
 | Error of string            (* same as stop, but it's an error *)
 | Restart of (Document.handle -> Document.handle) 
   (* restart the same request, but apply transformation on the continuation *)
@
%less: LP split and aspectize advanced features

\subsection{[[Retrieve.http_check()]]}

% rename? Retrieve.process_status_code?
<<function [[Retrieve.http_check]]>>=
(* 
 * Dispatch according to status code
 *  retry: how to re-emit a request
 *  cont: what to do with the response 
 *)
(* f -> Http.req (via protos) cont -> <> (via cont.document_process) -> codex *)
let rec http_check (caps: < Cap.network; .. > )
         cache 
         (retry : Hyper.link -> unit)
         (cont : Document.continuation) 
         (wwwr : Www.request)
         (dh : Document.handle) : unit =
  Logs.debug (fun m -> m "Retrieve.http_check");
  try (* the appropriate behavior *)
    (* alt: just have a single function matching on code *)
    let behav = Hashtbl.find http_process dh.document_status in
    match behav wwwr dh with
    | Ok -> 
        (* do I cache ? *)
        let cacheable = wwwr.www_link.h_method = GET in
        cont.document_process
          (if cacheable then wrap_cache cache dh else dh)
    | Stop msg ->
        Document.dclose true dh;
        cont.document_finish false;
        wwwr.www_error#ok msg
    | Error msg ->
        Document.dclose true dh;
        cont.document_finish false;
        wwwr.www_error#f msg
    | Retry hlink ->
        Document.dclose true dh;
        cont.document_finish false;
        retry hlink
    | Restart transform ->
        Document.dclose true dh;
        f caps wwwr retry 
         { cont with 
           document_process = (fun dh -> cont.document_process (transform dh))}
        |> ignore; (* we should probably do something of the result ! *)
  with Not_found ->
     (* default behavior is to call the normal continuation 
      * BUT WE DON'T CACHE !
      * e.g. 404 Not found, 500, ...
      *)
      cont.document_process dh
@


% Retrieve.f -> http_check -> <> (-> Retype.f)
<<function [[Retrieve.wrap_cache]]>>=
(* What do we cache ? : text/html and text/plain in memory *)
let wrap_cache cache (dh : Document.handle) : Document.handle =
  Logs.debug (fun m -> m "Wrapping cache for %s(%d)"
             (Url.string_of dh.document_id.document_url)
             dh.document_id.document_stamp);
  (* infer content-type and content-encoding using filename extension of
   * document if content-type was not specified in the headers
   *)
  Retype.f dh;
  try
    match Lexheaders.media_type (Http_headers.contenttype dh.dh_headers) with
    | ("text","html"),_ 
    | ("text","plain"),_ ->
      begin 
       try
         let doc, c = cache dh in
         Cache.add dh.document_id
                 { document_address = dh.document_id.document_url;
                   document_data = doc; 
                   document_headers = dh.dh_headers };
          Cache.wrap c dh
       with Cache.DontCache -> dh
      end
    | _ -> dh
  with Not_found -> dh
@


\subsection{HTTP status codes}
% processor? postprocessor? status code post processor?

<<constant [[Retrieve.http_process]]>>=
(*
 * Provision for user (re)definition of behaviours.
 *)
let http_process : 
  (int, Www.request -> Document.handle -> behaviour) Hashtbl.t = 
  Hashtbl_.create ()
@
% pass handler so can access the headers

<<signature [[Retrieve.add_http_processor]]>>=
val add_http_processor : 
  int -> (Www.request -> Document.handle -> behaviour) -> unit
@
<<constant [[Retrieve.add_http_processor]]>>=
let add_http_processor = Hashtbl.add http_process
@
%alt: just write an http_process function with a big match

<<toplevel [[Retrieve._1]]>>=
(* 400 : proxies do return this code when they can satisfy the request,
 *       so we keep it as default (displayed)
 *)
let _ =
  [200, code200;
   201, code200;
   202, code200;
   204, code204;
   <<Retrieve code behaviour other elements>>
  ] |> List.iter (function (code, behave) -> 
     Hashtbl.add http_process code behave
  )
@

% no 404? :)


<<function [[Retrieve.code200]]>>=
(* 200 OK *)
let code200 _wwwr _dh = Ok
(* 201 Created (same as 200) *)
(* 202 Accepted (same as 200) *)
@
<<function [[Retrieve.code204]]>>=
(* 204 No Content: we should modify the headers of the referer ? *)
let code204 _wwwr (dh : Document.handle) =
  Stop (s_ "Request fulfilled.\n(%s)" (Http_headers.status_msg dh.dh_headers))
@

<<function [[Retrieve.code400]]>>=
(* 400 Bad request *)
let _code400 _wr _dh = Error (s_ "Bad Request")
@
% dead??

\section{Active connections}

<<module Www.UrlSet>>=
(* Table of unresolved active connexions *)
(* We need to keep a trace of pending connections, since there is a race
   condition when the user clicks twice rapidly on an anchor. If the second
   click occurs before the document is added to the cache, (e.g. because we
   are waiting for the headers), then the document will be retrieved twice.
   And naturally, for documents that don't enter the cache we always will
   duplicate connexions.
   Retrieve.f is a safe place to add the request to the list of pending
   connexions, because it is synchronous.
   Removing an active connexion must take place when we close the 
   dh.document_fd.
*)
module UrlSet = Set.Make(struct type t = Url.t let compare = compare end)
@
%TODO Set_.t

<<constant [[Www.active_connexions]]>>=
let active_connexions = ref UrlSet.empty
@

<<signature [[Www.is_active_cnx]]>>=
val is_active_cnx : Url.t -> bool
@
<<signature [[Www.add_active_cnx]]>>=
val add_active_cnx : Url.t -> unit
@
<<signature [[Www.rem_active_cnx]]>>=
val rem_active_cnx : Url.t -> unit
@

% Retrieve.f -> <>
<<functions [[Www.xxx_active_cnx]]>>=
let is_active_cnx url = 
  UrlSet.mem url !active_connexions
let add_active_cnx url = 
  active_connexions := UrlSet.add url !active_connexions
@

% Retrieve.f (when error) | (??-> Document.dclose) | Http.failed_request -> <>
<<functions [[Www.xxx_active_cnx]]>>=
let rem_active_cnx url =
  active_connexions := UrlSet.remove url !active_connexions
@

\section{Connections, [[Feed.t]]}

<<type [[Feed.internal]]>>=
(* An abstract notion of connection *)
type internal = Unix.file_descr
@
%less: why not put as abstract type for real then?

<<type [[Feed.t]]>>=
type t = {
  feed_read : bytes -> int -> int -> int;

  feed_schedule : (unit -> unit) -> unit;
  feed_unschedule : unit -> unit;

  feed_close : unit -> unit;

  feed_internal : internal  
}
@


<<signature [[Feed.of_fd]]>>=
val make_feed : Unix.file_descr -> (bytes -> int -> int -> int) -> t
@

XXX split and understand

% ??? -> <>
<<function [[Feed.of_fd]]>>=
(* We should distinguish internal/external connections *)
let make_feed (fd : Unix.file_descr) (do_read : bytes -> int -> int -> int) : t =

  let is_open = ref true in
  let action = ref None in
  let condition = Condition.create() in
  let first_read = ref false in

  (* ASSUMES: this is the first read on the fileevent *)
  let safe_read (buf : bytes) (offs : int) (len : int) : int =
    first_read := false;
    if !is_open
    then do_read buf offs len
    else 0
  in

  (* In other cases : this is non blocking but not fully threaded. *)
  let special_read (buf : bytes) (ofs : int) (len : int) : int =
     (* remove the normal handler *)
     Fileevent_.remove_fileinput fd; 
     (* add a handler to trigger the condition *)
     Fileevent_.add_fileinput fd (fun () ->
       Fileevent_.remove_fileinput fd; (* remove myself *)
       Condition.set condition
     );
     (* wait for the condition to happen *)
     Condition.wait condition;
     (* Meanwhile, someone may have unscheduled/closed the 
      * feed (e.g. abort). We call safe_read, but if the feed has been
      * closed, read will fail.
      * To know if we have to put back on schedule, check the *current*
      * state of action
      *)
     let n = try safe_read buf ofs len with _ -> 0 in
     (* reschedule; it is essential that Low.add_fileinput does not
      * call the event loop, otherwise we loose sequentiality of reads 
      *)
     (match !action with
      | Some f ->
          Fileevent_.add_fileinput fd (fun () -> first_read := true; f())
      | None -> ()
      );
     (* and return *)
     n
  in 
  { feed_read = (fun buf ofs len -> 
      if !first_read 
      then safe_read buf ofs len
      else special_read buf ofs len
   );

   feed_schedule = (fun f ->
      if not !is_open 
      then Logs.err (fun m -> m "feed is closed, can't schedule")
      else 
       (match !action with
        | Some _f -> (* we are already scheduled ! *)
            Logs.warn (fun  m -> m "feed already scheduled")
        | None ->
            action := Some f;
            Low.add_fileinput fd (fun () -> first_read := true; f())
        )
   );

   feed_unschedule = (fun () -> 
     match !action with
     | Some _f -> 
         Low.remove_fileinput fd; 
         action := None
     | None -> 
         (* this happens quite often (for all action codes which
          * do not process the body of the document, the feed got
          * unscheduled as the end of headers) 
          *)
         ()
   );

   (* feed_close must be called only if the feed it *not* scheduled *)

   feed_close = (fun () -> 
     (* if we abort during a state when we are waiting on the condition,
      * the feed is unscheduled but we never get out. So always change
      * the state 
      *)
      Condition.set condition;
      if !is_open 
      then
        (match !action with 
        | Some _f -> Logs.err (fun m -> m "feed is scheduled, can't close")
        | None -> 
            Unix.close fd;
            is_open := false;
            (* Condition.free condition RACE CONDITION HERE *)
        )
    );

    feed_internal = fd
   }
@

<<signature [[Feed.internal]]>>=
val internal : t -> internal
@
<<function [[Feed.internal]]>>=
let internal (feed : t) : internal =
  feed.feed_internal
@


\section{Logging}
%less: mv in appendix



<<signature [[Document.dclose]]>>=
val dclose : bool (* remactive *) -> handle -> unit
  (* [dclose remactive dh] closes a living dh *)
@

<<signature [[Document.add_log]]>>=
val add_log: handle -> string -> Www.aborter -> unit
@

<<signature [[Document.put_log]]>>=
val put_log : handle -> string -> unit
@

<<signature [[Document.progress_log]]>>=
val progress_log : handle -> int -> unit
@

<<signature [[Document.end_log]]>>=
val end_log : handle -> string -> unit
@

<<signature [[Document.destroy_log]]>>=
val destroy_log : handle -> bool -> unit
  (* logging functions *)
@



<<function [[Document.dclose]]>>=
(* Close a connexion. Should be called only by a fileinput callback
      or by somebody attempting to abort the connexion 
   We remove the fd of the select before closing it since we don't want
   a spurious read to happen. This way we are somewhat independant of the
   Tk implementation 
 *)

let dclose (remactive : bool) (dh : handle) : unit =
  dh.document_feed.feed_unschedule();
  dh.document_feed.feed_close();
  if remactive then Www.rem_active_cnx dh.document_id.document_url
@


<<function [[Document.add_log]]>>=
let add_log (dh : handle) initmsg aborter =
  !add_log_backend dh initmsg aborter
@

<<function [[Document.end_log]]>>=
let end_log (dh : handle) (msg : string) : unit =
    dh.document_logger.logger_end msg;
    destroy_log dh true
@

<<functions [[Document.xxx_log]]>>=
let put_log (dh : handle) = dh.document_logger.logger_msg
let destroy_log (dh : handle) = dh.document_logger.logger_destroy
let progress_log (dh : handle) = dh.document_logger.logger_progress
@


\section{Images}

<<signature [[Img.get]]>>=
val get : <Cap.network; ..> ->
   Document.id -> Hyper.link -> (Url.t -> ImageData.t -> unit) -> 
   Scheduler.progress_func -> unit
@

XXX ??
<<signature [[Img.update]]>>=
val update : < Cap.network; ..> ->
  Url.t -> unit
@


<<function [[Img.get]]>>=
(* ??? -> <> *)
let get (caps : < Cap.network; ..>) (did : Document.id) (link : Hyper.link) cont 
        (prog : Scheduler.progress_func) : unit =
  let wr = Www.make link in
  wr.www_headers <- "Accept: image/*" :: wr.www_headers;
  ImageScheduler.add_request (caps :> < Cap.network >) wr did cont prog
@


<<function [[Img.update]]>>=
(* ??? -> <> *)
let update (caps : < Cap.network; ..>) (url : Url.t) : unit =
  try
    let (oldi, refs, headers) = ImageData.direct_cache_access url in
    let link = Hyper.default_link (Url.string_of url) in
    let wr = Www.make link in
    let date_received = Http_headers.get_header "date" headers in
    wr.www_headers <- 
       ("If-Modified-Since: "^date_received)
       :: "Pragma: no-cache"
       :: wr.www_headers;

    ImageScheduler.add_request (caps :> < Cap.network >) wr (Document.DocumentIDSet.choose !refs)
      (fun _url i -> 
        match oldi, i with
        | Still (ImagePhoto oldn) , Still (ImagePhoto newn) ->
          Imagephoto.copy oldn newn []
        | _, _ -> ()
      )
      Progress.no_meter

  with
    Not_found ->  (* either not in cache (bogus) or no date *)
      ()
@


\section{Scheduling}



\section{Progressing}
% important in a slow word to have some feedback


<<type [[Scheduler.progress_func]]>>=
type progress_func = int option -> int -> unit
@



<<signature [[Progress.no_meter]]>>=
val no_meter : Scheduler.progress_func
@
<<constant [[Progress.no_meter]]>>=
let no_meter = (fun _ _ -> () : Scheduler.progress_func)
@

<<signature [[Progress.meter]]>>=
@

<<function [[Progress.meter]]>>=
@


%******************************************************************************
\chapter{HTTP}
%******************************************************************************
%Communication Protocol
% http/

% will see http://, main protocol, see also file://, mailto://
% in extra protocol chapter, later

%rappel:
%<<signature Protos.get>>=
%val get: Url.protocol ->
%  (Www.request -> Document.document_continuation -> Www.aborter) *
%  (Document.handle -> Document.document_data * Cache.cache_fill)
%@

%less: why use continuation instead of returning things?
% this makes the code harder to follow.
% for instance tcp_connect takes a continuation, but return a connection
% that later will call the continuation. argh.
% use lwt instead? or async? or monads? or use threads??
% might be far simpler with threads no? or is it because
% it would not play well with tk?

% Build each time a serie of intermediate computations.
% for instance I guess mmm want to be called once the document
% arrived, e.g. doc_arrived()
% then we initiate a connection and want
% first start_request to be called and then doc_arrived, so
% we pass another continuation like (fun ... -> start_request   cont)
% where cont will be doc_arrived called by start_request once it's
% done. 



\section{The request}

\subsection{[[Http.req()]]}

<<toplevel [[Protos._2]]>>=
let _ = Hashtbl.add protos Url.HTTP (Http.req, Cache.tobuffer)
let _ = Hashtbl.add protos Url.HTTPS (Http.req, Cache.tobuffer)
@

% Nav.request -> Retrieve.f (wr where wr protocol = HTTP) -> <> 
%  (as Retrieve.f.req <- Protos.get HTTP wr <- Hashtbl.add protos (<>) <- _top
<<signature [[Http.req]]>>=
val req: < Cap.network; ..> ->
  Www.request -> Document.continuation -> Www.aborter
@

% wr = web request, cont = continuation
<<function [[Http.req]]>>=
(* Wrappers returning the abort callback *)
(* Retrieve.f -> <> (via protos) -> ... -> cont.document_process *)
let req caps (wr : Www.request) (cont : Document.continuation) : Www.aborter =
  let cnx = request caps wr cont in
  (fun () -> cnx#abort)
@
% run the request asynchronously,
% and return the function to abort to the caller want to call it!

%urlp = url parsed?
<<function [[Http.request]]>>=
(* Issueing request, with the "retry" logic (unless is "always proxy" mode, 
   we attempt first to connect directly to the host, and if it fails,
   we retry through the proxy
 *)
(* Retrieve.f -> req (via protos) -> <> -> tcp_connect -> 
 *  start_request (via contf) -> async_request -> process_response ->
 *   cont.document_process
 *)
let request (caps : < Cap.network; ..>)
    (wr : Www.request) (cont : Document.continuation) : cnx =
  <<[[Http.request()]] if always proxy>>
  else 
    let urlp = wr.www_url in
    if urlp.protocol = HTTP || urlp.protocol = HTTPS
    then
      let host = 
        match urlp.host with
        | Some h -> h 
        | _ -> raise (HTTP_error (s_ "Missing host in url"))
      in
      let port =  
        match urlp.port with
        | Some p -> p
        | None -> 
          (match urlp.protocol with
          | HTTP -> 80  (* default http port *)
          | HTTPS -> 443
          | _ -> raise (Impossible "can only have HTTP or HTTPS here")
          )
      in 
      let is_https = urlp.protocol = HTTPS in
      try
        tcp_connect ~is_https caps host port wr.www_logging
            (fun cnx -> start_request false wr cont  cnx)
            (fun s aborted -> failed_request wr cont.document_finish s aborted)

      with HTTP_error _ -> (* direct failed, go through proxy *)
        <<[[Http.request()]] if http error on [[tcp_connect]], try proxy>>
    else 
      raise (HTTP_error (s_ 
             "INTERNAL ERROR\nHttp.request (not a distant http url): %s" 
               (Url.string_of wr.www_url)))
@
%old: used to use partial app of start_request and failed_request
% but clearer to eta expand I think


\subsection{[[Http.tcp_connect()]]}

% Http.req -> <>
<<function [[Http.tcp_connect]]>>=
(* Open a TCP connection, asynchronously (except for DNS).
   We pass the continuation *)
(* req | proxy_req -> request | proxy_request -> <> *)
let tcp_connect ?(is_https = false) (caps : < Cap.network; ..>)
    (server_name : string) (port : int) logf contf errorf =

  (*  Find the inet address *)
  let server_addr : Unix.inet_addr =
    try Unix.inet_addr_of_string server_name
    with Failure _ ->
      <<[[Http.tcp_connect()]] if [[inet_add_of_string]] fails>>
  in

  (* Attempt to connect *)
  let sock = Unix.socket PF_INET SOCK_STREAM 0 in
  Unix.clear_nonblock sock;
  Unix.set_nonblock sock; (* set to non-blocking *)
  let cnx = new cnx (sock, errorf "User abort") in
  logf (s_ "Contacting host...");
  let ssl_handshake_and_continue cnx =
    if is_https then
      (try
        let s = Ssl.embed_socket cnx#fd ssl_ctx in
        Ssl.set_client_SNI_hostname s server_name;
        Ssl.connect s;
        cnx#set_ssl s;
        contf cnx
      with exn ->
        cnx#close;
        errorf (s_ "SSL handshake failed with %s: %s" server_name
                    (Printexc.to_string exn)) false)
    else
      contf cnx
  in
  try
    begin try
      CapUnix.connect caps sock (ADDR_INET(server_addr, port));
      (* just in case. Normally an error should be raised *)
      Unix.clear_nonblock sock; (* set to non-blocking *)
      logf (s_ "connection established");
      Logs.debug (fun m -> m "Connect returned without error !");

      (* because we need to return cnx *)
      Timer_.set 10 (fun () ->
        (* ! calling the continuation, e.g. start_request *)
        ssl_handshake_and_continue cnx
      );
      cnx
    with Unix.Unix_error((EINPROGRESS | EWOULDBLOCK | EAGAIN), "connect", _) -> 
      <<[[Http.tcp_connect()]] if unix error when connect>>
    end
  with Unix.Unix_error(e,fn,_) ->  (* other errors in connect *)
    cnx#close;
    raise (HTTP_error (s_ "Cannot establish connection\n%s:%s"
                             (Unix.error_message e) fn))
@

\subsubsection{[[cnx]]}

<<type [[Http.status]]>>=
(* Support for aborting requests while in connect/write/headers mode.
   When we start applying the document continuation, it is not our job
   anymore to abort the connection.
 *)
type status = 
  | Writing 
  <<[[Http.status]] cases>>
@


<<class [[Http.cnx]]>>=
class cnx (sock, finish) =
 object (self)
  val mutable status = Writing
  val mutable fd = sock

  (* val finish = finish *)
  val mutable fdclosed = false		(* protect against double close *)
  val mutable aborted = false
  val mutable ssl_sock : Ssl.socket option = None

  method fd = 
    fd
  method aborted = 
    aborted
  method set_fd newfd = 
    fd <- newfd
  method set_status s =
    status <- s
  method ssl_socket = ssl_sock
  method set_ssl s = ssl_sock <- Some s

  method write (buf : bytes) pos len =
    match ssl_sock with
    | None   -> Unix.write fd buf pos len
    | Some s -> Ssl.write s buf pos len

  method read (buf : bytes) pos len =
    match ssl_sock with
    | None   -> Low.read fd buf pos len
    | Some s -> Low.count_read (fun buf offs l ->
        try Ssl.read s buf offs l
        with Ssl.Read_error _ -> 0 (* treat all SSL read errors as EOF *)
      ) buf pos len

  method close =
    if not fdclosed then begin
      (match ssl_sock with
       | None -> ()
       | Some s -> (try Ssl.shutdown s with _ -> ()));
      Unix.close fd;
      fdclosed <- true
    end

  (* can be called from the aborter by the user or some exn handler *)  
  method abort =
     if not aborted then begin
       aborted <- true;
       match status with
       | Writing -> 
           Fileevent_.remove_fileoutput fd; 
           self#close; 
           finish true
       <<[[Http.cnx.abort()]] cases>>
    end
end
@
% ugly, could simplify? use regular record, no need those setter/getter boilerplate


\subsubsection{Error management}

<<[[Http.tcp_connect()]] if [[inet_add_of_string]] fails>>=
try
  logf (s_ "Looking for %s ..." server_name);
  let adr = (Low.busy Munix.gethostbyname server_name).h_addr_list.(0) in
  logf (s_ "%s found" server_name);
  adr
with Not_found -> 
 raise (HTTP_error (s_ "Unknown host: %s" server_name)) 
@

<<[[Http.tcp_connect()]] if unix error when connect>>=
 (* that is ok, we are starting something *)
 let stuck = ref true in
 Fileevent_.add_fileoutput sock
   (* we are called when the cnx is established *)
   (fun () -> 
     stuck := false;
     Fileevent_.remove_fileoutput sock;
     Unix.clear_nonblock sock; (* return to blocking mode *)
     begin try (* But has there been a cnx actually *)
       let _ = Unix.getpeername sock in
       logf (s_ "connection established");
       ssl_handshake_and_continue cnx
     with Unix.Unix_error(ENOTCONN, "getpeername", _) ->
       cnx#close;
       errorf (s_ "Connection refused to %s" server_name) false
      end
   );
  <<[[Http.tcp_connect()]] setup timeout>>
  cnx
@



\subsubsection{Timout management}

<<constant [[Http.timeout]]>>=
let timeout = ref 60		(* in seconds *)
@

<<[[Http.tcp_connect()]] setup timeout>>=
(* but also start the timer if nothing happens now
* the kernel has a timeout, but it might be too long (linux) 
*)
Timer_.set (1000 * !timeout)
  (fun () -> 
     if not cnx#aborted && !stuck 
     then begin
       Fileevent_.remove_fileoutput sock;
       cnx#close;
       errorf (s_ "Timeout during connect to %s" server_name) false
      end
  );
@

\subsection{[[Http.start_request()]]}

% tcp_connect -> <>
<<function [[Http.start_request]]>>=
let start_request (proxy_mode : bool) (wwwr : Www.request)
     (cont : Document.continuation) =
 fun (cnx : cnx) ->
  async_request proxy_mode wwwr 
     (fun cnx -> process_response wwwr cont cnx) cnx
@
% the continuation once we get the date is indeed to process
% the response!

<<function [[Http.async_request]]>>=
(* Writing the request to the server
 *   TODO:  We might get some error here in write
 *   NOTE: tk doesn't allow two handles on the same fd, thus use CPS
 *         so that reading response is our continuation
 *)
let async_request (proxy_mode : bool) (wwwr : Www.request) cont (cnx : cnx) =
  let b = Ebuffer.create 1024 in
  full_request (fun x -> Ebuffer.output_string b x) proxy_mode wwwr;
  let req = Ebuffer.get b in
  let len = Ebuffer.used b in
  let curpos = ref 0 in
  wwwr.www_logging (s_ "Writing request...");
  Fileevent_.add_fileoutput cnx#fd (fun _ ->
    let n = cnx#write (Bytes.of_string req) !curpos (len - !curpos) in (* blocking ? *)
    curpos := !curpos  + n;
    if !curpos = len then begin
      Fileevent_.remove_fileoutput cnx#fd;
      <<[[Http.async_request()]] log request string req if verbose>>
      (* ! calling the continuation, e.g. process_response *)
      cont cnx
    end)
@

% the continuation here should be process_response!

\subsection{[[Http.full_request()]]}

% this will build the content of the request in a buffer
% represented by the writer 'w'
% less: pass the buffer instead? need to abstract?
% less: rename build_request_string?

% Http.req -> tcp_connect -> start_request -> async_request -> <>
<<function [[Http.full_request]]>>=
(* 'w' is the writer that will fill a buffer set in the caller *)
(* request -> tcp_connect -> start_request (via cont) -> async_request -> <> *)
let full_request (w : string -> unit) (proxy_mode : bool) (wwwr : Www.request) : unit = 
  let url : string = 
    <<[[Http.full_request()]] url value if proxy mode>>
    else Url.distant_path wwwr.www_url 
  in
  <<[[Http.full_request()]] helper functions>>
  match wwwr.www_link.h_method with
  <<[[Http.full_request()]] method cases>>
@


<<signature [[Url.distant_path]]>>=
(* For http. The thing we have to send in the request *)
val distant_path : t -> string
@
<<function [[Url.distant_path]]>>=
(* For http only *)
let distant_path urlp =
  match urlp.path, urlp.search with
     None, None -> "/"
   | Some p, None -> "/"^p
   | Some p, Some s -> "/" ^ p ^ "?" ^ s
   | None, Some s -> "/?" ^ s (* ??? *)
@
% so we just send the path and search component!
% the host know who it is already
%less: why distant??

\subsubsection{[[GET]]}

<<[[Http.full_request()]] method cases>>=
| GET ->
    w ("GET " ^ url ^ " HTTP/1.0\r\n");
    (* No General-Header *)
    w (std_request_headers());
    write_referer ();
    <<[[Http.full_request()]] write auth stuff>>
    write_other_headers();
    write_host();
    w "\r\n"
@
% finally! the GET request
% will see referer in advanced topic section

<<function [[Http.std_request_headers]]>>=
let std_request_headers() =
  Printf.sprintf "User-Agent: %s\r\n" !user_agent
@

<<constant [[Http.user_agent]]>>=
let user_agent = 
  ref Version.http
@




<<[[Http.full_request()]] helper functions>>=
let write_other_headers () =
  wwwr.www_headers |> List.iter (fun s -> w s; w "\r\n");
  (* If no Accept given in request, write default one *)
  begin
    try
      Http_headers.get_header "accept" wwwr.www_headers |> ignore
    with Not_found -> w "Accept: */*\r\n"
  end
in
@
% is it where the parameter of the GET are stored?

<<[[Http.full_request()]] helper functions>>=
(* Host: header for virtual domains *)
let write_host () =
  match wwwr.www_url.host with
  | None -> (* never happens *) ()
  | Some h -> 
      (match wwwr.www_url.port with
      | None -> w ("Host: "^h^"\r\n")
      | Some p ->  w ("Host: "^h^":"^string_of_int p^"\r\n")
      )
in
@


\subsubsection{[[POST]]}

<<[[Http.full_request()]] method cases>>=
| POST data ->
    w ("POST "^url^" HTTP/1.0\r\n");
    (* No General-Header *)
    w (std_request_headers());
    write_referer ();
    <<[[Http.full_request()]] write auth stuff>>
    write_other_headers();
    write_host();
    (* 8.2.1 *)
    w ("Content-Type: application/x-www-form-urlencoded\r\n");
    (* 7.2 note *)
    w ("Content-Length: " ^ string_of_int (String.length data)^ "\r\n");
    w "\r\n";
    w data
@


\subsubsection{[[HEAD]]}

% when this is used? Who is doing HEAD request?

<<[[Hyper.link_method]] other cases>>=
| HEAD
@

<<[[Http.full_request()]] method cases>>=
| HEAD ->
    w ("HEAD "^url^" HTTP/1.0\r\n");
    (* No General-Header *)
    w (std_request_headers());
    write_referer ();
    <<[[Http.full_request()]] write auth stuff>>
    write_other_headers();
    write_host();
    w "\r\n"
@
% ???

\subsection{[[Http.failed_request()]]}

% call with aborted = true when ??
<<function [[Http.failed_request]]>>=
(* shared error *)
let failed_request (wr : Www.request) finish =
 fun s aborted ->
  finish aborted;
  Www.rem_active_cnx wr.www_url;
  wr.www_logging (s_ "Failed");
  wr.www_error#f (s_ "Request for %s failed\n%s" (Url.string_of wr.www_url) s)
@
% aborted is a bool

\section{The response}

\subsection{[[Http.process_response()]]}

% async_request (via its continuation passed in start_request) -> <>
<<function [[Http.process_response]]>>=
(* Read headers and run continuation *)
(* tcp_connect -> <> (via contf) *)
let process_response (wwwr : Www.request) (cont : Document.continuation) =
 fun (cnx : cnx) ->
  let url : string = Url.string_of wwwr.www_url in
  wwwr.www_logging (s_ "Reading headers...");

  let dh = 
    Document.{ document_id = document_id wwwr;
      document_referer = wwwr.www_link.h_context;
      document_fragment = wwwr.www_fragment;

      document_status = 0;
      dh_headers = [];
      document_feed = Feed.make_feed cnx#fd cnx#read;

      document_logger = Document.tty_logger;
    }
  in
  cnx#set_status (Reading dh);

  let stuck = ref true in
  (* set up a timer to abort if server is too far/slow *)
  <<[[Http.process_response()]] setup a timer>>

  (* reading the headers *)
  dh.document_feed.feed_schedule
    (fun () ->
       stuck := false;
       <<[[Http.process_response()]] reading headers>>
@
% seems to call the continuation only for error cases

<<[[Http.status]] cases>>=
| Reading of Document.handle 
@

\subsection{Reading headers}

<<[[Document.handle]] other fields>>=
mutable document_status : int;
  (* Status code of response *)
@


<<[[Http.process_response()]] reading headers>>=
try
  if dh.dh_headers = [] then begin
    (* it should be the HTTP Status-Line *)
    let l = Low.read_line_fn cnx#read in
    dh.document_status <- (Http_headers.parse_status l).status_code;
    dh.dh_headers <- [l] (* keep it there *)
  end else
     dh.dh_headers <- read_headers cnx#read dh.dh_headers
with
(* each branch must unschedule *)
<<[[Http.process_response()]] feed schedule callback failure cases>>
@

<<exception [[Http.End_of_headers]]>>=
exception End_of_headers
@

<<signature [[Http.read_headers]]>>=
(* [read_headers fd]
 *  reads HTTP headers from a fd
 *    raises End_of_file
 *    raises Invalid_HTTP_header
 *)
val read_headers:
  (bytes -> int -> int -> int) -> string list -> string list
@
% process_response | fake_cgi -> <>
<<function [[Http.read_headers]]>>=
let read_headers read_fn previous =
  let l = Low.read_line_fn read_fn in
   if String.length l = 0 
   then raise End_of_headers (* end of headers *)
   else 
     if l.[0] = ' ' || l.[0] = '\t' 
     then  (* continuation *)
       match previous with
       | [] -> raise (Http_headers.Invalid_header ("invalid continuation " ^ l))
       | s :: rest -> (s^l) :: rest
      else l :: previous
@
% empty line means end of response!
% tabs or space are compacted?


% this is the normal case! 
% we finally call the continuation! to let the caller
% process the document! woohoo!
<<[[Http.process_response()]] feed schedule callback failure cases>>=
| End_of_headers ->
    dh.document_feed.feed_unschedule();
    cnx#set_status Discharged;

    (* ! call the continuation, finally! *)
    cont.document_process dh

@
%less: not a big fan of using exn again for non exception cases
% but instead regular flow.

<<[[Http.status]] cases>>=
| Discharged
@
<<[[Http.cnx.abort()]] cases>>=
| Discharged -> ()
@


\subsection{Error management}


<<[[Http.process_response()]] feed schedule callback failure cases>>=
| Not_found -> (* that's what parse_status raises. HTTP/0.9 dammit *)
    failwith "HTTP 0.9 not handled anymore"
@

<<[[Http.process_response()]] feed schedule callback failure cases>>=
| Unix.Unix_error(e,_,_) ->
    cnx#abort;
    wwwr.www_error#f (s_ "Error while reading headers of %s\n%s" url 
                           (Unix.error_message e))
@

<<[[Http.process_response()]] feed schedule callback failure cases>>=
| Http_headers.Invalid_header s ->
    cnx#abort;
    wwwr.www_error#f (s_ "Error while reading headers of %s\n%s" url s)
@
<<[[Http.process_response()]] feed schedule callback failure cases>>=
| End_of_file ->
    cnx#abort;
    wwwr.www_error#f (s_ "Error while reading headers of %s\n%s" url "eof"))
@

<<[[Http.cnx.abort()]] cases>>=
| Reading dh -> 
    Document.dclose true dh; 
    finish true
@

\subsection{Timeout management}


<<[[Http.process_response()]] setup a timer>>=
let rec timout () =
   Timer_.set (1000 * !timeout) 
    (fun () -> 
       if not cnx#aborted && !stuck 
       then
         match 
          wwwr.www_error#ari (s_ "Timeout while waiting for headers of %s" url) 
         with
         (* TODO: use proper enum for www_error#ari return type *)
         | 0 -> (* abort *) if !stuck then cnx#abort
         | 1 -> (* retry *) timout ()
         | 2 -> (* ignore *) ()
         | _ -> ()
  ) 
in

timout();
@



\section{Headers merging}
%todo: merge in parsing/

% Retype.f | ... -> <>
<<signature [[Http_headers.merge_headers]]>>=
val merge_headers : Messages.header list -> Messages.header list -> Messages.header list
  (* [merge_headers oldhs newhs] merges headers, overriding headers in
     [oldhs] by headers in [newhs] *)
@
<<function [[Http_headers.merge_headers]]>>=
(* Keep only unmodified headers *)
let merge_headers oldh newh =
  let rec filter acc = function
     [] -> acc
   | s::l ->
      if String.length s > 5 && String.sub s 0 5 = "HTTP/" then
       filter acc l
      else
       try
        let t = header_type s in
        let _d = get_header t newh in
      filter acc l
       with
          Invalid_header _ -> 
          Log.debug (sprintf "Dumping invalid header (%s)" s);
              filter acc l
        | Not_found -> filter (s::acc) l in
  (filter [] oldh) @ newh
@

% merge_headers -> <>
<<signature [[Http_headers.header_type]]>>=
val header_type : string -> string
  (* [header_type h] returns the field_name token of [h], in lowercase *)
@
<<function [[Http_headers.header_type]]>>=
let header_type s =
  match Str.bounded_split (regexp "[:]") s 2 with
  | [t;_] -> String.lowercase_ascii t
  | _ -> raise (Invalid_header s)
@


<<signature [[Http_headers.remove_headers]]>>=
val remove_headers : Messages.header list -> string list -> Messages.header list
  (* [remove_headers hs field_names] returns [hs] without the headers
     with field_name present in [field_names] *)
@
<<function [[Http_headers.remove_headers]]>>=
let remove_headers hs names =
  Log.debug "remove headers";
  let rec rem acc = function
     [] -> acc
   | h::l ->
      try
       let t = header_type h in
         if List.mem t names then rem acc l
         else rem (h::acc) l
       with Invalid_header s ->
          Log.debug (sprintf "Dumping invalid header (%s)" s);
          rem acc l

   in rem [] hs
@
% dead?





\section{Time}
% could be in Stdlib? with Date?

% why need an extra time library? why not use Unix.tm indeed?
<<type [[Http_date.http_time]]>>=
(* Based on Unix.tm *)
type http_time =
  { ht_sec : int;                       (* Seconds 0..59 *)
    ht_min : int;                       (* Minutes 0..59 *)
    ht_hour : int;                      (* Hours 0..23 *)
    ht_mday : int;                      (* Day of month 1..31 *)
    ht_mon : int;                       (* Month of year 0..11 *)
    ht_year : int;                      (* Year - 1900 *)
    ht_wday : int }                     (* Day of week (Sunday is 0) *)
@

<<signature [[Http_date.expired]]>>=
val expired : http_time -> bool
  (* Determines if an http_time is in the past *)
@

<<signature [[Http_date.compare]]>>=
val compare : http_time -> http_time -> int
  (* Compares two http_times *)
@

<<signature [[Http_date.string_of_ht]]>>=
val string_of_ht : http_time -> string
  (* Text version (RFC822) of an http time stamp *)
@

<<signature [[Http_date.tm_of_ht]]>>=
val tm_of_ht : http_time -> Unix.tm
@

<<signature [[Http_date.stamp_of_ht]]>>=
val stamp_of_ht : http_time -> float
@

<<signature [[Http_date.ht_of_stamp]]>>=
val ht_of_stamp : float -> http_time
@



<<function [[Http_date.expired]]>>=
let expired ht =
  let now = gmtime(time()) in
  let lht = 
    [ht.ht_year; ht.ht_mon; ht.ht_mday; ht.ht_hour; ht.ht_min; ht.ht_sec]
  and lnow =
    [now.tm_year; now.tm_mon; now.tm_mday; now.tm_hour; now.tm_min; now.tm_sec]
  in
    compare_time (lht, lnow) <= 0
@

<<function [[Http_date.compare]]>>=
let compare ht1 ht2 =
 compare_time
  ([ht1.ht_year; ht1.ht_mon; ht1.ht_mday; ht1.ht_hour; ht1.ht_min; ht1.ht_sec],
   [ht2.ht_year; ht2.ht_mon; ht2.ht_mday; ht2.ht_hour; ht2.ht_min; ht2.ht_sec])
@

<<function [[Http_date.string_of_ht]]>>=
let string_of_ht ht =
  sprintf "%s, %02d %s %d %02d:%02d:%02d GMT"
      (asc_wkday ht.ht_wday)
      ht.ht_mday
      (asc_month ht.ht_mon)
      (ht.ht_year + 1900)
      ht.ht_hour
      ht.ht_min
      ht.ht_sec
@

<<function [[Http_date.tm_of_ht]]>>=
(* 
let has_dst = localtime(time()).tm_isdst
*)
let tm_of_ht ht = {
    tm_sec = ht.ht_sec;
    tm_min = ht.ht_min;
    tm_hour = ht.ht_hour;
    tm_mday = ht.ht_mday;
    tm_mon = ht.ht_mon;
    tm_year = ht.ht_year;
    tm_wday = ht.ht_wday;
    tm_yday = 0;
    tm_isdst = false        (* I don't have a clue here *)
   }
@

<<function [[Http_date.stamp_of_ht]]>>=
let stamp_of_ht ht =
   fst (mktime (tm_of_ht ht))
@

<<function [[Http_date.ht_of_stamp]]>>=
let ht_of_stamp ut =
  let tm = gmtime ut in {
    ht_sec = tm.tm_sec;
    ht_min = tm.tm_min;
    ht_hour = tm.tm_hour;
    ht_mday = tm.tm_mday;
    ht_mon = tm.tm_mon;
    ht_year = tm.tm_year;
    ht_wday = tm.tm_wday
     }
@

%******************************************************************************
\chapter{Viewers}
%******************************************************************************
% viewers/, content-type based viewer dispatcher

%reput process_viewer():
% fun nav wr dh ->
%  let ctx = make_ctx nav dh.document_id in
%  match Viewers.view nav.nav_viewer_frame ctx dh with
%  | None -> () (* external viewer *)
%  | Some di ->
%      <<[[Nav.process_viewer()]] add in cache and history the document>>
%      nav.nav_show_current di dh.document_fragment

%where nav_show_current is:
%    di#di_touch;
%    pack di, set title of toplevel window to name of document
%    di#di_fragment frag;


<<signature [[Viewers.view]]>>=
val f : Widget.widget -> context -> Document.handle -> display_info option
@
% important for browser to give hooks to view different kinds
% of documents, for instance chrome allow to open pdf by calling
% adobe
%less: why need to pass the widget? it's already in the context

\section{[[Viewers.f()]]}

% Nav.request -> ... document_finish continuation -> Nav.process_viewer  -> <>
<<function [[Viewers.view]]>>=
(* the meat (was called view) *)
(* Nav.absolutegoto -> Nav.request -> Nav.process_viewer (via process) -> <>
 *   -> Plain.viewer | Htmlw.viewer (via viewers) 
 *)
and f frame (ctx : context) (dh : Document.handle) : display_info option =
  try 
    let ctype = Http_headers.contenttype dh.dh_headers in
    let (typ, sub), pars = Lexheaders.media_type ctype in
    try (* Get the viewer *)
      Logs.debug (fun m -> m "Viewers.view %s/%s" typ sub);
      let viewer =
        try Hashtbl.find viewers (typ,sub)
        with Not_found -> 
          Logs.warn (fun m -> m "didn't find viewer for %s/%s" typ sub);
          Hashtbl.find viewers (typ,"*")
      in
      match viewer with
      <<[[Viewers.view]] match viewer cases>>
    with
    <<[[Viewers.view]] exn handler 1>>
  with 
  <<[[Viewers.view]] exn handler 2>>
@


%alt: \subsection{[[Viewers.viewers]]}
% now in core DS

<<signature [[Viewers.add_viewer]]>>=
val add_viewer : Http_headers.media_type -> t -> unit
    (* [add_viewer type viewer] *)
@
<<function [[Viewers.add_viewer]]>>=
(* That's for internal viewers only *)
let add_viewer ctype viewer =
  Hashtbl.add viewers ctype (Internal viewer)
@

<<signature [[Viewers.rem_viewer]]>>=
val rem_viewer : Http_headers.media_type -> unit
@
% ?? -> <>
<<function [[Viewers.rem_viewer]]>>=
let rem_viewer ctype =
  Hashtbl.remove viewers ctype
@



<<constant [[Viewers.builtin_viewers]]>>=
let builtin_viewers = ref []
@
<<signature [[Viewers.add_builtin]]>>=
val add_builtin : Http_headers.media_type -> t -> unit
    (* [add_builtin type viewer] makes viewer a builtin for type *)
@
<<function [[Viewers.add_builtin]]>>=
let add_builtin t v =
  builtin_viewers := (t,v) :: !builtin_viewers
@
% but when those one get selected then?
% because Viewers.reset add them


<<signature [[Viewers.reset]]>>=
val reset : unit -> unit
@
% ??? -> <>
<<function [[Viewers.reset]]>>=
(* ?? -> <> *)
let reset () =
  (* Reset the viewer table *)
  Hashtbl.clear viewers;

  (* Restore the builtin viewers *)
  List.iter (fun (x,y) -> add_viewer x y) !builtin_viewers;

  <<[[Viewers.reset()]] setting other viewers>>
  ()
@


\subsection{Dispatching}

<<[[Viewers.view]] match viewer cases>>=
| Internal viewer ->
    ctx#log (s_ "Displaying...");
    viewer pars frame ctx (Decoders.insert dh)
@

% will see later other cases, for External and more

\subsection{Error management}

<<[[Viewers.view]] exn handler 1>>=
| Failure "too late" -> (* custom for our internal viewers *)
    Document.dclose true dh;
    Document.destroy_log dh false;
    None
@

<<[[Viewers.view]] exn handler 2>>=
| Http_headers.Invalid_header e ->
    ctx#log (s_ "Malformed type: %s" e);
    unknown frame ctx dh
| Not_found -> 
    (* Content-type was not defined in the headers *)
    (* and could not be computed from url *)
    unknown frame ctx dh
@

<<function [[Viewers.unknown]]>>=
let rec unknown (frame : Widget.widget) (ctx : context) (dh : Document.handle)
   : display_info option =
  match Frx_dialog.f frame (Mstring.gensym "error")
         (s_ "MMM Warning")
         (s_ "No MIME type given for the document\n%s"
               (Url.string_of dh.document_id.document_url))
         (Tk.Predefined "question") 
         0
         [s_ "Retry with type"; s_ "Save to file"; s_ "Abort"] 
  with
  | 0 ->
    let v = Textvariable.create_temporary frame in
    Textvariable.set v "text/html";
    if Frx_req.open_simple_synchronous (s_ "MIME type") v then
       let ctype = Textvariable.get v in
       dh.dh_headers <- ("Content-Type: " ^ ctype) :: dh.dh_headers;
       (* try again *)
       f frame ctx dh
    else begin
       Save.interactive (fun _ -> ()) dh;
       None
    end
 | 1 -> Save.interactive (fun _ -> ()) dh; None
 | 2 -> Document.dclose true dh; None
 | _ -> assert false (* property of dialogs *)
@

\section{Content types}

\subsection{[[text/plain]], [[Plain.viewer()]]}

<<toplevel [[Plain._1]]>>=
let _ =
  Viewers.add_builtin ("text","plain") viewer
@

% Nav.request -async-> Nav.process_viewer -> Viewers.view -> <> 
%   (as viewer <- Hashtbl.find viewers <- Plain_1)
<<function [[Plain.display_plain]]>>=
(* Viewing text/plain *)
(* old: was called display_plain *)
(* Viewer.f -> <> (via Viewers.viewers) *)
let viewer : Viewers.t =
 fun _mediapars 
    (top : Widget.widget) (vcontext : Viewers.context) (dh : Document.handle) :
     Viewers.display_info option ->
  let disp = new display_plain (top,vcontext,dh) in
  disp#init;
  Some (disp :> Viewers.display_info)
@

% display_plain -> <>
<<class [[Plain.plain]]>>=
class display_plain ((top : Widget.widget),
                     (ctx : Viewers.context),
                     (dh : Document.handle)) =
 object (self)
  inherit Viewers.display_info () as _di  (* gives us basic features *)
(*
  inherit Htmlw.viewer_globs (ctx, dh)
*)
  method ctx = ctx

  method di_title =
    Url.string_of dh.document_id.document_url

  <<[[Plain.plain]] private fields>>

  <<[[Plain.plain]] frame widget methods>>
  <<[[Plain.plain]] init method>>
  <<[[Plain.plain]] adding text method>>

  <<[[Plain.plain]] progress methods>>
  <<[[Plain.plain]] abort methods>>
  <<[[Plain.plain]] redisplay methods>>

  <<[[Plain.plain]] graphic cache destroy methods>>
  <<[[Plain.plain]] empty methods>>
  <<[[Plain.plain]] other methods or fields>>
end
@
% di_title could also use ctx#base.document_url, like in display_html
%  probably



<<[[Plain.plain]] frame widget methods>>=
val frame = 
  if not (Winfo.exists top) 
  then failwith "too late"
  else Frame.create top [Class "Plain"]
method frame = frame

method di_widget = frame
@
% why this intermediate frame? because computed once and saved
% whereas di_widget is a method called each time?

<<[[Plain.plain]] private fields>>=
(* text widget, will be set to the proper value in init() *)
val mutable (*private*) tw = Widget.default_toplevel
@
% why need also the frame widget then?

% display_plain -> <>
<<[[Plain.plain]] init method>>=
method init =
  Logs.debug (fun m -> m "Plain#init");
  <<[[Plain.plain#init]] set header widgets>>

  (* Scrollable text widget *)
  let hgroup = Frame.create_named frame "textw" [Class "Plain"] in
  let ftext, text = 
    Frx_text.new_scrollable_text hgroup [Wrap WrapWord; State Disabled] true 
  in
  <<[[Plain.plain#init]] tk fixes on text widget>>
  (* IN THIS ORDER -- RESIZING *)
  pack [ftext][Side Side_Left; Fill Fill_Both; Expand true];
  pack [hgroup][Fill Fill_Both; Expand true];

  <<[[Plain.plain#init]] setup fonts>>

  tw <- text;

  <<[[Plain.plain#init]] locals>>
  dh.document_feed.feed_schedule (fun () ->
    <<[[Plain.plain#init]] feed schedule callback>>
   );
@


<<[[Plain.plain#init]] locals>>=
let buffer = Bytes.create 2048 in
let size = 
  try Some (Http_headers.contentlength dh.dh_headers)
  with Not_found -> None (* duh *) 
in
let read = ref 0 in
let lastwascr = ref false in
@
% last was carriage return
% was called red, hmmm

<<[[Plain.plain#init]] feed schedule callback>>=
try 
  let n = dh.document_feed.feed_read buffer 0 2048 in
  if n = 0 then begin
    if !lastwascr 
    then self#add_text "\n";
    self#add_text ""; (* special case to indicate end *)
    self#set_progress (Some !read) !read;
    self#finish false (* not abort *)
  end else begin
    read := !read + n;
    self#set_progress size !read;
    let s,flag = Mstring.norm_crlf !lastwascr (Bytes.to_string buffer) 0 n in
    lastwascr := flag;
    self#add_text s
  end
with Unix.Unix_error(_,_,_) ->
   self#set_progress size (-1);
   self#di_abort
@

<<[[Plain.plain]] adding text method>>=
val mutable pending = true
method add_text s =
  if s = "" 
  then pending <- false 
  else
    if Winfo.exists tw then begin
      Text.configure tw [State Normal];
      Text.insert tw Frx_text.textEnd s [];
      Text.configure tw [State Disabled]
    end
@
%less: what pending is for? who uses that? can remove it?

<<[[Plain.plain#init]] set header widgets>>=
(*
let hgbas, progf = Htmlw.progress_report frame ctx in
set_progress <- progf;
pack [hgbas] [Side Side_Bottom; Fill Fill_X];
let (headgroup,_,_,_,_) = 
  Htmlw.html_head_ui dh.document_headers (fun () -> ()) (ref false)
   frame ctx 
in 
pack [headgroup][Side Side_Top; Fill Fill_X];
*)
@

<<[[Plain.plain#init]] tk fixes on text widget>>=
(* Tk4.0pl3 fix, + avoid cb to scrollbar *)
Text.configure text [TakeFocus true; InsertOffTime 0];
Frx_text.addsearch text;
@


\subsection{[[text/html]], [[Htmlw.viewer()]]}

% htmlw = html viewer

<<toplevel [[Htmlw._1]]>>=
let _ =
  Viewers.add_builtin ("text","html") viewer
@

% Viewers.view -> <> (as viewer <- Hashtbl.find viewers <- Plain_1)
<<function [[Htmlw.display_html]]>>=
(* Nav.absolutegoto -> Nav.request -> Nav.process_viewer (via process) ->
 *  Viewers.f -> <> (via viewers)
 *)
let viewer : Viewers.t = 
 fun mediapars top (ctx : Viewers.context) (dh : Document.handle) ->
  let imgmanager = Imgload.create() in
  let disp = new display_html (top,ctx,mediapars,imgmanager,dh) in
  disp#init true;
  Some (disp :> Viewers.display_info)
@

\section{MIME types}
%\section{Filename suffixe content type hint, [[mime.types]]}

% MIME = Multi-Purpose Internet Mail Extensions
%http://en.wikipedia.org/wiki/MIME

<<type [[Http_headers.hint]]>>=
(* Associating MIME type or Content-Encoding with file/URI suffix *)
type hint =
  | ContentType     of Messages.header
  | ContentEncoding of Messages.header
@

<<constant [[Http_headers.default_hints]]>>=
let default_hints = [ 
  "html",	ContentType  "Content-Type: text/html";
  "htm",	ContentType  "Content-Type: text/html";

  "txt",  	ContentType  "Content-Type: text/plain";

  "ps",  	ContentType  "Content-Type: application/postscript";
  "dvi",  	ContentType  "Content-Type: application/x-dvi";

  "gif",	ContentType  "Content-Type: image/gif";
  "jpeg",	ContentType  "Content-Type: image/jpeg";
  "jpg",	ContentType  "Content-Type: image/jpeg";
  "tiff",	ContentType  "Content-Type: image/tiff";
  "tif",	ContentType  "Content-Type: image/tiff";

  "au",		ContentType  "Content-Type: audio/basic";
  "snd",	ContentType  "Content-Type: audio/basic";
  "wav",	ContentType  "Content-Type: audio/x-wav";
  "mid",	ContentType  "Content-Type: audio/midi";

  "mpeg",	ContentType  "Content-Type: video/mpeg";
  "mpg",	ContentType  "Content-Type: video/mpeg";
  "avi",	ContentType  "Content-Type: video/avi";
  "fli",	ContentType  "Content-Type: video/fli";
  "flc",	ContentType  "Content-Type: video/fli";

   <<[[Http_headers.suffixes]] elements>>
]
@



\subsection{[[Http_headers.suffixes]]}

% but who uses that?
% http_check -> wrap_cache -> Retype.f -> ... 
<<constant [[Http_headers.suffixes]]>>=
let suffixes =
   (Hashtbl.create 101 : (string, hint) Hashtbl.t)
@

<<toplevel [[Http_headers._1]]>>=
(* If the suffix file says otherwise, it will have priority *)
let _ = 
  default_hints |> List.iter (fun (s,t) -> Hashtbl.add suffixes s t)
@
% cmo, hehe :)

\subsection{[[mmm -suffixes]]}

<<[[Main.main()]] locals>>=
let sufxfile = ref (Mmm.user_file "mime.types") in
@
<<[[Main.main()]] command line options>>=
"-suffixes", Arg.String (fun s -> sufxfile := (Fpath.v s)),
" <file> Suffix file";
@

<<[[Main.main()]] suffix initialisation>>=
(* Suffix mapping to Content-Type and Content-Encoding *)
if Sys.file_exists !!(!sufxfile) 
then Http_headers.read_suffix_file !!(!sufxfile);
@

%\subsection{[[Http_headers.read_suffix_file()]]}

<<signature [[Http_headers.read_suffix_file]]>>=
val read_suffix_file : string -> unit
@
<<function [[Http_headers.read_suffix_file]]>>=
(* In the file, we select ContentType if there is a slash,
   ContentEncoding otherwise *)
let read_suffix_file f =
 try
   let ic = open_in f in
   try while true do
     let l = input_line ic in
     if l <> "" && l.[0] <> '#' 
     then
       let tokens = 
         split_str (function ' '|'\t' -> true | _ -> false) l in
       match tokens with
       | [] -> ()
       | x::l ->
           try 
             let _ = String.index x '/' in
             l |> List.iter  (fun sufx -> 
                Hashtbl.add suffixes sufx  (ContentType ("Content-Type: "^x))
             )
          with Not_found ->
            l |> List.iter  (fun sufx ->
                Hashtbl.add suffixes sufx  
                  (ContentEncoding ("Content-Encoding: "^x))
            )
     done
   with End_of_file -> close_in ic
 with Sys_error _ ->  ()
@

\subsection{Filename suffix to content type}

% ??? -> <>
<<function [[Http_headers.hints]]>>=
let hints path =
  (* Get the url suffix *)
  let sufx = Mstring.get_suffix path in
  try
    let v = 
      try Hashtbl.find suffixes sufx 
      with Not_found -> 
        Hashtbl.find suffixes (String.lowercase_ascii sufx)
    in
    match v with
    | ContentType t -> [t] (* good, we have a type *)
    | ContentEncoding e ->
       (* we have an encoding, but do we have a type too ? *)
       let path2 = Filename.chop_suffix path ("."^sufx) in
       let sufx2 = Mstring.get_suffix path2 in
       begin try 
         let v2 = Hashtbl.find suffixes sufx2 in
         match v2 with
         | ContentType t -> (* good, we have a type *)
            [t;e]
         | ContentEncoding _ -> [e] (* nah, forget it *)
        with Not_found -> [e] (* no type *)
      end
  with Not_found -> [] (* no hint ... *)
@

\subsection{[[Retype.f()]]}

<<signature [[Retype.f]]>>=
val f : Document.handle -> unit
  (* physically modify the headers, adding ContentType/ContentEncoding
   * from URL suffixes if this information is missing from the headers.
   *)
@
% Retrieve.f -> http_check -> wrap_cache | ??? ... -> <>
<<function [[Retype.f]]>>=
(* Attempt to find a decent Content-Type *)
let f dh =
  let url = Url.string_of dh.document_id.document_url in
  try
    let ctype = Http_headers.contenttype dh.dh_headers in 
    let mtyp,_pars = Lexheaders.media_type ctype in
    if mtyp = ("application","octet-stream") 
    then dh.dh_headers <- merge_headers dh.dh_headers (hints url)
  with Not_found ->
    let hints = Http_headers.hints url in
    dh.dh_headers <- merge_headers dh.dh_headers hints
@
%less: LP split octet-stream stuff

% put merging headers here?


%alt: \section{[[Nav.stdctx]]}
% now earlier in chapter main()



\section{External viewer}

<<[[Viewers.reset()]] setting other viewers>>=
(* Preference settings *)
Tkresource.stringlist "externalViewers" [] |> List.iter (fun ctype -> 
  try
    let (typ,sub), _pars = Lexheaders.media_type ctype in
    Hashtbl.add viewers (typ,sub) External
  with Http_headers.Invalid_header e ->
    Error.f (s_ "Invalid MIME type %s\n%s" ctype e)
);
@


<<[[Viewers.view]] match viewer cases>>=
| External ->
    ctx#log (s_ "Displaying externally");
    extern (Decoders.insert dh) (sprintf "%s/%s" typ sub);
    None
@


<<function [[Viewers.extern]]>>=
(* "interactive" version: 
 *    send data to metamail as it arrives, but allow abort
 * NOTE: There are sometimes weird errors when the child dumps core
 *     	 between fork/exec with no apparent reason (on SunOS4.1 only)
 *)
let extern (dh : Document.handle) (ctype : string) : unit =
  let (pin, pout) = Unix.pipe() in
  (* children must not keep pout open *)
  Unix.set_close_on_exec pout;
  match Low.fork() with
  | 0 ->
      Unix.dup2 pin Unix.stdin; 
      Unix.close pin;
      Munix.execvp "metamail" [| "metamail"; "-b"; "-x"; "-c"; ctype |]
  | pid ->  
      Unix.close pin;
      let kill () = 
         try Unix.kill pid 2
         with Unix.Unix_error (e,_,_) ->
          Log.f (sprintf "Can't kill child (%s)" (Unix.error_message e))
      in
      let url = Url.string_of dh.document_id.document_url in
      Document.add_log dh 
        (s_ "Retrieving %s\nfor external display with MIME type %s" url ctype)
        kill;

      let red = ref 0 in
      let size =   
        try Http_headers.contentlength dh.dh_headers
        with Not_found -> 40000 (* duh *)
      in
      let buffer = Bytes.create 4096 in
      dh.document_feed.feed_schedule
        (fun () ->
          try
            let n = dh.document_feed.feed_read buffer 0 4096 in
            if n = 0 then begin
              Document.dclose true dh;
              Unix.close pout;
              Document.end_log dh (s_ "End of transmission")
            end else begin
              ignore (Unix.write pout buffer 0 n);
              red := !red + n;
              Document.progress_log dh (!red * 100 / size)
            end
          with Unix.Unix_error(e,_,_) ->
            Log.f (sprintf "Error writing to viewer (%s)"
                    (Unix.error_message e));
            Document.dclose true dh;
            kill();
            Unix.close pout;
            Document.destroy_log dh false;
            Error.f (s_ "Error during retrieval of %s" url)
       )
@



\section{Interactive viewer}

<<[[Viewers.spec]] other cases>>=
(*| Interactive  (* ask what to do about it *)*)
@

<<[[Viewers.view]] match viewer cases>>=
(*| Interactive ->
    interactive frame ctx dh ctype*)
@

<<[[Viewers.view]] exn handler 1>>=
| Not_found -> 
   (* we don't know how to handle this *)
   ctx#log (s_ "Displaying externally");
   interactive frame ctx dh ctype
@


<<function [[Viewers.interactive]]>>=
and interactive frame (ctx : context) (dh : Document.handle) (ctype : string) 
   : display_info option =
  match Frx_dialog.f frame (Mstring.gensym "error")
         (s_ "MMM Viewers")
         (s_
          "No behavior specified for MIME type\n%s\ngiven for the document\n%s"
           ctype
           (Url.string_of dh.document_id.document_url))
         (Tk.Predefined "question") 
         0
         [s_ "Retry with another type";
          s_ "Display with metamail";
          s_ "Save to file";
          s_ "Abort"] 
  with
  | 0 ->
      let v = Textvariable.create_temporary frame in
      Textvariable.set v "text/html";
      if Frx_req.open_simple_synchronous (s_ "MIME type") v then
        let ctype = Textvariable.get v 
        in
        dh.dh_headers <- ("Content-Type: " ^ ctype) :: dh.dh_headers;
        (* try again *)
        f frame ctx dh
      else begin
        Save.interactive (fun _ -> ()) dh;
        None
      end
  | 1 -> extern (Decoders.insert dh) ctype; None
  | 2 -> Save.interactive (fun _ -> ()) dh; None
  | 3 -> Document.dclose true dh; None
  | _ -> assert false (* property of dialogs *)
@

\section{Save to file viewer}

<<[[Viewers.spec]] other cases>>=
| Save	     (* always save *)
@

<<[[Viewers.reset()]] setting other viewers>>=
Tkresource.stringlist "savedTypes" [] |> List.iter (fun ctype -> 
  try
    let (typ,sub),_pars = Lexheaders.media_type ctype in
    Hashtbl.add viewers (typ,sub) Save
  with Http_headers.Invalid_header e ->
    Error.f (s_ "Invalid MIME type %s\n%s" ctype e)
);
@

<<[[Viewers.view]] match viewer cases>>=
| Save ->
    Save.interactive (fun _ -> ()) dh;
    None
@


<<signature [[Save.interactive]]>>=
val interactive : (string -> unit) -> Document.handle -> unit
@
<<function [[Save.interactive]]>>=
let rec interactive cont dh =
  (* The initial content of the requester *)
  let url = Url.string_of dh.document_id.document_url in
  let path = 
    match dh.document_id.document_url.path with Some p -> p | None -> "" in

  Fileselect.f (s_ "Save document") (function 
    | [] ->
         (* by closing dh, we might break the cache *)
         dclose true dh
    | [fname] ->
        begin try 
          let endmsg = (s_ "URL %s\nsaved as %s" url fname) in
          f cont dh fname endmsg;
          Document.add_log dh 
              (s_ "Saving %s\nto %s" url fname)
              (* channel is not closed ! *)
              (fun () -> Msys.rm fname)
        with Sys_error msg -> 
          Error.f (s_ "Cannot save to %s\n(%s)" fname msg);
          interactive cont dh
        end
    | _l -> raise (Failure "multiple selection")
    )
    "*"
    (Filename.basename path)
    false false
@





%******************************************************************************
\chapter{HTML Display}
%******************************************************************************
% display/, html layout engine


<<[[Main.main()]] misc initialisation>>=
(* Various stuff for the HTML viewer, needing Tk *)
Ctext.init();
Attrs.init !Textw_fo.html_bg; (* built the bullet images *)
@
% ???

\section{The display info, [[Htmlw.display_html]]}
% The display info

% see previously display_html(), the viewer for text/html content type
% which instantiates this class below that is a display_info

<<class [[Htmlw.display_html]]>>=
class display_html ((top : Widget.widget),
                    (ctx : Viewers.context),
                    (_mediapars : (string * string) list),
                    (imgmanager: Imgload.loader),
                    (dh': Document.handle)) =
 object (self)
  inherit Viewers.display_info () as _di  (* gives us basic features *)
  inherit viewer_globs (ctx, dh')
  inherit html_parse (dh')
  inherit html_body () as _body
  inherit bored ()

  (* val imgmanager = imgmanager *)

  <<[[Htmlw.display_html]] private fields>>

  (*less: can be changed? *)
  val mutable title = Url.string_of ctx#base.document_url
  method di_title = title

  <<[[Htmlw.display_html]] frame widget methods>>
  <<[[Htmlw.display_html]] init method>>

  <<[[Htmlw.display_html]] load images methods>>
  <<[[Htmlw.display_html]] update embedded objects methods>>
  <<[[Htmlw.display_html]] load frames methods>>
  <<[[Htmlw.display_html]] fragment methods>>

  <<[[Htmlw.display_html]] error managment methods>>

  <<[[Htmlw.display_html]] progress method>>
  <<[[Htmlw.display_html]] abort methods>>
  <<[[Htmlw.display_html]] redisplay methods>>

  <<[[Htmlw.display_html]] graphic cache destroy methods>>
  <<[[Htmlw.display_html]] other methods or fields>>

end
@
%no  <<[[Htmlw.display_html]] empty methods>>

<<[[Htmlw.display_html]] frame widget methods>>=
val frame = 
  if not (Winfo.exists top) 
  then failwith "too late"
  else Frame.create_named top (Mstring.gensym "html") [Class "Html"]
    (* this might as well fail if the window was destroyed before we
     * finally could get the headers of the document.
     *)
method frame = frame

method di_widget = frame
@
% similar to text/plain viewers code

<<[[Htmlw.display_html]] private fields>>=
val mutable init_mode = true
val mutable pending = true
@
% why need that?

<<[[Htmlw.display_html]] reset private fields>>=
init_mode <- full;
pending <- true;

errors := []; 
annotations := []; 
terminated <- false; 
set_progress <- Progress.no_meter;
@

% mach for display machine, vague
<<[[Htmlw.display_html]] private fields>>=
val mutable mach = F.create (ctx, imgmanager)
@
<<[[Htmlw.display_html]] reset private fields>>=
mach <- F.create (ctx, imgmanager);
@
<<[[Htmlw.display_html]] load images methods>>=
method mach = mach
@


<<module Htmlw.F>>=
module F = Html_disp (*Html_disp.Make(Textw_fo)(Form)(Table) *)
@
<<signature functor [[Html_disp.Make]]>>=
(*module Make 
  (G: Htmlfmt.GfxHTML) 
  (F: Htmlfmt.FormDisplay) 
  (T: Htmlfmt.TableDisplay) 
  : sig
    (* Do we need to export FormLogic and TableLogic so that extensions
     *  can access them ?
     *)
*)
val create : Viewers.context * imgloader -> machine
(*end*)
@
% will see later




<<[[Htmlw.display_html]] init method>>=
(* since we may be called multiple times, we have to clear some of the
   instance variables *)
method init full =
  <<[[Htmlw.display_html]] reset private fields>>

  <<[[Htmlw.display_html]] set meta tag>>

  <<[[Htmlw.display_html]] set progress report and head UI>>

  self#body_init full;

  <<[[Htmlw.display_html]] display frames>>

  (* Asynchronous parsing and display, token by token *)
  self#parse_init;

  <<[[Htmlw.display_html]] i18 encoder for forms>>

  dh.document_feed.feed_schedule (fun () ->
    try 
      let warnings, correct,   tokens, loc = 
        lexer self#lexbuf 
      in
      <<[[Htmlw.display_html]] in feed, record possible errors after lexing>>

      <<[[Htmlw.display_html]] in feed, annotate>>
       tokens |> List.iter (fun token -> 
         begin  
           try mach#send token
           with Html.Invalid_Html s -> self#record_error loc s
         end;
         if token = EOF then begin
           pending <- false;
           imgmanager#flush_images;
           raise End_of_file
         end
       )
    with 
    | End_of_file ->
        <<[[Htmlw.display_html]] in feed, [[End_of_file]] exn handler>>
    <<[[Htmlw.display_html]] in feed, other exceptions handler>>
   )
@

% flush_images!

<<[[Htmlw.display_html]] in feed, [[End_of_file]] exn handler>>=
self#set_progress (Some red) red;
self#finish false;
<<[[Htmlw.display_html]] in feed, [[End_of_file]] exn handler, goto fragment>>
@
%<<[[Htmlw.display_html]] in feed, End_of_file exn handler, if japan>>
%self#set_progress (Some red) red;
%self#finish false;
%<<[[Htmlw.display_html]] in feed, End_of_file exn handler, goto fragment>>
%<<[[Htmlw.display_html]] in feed, End_of_file exn handler, if japn and charset>>




<<[[Htmlw.display_html]] set progress report and head UI>>=
(* We have full display, so put up progress report and head UI *)
if full then begin 
  let hgbas, progf = progress_report frame ctx in
  set_progress <- progf;
  self#bored_init hgbas;
  pack [hgbas] [Side Side_Bottom; Fill Fill_X];

  let headgroup, set_title, add_link, add_header, add_ext_header =
    html_head_ui dh.dh_headers (fun () -> self#redisplay)
    self#current_scroll_mode frame ctx
  in
  add_extra_header <- add_ext_header;
  pack [headgroup] [Side Side_Top; Fill Fill_X];
  let set_title s = 
    title <- s; 
    set_title s 
  in
  head_hook (headgroup, set_title, add_link, add_header) self#mach
end;
@
% head_hook!!



\section{The display machine, [[Html_disp.machine]]}

<<functor [[Html_disp.Make]]>>=
(*module Make (G : GfxHTML) (F: FormDisplay) (T: TableDisplay) = struct 
  module FormLogic = Html_form.Make(F)
  module TableLogic = Html_table.Make(T)
*)
module G = Textw_fo
module FormLogic = Html_form
module TableLogic = Html_table

  <<type [[Html_disp.Make.anchor_type]]>>

  (* Tag machinery *)
  <<type [[Html_disp.Make.html_behavior]]>>
    
  <<functions [[Html_disp.Make.ignore_xxx]]>>

  <<class [[Html_disp.Make.display_machine]]>>

  <<function [[Html_disp.Make.init]]>>

  <<function [[Html_disp.Make.create]]>>
(* end *)
@
%later: can remove functor and use directly the referred modules
% as we don't instantiate more than once this functor I think

<<function [[Html_disp.Make.create]]>>=
let create (ctx, imgmanager) =
  let mach = new display_machine (ctx, imgmanager) in
  init mach;
  <<[[Html_disp.Make.create()]] run user hooks>>
  (mach :> machine)
@


\subsection{class [[Html_disp.display_machine]]}


% rename display_html_machine? html_machine?
<<class [[Html_disp.Make.display_machine]]>>=
class display_machine ((ctx : Viewers.context), imgmanager) =
 object (self) 
    inherit machine ()

    (* Keep a copy of the arguments *) 
    (* val ctx = ctx *)
    (* val imgmanager = imgmanager *)
    method ctx = ctx
    method imgmanager = imgmanager    

    <<[[Html_disp.display_machine]] base methods>>
    <<[[Html_disp.display_machine]] target methods>>

    <<[[Html_disp.display_machine]] private fields>>

    <<[[Html_disp.display_machine]] html token input methods>>

    <<[[Html_disp.display_machine]] tag machinery methods>>
    <<[[Html_disp.display_machine]] action stack methods>>
    <<[[Html_disp.display_machine]] formatter methods>>

    <<[[Html_disp.display_machine]] embedded methods>>
    <<[[Html_disp.display_machine]] fragment methods>>

   <<[[Html_disp.display_machine]] i18n methods>>
     
end
@



<<[[Html_disp.machine]] other fields>>=
method virtual base : string
method virtual set_base : string -> unit
@
<<[[Html_disp.display_machine]] base methods>>=
val mutable base = Url.string_of ctx#base.document_url
method base = base
method set_base s = base <- s
@

<<[[Html_disp.machine]] other fields>>=
method virtual target : string option
method virtual set_target : string -> unit
@
<<[[Html_disp.display_machine]] target methods>>=
val mutable target = None
method target = target
method set_target t = target <- Some t
@






<<type [[Html_disp.Make.html_behavior]]>>=
type html_behavior = {
  tag_open  : Htmlfmt.formatter -> Html.tag -> unit;
  tag_close : Htmlfmt.formatter -> unit
}
@
<<[[Html_disp.display_machine]] private fields>>=
val (*private*) tags = (Hashtbl.create 101 : (string, html_behavior) Hashtbl.t)
@

<<[[Html_disp.machine]] tags methods>>=
method virtual get_tag : 
  string -> 
  (Htmlfmt.formatter -> Html.tag -> unit) * 
  (Htmlfmt.formatter -> unit)
@
<<[[Html_disp.display_machine]] tag machinery methods>>=
(* Adding and removing tag behaviors *)
method add_tag t o c = 
  Hashtbl.add tags t {tag_open = o; tag_close = c}
method get_tag t =
  let {tag_open = o; tag_close = c} = Hashtbl.find tags t in 
  o,c
method remove_tag = Hashtbl.remove tags
@


<<[[Html_disp.display_machine]] private fields>>=
val mutable (*private*) action = (fun _s -> ())
val mutable (*private*) action_stack = []
@
<<[[Html_disp.machine]] action stack methods>>=
method virtual push_action : (string -> unit) -> unit
method virtual pop_action : unit
@
<<[[Html_disp.display_machine]] action stack methods>>=
(* Changing the default mode for pcdata and cdata *)
method push_action f =
  action_stack <-  f :: action_stack;
  action <- f
method pop_action =
  match action_stack with
  | [] -> Log.f "Warning: empty action stack"
  |	_old::l ->
  action_stack <- l;
  action <- match l with [] -> (fun _s ->()) | newa::_ -> newa
@


<<[[Html_disp.display_machine]] private fields>>=
val mutable (*private*) formatter = default_fo
@
<<[[Html_disp.display_machine]] formatter methods>>=
(* Accessing the variables *)
method formatter = formatter
@

<<[[Html_disp.display_machine]] private fields>>=
val mutable (*private*) formatter_stack = []
@
<<[[Html_disp.machine]] formatter stack methods>>=
method virtual push_formatter : Htmlfmt.formatter -> unit
method virtual pop_formatter : Htmlfmt.formatter
@
<<[[Html_disp.display_machine]] formatter methods>>=
(* Nested formatters for table cells and other usage *)
method push_formatter fo =
  formatter <- fo;
  formatter_stack <- fo :: formatter_stack;
  self#push_action fo.format_string;
  see_frag <- fo.see_frag

method pop_formatter =
  self#pop_action;
  match formatter_stack with
  | [] -> 
      Log.f "Warning: empty formatter stack";
      default_fo
  | old::l ->
      old.flush();
      see_frag <- old.see_frag;
      formatter_stack <- l;
      formatter <- (match l with [] -> default_fo | newf :: _ -> newf);
      old
@


<<[[Html_disp.machine]] formatter misc methods>>=
method virtual create_formatter : 
  Htmlfmt.formatterSpec -> Widget.widget -> Htmlfmt.formatter * Widget.widget
@

<<[[Html_disp.display_machine]] formatter methods>>=
(* Nested windows *)
val table_namer = Mstring.egensym "tablecell"
method create_formatter spec w = G.create table_namer spec w ctx
@

% no virtual signature?
<<[[Html_disp.display_machine]] formatter methods>>=
(* This is only for robustness *)
method flush_formatters =
  while List.length formatter_stack > 0 do
    Log.f "WARNING: too many formatters in stack";
    self#pop_formatter.flush()
  done
@

<<function [[Textfw_fo.create.flush]]>>=
flush = (fun () -> 
  fonts#pop_all (cur());	(* basefont lossage *)
  internal_flush true
);
@


<<[[Html_disp.machine]] html input other methods>>=
method virtual look_for : Html.token -> unit
@

<<[[Html_disp.display_machine]] html token input methods>>=
(* ignore everything up to some tag *)
val mutable look_for = None

method look_for e = 
  look_for <- Some e
@

<<[[Html_disp.display_machine]] html token input methods>>=
(* Dispatching a token *)
method private normal_send = function
| Html.EOF -> self#flush_formatters;
| CData s -> action s
| PCData s -> action s
| OpenTag t ->
    begin try
      let tag = Hashtbl.find tags t.tag_name in
      tag.tag_open formatter t
   with Not_found ->
     if !verbose 
     then Logs.debug (fun m -> m "Display machine: <%s> ignored" t.tag_name)
   end
| CloseTag n ->
    begin try
      (Hashtbl.find tags n).tag_close formatter
    with Not_found ->
       if !verbose 
      then Logs.debug (fun m -> m "Display machine: </%s> ignored" n)
    end
| Comment _ -> ()
| Doctype _ -> ()

method send tok =
  match look_for with
  | None -> self#normal_send tok
  | Some it when it = tok -> 
      self#normal_send tok;
      look_for <- None
  | _ -> ()
@



\subsection{[[Html_disp.Make.init()]]}

<<function [[Html_disp.Make.init]]>>=
(* Standard initialisation for HTML 2.0 (+bits of 3.2) *)
let init (mach : display_machine) =
  <<[[Html_disp.Make.init()]] HTML elements machine initialisation>>
()
@
% big big big function, splitted in section below

\section{The formatter}

%module F = Html_disp.Make(Textw_fo)(Form)(Table)

<<signature [[Textw_fo.create]]>>=
val create :
  (unit -> string) ->
  Htmlfmt.formatterSpec -> 
  Widget.widget -> Viewers.context ->  Htmlfmt.formatter * Widget.widget
@

<<function [[Textw_fo.create]]>>=
(* Build a formatter, as required by html_disp *)
let create namer spec top ctx =
  <<[[Textw_fo.create]] locals>>
  let formatter =           
  { 
    <<function [[Textfw_fo.create.new_paragraph]]>>
    <<function [[Textfw_fo.create.close_paragraph]]>>
    <<function [[Textfw_fo.create.print_newline]]>>
    <<function [[Textfw_fo.create.print_verbatim]]>>
    <<function [[Textfw_fo.create.format_string]]>>

    <<function [[Textfw_fo.create.flush]]>>

    <<function [[Textfw_fo.create.hr]]>>
    <<function [[Textfw_fo.create.bullet]]>>


    <<function [[Textfw_fo.create.set_defaults]]>>

    <<function [[Textfw_fo.create.push_attr]]>>
    <<function [[Textfw_fo.create.pop_attr]]>>

    <<function [[Textfw_fo.create.isindex]]>>
    
    <<function [[Textfw_fo.create.start_anchor]]>>
    <<function [[Textfw_fo.create.end_anchor]]>>

    <<function [[Textfw_fo.create.add_mark]]>>

    <<function [[Textfw_fo.create.create_embedded]]>>

    <<function [[Textfw_fo.create.see_frag]]>>
    } in

  formatter, fhtml
@


<<type [[Htmlfmt.formatterSpec]]>>=
type formatterSpec = 
  | TopFormatter of bool		(* flag is pixel-scrolling mode *)
  | NestedFormatter
  | FrameFormatter of (string * string) list (* decoration ... *)
@
%TODO lp split, and aspectize frames


<<[[Textw_fo.create]] locals>>=
let other_bg = ref (fun _ -> ()) in
let fhtml, thtml =
  match spec with
    TopFormatter pscrolling ->
  let f,t = 
   if pscrolling then begin
    let f,t = 
      Ctext.create top [Wrap WrapWord; State Disabled] true in
      Canvas.configure (Winfo.parent t)
         [Background (NamedColor !html_bg)];
       other_bg := Canvas.configure (Winfo.parent t);
      f, t
    end
   else
     new_scrollable_text top 
        [Wrap WrapWord; State Disabled]
        true 
  in
  (* Try to solve focus problem -- JPF *)
  bind t [[],Enter] (BindSet ([], fun _ -> Focus.set t));
  f, t
  | NestedFormatter -> (* Embedded formatters (tables) *)
     let t = Text.create_named top (namer())
          [BorderWidth (Pixels 0); State Disabled; 
            Relief Sunken; Wrap WrapNone;
        TextWidth 1; TextHeight 1]
  in
      t, t
  | FrameFormatter args -> 
  let marginwidth = 
    try [PadX (Pixels (int_of_string (List.assoc "marginwidth" args)))]
    with Not_found | Failure "int_of_string" -> []
  and marginheight = 
    try [PadY (Pixels (int_of_string (List.assoc "marginheight" args)))]
    with Not_found | Failure "int_of_string" -> []
  in
 let f,t = 
   Ctext.create top (marginwidth @ marginheight @ 
              [TextHeight 1; 
                Wrap WrapWord; State Disabled]) true in
 Canvas.configure (Winfo.parent t)
   [Background (NamedColor !html_bg)];
       other_bg := Canvas.configure (Winfo.parent t);

  f, t
in

(* Tk4.0pl3 fix, + avoid cb to scrollbar *)
(* Make the widget searchable *)
(* NOTE: search doesn't apply to nested windows *)
begin match spec with
  TopFormatter _ | FrameFormatter _ -> 
    Text.configure thtml [TakeFocus true; InsertOffTime 0];
    Frx_text.addsearch thtml
| NestedFormatter -> 
    Text.configure thtml [TakeFocus false; InsertOffTime 0]
end;

(* Set (other) defaults *)
let _, html_font = Fonts.compute_tag !Fonts.default in
 Text.configure thtml html_font;

(* transparent GIF hack *)
Textvariable.set (Textvariable.coerce "TRANSPARENT_GIF_COLOR") !html_bg;

(* The formatter
 *    to minimize calls to Tk, we write only one string for 
 * each paragraph larger than some size. Because of this, it seems
 * that we also have to set tags and marks at the end.
 *)

(* Things queued *)
let marks = ref []
and embedded = ref []
and tagdefs = new Attrs.tags thtml
(* Hypertext Anchor support *)
and anchors = new Attrs.anchortags thtml

(* It's easier for us to keep character positions as offsets from the
 * beginning, but it's very costly in Tk (conversion 0+nchars -> index),
 * especially when the size gets large.
 * Thus, we keep the base index of the current buffer, and positions
 * as offsets from there.
 * We must be careful not to leave position values relative to old
 * buffer_base.
 *)
and buffer_base = ref (LineChar(0,0))
and position = ref 0
and anchor_start = ref (TextIndex(LineChar(0,0),[]))

(* Paragraphs and space squeezing *)
and trailing_space = ref false
and prev_is_newline = ref false
    (* if this is false, we are displaying text. if this is true, we
       just issued a newline *)
in

(* Index for Tk *)
let get_index p = TextIndex (!buffer_base, [CharOffset p]) in
let cur () = get_index !position in

(* colors for *this* window, can be changed by set_defaults *)
let fg = ref !html_fg
and bg = ref !html_bg
in
(* inherited properties (set_defaults) : we apply them to embedded
   formatters (table cells) *)
let inherited = ref [] in
anchors#init ctx;      (* install bindings *)
anchors#define "visited" [Foreground (NamedColor "MidnightBlue")];
anchors#define "anchor" [Foreground (NamedColor "#0000ff"); Underline true];


(* Size of buffer can impact performances *)
let refresh_threshold = 
   if !internal_buffer < 1000 then 1000 else !internal_buffer in
let buffer = Ebuffer.create (2 * refresh_threshold)
and last_flush = ref !Low.global_time in

let internal_flush refresh = (* flush the buffer *)
  last_flush := !Low.global_time;
  Text.configure thtml [State Normal];
  Text.insert thtml textEnd (Ebuffer.get buffer) [];
  Ebuffer.reset buffer;
  List.iter 
    (function (opts,p) -> Text.window_create thtml (get_index p) opts)
    (List.rev !embedded);
  List.iter (function (m,p) -> Text.mark_set thtml m (get_index p)) !marks;
  tagdefs#flush;
  anchors#flush;
  Text.configure thtml [State Disabled];
  marks := [];
  embedded := [];
   (* reset the position *)
  buffer_base := 
     Text.index thtml (TextIndex(!buffer_base,[CharOffset !position]));
  position := 0;
   (* try to give a reasonable initial height for the text widget *)
  if refresh then begin 
   begin match spec with
     TopFormatter true 
   | NestedFormatter 
   | FrameFormatter _ -> Fit.set_initial_height thtml
   | _ -> ()
   end;
   Low.update_idletasks()
  end
   in

let put_text s =
  match String.length s with
    0 -> ()
  | l ->
      (* old: was Lexkanji.length but we needed to update the code to
       * handle Utf8 characters. Tk 8.x assumes utf8 characters so
       * if we compute here the position wrong, Tk would then highlight
       * anchors at the wrong position.
       *)
      position := !position + Mstring.utf8_length s;
      prev_is_newline := false;
      Ebuffer.output_string buffer s;
  trailing_space := s.[l-1] = ' ';
  if  !Low.global_time > !last_flush + 4 (* it's been a while *)
  then internal_flush true
  else if  Ebuffer.used buffer > refresh_threshold 
  then internal_flush false
     in

(* Logic for tag manipulation *)
let margins = new Attrs.margin tagdefs
and aligns = new Attrs.align tagdefs
and fonts = new Attrs.font tagdefs
and fgcolors = new Attrs.fgcolor tagdefs
and bgcolors = new Attrs.bgcolor tagdefs
and spacing = new Attrs.spacing tagdefs
and offset = new Attrs.offset tagdefs
and underline = new Attrs.misc (tagdefs, "underline", [Underline true])
and strike = new Attrs.misc (tagdefs, "strike", [OverStrike true])

in
let put_embedded w align =
  let opts = match String.lowercase_ascii align with
    "top" -> [Align Align_Top]
  | "middle" -> [Align Align_Center] (* not exactly *)
  | "bottom" -> [Align Align_Baseline] 
  |  _ -> [] in
  embedded := ((Window w)::opts, !position) :: !embedded;
  prev_is_newline := false;
  incr position    (* an embedded window is one char wide *)    
in

let break () =
   if not !prev_is_newline then begin
     put_text "\n"; prev_is_newline := true
     end
in

let paropen = ref (cur()) in
@


\section{HTML attributes}

% specified where? RFC?
<<constant [[Html.default_attributes]]>>=
(* Attribute values *)
let default_attributes = [ 
  ("isindex"  , "prompt" ),  "Document is indexed/searchable: ";
                             
  ("a"        , "methods"),  "GET";     (* <A METHODS=GET> *)
  ("embed"    , "methods"),  "GET";		(* <EMBED METHODS=GET> *)
  ("embed"    , "alt"    ),  "[EMBEDDED OBJECT]";(* <EMBED ALT="EMBEDDED OBJECT"> *)
  ("form"     , "method" ),  "GET";		(* <FORM METHOD=GET> *)
  ("form"     , "enctype"),  "application/x-www-form-urlencoded";

  ("ol"       , "type"   ),  "1";       (* <OL TYPE=1 *)
  ("input"    , "type"   ),  "TEXT";	(* <INPUT TYPE=TEXT> *)
  ("select"   , "size"   ),  "5";
  ("textarea" , "align"  ),  "bottom";
  ("input"    , "align"  ),  "bottom";
  ("select"   , "align"  ),  "bottom";
  ("img"      , "align"  ),  "bottom";
  (* ("img"   , "alt"    ),  "[IMAGE]"; *) (* Just "IMAGE" ? Boring... *)
  ("area"     , "shape"  ),  "rect";
  ("div"      , "align"  ),  "left";
  ("basefont" , "size"   ),  "3";

  (* frames *)
  ("frame"    , "frameborder" ), "0";
  ("frame"    , "scrolling"   ), "auto";
  ("frameset" , "rows"        ), "100%";
  ("frameset" , "cols"        ), "100%";
  ]
@
%TODO: distribute!


<<signature [[Html.get_attribute]]>>=
val get_attribute : tag -> string -> string
  (* [get_attribute tag attrib_name] *)
@
<<function [[Html.get_attribute]]>>=
let get_attribute tag attr =
  try
    List.assoc attr tag.attributes 
  with Not_found ->
    List.assoc (tag.tag_name, attr) default_attributes
@


<<signature [[Html.has_attribute]]>>=
val has_attribute : tag -> string -> bool
  (* [has_attribute tag attrib_name] *)
@
<<function [[Html.has_attribute]]>>=
let has_attribute tag attr =
     List.mem_assoc attr tag.attributes
  || List.mem_assoc (tag.tag_name, attr) default_attributes
@



\section{HTML tags}

\subsection{Header}

\subsubsection{[[<html>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* 5.1 HTML *)
mach#add_tag "html" ignore_open ignore_close;
@

<<functions [[Html_disp.Make.ignore_xxx]]>>=
let ignore_open = fun _ _ -> ()
let ignore_close = fun _ -> ()
@

\subsubsection{[[<head>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.2 Head: <HEAD>
 * <!ENTITY % head.content "TITLE & ISINDEX? & BASE? %head.extra">
 * <!ENTITY % head.extra "& NEXTID?">
 * NOTE: this is now handled elsewhere
 *)
mach#add_tag "head" ignore_open ignore_close;
@

\subsubsection{[[<title>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.2.1 Title: <TITLE>
 * assumes a unique Text token inside since
 * <!ELEMENT TITLE - -  (#PCDATA)*>
 * the title is not printed
 * NOTE: this is now handled elsewhere
 *)
mach#add_tag "title" ignore_open ignore_close;
@

\subsubsection*{[[<base>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.2.2 Base Address: <BASE>
 * TARGET is from PR-HTML4.0
 *)
mach#add_tag "base"
    (fun _fo tag ->
      begin 
        try mach#set_target (Html.get_attribute tag "target")
        with Not_found -> ()
      end;
      begin 
        try mach#set_base (Html.get_attribute tag "href")
        with Not_found -> raise (Html.Invalid_Html "HREF required in BASE")
      end)
    ignore_close
;
@

\subsubsection*{[[<isindex>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.2.3 Keyword Index: <ISINDEX>
 * HTML3.2: PROMPT attribute (default given)
 * NOTE: ISINDEX in HEAD is handled elsewhere, but we must keep it
 *       here because it may appear in BODY
 *)
mach#add_tag "isindex"
   (fun fo t -> fo.isindex (Html.get_attribute t "prompt") mach#base)
   ignore_close
;
@
%todo: aspectize isindex


<<[[Htmlfmt.formatter]] structure primitives methods>>=
isindex : string -> string -> unit;         (* <ISINDEX> *)
@
<<function [[Textfw_fo.create.isindex]]>>=
(* Compliance: text is not part of document ? *)
isindex = (fun prompt base ->
  let f,e = Frx_entry.new_label_entry thtml prompt
      (function s -> 
        ctx#goto { h_uri = "?" ^ Urlenc.encode s;
                   h_context = Some base;
                   h_method = GET;
                   h_params = []}
  ) in
  (* default size 0 ! *)
  Entry.configure e [TextWidth 20];
  put_embedded f "";
  put_text "\n"
);
@

\subsubsection*{[[<link>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.2.4 Link: <LINK>
 * 5.2.5 Associated Meta-information: <META>
 * 5.2.6 Next Id: <NEXTID>
 * NOTE: this is now handled elsewhere (only in HEAD)
 *)
["link"; "meta"; "nextid"] |> List.iter (fun t -> 
  mach#add_tag t ignore_open ignore_close
);
@

\subsection{Content, [[<body>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.3 Body: <BODY>
 * <!ENTITY % html.content "HEAD, BODY">
 * Note: with textw_fo, flush disables the text widget, so anything
   beyond </BODY> will not be displayed. Some documents have multiple
   bodies, or </BODY> before the end of the document. So we decide
   to completely ignore this tag. A stricter interpretation would be
   {tag_open = ...; tag_close = (fun fo -> fo.flush())};
   Our simpled minded minimization rules also introduce multiple BODY.
 *)
mach#add_tag "body" ignore_open ignore_close;
@

\subsection{Headings, [[<h1>]], [[<h2>]], etc}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.4 Headings <H1> ... <H6>
 * <!ELEMENT ( %heading )  - -  (%text;)*>
 * Assume headings may contain typographic styles, anchors
 * HTML3.2
 * <!ATTLIST ( %heading )
 *         align  (left|center|right) #IMPLIED
 *         >
 *)

<<[[Html_disp.Make.init()]] headings private variables>>
<<function [[Html_disp.Make.init.open_header]]>>
<<function [[Html_disp.Make.init.close_header]]>>
[1;2;3;4;5;6] |> List.iter (fun headnum ->
  mach#add_tag (Printf.sprintf "h%d" headnum) (open_header headnum) close_header
);
         
@


<<[[Html_disp.Make.init()]] headings private variables>>=
(* Private variables of header *)
let header_size = ref 0 in
let header_align = ref None in
@

<<function [[Html_disp.Make.init.open_header]]>>=
let open_header size = 
 fun (fo : Htmlfmt.formatter) tag ->
  fo.new_paragraph() ;
  header_size := size;
  push_style fo (Printf.sprintf "header%d" size);
  try
    let align = Html.get_attribute tag "align" in 
    fo.push_attr [Justification align];
    header_align := Some align
  with Not_found -> header_align := None
in
@

<<[[Htmlfmt.gattr]] alignment cases>>=
| Justification of string
@
% alignment?

<<[[Htmlfmt.formatter]] primitives methods>>=
new_paragraph: unit -> unit;  	(* Open a new paragraph *)
  (* make sure the following text will start on a new line *)
close_paragraph: unit -> unit;  	(* Close a paragraph *)
  (* make sure there is an eol after the current text *)
@

<<function [[Textfw_fo.create.new_paragraph]]>>=
new_paragraph = (fun () -> 
  break(); 
  spacing#push (cur()) 5; 
  paropen := cur()
);
@

<<function [[Textfw_fo.create.close_paragraph]]>>=
close_paragraph = (fun () -> 
  spacing#pop (cur()) 5; 
  if (cur() = !paropen) 
  then prev_is_newline := false;
  break()
);
@


<<function [[Html_disp.Make.init.close_header]]>>=
let close_header fo =
  pop_style fo (Printf.sprintf "header%d" !header_size);
  fo.close_paragraph();
  match !header_align with
  | None -> ()
  | Some a -> fo.pop_attr [Justification a]
in
@

\subsection{Paragraphs, [[<p>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.5.1 Paragraph: <P>
 *   a bit approximative in HTML 2.0
 * HTML3.2
 * <!ATTLIST P
 *         align  (left|center|right) #IMPLIED
 *         >
 *)
let paligns = ref [] in

mach#add_tag "p" 
  (fun fo tag -> 
     fo.new_paragraph ();
     try
       let a = Html.get_attribute tag "align" in
       paligns := (Some a) :: !paligns;
       fo.push_attr [Justification a]
     with Not_found -> paligns := None :: !paligns)
  (fun fo ->
     fo.close_paragraph();
     match !paligns with
     | [] -> () (* that's an error actually *)
     | (Some a)::l ->
         fo.pop_attr [Justification a];
         paligns := l
     | None::l ->
         paligns := l)
;
@

\subsection{Text styles part 1}

<<function [[Html_disp.push_style]]>>=
(* Style abbreviation 
 * TODO?: check stack.
 *)
let push_style (fo : Htmlfmt.formatter) s =
  try fo.push_attr (Styles.get s)
  with Not_found -> Logs.warn (fun m -> m "Missing style : %s" s)
@
<<function [[Html_disp.pop_style]]>>=
let pop_style (fo : Htmlfmt.formatter) s =
  try fo.pop_attr (Styles.get s)
  with Not_found -> Logs.warn (fun m -> m "Missing style : %s" s)
@

<<[[Htmlfmt.formatter]] graphical attributes methods>>=
push_attr : gattr list -> unit;
pop_attr : gattr list -> unit;
@


<<function [[Textfw_fo.create.push_attr]]>>=
push_attr = (fun l ->
  let fis = ref [] in
  l |> List.iter (function
    | Font fi -> 
        fis := fi :: !fis
    | Margin n -> 
        margins#push (cur()) n
    | Justification a -> 
        aligns#push (cur()) a
    | FgColor s -> 
        if !usecolors 
        then fgcolors#push (cur()) s
    | BgColor s ->
        if !usecolors 
        then bgcolors#push (cur()) s
    | Spacing n -> 
        spacing#push (cur()) n
    | Underlined -> 
        underline#push (cur())
    | Striked -> 
        strike#push (cur())
    | Superscript -> 
        fis := (FontDelta (-2)) :: !fis;
        offset#push (cur()) 5
    | Lowerscript ->
        fis := (FontDelta (-2)) :: !fis;
        offset#push (cur()) (-5)
    );
  if !fis <> [] 
  then fonts#push (cur()) !fis;
);
@

<<function [[Textfw_fo.create.pop_attr]]>>=
pop_attr = (fun l ->
  let fis = ref [] in
  l |> List.iter (function
    | Font fi -> fis := fi :: !fis
    | Margin n -> margins#pop (cur()) n
    | Justification a -> aligns#pop (cur()) a
    | FgColor s -> 
         if !usecolors then fgcolors#pop (cur()) s
    | BgColor s ->
         if !usecolors then bgcolors#pop (cur()) s
    | Spacing n -> spacing#pop (cur()) n
    | Underlined -> underline#pop (cur())
    | Striked -> strike#pop (cur())
    | Superscript ->
              fis := (FontDelta (-2)) :: !fis;
              offset#pop (cur()) 5
    | Lowerscript ->
              fis := (FontDelta (-2)) :: !fis;
              offset#pop (cur()) (-5)
  );
  if !fis <> [] 
  then fonts#pop (cur()) !fis;
);
@


\subsubsection{[[<pre>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* 
 * 5.5.2 Preformatted Text : <PRE>
 *    TODO: optional attribute WIDTH
 *    should be fixed font, respecting newlines
 *    local styles authorized however (i.e. markup is parsed)
*)
(* 5.5.2.1 Example and Listing: <XMP>, <LISTING>
 *    deprecated anyway
 *)

["pre"; "listing"; "xmp"] |> List.iter (fun s -> 
  mach#add_tag s 
    (fun fo _tag ->
       fo.new_paragraph();
       push_style fo "verbatim";
       mach#push_action fo.print_verbatim)
    (fun fo ->
       pop_style fo "verbatim";
       fo.close_paragraph();
       mach#pop_action)
);
@
%less: remove listing? xmp? still used?

<<[[Htmlfmt.formatter]] primitives methods>>=
print_verbatim : string -> unit;	(* Print as-is *)
@
<<function [[Textfw_fo.create.print_verbatim]]>>=
print_verbatim = (fun s -> 
  put_text s; 
  prev_is_newline := false
);
@

\subsubsection{[[<address>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.5.3 Address: <ADDRESS>
 *)
mach#add_tag "address" 
   (fun fo _tag -> fo.new_paragraph(); push_style fo "italic")
   (fun fo -> pop_style fo "italic"; fo.close_paragraph())
;
@

\subsubsection{[[<blockquote>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.5.4 Block Quote: <BLOCKQUOTE>
 *)
mach#add_tag "blockquote"
   (fun fo _tag ->
      fo.new_paragraph();
      push_style fo "italic";
      fo.push_attr [Margin 10])
   (fun fo ->
      pop_style fo "italic";
      fo.pop_attr [Margin 10];
      fo.close_paragraph())
;
@

<<[[Htmlfmt.gattr]] spacing cases>>=
| Margin of int
@

\subsection{Text styles part 2}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.7.1.1 Citation: <CITE>
 * 5.7.1.2 Code: <CODE>
 * 5.7.1.3 Emphasis: <EM>
 * 5.7.1.4 Keyboard: <KBD>
 * 5.7.1.5 Sample: <SAMP>
 * 5.7.1.6 Strong Emphasis: <STRONG>
 * 5.7.1.7 Variable: <VAR>
 *)

(* Different typographic styles, shared *)
let italic_style t = 
  mach#add_tag t 
     (fun fo _tag -> push_style fo "italic")
     (fun fo -> pop_style fo "italic")
in
let fixed_style t =
  mach#add_tag t 
    (fun fo _tag -> push_style fo "fixed")
    (fun fo -> pop_style fo "fixed")
in
let bold_style t =
  mach#add_tag t 
    (fun fo _tag -> push_style fo "bold")
    (fun fo -> pop_style fo "bold")
in
@

\subsubsection*{Main styles, [[<b>]], [[<i>]], [[<tt>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.7.2.1 Bold: <B>
 * 5.7.2.2 Italic: <I>
 * 5.7.2.3 Teletype: <TT>
 *)
bold_style "b";
italic_style "i";
fixed_style "tt";
@

\subsubsection*{More Italics, [[<em>]], [[<cite>]], [[<var>]]}
% could remove those dupes?

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
["cite"; "em"; "var"] |> List.iter italic_style;
@

\subsubsection*{More fixed, [[<code>]], [[<kbd>]], [[<samp>]]}
% could remove those dupes?

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
["code"; "kbd"; "samp"] |> List.iter fixed_style;
@

\subsubsection*{More bold, [[<strong>]]}
% could remove those dupes?

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
bold_style "strong";
@

\subsection{Text styles part 3}

<<[[Htmlfmt.gattr]] style cases>>=
| Underlined
@

\subsubsection{Underline, [[<u>]]}
<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 flashy features *)
mach#add_tag "u"
  (fun fo _t -> fo.push_attr [Underlined])
  (fun fo  -> fo.pop_attr [Underlined]);
@
\subsubsection{Strike, [[<strike>]]}

<<[[Htmlfmt.gattr]] style cases>>=
| Striked
@

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
mach#add_tag "strike"
  (fun fo _t -> fo.push_attr [Striked])
  (fun fo  -> fo.pop_attr [Striked]);
@

\subsubsection{Superscript, [[<sup>]]}

<<[[Htmlfmt.gattr]] style cases>>=
| Superscript
@

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
mach#add_tag "sup"
  (fun fo _t -> fo.push_attr [Superscript])
  (fun fo  -> fo.pop_attr [Superscript]);
@
\subsubsection{Lowerscript, [[<sub>]]}

<<[[Htmlfmt.gattr]] style cases>>=
| Lowerscript
@

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
mach#add_tag "sub"
  (fun fo _t -> fo.push_attr [Lowerscript])
  (fun fo  -> fo.pop_attr [Lowerscript]);
@

\subsection{Text styles part 4}

\subsubsection{Center, [[<center>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 flashy features *)
mach#add_tag "center"
    (fun fo _t -> fo.push_attr [Justification "center"])
    (fun fo -> fo.pop_attr [Justification "center"]);
@

\subsubsection{Alignment, [[<div>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 flashy features *)
  mach#add_tag "div"
      (fun fo t -> fo.push_attr [Justification (Html.get_attribute t "align")])
      (fun fo -> fo.pop_attr [Justification "whocares"]);
@

\subsubsection{Lowerscript, [[<sub>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 flashy features *)
  mach#add_tag "big"
      (fun fo _t -> fo.push_attr [Font (FontDelta 2)])
      (fun fo  -> fo.pop_attr [Font (FontDelta 2)]);
@

\subsubsection{Lowerscript, [[<sub>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 flashy features *)
  mach#add_tag "small"
      (fun fo _t -> fo.push_attr [Font (FontDelta (-2))])
      (fun fo  -> fo.pop_attr [Font (FontDelta (-2))]);
@

\subsection{Lists}

\subsubsection{[[<ul>]], [[<li>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.6.1 Unordered List: <UL>, <LI>
 * HTML3.2 
 * <!ENTITY % ULStyle "disc|square|circle">
 * 
 * <!ATTLIST UL -- unordered lists --
 *         type    (%ULStyle)   #IMPLIED   -- bullet style --
 *         compact (compact)    #IMPLIED   -- reduced interitem spacing --
 *         >
 *)
let list_level = ref 0 in

let open_list (fo : Htmlfmt.formatter) tag =
  fo.push_attr [Margin 10];
  incr list_level;
  let bullet = 
    try Html.get_attribute tag "type" 
    with Not_found ->
       (match !list_level mod 3 with
       | 1 -> "disc" 
       | 2 -> "circle" 
       | _ -> "square" 
       )
  in
  let compact = Html.has_attribute tag "compact" in
  let first_line = ref true in
  fo.new_paragraph();
  mach#add_tag "li"
     (fun fo tag -> 
        if !first_line 
        then first_line := false
        else 
          if compact 
          then fo.print_newline false 
          else fo.new_paragraph();
        let bullet = try Html.get_attribute tag "type" with Not_found -> bullet in
     fo.bullet bullet)
     (fun fo -> if not compact then fo.close_paragraph())
in

let close_list (fo : Htmlfmt.formatter) =
  decr list_level;
  fo.close_paragraph();
  fo.pop_attr [Margin 10];
  mach#remove_tag "li"
in

mach#add_tag "ul" open_list close_list;
@

<<[[Htmlfmt.formatter]] predefined images methods>>=
bullet : string -> unit;
@

<<function [[Textfw_fo.create.bullet]]>>=
(* TODO *)
bullet = begin
 let bulletsym = Mstring.egensym "bullet" in
 (fun s -> 
   try 
     let img = Hashtbl.find Attrs.bullet_table s in
     put_embedded (Label.create_named thtml (bulletsym())
                  [img; BorderWidth (Pixels 0);
                   Background (NamedColor !html_bg)]) ""
   with Not_found  -> put_text "*"
  )
end;
@

\subsubsection{[[<ol>]], [[<li>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* 
 * 5.6.2 Ordered List: <OL>, <LI>
 * HTML3.2
 * <!--
 *        Numbering style
 *     1   arablic numbers     1, 2, 3, ...
 *     a   lower alpha         a, b, c, ...
 *     A   upper alpha         A, B, C, ...
 *     i   lower roman         i, ii, iii, ...
 *     I   upper roman         I, II, III, ...
 * 
 *     The style is applied to the sequence number which by default
 *     is reset to 1 for the first list item in an ordered list.
 * -->
 * 
 * <!ENTITY % OLStyle "CDATA" -- "1|a|A|i|I" but SGML folds case -->
 * 
 * <!ATTLIST OL -- ordered lists --
 *         type     (%OLStyle)  #IMPLIED   -- numbering style --
 *         start     NUMBER     #IMPLIED   -- starting sequence number --
 *         compact  (compact)   #IMPLIED   -- reduced interitem spacing --
 *         >
 *)

let numbering_styles =
  ["1", string_of_int;
   "a", lowernumber;
   "A", uppernumber;
   "i", (function i -> String.lowercase_ascii (roman i));
   "I", roman
  ]
in

let nesting = ref [] in

let open_nlist (fo : Htmlfmt.formatter) tag =
  let li_counter = 
    ref (try int_of_string (Html.get_attribute tag "start")
         with _ -> 1) 
  in
  fo.push_attr [Margin 10];
  nesting := li_counter :: !nesting;
  let thisnumbers = List.rev !nesting in
  let numbering = 
     try List.assoc (Html.get_attribute tag "type") numbering_styles 
     with Not_found -> string_of_int
  in
  let compact = Html.has_attribute tag "compact" in
  mach#add_tag "li"
    (fun fo tag ->
      fo.new_paragraph();
      if compact 
      then fo.push_attr [Spacing 0];
      (* if value is given, use it as number *)
      begin
        try
          let n = int_of_string (Html.get_attribute tag "value") in
          match !nesting with
          | c::_ -> c := n
          |	_ -> () (* assert false *)
        with Not_found | Failure "int_of_string" -> ()
      end;
      thisnumbers |> List.iter (fun i ->
        fo.format_string (numbering !i);
        fo.format_string "."
      ))
    (fun fo ->
      incr li_counter;
      if compact 
      then fo.pop_attr [Spacing 0];
      fo.close_paragraph())
in

let close_nlist (fo : Htmlfmt.formatter) =
  fo.pop_attr [Margin 10];
  nesting := 
    (match !nesting with
    | [] -> [] 
    | _x::l -> l 
    );
  mach#remove_tag "li"
in

mach#add_tag "ol" open_nlist close_nlist;
@
%less use Stack.pop on nesting

<<[[Htmlfmt.formatter]] primitives methods>>=
format_string : string -> unit;	(* Line wrap, newlines don't count *)
@
<<function [[Textfw_fo.create.format_string]]>>=
format_string = (fun s -> 
  if not !prev_is_newline 
  then (* we are in text *)
    put_text (Html.beautify !trailing_space s)
  else (* decide if we should start a text *)
    let bs = Html.beautify true s in
    if bs = "" 
    then () (* it was all spaces *)
    else begin
      put_text bs;
      prev_is_newline := false
    end
);
@


<<[[Htmlfmt.gattr]] spacing cases>>=
| Spacing of int
@

<<function [[Html_disp.lowernumber]]>>=
(* SMOP Utilities for OL numbering *)
let lowernumber n =
  let rec f cur n = 
    if n < 0 then cur
    else  f (String.make 1 (Char.chr (97 + n mod 26)) ^ cur) (n / 26 - 1)
  in 
  if n <= 0 then "*" else f "" (n-1)
@

<<function [[Html_disp.uppernumber]]>>=
let uppernumber n =
  let rec f cur n = 
    if n < 0 then cur
    else  f (String.make 1 (Char.chr (64 + n mod 26)) ^ cur) (n / 26 - 1)
  in
  if n <= 0 then "*" else f "" (n-1)
@

<<constant [[Html_disp.romans]]>>=
let romans = [|
  [| ""; "I"; "II"; "III"; "IV"; "V"; "VI"; "VII"; "VIII"; "IX" |];
  [| ""; "X"; "XX"; "XXX"; "XL"; "L"; "LX"; "LXX"; "LXXX"; "XC" |];
  [| ""; "C"; "CC"; "CCC"; "CD"; "D"; "DC"; "DCC"; "DCCC"; "CM" |];
  [| ""; "M"; "MM"; "MMM"; "*MMM"; "*MMM"; "*MMM"; "*MMM"; "*MMM"; "*MMM" |];
  |]
@
<<function [[Html_disp.roman]]>>=
let roman n =
  let rec r cur level n =
    if n = 0 then cur
    else if level > 3 then "*" ^ cur
    else r (romans.(level).(n mod 10) ^ cur) (succ level)  (n / 10)
  in if n <= 0 then "*" else r "" 0 n
@

\subsubsection*{[[<dir>]], [[<menu>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.6.3 Directory List: <DIR>
 * 5.6.4 Menu List: <MENU>
 *  do as <UL>, but we should work on presentation
 *)
mach#add_tag "dir" open_list close_list;
mach#add_tag "menu" open_list close_list;
@

\subsubsection*{[[<dl>]], [[<dt>]], [[<dd>]]}
% apparently it's also used for tables in degenerated mode

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.6.5 Definition List: <DL>, <DT>, <DD> 
 *)
let open_dl (fo : Htmlfmt.formatter) tag =
  let compact = Html.has_attribute tag "compact" in
  fo.new_paragraph();
  fo.push_attr [Margin 10];

  if not compact then begin
    let prev_is_dt = ref false in

    mach#add_tag "dt"
      (fun fo _tag -> 
         if not !prev_is_dt then begin
           fo.new_paragraph();
           prev_is_dt := true
         end else 
           fo.print_newline false;
         push_style fo "bold")
      (fun fo -> pop_style fo "bold");

    mach#add_tag "dd"
      (fun fo _tag ->
         if !prev_is_dt then begin
           fo.close_paragraph();
           prev_is_dt := false
         end;
         fo.new_paragraph();
         fo.push_attr [Margin 20])
      (fun fo ->
          fo.pop_attr [Margin 20];
          fo.close_paragraph())

    end else begin
      (* if compact *)
      let first_item = ref true in

      mach#add_tag "dt"
        (fun fo _tag -> 
           if not !first_item 
           then fo.print_newline false
           else first_item := false;
           push_style fo "bold")
        (fun fo -> pop_style fo "bold");

      mach#add_tag "dd"
        (fun fo _tag ->
           if not !first_item 
           then fo.print_newline false
           else first_item := false;
           fo.push_attr [Margin 20])
        (fun fo -> fo.pop_attr [Margin 20])
    end
in

let close_dl (fo : Htmlfmt.formatter) =
  fo.pop_attr [Margin 10];
  fo.close_paragraph();
  mach#remove_tag "dt";
  mach#remove_tag "dd";
in

mach#add_tag "dl" open_dl close_dl;
@

\subsection{Anchors, [[<a>]]}

<<type [[Html_disp.Make.anchor_type]]>>=
type anchor_type = HREF | NAME
@

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.7.3 Anchor: <A> 
 * Assumes anchors are not nested
 * Can be both HREF and NAME.
 *)

let anchor_type = ref None in
let anchor_link = ref (Hyper.default_link "") in
let in_anchor = ref false in

let open_anchor (fo : Htmlfmt.formatter) tag =
  anchor_type := None;
  <<[[Html_disp.Make.init.open_anchor()]] look for NAME attribute>>
  <<[[Html_disp.Make.init.open_anchor()]] look for HREF attribute>>
in

let close_anchor (fo : Htmlfmt.formatter) =
  match !anchor_type with
  <<[[Html_disp.Make.init.close_anchor()]] match anchor type cases>>
  | None -> raise (Html.Invalid_Html "Unmatched </A>")
in
mach#add_tag "a" open_anchor close_anchor;
@

\subsubsection{Anchor, [[<a name=...>]]}

<<[[Html_disp.Make.init.open_anchor()]] look for NAME attribute>>=
(* is there a NAME attribute ? *)
begin
  try 
    fo.add_mark (Html.get_attribute tag "name");
    anchor_type := Some NAME
  with Not_found -> ()
end;
@
%bug? forgot in_anchor := true?

<<[[Html_disp.Make.init.close_anchor()]] match anchor type cases>>=
| Some NAME ->
    in_anchor := false;
    anchor_type := None
@

<<[[Htmlfmt.formatter]] structure primitives methods>>=
add_mark : string -> unit;
@
<<function [[Textfw_fo.create.add_mark]]>>=
(* WARNING: if anchor name is a standard tk name, such as end,
   we're f*cked, so we force # *)
add_mark = (fun s -> marks := ("#"^s, !position) :: !marks );
@

\subsubsection{Anchor, [[<a href=...>]]}

<<[[Html_disp.Make.init.open_anchor()]] look for HREF attribute>>=
(* is there an HREF attribute ? (if both, anchor_type is set to HREF *)
(* so that close_anchor does the right thing) *)
begin
  try
    let href = Html.get_attribute tag "href" in
    let h_params =
      try ["target", Html.get_attribute tag "target"]
      with Not_found ->
        (match mach#target with
        | Some s -> ["target", s]
        | None -> []
        )
    in
    anchor_link := { 
      h_uri = href;
      h_context = Some mach#base;
      h_method = 
        (try Hyper.parse_method (Html.get_attribute tag "methods")
         with _ -> GET
        );
      h_params = h_params
    };
    in_anchor := true;
    anchor_type := Some HREF;
    fo.start_anchor ();
    (* push_style fo "anchor" *)
  with Not_found ->
    (match !anchor_type with
    | None -> raise (Html.Invalid_Html "Missing NAME or HREF in <A>")
    | _ -> ()
    )
end
@

<<[[Html_disp.Make.init.close_anchor()]] match anchor type cases>>=
| Some HREF -> 
    fo.end_anchor !anchor_link;
    (* pop_style fo "anchor"; *)
    in_anchor := false;
    anchor_type := None
@

<<[[Htmlfmt.formatter]] structure primitives methods>>=
start_anchor : unit -> unit;
end_anchor : Hyper.link -> unit;
@

<<function [[Textfw_fo.create.start_anchor]]>>=
start_anchor = (fun () -> anchor_start := (cur()));
@
<<function [[Textfw_fo.create.end_anchor]]>>=
(* set the tag for the anchor *)
end_anchor = (fun link -> anchors#add_anchor !anchor_start (cur()) link);
@

\subsection{Breaks}

\subsubsection{Line breaks, [[<br>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.8 Line break: <BR> 
 *)
mach#add_tag "br" 
  (fun fo _tag -> fo.print_newline true)
  ignore_close
;
@

<<[[Htmlfmt.formatter]] primitives methods>>=
print_newline : bool -> unit;		(* Force a line break *)
@

<<function [[Textfw_fo.create.print_newline]]>>=
print_newline = (fun force -> 
 if force then begin
   put_text "\n"; 
   trailing_space := true
 end
 else break()
);
@

\subsubsection{Horizontal rules, [[<hr>]]}

<<type [[Html.length]]>>=
(* HTML length *)
type length = 
    Nolength
  | LengthPixels of int
  | LengthRatio of float
  | LengthRel of int
@


<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.9 Horizontal Rule: <HR>
 *)
mach#add_tag "hr"
  (fun fo tag -> 
     let width =
       try Html.length_of_string (Html.get_attribute tag "width")
       with Not_found -> Nolength 
     in
     let height =
       try int_of_string (Html.get_attribute tag "size")
       with Not_found | Failure "int_of_string" -> 1
     in
     let solid = Html.has_attribute tag "noshade" in
     fo.print_newline false;
     fo.hr width height solid;
     fo.print_newline false)
  ignore_close
;
@

<<[[Htmlfmt.formatter]] predefined images methods>>=
hr : Html.length -> int -> bool -> unit;  (* [hr width height solid] *)
@

<<function [[Textfw_fo.create.hr]]>>=
hr = begin
  let hrsym = Mstring.egensym "hr" in
  (fun width height solid ->
    let fr = Hr.create_named thtml (hrsym()) width height solid in
    Frame.configure fr [Background (NamedColor !fg)];
    put_embedded fr ""
  )
end;
@


<<signature [[Html.length_of_string]]>>=
val length_of_string : string -> length
@
<<function [[Html.length_of_string]]>>=
(* Either size in pixels or ration in percent *)
let length_of_string s =
  try
    let pos = String.index s '%' in
    try LengthRatio (float_of_string (String.sub s 0 pos) /. 100.)
    with Failure "int_of_string" -> Nolength
  with Not_found ->
    try
      let pos = String.index s '*' in
      if pos = 0 
      then LengthRel 1
      else
        try LengthRel (int_of_string (String.sub s 0 pos))
        with Failure "int_of_string" -> Nolength
    with Not_found ->
      try LengthPixels (int_of_string s)
      with Failure "int_of_string" -> Nolength
@

\subsection{Images, [[<img>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(*
 * 5.10 Image: <IMG>
 *)
mach#add_tag "img"
  (fun fo tag -> 
     try
       let src = Html.get_attribute tag "src" in
       let align = Html.get_attribute tag "align" in

       let width = 
         try Some (int_of_string (Html.get_attribute tag "width"))
         with Not_found | Failure "int_of_string" -> None
       in
       let height = 
         try Some (int_of_string (Html.get_attribute tag "height"))
         with Not_found | Failure "int_of_string" -> None
       in

       <<[[Html_disp.Make.init()]] IMG case, let alt>>
       let w = fo.create_embedded align width height in
       let link = Hyper.{ 
         h_uri = src; 
         h_context = Some mach#base;
         h_method = GET; 
         h_params = []
       } in
       <<[[Html_disp.Make.init()]] IMG case, let map>>
       let caps = Cap.network_caps_UNSAFE () in
       mach#imgmanager#add_image caps
         { embed_hlink = link;
           embed_frame = w;
           embed_context = mach#ctx#for_embed tag.attributes [];
           embed_map = map;
           embed_alt = alt
          }
     with Not_found -> (* only on SRC *)
       raise (Html.Invalid_Html "missing SRC in IMG"))

  ignore_close
;
@


<<[[Htmlfmt.formatter]] embedding primitives methods>>=
create_embedded : 
   string -> int option -> int option -> Widget.widget;
     (* [create_embedded align w h ]: 
    returns a widget that we can pass as target to the embed manager.
    Should respect background color ?
  *)
@
<<function [[Textfw_fo.create.create_embedded]]>>=
create_embedded = begin
  (* avoid space leak in Tk hash table : reuse the same names *)
  let embsym = Mstring.egensym "emb" in

  (fun _a w h ->
     let f = Frame.create_named thtml (embsym()) [Class "HtmlEmbedded"] in
     if !usecolors 
     then Frame.configure f [Background (NamedColor !bg)];

     (* To solve the focus problem 
     Tk.bindtags  f ((WidgetBindings thtml) :: Tk.bindtags_get f);
     bind f [[],Enter] (BindSet ([], fun _ -> Focus.set thtml)); 
      *)
     (* -- end *)
     (match w, h with
      | Some w, Some h ->
          Frame.configure f [Width (Pixels w); Height (Pixels h);
          BorderWidth (Pixels 0)];
           Pack.propagate_set f false
      | _, _ -> ()
     );
     put_embedded f "";
     f
  )
end;
@


<<[[Html_disp.Make.init()]] IMG case, let map>>=
(* some people use both ismap and usemap...
 *  prefer usemap
 *)
let map =
  try 
    let mapname = Html.get_attribute tag "usemap"  in
    Maps.ClientSide { 
      h_uri = mapname;
      h_context = Some mach#base;
      h_method = GET;
      h_params = []
    }
  with Not_found -> 
    if !in_anchor 
    then
      if Html.has_attribute tag "ismap"
      then Maps.ServerSide !anchor_link
      else Maps.Direct !anchor_link
    else NoMap
in
@


<<[[Html_disp.Make.init()]] IMG case, let alt>>=
let alt = 
  try Html.get_attribute tag "alt"
  with Not_found ->
    let image_name = 
      let pos = 
        let cpos = ref (String.length src) in
        try
          while !cpos > 0 do
            match src.[!cpos - 1] with
            | '/' | '\\' (* for f!@#ing DOS users *) -> raise Exit
            | _ -> decr cpos
          done;
          0
       with Exit -> !cpos
     in
     if pos = String.length src 
     then "IMAGE"
     else String.sub src pos (String.length src - pos)
  in
  Printf.sprintf "[%s]" image_name	 
in          
@

\subsection{Forms}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* FORMS: they are defined elsewhere (html_form) *)
FormLogic.init mach;
(* standard basic HTML2.0 initialisation stops here *)
@

\subsection{Tables}

<<signature [[Html_disp.attempt_tables]]>>=
val attempt_tables : bool ref
@
<<constant [[Html_disp.attempt_tables]]>>=
(* Preference settings *)
let attempt_tables = ref false
@

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* TABLE support *)
if !attempt_tables 
then TableLogic.init mach
else begin
  let behave_as oldtag newtag =
     mach#add_tag newtag
       (fun _fo _t -> mach#send (OpenTag {tag_name = oldtag; attributes = []}))
       (fun _fo ->   mach#send (CloseTag oldtag))
  in
  (* use DL for tables *)
  behave_as "dl" "table";
  mach#add_tag "tr" ignore_open ignore_close;
  behave_as "dt" "th";
  behave_as "dd" "td"
end;
@

\subsection{Embedded elements, [[<embed>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* EMBED
 *  The definition is a mix of what was done for earlier versions
 *  of MMM and Netscape Navigator. The reason is to get compatible HTML for
 *  Caml Applets in both browsers.
 *)
mach#add_tag "embed"
  (fun fo tag -> 
     try
       let link = Hyper.{
         h_uri = Html.get_attribute tag "src";
         h_method = GET;
         h_context = Some mach#base;
         h_params = []} in
       let width =
        try Some (int_of_string (Html.get_attribute tag "width"))
        with Not_found -> None
       and height =
         try Some (int_of_string (Html.get_attribute tag "height"))
         with Not_found -> None
       and alttxt = Html.get_attribute tag "alt" in

       let fr = fo.create_embedded "" width height in
       mach#add_embedded {
       embed_hlink = link;
       embed_frame = fr;
       embed_context = mach#ctx#for_embed tag.attributes [];
       embed_map = NoMap; (* yet *)
       embed_alt = alttxt
      }
     with
      Not_found ->
       raise (Html.Invalid_Html ("SRC missing in EMBED")))
  ignore_close;
@


\subsection{Maps}

% from maps.ml comment:
%(* Client-side image maps:
%     the "only" difficulty in implementing client-side image maps is that
%     the map may well come *after* the image in the document. In general,
%     anyway, the map may be an arbitrary URL.
%
%   We thus have to implement a general delay mechanism for maps : the idea
%   here is to use a table of maps, each map being accessed by an URI (that is,
%   an URL plus a fragment).
%
%   PROBLEM: we have no idea in general when to flush this table.
%
% *)


<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 good features *)
let areas = ref [] in
let mapname = ref "" in

mach#add_tag "map"
  (fun _fo t ->
       (* the name of the map *)
       let absname = 
         try 
      let name = Html.get_attribute t "name" in
      (* we must get a normalized name here *)
        Hyper.string_of {h_uri = "#"^name; h_context = Some mach#base;
                h_method = GET; h_params = []}
         with
       Not_found -> 
         Hyper.string_of (Hyper.default_link mach#base)
       in
       mapname := absname;
       areas := [];
       mach#add_tag "area" 
      (fun _fo tag -> 
         let shape = String.lowercase_ascii (Html.get_attribute tag "shape")
         and href = 
       try Some (Html.get_attribute tag "href") with Not_found -> None
             and coords =
       try Maps.parse_coords (Html.get_attribute tag "coords")
       with _ -> [] 
             and alttxt =
               try Html.get_attribute tag "alt" with Not_found -> ""
             in
         let h_params =
       try ["target", Html.get_attribute tag "target"]
       with
         Not_found ->
           match mach#target with
             Some s -> ["target", s]
           |	None -> []
         in
         match href with
         | None -> () (* this creates a HOLE. not yet supported *)
         | Some uri ->
          let link = Hyper.{h_uri = uri; h_context = Some mach#base;
                          h_method = GET; h_params = h_params} in
          let area = 
          match shape with
           "default" -> Maps.{area_kind = Default; area_coords = [];
                              area_link = link; area_alt = alttxt}
         | "rect" -> Maps.{area_kind = Rect; area_coords = coords;
                           area_link = link; area_alt = alttxt}
         | "circle" -> Maps.{area_kind = Circle; area_coords = coords;
                             area_link = link; area_alt = alttxt}
         | "poly" -> Maps.{area_kind = Poly; area_coords = coords;
                           area_link = link; area_alt = alttxt} 
         | _ -> Maps.{area_kind = Default; area_coords = [];
                      area_link = link; area_alt = alttxt} in
                areas := area :: !areas)
          ignore_close)

  (fun _fo -> 
    mach#remove_tag "area";
    Maps.add !mapname !areas)
;
@

% important for imgs?

%(* Client-side image maps:
%     the "only" difficulty in implementing client-side image maps is that
%     the map may well come *after* the image in the document. In general,
%     anyway, the map may be an arbitrary URL.
%
%   We thus have to implement a general delay mechanism for maps : the idea
%   here is to use a table of maps, each map being accessed by an URI (that is,
%   an URL plus a fragment).
%
%   PROBLEM: we have no idea in general when to flush this table.
%
% *)


<<type [[Maps.area_kind]]>>=
(* The active areas *)
type area_kind = 
 | Rect 
 | Circle 
 | Poly 
 | Default
@

<<type [[Maps.area]]>>=
(* The area *)
type area = {
  area_kind : area_kind;
  area_coords : int list;
  area_link : Hyper.link;
  area_alt  : string
 }
@

<<type [[Maps.map]]>>=
type map = area list
@

<<type [[Maps.t]]>>=
(* We merge any kind of map, for we actually are going to support
   maps for arbitrary embedded objects
 *)
type t = 
  | ClientSide of Hyper.link		(* usemap link *)
  | ServerSide of Hyper.link		(* ismap *)
  | Direct of Hyper.link			(* inside an anchor *)
  | NoMap				(* no additionnal navigation *)
  | FormMap of (int * int -> Hyper.link)
@

<<type [[Maps.map_status]]>>=
(* The table of client-side image maps *)
type map_status =
 | KnownMap of map
 | RequestedMap of string
@

<<signature [[Maps.parse_coords]]>>=
val parse_coords : string -> int list
@

<<signature [[Maps.get]]>>=
val get : string -> map_status
@

<<signature [[Maps.add]]>>=
val add : string -> map -> unit
@


<<constant [[Maps.table]]>>=
let table = (Hashtbl.create 37 : (string, map_status) Hashtbl.t)
@

<<constant [[Maps.coord_sep]]>>=
(* Tolerance: official syntax is "," separated.
   We use instead "[ \t\n]+\|\([ \t\n]*,[ \t\n]*\)"
   that is non empty sequence of whitespace
        or comma with possible surrounding whitespace
 *)
(* let coord_sep = Str.regexp "," *)
let coord_sep = Str.regexp "[ \t\n]+\\|\\([ \t\n]*,[ \t\n]*\\)"
@

<<function [[Maps.parse_coords]]>>=
let parse_coords s =
  List.map int_of_string (Str.split coord_sep s)
@

<<function [[Maps.add]]>>=
let add name map =
  Log.debug (sprintf "Adding map : %s" name);
  try
    match Hashtbl.find table name with
      KnownMap _m -> Log.debug "Map already known !"
    | RequestedMap event ->
       Hashtbl.remove table name; (* remove it *)
       Hashtbl.add table name (KnownMap map); (* add its value *)
       !broadcast_backend event (* trigger all waiting people *)
  with
    Not_found -> (* nobody requested it *)
      Hashtbl.add table name (KnownMap map)
@

<<function [[Maps.get]]>>=
let get name =
  Log.debug (sprintf "Asking map : %s" name);
  try
    Hashtbl.find table name 
  with
    Not_found ->
       let m = Mstring.gensym "map" in
         Hashtbl.add table name (RequestedMap m);
     RequestedMap m
@



\subsection{Fonts}

<<[[Htmlfmt.gattr]] font cases>>=
| Font of Fonts.fontInfo		        (* mostly size and face *)
@

\subsubsection{[[<basefont>]]}


<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
mach#add_tag "basefont"
  (fun fo t -> 
     try
       let n = int_of_string (Html.get_attribute t "size") in
       fo.set_defaults "font" [Font (FontIndex n)]
     with Not_found | Failure "int_of_string" ->
       raise (Html.Invalid_Html "invalide SIZE"))
  ignore_close;
@

<<[[Htmlfmt.formatter]] graphical attributes methods>>=
set_defaults : string -> gattr list -> unit;     (* bg, fg, links *)
@

<<function [[Textfw_fo.create.set_defaults]]>>=
(* TODO : vlink *)
set_defaults = (fun name attrs -> 
  inherited := (name, attrs) :: !inherited;
  match name with
  | "background" ->
      attrs |> List.iter (function
      | BgColor s ->
          if !usecolors then
            let c = Attrs.html_color s in
            if Frx_color.check c then begin
              bg := c;
              Resource.add 
                 (sprintf "Mmm%s*background" (Widget.name thtml))
                   c Interactive;
              Text.configure thtml [Background (NamedColor c)];
              !other_bg [Background (NamedColor c)]
            end
      | _ -> ())

  | "foreground" ->
      attrs |> List.iter (function
        | FgColor s ->
           if !usecolors then
             let c = Attrs.html_color s in
             if Frx_color.check c then begin
               fg := c;
               Resource.add 
                 (sprintf "Mmm%s*foreground" (Widget.name thtml))
                   c Interactive;
               Text.configure thtml [Foreground (NamedColor c)]
           end
        | _ -> ())

  | "link" ->
      attrs |> List.iter (function
        | FgColor s ->
            if !usecolors then
              let c = Attrs.html_color s in
              if Frx_color.check c then 
                anchors#change "anchor" [Foreground (NamedColor c)]
        | _ -> ())

  | "alink" ->
      attrs |> List.iter (function
        | FgColor s ->
            if !usecolors then
              let c = Attrs.html_color s in
              if Frx_color.check c then 
                anchors#change "visited" [Foreground (NamedColor c)]
        | _ -> ())

  | "font" ->
      attrs |> List.iter (function
        | Font (FontIndex x)  -> 
            fonts#set_base (cur()) x
        |	_ -> ())

  | _ -> ()
);
@

\subsubsection{[[<font>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
let fontchanges = ref [] in

mach#add_tag "font"
  (fun fo t ->
     let attrs = [] in
     let attrs =
       try
         let size = Html.get_attribute t "size" in
         let l = String.length size in
         if l = 0 
         then raise Not_found
         else 
           if size.[0] = '+' 
           then
             (Htmlfmt.Font (FontDelta (int_of_string (String.sub size 1 (pred l)))))
                    :: attrs
           else 
             if size.[0] = '-' 
             then (Htmlfmt.Font (FontDelta (int_of_string size)))::attrs
             else (Htmlfmt.Font (FontIndex (int_of_string size)))::attrs
       with Not_found | Failure _ -> attrs 
     in
     let attrs = 
        try
          let color = Html.get_attribute t "color" in
          (Htmlfmt.FgColor color)::attrs
        with Not_found -> attrs 
     in
     (* attrs may well be the empty list *)
     if attrs <> [] 
     then fo.push_attr attrs;
     fontchanges := attrs :: !fontchanges)

  (fun fo -> 
     match !fontchanges with
     | [] -> raise (Html.Invalid_Html "unmatched </font>")
     | x::l -> 
         fontchanges := l;
         if x <> [] 
         then fo.pop_attr x)
;
@

<<[[Htmlfmt.gattr]] color cases>>=
| FgColor of string
@

\subsection{[[<style>]]}

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 obnoxious features *)
(* STYLE, SCRIPT in HEAD: not managed here
   For some reason, script is also allowed in text by the DTD.
   Make sure we just dump the contents...
   We do the same for style, just in case people dont respect the DTD
 *)
mach#add_tag "style"
  (fun _fo _t -> mach#push_action (fun _s -> ()))
  (fun _fo -> mach#pop_action);
@

\subsection{[[<script>]]}

% haha, "obnoxious" :)

<<[[Html_disp.Make.init()]] HTML elements machine initialisation>>=
(* Some HTML 3.2 obnoxious features *)
mach#add_tag "script"
  (fun _fo _t -> mach#push_action (fun _s -> ()))
  (fun _fo -> mach#pop_action);
@

\subsection{Frames}
% related to embed?
% no frame tag? yes, but it's done in head_hook

<<constant [[Htmlw.frames_as_links]]>>=
(* Prefs globals *)
let frames_as_links = ref false
@

<<[[Htmlw.display_html]] display frames>>=
if not !frames_as_links then
  Htframe.add_frames (self#load_frames) (fun () ->
    match body_frame with
    | None -> ()
    | Some f -> Tk.destroy f
  ) frame mach;
@

<<[[Htmlw.display_html]] load frames methods>>=
method load_frames frames =
  (* all targets defined in all framesets in this document *)
  let targets = 
    frames |> List.map (fun ((frdesc : Htframe.frame), w) -> 
          frdesc.frame_name, w) 
  in
  frames |> List.iter (fun ((frdesc : Htframe.frame), w) ->
    let thistargets =
         ("_self", w) (* ourselves *)
      :: ("_parent", Winfo.parent w) (* our direct parent *)
      :: targets (* common targets *)
    in
    let ectx = ctx#for_embed frdesc.frame_params thistargets in
    (* add frame parameters and targets to our ctx *)
    (* NOTE: there is a redundancy between embed_frame and _self in ctx,
       but frames are only an instance of embedded objects so we should
       no rely on the existence of _self for embed display machinery *)
     mach#add_embedded {
       embed_hlink = { 
         h_uri = frdesc.frame_src;
         h_context = Some (Url.string_of ctx#base.document_url);
         h_method = GET;
         h_params = []
       };
       embed_frame = w;
       embed_context = ectx;
       embed_map = Maps.NoMap;
       embed_alt = frdesc.frame_name
     }
  )
@


<<type [[Viewers.frame_targets]]>>=
type frame_targets = (string * Widget.widget) list
@

<<signature [[Viewers.frame_adopt]]>>=
val frame_adopt : Widget.widget -> frame_targets -> frame_targets
    (* remap _self and _parent *)
@
<<signature [[Viewers.frame_fugue]]>>=
val frame_fugue : frame_targets -> frame_targets
    (* forget about _self and _parents *)
@


<<function [[Viewers.frame_adopt]]>>=
let frame_adopt w targets = 
  targets |> List.map (function 
    | "_self",_ -> "_self", w
    | "_parent", _ -> "_parent", Winfo.parent w
    | s, f -> s, f
  )
    
@

<<function [[Viewers.frame_fugue]]>>=
let frame_fugue targets =
  let rec ff accu = function
    | [] -> accu
    | ("_self", _) :: l -> ff accu l
    | ("_parent", _) :: l -> ff accu l
    | p :: l -> ff (p::accu) l
  in
  ff [] targets
@

\section{Styles}

% Styles.get

\section{Fonts}

%todo? http://www.google.com/fonts

% http://www.ampsoft.net/webdesign-l/WindowsMacFonts.html

<<[[Plain.plain#init]] setup fonts>>=
(*
(* pick up the fixed font *)
let attrs_fixed   = Styles.get_font "fixed" in
let attrs_default = Styles.get_font "default" in
let fd = 
  Fonts.merge (Fonts.merge !Fonts.default attrs_default) attrs_fixed in
let (_, opts) = Fonts.compute_tag fd in
Text.configure text opts;
*)
@

\section{Forms}

<<type [[Htmlfmt.input_kind]]>>=
(* Form manager *)
type input_kind = EntryInput | FileInput | OtherInput
@

\section{Tables}

<<type [[Htmlfmt.width_constraint]]>>=
(* Table manager *)
type width_constraint =
  | TopWidth				(* toplevel window size*)
  | FixedWidth of int			(* width is given in pixels *)
  | UnknownWidth of (unit -> bool)	(* constraint to satisfy *)
@

\section{XXX}

\subsection{Meta tag}

<<[[Htmlw.display_html]] set meta tag>>=
let meta_charset = ref None in
(* <META HTTP-EQUIV="Content-Type" CONTENT="*/*;CHARSET=*"> stuff *)
if not !ignore_meta_charset then begin 
  mach#add_tag "meta" (fun _fo tag ->
   try 
     let h = Html.get_attribute tag "http-equiv" in
     let v = Html.get_attribute tag "content" in
     match String.lowercase_ascii h with
     | "content-type" ->
          begin try
            let (t,h), l = Lexheaders.media_type v in
            if String.lowercase_ascii t <> "text" ||
               String.lowercase_ascii h <> "html" then begin
                 Log.f ("Unknown meta content-type = "^t^"/"^h);
                raise Exit
            end;
            try 
              List.iter (fun (h,v) ->
                if String.lowercase_ascii h = "charset" then begin
                  let v = String.lowercase_ascii v in
                  Log.f ("MetaCharset detect : " ^ v);
                  begin try
                    let code = 
                      let code = ref Charset.Unknown in
                      try List.iter (fun (x,c) -> 
                         if Str.string_match (Str.regexp x) v 0 then begin
                           code := c;
                           raise Exit
                         end
                         ) Charset.encode_table ;
                         raise Not_found
                      with Exit -> !code
                    in
                    (* feed_read#set_code code; this does not work... *)
                    meta_charset := Some code
                  with Not_found ->
                    Log.f (v ^ ": I don't know this charset")
                  end;
                  raise Exit
               end) l;
            with Exit -> ()
          with _ -> () (* if failed to parse, ignore it *)
        end
     | _ -> ()
   with Not_found -> ()
 )
 ignore_close
  end;
@


\subsection{Annotations}

<<[[Htmlw.display_html]] private fields>>=
val (*private*) annotations = ref []
@
% ??? -> <>
<<[[Htmlw.display_html]] other methods or fields>>=
method annotate loc = function
  | OpenTag {tag_name=name; _} ->
      annotations := (name, loc) :: !annotations
  | CloseTag name ->
      annotations := (name, loc) :: !annotations
  | _ -> ()
@


<<[[Htmlw.display_html]] in feed, annotate>>=
(* We annotate only the last token, which is normally the one
 * from the original token stream *)
let rec annot_last = function
| [] -> ()
| [x] -> self#annotate loc x
| _x::l -> annot_last l
in
annot_last tokens;
@

\subsection{Extra headers}

<<[[Htmlw.display_html]] private fields>>=
val mutable add_extra_header = fun _f -> ()
@
% ??? -> <>
<<[[Htmlw.display_html]] other methods or fields>>=
method add_extra_header = add_extra_header
@


\subsection{Error management}

<<[[Htmlw.display_html]] private fields>>=
val (*private*) errors = ref []
@
% ??? -> <>
<<[[Htmlw.display_html]] error managment methods>>=
(* error reporting *)
method record_error loc msg =
  errors := (loc,msg) :: !errors;
  self#set_progress size (-1)
@

<<[[Htmlw.display_html]] in feed, record possible errors after lexing>>=
warnings |> List.iter (fun (reason, pos) -> 
  self#record_error (Html.Loc(pos,succ pos)) reason
);
(match correct with
| Legal -> ()
| Illegal reason -> self#record_error loc reason
);
@





<<[[Htmlw.display_html]] in feed, other exceptions handler>>=
| Html.Html_Lexing (s,n) ->
    (* this should not happen if Lexhtml was debugged *)
    self#record_error (Html.Loc(n,n+1)) s
@

<<[[Htmlw.display_html]] in feed, other exceptions handler>>=
| Unix.Unix_error(_,_,_) ->
    self#finish true
| e ->
    Log.f (sprintf "FATAL ERROR (htmlw) %s" (Printexc.to_string e));
    self#finish true
@

%******************************************************************************
\chapter{Embedded Elements}
%******************************************************************************

\section{Overview}

% example, images, but also java applets, caml applets :)
% flash, iframe?. Pretty important. Pretty important
% also to display then independently of main document, to not
% wait to have all the pictures to start to draw things
% (also why jpg is good, because can start to draw things
% and then as get more data we can refine the picture).
% Incremental!

\section{XXX}

<<method [[Viewers.context.for_embed]]>>=
(* apply this on a copy ! *)
method for_embed (vparams: vparams) (newtargets : frame_targets) : 'a =
  {< viewer_params = vparams; 
     targets = 
       let _oldtargets = targets in (* for debug *)
        match newtargets with 
        (* keep exactly the same environment *)
        | [] -> targets 
        (* assume I'm given new _self and _parent *)
        | l -> l @ frame_fugue targets 
  >}
@

<<method [[Viewers.context.in_embed]]>>=
method in_embed did =
  {< base = did >}
@

<<nested function [[Nav.stdctx.init.make_embed]]>>=
(* a new context for an embedded window *)
let make_embed_ctx (w : Widget.widget) (targets : Viewers.frame_targets) 
    : Viewers.context = 
  let targets = 
    ("_self", w) :: ("_parent", Winfo.parent w) :: (Viewers.frame_fugue targets) in
  let newctx = (new stdctx caps (did,nav))#init in
  begin
    try 
      let f = List.assoc "pointsto" self#hyper_funs in
      let g = List.assoc "clearpointsto" self#hyper_funs in
      newctx#add_nav ("pointsto", f);
      newctx#add_nav ("clearpointsto", g);
    with Not_found -> ()
  end;
  (newctx#for_embed [] targets :> Viewers.context)
in
@


<<nested function [[Nav.stdctx.init.frame_goto]]>>=
let frame_goto ( caps : < Cap.network; .. > )
     (targets : Viewers.frame_targets) (hlink : Hyper.link) =
  try
  (* target semantics PR-HTML 4.0 16.3.2 *)
   match List.assoc "target" hlink.h_params with
   | "_blank" ->
    let w = Toplevel.create Widget.default_toplevel [] in
    Embed.add caps { 
     embed_hlink = hlink;
     embed_frame = w;
     embed_context = make_embed_ctx w targets;
     embed_map = Maps.NoMap;
     embed_alt = "" }
   | "_self" ->
    let w = List.assoc "_self" targets in
    Embed.add caps {
     embed_hlink = hlink;
     embed_frame = w;
     embed_context = make_embed_ctx w targets;
     embed_map = Maps.NoMap;
     embed_alt = "" }
   | "_top" -> follow_link caps targets hlink
   | "_parent" ->
    let w = List.assoc "_parent" targets in
    Embed.add caps { 
     embed_hlink = hlink;
     embed_frame = w;
     embed_context = make_embed_ctx w targets;
     embed_map = Maps.NoMap;
     embed_alt = "" }
   | s ->
    let w = List.assoc s targets in
    Embed.add caps {
     embed_hlink = hlink;
     embed_frame = w;
     embed_context = make_embed_ctx w targets;
     embed_map = Maps.NoMap;
     embed_alt = "" }
  with
   Not_found -> (* if we are in a frame, it is available as _self *)
  try
    let w = List.assoc "_self" targets in
    Embed.add caps {
     embed_hlink = hlink;
     embed_frame = w;
     embed_context = make_embed_ctx w targets;
     embed_map = Maps.NoMap;
     embed_alt = "" }
  with
    Not_found -> follow_link caps targets hlink
in
@

<<[[Html_disp.machine]] embedded fields>>=
method virtual add_embedded : Embed.obj -> unit
method virtual embedded : Embed.obj list
@
<<[[Html_disp.display_machine]] embedded methods>>=
(* record all embedded objects in this machine *)
val mutable (*private*) embedded = []
method add_embedded x = 
  let caps = Cap.network_caps_UNSAFE () in
  Embed.add caps x;
  embedded <- x :: embedded
method embedded = embedded
@


<<[[Viewers.context]] embedded methods signatures>>=
(*-*)
method for_embed : vparams -> frame_targets -> 'a
method in_embed : Document.id -> 'a
@

<<[[Viewers.context]] other methods signatures>>=
method params : vparams
@

<<type [[Viewers.vparams]]>>=
(* list of additionnal parameters for the viewer, according to its
   activation point *)
(* hyper functions are: "goto", "save", "gotonew" *)
type vparams = (string * string) list
@
% ???





<<type [[Embed.embobject]]>>=
(* Embedded objects *)
type obj = {
  embed_hlink : Hyper.link; (* hyperlink to the object *)
  embed_frame : Widget.widget;
      (* the frame where the viewers can do their stuff *)
  embed_context : Viewers.context;
  embed_map : Maps.t; (* associated map *)
  embed_alt : string;
}
@


<<signature [[Embed.add]]>>=
val add : < Cap.network; ..> ->
  obj -> unit
@

<<signature [[Embed.update]]>>=
val update : < Cap.network; ..> ->
  Widget.widget -> Viewers.context -> Document.t -> (unit -> unit) -> unit
@










<<[[Viewers.display_info]] embedded virtual methods signatures>>=
method virtual di_update : unit      (* update embedded objects *)
@


<<[[Plain.plain]] empty methods>>=
method di_update = ()
@

<<[[Htmlw.display_html]] update embedded objects methods>>=
method di_update =
  let caps = Cap.network_caps_UNSAFE () in
  imgmanager#update_images caps;

  Frx_after.idle (fun () ->
    mach#embedded |> List.iter (fun Embed.{embed_frame = f; _} ->
      Winfo.children f |> List.iter (Frx_synth.send "update")
    )
  )
@

\section{Embedded viewers}


<<signature [[Embed.add_viewer]]>>=
val add_viewer : 
  Http_headers.media_type -> 
  (Http_headers.media_parameter list -> Widget.widget -> Viewers.context ->
    Document.t -> unit) -> unit
@

<<signature [[Embed.rem_viewer]]>>=
val rem_viewer :  Http_headers.media_type -> unit
@


<<constant [[Embed.embedded_viewers]]>>=
(* Embedded viewers *)

let embedded_viewers = Hashtbl.create 11

@

<<function [[Embed.embedded_viewer]]>>=
let embedded_viewer (frame : Widget.widget) (ctx : Viewers.context)
    (doc : Document.t) : unit =
  (* Destroy the alt window *)
  List.iter Tk.destroy (Winfo.children frame);
  try
    let ctype = Http_headers.contenttype doc.document_headers in
    let (typ, subtyp), l = Lexheaders.media_type ctype in
    try
      let viewer =
        try Hashtbl.find embedded_viewers (typ, subtyp) with
        | Not_found -> Hashtbl.find embedded_viewers (typ, "*")
      in
      viewer l frame ctx doc
    with
    | Not_found ->
        let t = s_ "Embed Error: no viewer for type %s/%s" typ subtyp in
        let l = Label.create frame [ Text t ] in
        pack [ l ] []
  with
  | Not_found ->
      let t =
        s_ "Embed Error: no type for document %s"
          (Url.string_of doc.document_address)
      in
      let l = Label.create frame [ Text t ] in
      pack [ l ] []
  | Http_headers.Invalid_header e ->
      let t =
        s_ "Embed Error: malformed type %s (%s)"
          (Http_headers.contenttype doc.document_headers)
          e
      in
      let l = Label.create frame [ Text t ] in
      pack [ l ] []
@





<<constant [[Embed.embedded]]>>=
(* Remember all current embedded objects by their frame *)
let embedded = (Hashtbl.create 101 : (string, obj) Hashtbl.t)
@

<<function [[Embed.add_embed]]>>=
(* add and notify *)
let add_embed (emb : obj) =
  Hashtbl.add embedded (Widget.name emb.embed_frame) emb;
  Frx_synth.send "setembed" emb.embed_frame
@

<<function [[Embed.when_destroyed]]>>=
(* when the frame gets destroyed, remove us from the table *)
let when_destroyed (w : Widget.widget) = Hashtbl.remove embedded (Widget.name w)

@

<<toplevel [[Embed._1]]>>=
let _ = Protocol.add_destroy_hook when_destroyed
@

<<function [[Embed.add]]>>=
(* Queueing an embed *)
let add (caps : < Cap.network ; .. >) (emb : obj) =
  let {
    embed_hlink = link;
    embed_frame = frame;
    embed_context = embed_ctx;
    embed_map = _m;
    embed_alt = alt_txt;
  } =
    emb
  in
  (* Put up the ALT text *)
  List.iter Tk.destroy (Winfo.children frame);
  pack [ Label.create_named frame "alt" [ Text alt_txt ] ] [];
  (* Check if the type is defined and a viewer available *)
  try
    let given_type = List.assoc "type" embed_ctx#params in
    let (typ, subtyp), parms = Lexheaders.media_type given_type in
    try
      let viewer =
        try Hashtbl.find embedded_viewers (typ, subtyp) with
        | Not_found -> Hashtbl.find embedded_viewers (typ, "*")
      in
      EmbeddedScheduler.add_request
        (caps :> < Cap.network >)
        (Www.make link) embed_ctx#base
        (* the continuation: it will receive the document *)
          (fun _url doc ->
          let doc =
            Document.
              { doc with
                document_headers =
                  Http_headers.merge_headers doc.document_headers
                    [ "Content-Type: " ^ given_type ];
              }
          in
          (* Destroy the alt window *)
          List.iter Tk.destroy (Winfo.children frame);
          (* Add to our table/notify *)
          add_embed emb;
          viewer parms frame embed_ctx doc)
        (Tk_progress.meter frame)
    with
    | Not_found ->
        (* no viewer for this *)
        let t = s_ "Embed Error: no viewer for type %s" given_type in
        pack [ Label.create frame [ Text t ] ] []
    | Www.Invalid_request (w, msg) ->
        let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
        pack [ Message.create frame [ Text t ] ] []
    | Hyper.Invalid_link _err ->
        let t = s_ "Embed Error: invalid link" in
        pack [ Message.create frame [ Text t ] ] []
  with
  | Not_found -> (
      (* not type given, we have to retrieve to know *)
      (* Firing the request *)
      try
        EmbeddedScheduler.add_request
          (caps :> < Cap.network >)
          (Www.make link) embed_ctx#base
          (* the continuation: it will receive the document *)
          (* In general, we don't know the type before we get the document *)
            (fun _url doc -> embedded_viewer frame embed_ctx doc)
          (Tk_progress.meter frame)
      with
      | Www.Invalid_request (w, msg) ->
          let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
          pack [ Message.create frame [ Text t ] ] []
      | Hyper.Invalid_link _err ->
          let t = s_ "Embed Error: invalid link" in
          pack [ Message.create frame [ Text t ] ] [])
@

<<function [[Embed.update]]>>=
let update (caps : < Cap.network ; .. >) (frame : Widget.widget)
    (embed_ctx : Viewers.context) (doc : Document.t) notchanged =
  try
    (* find the date of previous download, (or last-modified ?) *)
    let date_received = Http_headers.get_header "date" doc.document_headers in
    let rewrite_wr (wr : Www.request) =
      wr.www_headers <-
        ("If-Modified-Since: " ^ date_received) :: wr.www_headers;
      wr.www_headers <- "Pragma: no-cache" :: wr.www_headers;
      wr
    in
    let link = Hyper.default_link (Url.string_of doc.document_address) in
    (* wrapped viewer : decide if we need to redisplay or not *)
    let smart_viewer stdviewer frame embed_ctx (newdoc : Document.t) =
      let newdate =
        try Http_headers.get_header "date" newdoc.document_headers with
        | Not_found -> "foo"
      in
      if newdate <> date_received then begin
        List.iter Tk.destroy (Winfo.children frame);
        stdviewer frame embed_ctx newdoc
      end
      else notchanged ()
    in
    (* Check if the type is defined and a viewer available *)
    try
      let given_type = List.assoc "type" embed_ctx#params in
      let (typ, subtyp), parms = Lexheaders.media_type given_type in
      try
        let viewer =
          try Hashtbl.find embedded_viewers (typ, subtyp) with
          | Not_found -> Hashtbl.find embedded_viewers (typ, "*")
        in
        EmbeddedScheduler.add_request
          (caps :> < Cap.network >)
          (rewrite_wr (Www.make link))
          embed_ctx#base
          (* the continuation: it will receive the document *)
            (fun _url doc ->
            let doc =
              Document.
                {
                  document_address = doc.document_address;
                  document_data = doc.document_data;
                  document_headers =
                    Http_headers.merge_headers doc.document_headers
                      [ "Content-Type: " ^ given_type ];
                }
            in
            smart_viewer (viewer parms) frame embed_ctx doc)
          (Tk_progress.meter frame)
      with
      | Not_found ->
          (* no viewer for this *)
          let t = s_ "Embed Error: no viewer for type %s" given_type in
          pack [ Label.create frame [ Text t ] ] []
      | Www.Invalid_request (w, msg) ->
          let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
          pack [ Message.create frame [ Text t ] ] []
      | Hyper.Invalid_link _err ->
          let t = s_ "Embed Error: invalid link" in
          pack [ Message.create frame [ Text t ] ] []
    with
    | Not_found -> (
        (* not type given, we have to retrieve to know *)
        (* Firing the request *)
        try
          EmbeddedScheduler.add_request
            (caps :> < Cap.network >)
            (rewrite_wr (Www.make link))
            embed_ctx#base
            (* the continuation: it will receive the document *)
            (* In general, we don't know the type before we get the document *)
              (fun _url doc -> smart_viewer embedded_viewer frame embed_ctx doc)
            (Tk_progress.meter frame)
        with
        | Www.Invalid_request (w, msg) ->
            let t = s_ "Embed Error: %s\n(%s)" (Url.string_of w.www_url) msg in
            pack [ Message.create frame [ Text t ] ] []
        | Hyper.Invalid_link _err ->
            let t = s_ "Embed Error: invalid link" in
            pack [ Message.create frame [ Text t ] ] [])
  with
  | Not_found ->
      (* Document has no Date: header *)
      notchanged ()
@


%******************************************************************************
\chapter{Images}
%******************************************************************************
%alt: include in previous chapter? section of embed?
% seems pretty important and special to deserve its own chapter?

<<[[Html_disp.machine]] image methods>>=
method virtual imgmanager : imgloader
@


<<Document menu elements>>=
[Label (s_ "Load Images")    ; Command load_images];
@
% but should be default


<<function [[Mmm.navigator.load_images]]>>=
let load_images () =
  match !current_di with
  | None -> ()
  | Some di -> di#di_load_images
in
@

<<[[Viewers.display_info]] images virtual methods signatures>>=
method virtual di_load_images : unit (* load images *)
@

<<[[Plain.plain]] empty methods>>=
method di_load_images = ()
@
% no image in plain text


<<[[Htmlw.display_html]] load images methods>>=
method di_load_images = 
  (* load our images *)
  imgmanager#load_images;

  (* Recursively, for all embedded objects, send the load_images event.
   * Because we work on the children of the frame, the *currently* 
   *  displayed document in this frame gets the event.
   * NOTE: because of textvariable handlings, we can NOT send the
   *  event again during the processing of the event... 
   *)
  Frx_after.idle (fun () ->
    mach#embedded |> List.iter (fun Embed.{ embed_frame = f; _} ->
      Winfo.children f |> List.iter (Frx_synth.send "load_images")
    )
  )
@

\section{The image loader}

<<signature class [[Html_disp.imgloader]]>>=
class  virtual imgloader : (unit) -> object
  <<[[Html_disp.imgloader]] virtual fields signatures>>
end
@

<<[[Html_disp.imgloader]] virtual fields signatures>>=
method virtual add_image : < Cap.network > -> Embed.obj -> unit
method virtual flush_images : unit	         (* flush when document is loaded *)
method virtual load_images : unit		 (* manual flush *)
method virtual update_images : < Cap.network > -> unit
@


<<class [[Html_disp.imgloader]]>>=
class  virtual imgloader (_unit : unit) =
 object
  <<[[Html_disp.imgloader]] virtual fields signatures>>
end
@


% display_html -> <>
<<signature [[Imgload.create]]>>=
(* depending on !mode and !no_images will return a different kind of loader *)
val create : unit -> loader
@
<<class [[Imgload.loader]] signature>>=
class loader : (unit) -> object
  method add_image : <Cap.network > ->
     Embed.obj -> unit       (* add one image *)

  method flush_images : unit	         (* flush when document is loaded *)
  method load_images : unit		(* manual flush *)

  method update_images : < Cap.network> -> unit
end
@


%******************************************************************************
\chapter{Forms}
%******************************************************************************
%alt: section in Html display before, but too important
% quite important concept


%******************************************************************************
\chapter{CSS}
%******************************************************************************

% visual guide to most popular properties:
%http://cssreference.io/

%https://eager.io/blog/the-languages-which-almost-were-css/

%http://www.w3.org/TR/CSS2/
% (better spec than CSS 3 according to rubeck, more self contained)

%http://www.w3.org/TR/selectors/#specificity

% rules
% selectors

\section{Lexing}

\section{Parsing}


%******************************************************************************
\chapter{Javascript}
%******************************************************************************

\section{Lexing}

\section{Parsing}



%******************************************************************************
\chapter{Applets}
%******************************************************************************
% and modules

<<[[Http_headers.suffixes]] elements>>=
"cmo", ContentType "Content-Type: application/x-caml-applet; encoding=bytecode";
@

\section{Initialisation}

<<[[Main.main()]] applet system initialisation>>=
(* The applet system.
 * This loads the local modules also, so any setup that might be
 * overriden by a local module should happen before here.
 * However, preference initialisation must happen *after* initialisation
 * of the applet system
 *)
!Version.applet_init !modules;
@

<<[[Main.main()]] locals>>=
let modules = ref true in
@
<<[[Main.main()]] command line options>>=
"-nomodule", Arg.Unit (fun () -> modules := false),
" Don't load initial modules";
@



<<signature [[Version.applet_init]]>>=
(*-*)
val applet_init : (bool -> unit) ref
@
<<constant [[Version.applet_init]]>>=
(* Make it easier to compile both bytecode and native versions *)
let applet_init = ref (fun _ -> ())
@


\section{Module menu}
% see later

% (*      Menu.add_command othersm
%     [Label (s_ "Caml Modules"); 
%      Command (fun _ -> Applets.edit())];
%    Menu.add_command othersm
%     [Label (s_ "Load Caml Extension");
%   Command (fun _ ->
%              Fileselect.f (s_ "Load Caml Extension")
%          (function [] -> ()
%                  | [s] -> Applets.load_local s
%              | l -> raise (Failure "multiple selection"))
%          "*.cmo"
%          ""
%          false
%          false)
%      ];
% *)

\section{Applet user menu}

<<[[Mmm.navigator()]] User menu>>=
(* User menu, extensible by applets *)
let userb = Menubutton.create_named mbar "user" [Text (s_ "User")] in

let userm = ref (Menu.create_named userb "menu" []) in
let reset_user_menu _ =
  Tk.destroy !userm;
  userm := Menu.create_named userb "menu" [];
  !user_menus |> List.iter (fun (entry, f) ->
      Menu.add_command !userm 
           [Label entry; 
            Command (fun () -> f (Nav.make_ctx caps nav hist.h_current.h_did))]
  );
  Menubutton.configure userb [Menu !userm] 
in
reset_user_menu();
Frx_synth.bind userb "user_menu" reset_user_menu;
@




<<signature [[Mmm.add_user_menu]]>>=
(* Used for applets *)
val add_user_menu : string -> (Viewers.context -> unit) -> unit
@

<<constant [[Mmm.user_menus]]>>=
(* User defined menus *)
let user_menus = ref []
@
<<function [[Mmm.add_user_menu]]>>=
let add_user_menu entry f = 
  user_menus := (entry,(fun x -> try f x with _ ->())) :: !user_menus;
  Frx_synth.broadcast "user_menu"
@

\section{Machine hooks}

<<signature [[Html_disp.add_hook]]>>=
val add_hook: (machine -> unit) -> unit
@
<<function [[Html_disp.add_hook]]>>=
let add_hook f = 
  user_hooks := f :: !user_hooks
@
% dead?

<<constant [[Html_disp.user_hooks]]>>=
(* Hooks for applets/modules. Control is made elsewhere *)
let user_hooks = ref []
@

<<[[Html_disp.Make.create()]] run user hooks>>=
!user_hooks |> List.iter (fun f -> f (mach :> machine));
@

%\section{Modules}?
% separate from Applets?


%******************************************************************************
\chapter{Concurrency}
%******************************************************************************
% important in browser context, servo was actually started just for that.
% could also have an isolation chapter?

\section{Tasks}

<<signature [[Low.add_task]]>>=
val add_task : (unit -> unit) -> unit
  (* regular tasks *)
@

<<constant [[Low.tasks]]>>=
(* There is only a default task *)
let tasks = ref [
  (fun () -> !cur_tachy#report_traffic tick_duration !bytes_read !sample_read)
  ]
@

% main -> init -> <>
<<function [[Low.refresh]]>>=
let rec refresh() =
  incr global_time;
  List.iter (fun f -> f ()) !tasks;
  sample_read := 0;
  Timer_.add tick_duration refresh
@

<<signature [[Low.global_time]]>>=
val global_time : int ref
@
<<constant [[Low.global_time]]>>=
let global_time = ref 0
@


<<signature [[Low.init]]>>=
val init : unit -> unit
@
% main -> <>
<<function [[Low.init]]>>=
let init () = refresh ()
@

\section{Tachymeter}

\subsection{backend}

<<global [[Low.bytes_read]]>>=
let bytes_read = ref 0
@

<<global [[Low.sample_read]]>>=
let sample_read = ref 0
@


<<signature [[Low.cur_tachy]]>>=
val cur_tachy : tachymeter ref
@

\subsection{frontend}

<<[[Mmm.navigator()]] set tachymeter>>=
(* put this as a function so we can restart it if needed *)
let rec restart_tachy () =
   (* We must not pass hgroup to tachymeter applets *)
   let fcontainer = Frame.create hgroup [] in
   container_frame := Some fcontainer;
   (* restart it if destroyed *)
   bind fcontainer [[], Destroy] (BindSet ([Ev_Widget], (fun ei -> 
      if ei.ev_Widget = fcontainer 
         && Winfo.exists hgroup (* but we're not dead *) 
      then restart_tachy()))
   );
  let rw = Winfo.reqwidth fcontainer in
  let rh = Winfo.reqheight fcontainer in
  Wm.minsize_set top rw rh;
  pack [fcontainer][Side Side_Right; Anchor N];

  start_tachy();

  (* Bad hack to do bindings for our own internal tachymeter:
   * others, in applets, can just access these functions from the safe
   * library 
   *)
  if !tachy_maker == About.create_tachy then begin 
    match Winfo.children fcontainer with
    | [c] ->
         bind c (Glevents.get "tachy_new") (BindSet ([], (fun _ -> 
           new_window_initial ())));
         bind c (Glevents.get "tachy_sel") (BindSet ([], (fun _ -> 
           new_window_sel ())));
    | _ -> ()
  end
in

restart_tachy(); (* first initialisation *)

(* good size for keeping only the tachy *)
Wm.minsize_set top 80 80;
@


<<signature [[Mmm.change_tachy]]>>=
val change_tachy : (Widget.widget -> Low.tachymeter) -> unit
@
<<function [[Mmm.change_tachy]]>>=
let change_tachy (t : Widget.widget -> Low.tachymeter) = 
  !Low.cur_tachy#quit;
  tachy_maker := t;
  (match !container_frame with
   | Some f -> 
      List.iter Tk.destroy (Winfo.children f);
      Low.cur_tachy := t f
   | None -> ()
  )
@

<<constant [[Mmm.tachy_maker]]>>=
let tachy_maker = ref About.create_tachy
@


<<function [[Mmm.start_tachy]]>>=
let start_tachy () = 
  !container_frame |> Option.iter (fun f -> Low.cur_tachy := !tachy_maker f)
@

<<constant [[Mmm.container_frame]]>>=
(* Tachymeter support
 * [container_frame] is the parent frame for displaying a tachymeter
 * It's initialized only after the first navigator window is created.
 * [tachy_maker] contains the current tachymeter creation function.
 * [change_tachy] changes the current tachymeter. It has immediate
 * effect if the first navigator window is already available. Otherwise,
 * it will take effect at creation time, using [start_tachy].
 *)
let container_frame = ref None
@

%******************************************************************************
\chapter{Extra features}
%******************************************************************************

\section{Fragment navigation}

% saw already
% - uri_abs.uri_fragment, 
% - request.www_fragment

<<[[Document.handle]] other fields>>=
document_fragment : string option;
  (* fragment (#foo) if any *)
@
% copied from request.www_fragment in process_response

%saw:
%      nav.nav_show_current di dh.document_fragment
% and in show_current:
<<[[Mmm.navigator.show_current()]] goto fragment>>=
(* bogus if two views with fragment on the same pending document *)
di#di_fragment frag;
@

<<[[Viewers.display_info]] fragment virtual method signature>>=
method virtual di_fragment : string option -> unit	(* for # URIs *)
@
% di_fragment is used by the caller to go to a fragment, in show_current_di()

% easy case:
<<[[Plain.plain]] empty methods>>=
method di_fragment _frag = ()
@

<<[[Htmlw.display_html]] fragment methods>>=
method di_fragment = 
  mach#see_frag
@
<<[[Htmlw.display_html]] in feed, [[End_of_file]] exn handler, goto fragment>>=
mach#see_frag dh.document_fragment;
@




<<[[Html_disp.machine]] fragment method>>=
method virtual see_frag : string option -> unit
@
<<[[Html_disp.display_machine]] fragment methods>>=
(* This is an intrusion of graphics, but I don't see any other way 
 * The last formatter always tries see_frag...
 *)
method see_frag = see_frag
@
% return the field (confusing ...)
<<[[Html_disp.display_machine]] private fields>>=
val mutable see_frag = (fun _ -> ())
@
% can be changed?

<<[[Htmlfmt.formatter]] fragment method>>=
see_frag : string option -> unit;
@

<<function [[Textfw_fo.create.see_frag]]>>=
(* we try to remember the last "reading" position, so you can easily
 * switch back from a goto to some particular place in the document
 *)
see_frag = begin
  let prev_frag = ref false in
  let view_mem = ref 0.0 in
  match spec with
  | TopFormatter true -> (* this is pscrolling mode *)
    (function
     | None -> (* no place in particular *)
         if !prev_frag then begin
           try Canvas.yview (Winfo.parent thtml) (MoveTo !view_mem)
           with Protocol.TkError _ -> ()
         end;
         prev_frag := false
     | Some s ->
         if not !prev_frag then begin
           try view_mem := fst (Canvas.yview_get (Winfo.parent thtml))
           with Protocol.TkError _ -> ()
        end;
        prev_frag := true;
        if s <> "" then
          try
            let _,y,_,_,_  = Text.dlineinfo thtml
                 (TextIndex (Mark ("#"^s), [LineOffset (-2)]))
            and _,ye,_,_,_ = Text.dlineinfo thtml 
                 (TextIndex (End, [CharOffset (-1)])) in
           Canvas.yview (Winfo.parent thtml) 
                (MoveTo (float y /. float ye))
          with Protocol.TkError _ -> ()
   )
  |	_ ->
    (function
    | None -> (* no place in particular *)
        if !prev_frag then begin
          (* we were at view_mem *)
          try Text.yview thtml (MoveTo !view_mem)
          with Protocol.TkError _ -> ()
        end;
        prev_frag := false
    | Some s -> (* go to s *)
        if not !prev_frag then begin
          (* we were not in some special place, remember it *)
          try view_mem := fst (Text.yview_get thtml)
          with Protocol.TkError _ -> ()
        end;
        prev_frag := true;
        if s <> "" then
          try Text.yview_index thtml 
             (TextIndex (Mark ("#"^s), [LineOffset (-1)]))
          with Protocol.TkError _ -> ()
    )
end
@

\section{History navigation}

% see in Interface chapter code that call History API
% and historygoto!


<<type [[History.t]]>>=
type t = {
  mutable h_start : entry;
  mutable h_current: entry;

  h_key : int;
  mutable h_first : bool
  }
@
% h_key is a counter to differentiate different history
% created in different windows (used by Gcache)

<<type [[History.history_entry]]>>=
(* 
   Linear history: we keep going adding to the end of the list,
   EXCEPT when you go back and then on a new link.
*)
type entry = {
  h_did : Document.id;
  h_fragment : string option;

  h_prev : entry option;
  mutable h_next : entry option
  }
@
% why not use list? 

<<constant [[History.create]]>>=
let create =
  let keycnter = ref 0 in
  (fun did ->
    incr keycnter;
    let e = { h_did = did;
              h_fragment = None;
              h_prev = None;
              h_next = None } in
    { h_key = !keycnter;
      h_start = e;
      h_current = e;
      h_first = true
    })
@
% h_first is for?

% goback -> <>
<<function [[History.back]]>>=
let back h =
  match h.h_current.h_prev with
  | None -> None
  | Some e -> h.h_current <- e; Some (e.h_did, e.h_fragment)
@
% adjust h_current

% goforward -> <>
<<function [[History.forward]]>>=
let forward h =
  match h.h_current.h_next with
  | None -> None
  | Some e -> h.h_current <-e ; Some (e.h_did, e.h_fragment)
@
% adjust h_current


% goback | goforward | reload -> <> (false when from reload, don't use cache)
<<signature [[Nav.historygoto]]>>=
val historygoto : < Cap.network; ..> ->
  t -> Document.id -> string option -> bool -> bool
@
% bool parameter is to usecache or not.
% bool returned is everything when fine.
% todo: typeify! use Ok | Error

<<function [[Nav.historygoto]]>>=
(* Used by navigators for back/forward/reload *)
let historygoto (caps : < Cap.network; ..>)
     (nav : t) (did : Document.id) frag (usecache : bool) : bool =
  Logs.debug (fun m -> m "historygoto");
  if did.document_stamp = Document.no_stamp then begin
    (* we can safely consider this as normal navigation *)
    let uri : string = 
      match frag with
      | None -> Url.string_of did.document_url
      | Some f -> sprintf "%s#%s" (Url.string_of did.document_url) f 
    in
    (* modify wr *)
    let follow_link (lk : Hyper.link) =
      lk |> request caps nav  
        (process_viewer false (make_ctx caps)) (* don't add to history *)
        (usecache,
         (fun wr ->
            if not usecache 
            then wr.www_headers <- "Pragma: no-cache" :: wr.www_headers;
            wr),
         specific_viewer false)
    in
    follow_link (Hyper.default_link uri);
    true
  end else begin
    (* the url is a "non-unique" document, that is, its url is not
     * enough to retrieve the document. We should not attempt to
     * reload or retrieve if flushed from the cache
     *)
    try
      let di = Gcache.find nav.nav_id did in
      nav.nav_show_current di frag;
      true
    with Not_found ->
      nav.nav_error#f (s_ "Document was flushed from cache, and should be reloaded from its url\n(probably a POST request)");
      false
   end
@

\section{Lifecycle control}

\subsection{Abort}
% advanced topic?
% important! you want the user to control things

<<[[Mmm.navigator()]] navigation buttons>>=
let abortb = Button.create_named buttons 
  "abort" [Text (s_ "Abort"); Command abort] in
@

<<type [[Www.aborter]]>>=
type aborter = unit -> unit
@
% I introduced that, makes the code clearer I think


<<function [[Mmm.navigator.abort]]>>=
let abort () =
  actives |> Hashtbl.iter (fun _url aborter -> 
    aborter()
  );
  Hashtbl.clear actives;
  !current_di |> Option.iter (fun di -> di#di_abort)
in
@


<<local [[Mmm.navigator.actives]]>>=
let actives : (Url.t, Www.aborter) Hashtbl.t = Hashtbl_.create () in
@
%less: type? url * aborter! introduce type!


% Nav.request -> <>
<<[[Nav.t]] manage active connections methods>>=
nav_add_active : Url.t -> Www.aborter -> unit;
nav_rem_active : Url.t -> unit;
@
<<[[Mmm.navigator()]] set nav fields>>=
nav_add_active = (fun url aborter -> Hashtbl.add actives url aborter);
nav_rem_active = (fun url -> Hashtbl.remove actives url);
@


<<[[Viewers.display_info]] lifecycle virtual methods signatures>>=
method virtual di_abort : unit		 (* stop display *)
@

<<[[Plain.plain]] private fields>>=
val mutable (*private*) terminated = false
@
<<[[Plain.plain]] abort methods>>=
method di_abort = 
  self#finish true

(* [finish abort?] *)
method finish abort =
  if not terminated then begin
    terminated <- true;
    self#ctx#log (if abort then "Aborted" else "");
    Document.dclose true dh;
  end
@
%less: could say "Finish" at least in the log?


% very similar for html one, with img and embed scheduler interruption
% in addition
<<[[Htmlw.display_html]] private fields>>=
val mutable (*private*) terminated = false
@
<<[[Htmlw.display_html]] abort methods>>=
method di_abort = 
  self#finish true

(* [finish abort?] *)
method finish abort =
  if not terminated then begin
    terminated <- true;
    ctx#log (if abort then "Aborted" else "");
    Document.dclose true dh
  end;
  (* This has to happen even if we already finished displaying the document *)
  if abort then begin
    Img.ImageScheduler.stop dh.document_id;
    Embed.EmbeddedScheduler.stop dh.document_id
    (* TODO we should also require embedded objects to abort *)
  end
@

\subsection{Refresh}

<<[[Mmm.navigator()]] navigation buttons>>=
let reloadb = Button.create_named buttons
  "reload" [Text (s_ "Reload"); Command reload] in
@

<<function [[Mmm.navigator.reload]]>>=
let reload () =
  let did = hist.h_current.h_did in
  let frag = hist.h_current.h_fragment in
  if did.document_stamp = Document.no_stamp then begin
    (* kill both in cache and in gcache *)
    Cache.kill did; 
    Gcache.remove hist.h_key did;
    Nav.historygoto caps nav did frag false |> ignore
  end
  else error#f 
      (s_ "Document cannot be reloaded from its url\n(probably a POST request)")
in
@
% which error is that?

% ??? -> <>
% see also update_true alias
<<function [[Mmm.navigator.update]]>>=
let update (nocache : bool) =
  let did = hist.h_current.h_did in
  if did.document_stamp = Document.no_stamp then
    Nav.update caps nav did nocache
  else (* POST result *)
    error#f (s_ "Can't update document\n(probably a POST request)")
in
@

\subsection{Redisplay}
% diff?

<<Document menu elements>>=
[Label (s_ "Redisplay")      ; Command redisplay];
@

<<[[Viewers.display_info]] lifecycle virtual methods signatures>>=
method virtual di_redisplay : unit		(* redisplay *)
@


<<function [[Mmm.navigator.redisplay]]>>=
let redisplay () =
  !current_di |> Option.iter (fun di -> di#di_redisplay)
in
@

<<[[Plain.plain]] redisplay methods>>=
method di_redisplay = 
  self#redisplay

(* to redisplay, we have to destroy all widgets, then restart, except
   that we don't use the feed, but rather the cache *)
method redisplay =
  failwith "redisplay:TODO"
  (*
  try
    dh <- Decoders.insert (Cache.renew_handle dh);
    Winfo.children frame |> List.iter destroy;
    self#init
  with Not_found ->
    Error.f (s_ "Document not in cache anymore")
  *)
@

<<[[Htmlw.display_html]] redisplay methods>>=
method di_redisplay = 
  self#redisplay

(* to redisplay, we have to destroy all widgets, then restart, except
   that we don't use the initial feed, but rather the cache *)
method redisplay =
  if pending 
  then Error.f (s_ "Cannot redisplay document (pending)")
  else
    try
      dh <- Decoders.insert (Cache.renew_handle dh);
      Winfo.children frame |> List.iter destroy;
      self#init init_mode
    with Not_found ->
      Error.f (s_ "Document not in cache anymore")
@

%\subsection{Destroy}?

\section{Progress feedback}

<<[[Plain.plain]] progress methods>>=
(* progress report *)
val mutable set_progress = Progress.no_meter
method set_progress = set_progress
@
% need a mutable set_progress?

<<[[Htmlw.display_html]] private fields>>=
val mutable set_progress = Progress.no_meter
@
<<[[Htmlw.display_html]] progress method>>=
(* progress report *)
method set_progress = set_progress
@

<<function [[Htmlw.progress_report]]>>=
(* Builds the progress report and pointsto zone.
 * Adds ctx nav function for pointsto
 *)
let progress_report top ctx =
  let f = Frame.create_named top "progress" [] in
  let pointstov = Textvariable.create_temporary f in
  let pointsto = Textvariable.set pointstov in
  let lpoint = 
    Label.create_named f "pointsto" [TextVariable pointstov; Anchor W] in
  let fprog = 
    Frame.create_named f "fr" [Width (Pixels 200); Height(Pixels 5)]in

  (* progress meter requires an alt widget, but we don't have to pack it *)
  let _fakealt = Label.create_named fprog "alt" [] in
  pack [fprog][Side Side_Left];
  pack [lpoint][Side Side_Left; Fill Fill_X];
  (* hack to avoid lpoint forcing the navigator to grow like hell *)
  Frame.configure f
    [ Width (Pixels (Winfo.reqwidth (Winfo.toplevel f)));
      Height (Pixels (Winfo.reqheight lpoint))];
  Pack.propagate_set f false;

  ctx#add_nav ("pointsto" ,
                Viewers.{ hyper_visible = false;
                  hyper_title = "Show target";
                  hyper_func = (fun _ h -> 
                    let target = 
                      try Hyper.string_of h
                      with Hyper.Invalid_link _msg -> "invalid link" 
                    in
                    pointsto target
                  )});
  ctx#add_nav ("clearpointsto" ,
                { hyper_visible = false;
                  hyper_title = "Clear target";
                  hyper_func = (fun _ _h -> pointsto "")
                });
  f, Tk_progress.meter fprog
@
%todo: those hyper_xxx??

\section{Bookmarks}

\section{Hotlist}
% same as bookmarks?
% does not look like

<<Document menu elements>>=
[Label (s_ "Add to hotlist") ; Command add_to_hotlist];
@

<<constant [[Mmm.hotlist]]>>=
(* Preference settings *)
let _hotlist = ref ""
@
% dead?

<<function [[Mmm.navigator.add_to_hotlist]]>>=
let add_to_hotlist () =
  match !current_di with
  | None -> ()
  | Some di -> 
      Hotlist.f (Url.string_of hist.h_current.h_did.document_url) di#di_title
in
@

<<constant [[Hotlist.program]]>>=
(* A cool module *)
let program = ref ""
@

<<function [[Hotlist.f]]>>=
let f url title =
  match !program with 
  | "" -> Error.f (s_ "No hotlist command defined")
  | s -> 
      let _ = Munix.system_eval s ["URL", url; "TITLE", title] true in
      Error.ok (s_ "%s\nadded to hotlist with title\n%s" url title)
@
%less: rename, Hotlist.f is bad

\section{Multiple windows}

% mv later?
<<signature [[Mmm.main_navigator]]>>=
val main_navigator : Nav.t option ref
@
<<constant [[Mmm.main_navigator]]>>=
let main_navigator = ref None
@
% have this mostly to support multi windows,



<<constant [[Mmm.navigators]]>>=
(*
 * A navigator window
 *)
let navigators = ref 0
@

<<[[Mmm.navigator()]] new navigator hook>>=
incr navigators;
@

<<[[Mmm.navigator()]] destroy navigator hook>>=
decr navigators;
@

<<[[Mmm.navigator()]] exn handler, when multiple navigators>>=
else begin 
  Tk.destroy top;
  None
end
@


<<[[Nav.t]] other fields>>=
nav_new : Hyper.link -> unit;
@
<<[[Mmm.navigator()]] set nav fields>>=
nav_new = (fun link ->
   try
     let wwwr = Plink.make link in
     navigator caps false wwwr.www_url |> ignore
   with Hyper.Invalid_link _msg -> 
     error#f (s_ "Invalid link")
);
@

<<signature [[Mmm.new_window_initial]]>>=
(* ?? *)
val new_window_initial : < Cap.network; ..> -> unit
@
<<signature [[Mmm.new_window_sel]]>>=
(* ?? *)
val new_window_sel : < Cap.network; ..> -> unit
@

<<function [[Mmm.new_window_initial]]>>=
and new_window_initial (caps: < Cap.network; ..>) =
 navigator caps false 
   (match !initial_page with | Some u -> u | None -> assert false) |> ignore
@

<<function [[Mmm.new_window_set]]>>=
and new_window_sel (caps: < Cap.network; ..>) =
  try 
    let url = Selection.get [] in
    navigator caps false (Lexurl.make url) |> ignore
  with _ -> new_window_initial caps
@


<<[[Mmm.navigator()]] nested functions>>=
let new_window () =
     navigator caps false hist.h_current.h_did.document_url |> ignore
in
let new_window_initial () =
     navigator caps false initial_url |> ignore
in
let new_window_sel () =
  try 
     let url = Selection.get [] in
     navigator caps false (Lexurl.make url) |> ignore
  with _ -> navigator caps false initial_url |> ignore
in
@

\section{User preferences}

% important, like in efuns

\subsection{Preference file, [[mmm -prefs]]}
<<constant [[Mmm.preferences]]>>=
(* placeholder for preference panel *)
let preferences = ref (fun () -> ())
@

<<[[Mmm.initial_navigator()]] set preferences>>=
preferences := Mmmprefs.f preffile;
!preferences();
@


<<[[Main.main()]] locals>>=
let preffile = ref (Mmm.user_file "MMM.ad") in
@
<<[[Main.main()]] command line options>>=
"-prefs", Arg.String (fun s -> preffile := (Fpath.v s)),
" <file> Preference File";
@
% .ad?
% preferences of navigator
% diff with code using MMM.ad below?



<<signature [[Mmm.user_file]]>>=
val user_file : string -> Fpath.t
    (* [user_file base] returns $HOME/.mmm/[base] *)
@
%$
<<function [[Mmm.user_file]]>>=
let user_file (name : string) : Fpath.t =
  home / ".mmm" / name
@

%less: rename homedir!
<<constant [[Mmm.home]]>>=
let home : Fpath.t =
  try
    Fpath.v (Sys.getenv "HOME")
  with Not_found -> 
    Logs.err (fun m -> m "Please set the HOME environment variable.");
    raise (Exit.ExitCode (-1))
@


% user (localized) file
<<[[Main.main()]] user preferences file>>=
localize !preffile
@

\subsection{Initial geometry, [[mmm -geometry]]}

<<signature [[Mmm.initial_geom]]>>=
val initial_geom : string option ref
@
<<constant [[Mmm.initial_geom]]>>=
let initial_geom = ref None
@
<<[[Main.main()]] command line options>>=
"-geometry", Arg.String (fun s -> Mmm.initial_geom := Some s),
" <wxh+x+y> Initial geometry for the first navigator";
@

<<[[Mmm.navigator()]] set geometry if specified>>=
(match !initial_geom with 
 | None -> ()
 | Some g -> Wm.geometry_set top g
 );
@

\section{TK customization}

\subsection{Color palette, [[mmm -palette]]}

<<[[Main.main()]] resource initialisation>>=
begin match !palette with
| None -> ()
| Some bg -> try Palette.set_background (Tk.NamedColor bg) with _ -> ()
end;
@
% ??

<<[[Main.main()]] locals>>=
let palette = ref None in
@
<<[[Main.main()]] command line options>>=
"-palette", Arg.String (fun s -> palette := Some s),
" <color> Tk Palette";
@

\subsection{Click to follow, [[mmm -clicktofocus]]}

<<[[Main.main()]] tk initialisation>>=
if not !clicktofocus 
then Focus.follows_mouse();
@

<<[[Main.main()]] locals>>=
let clicktofocus = ref false in
@
<<[[Main.main()]] command line options>>=
"-clicktofocus", Arg.Unit (fun () -> clicktofocus := true),
" Click to Focus mode (default is Focus Follows Mouse)";
@


\section{Help URL, [[mmm -helpurl]]}

<<signature [[Mmm.helpurl]]>>=
(* Preferences, options *)
val helpurl : Url.t ref
@
<<constant [[Mmm.helpurl]]>>=
let helpurl = ref (Lexurl.make (Version.helpurl (Lang.lang ())))
@
<<[[Main.main()]] command line options>>=
"-helpurl", Arg.String (fun s -> Mmm.helpurl := Lexurl.make s),
" <url> Help URL";
@

<<signature [[Version.helpurl]]>>=
val helpurl : string -> string (* help url *)
@
<<function [[Version.helpurl]]>>=
let helpurl = function
  | "iso8859" -> 
      Printf.sprintf "http://pauillac.inria.fr/mmm/v%d/docindex.html" number
  | _ -> assert false
@



<<Help menu elements>>=
Menu.add_command helpm
  [Label (s_ "Help on MMM"); 
   Command (fun () -> navigator caps false !helpurl |> ignore)];
@
% false means not toplevel, no_tachy

\section{Extra Protocols}
%alt: put different chapter

\subsection{[[file://]]}

<<toplevel [[Protos._7]]>>=
let _ = Hashtbl.add protos Url.FILE ((fun _caps -> File.request), Cache.dummy)
@

<<[[Lexurl.f]] protocol cases>>=
(* the spec says file://host/ dammit *)
| "FILE" ->
    (try
       slashslash lexbuf;
       let h = fhost lexbuf in
       let p = slashpath lexbuf in
       result.protocol <- FILE;
       result.host <- h;
       result.path <- p
     with Url_Lexing _ ->
       let p = slashpath lexbuf in
       result.protocol <- FILE;
       result.path <- p
    )
@

<<functions [[Lexurl.xxx]]>>=
and fhost = parse
  ['A'-'Z' 'a'-'z' '0'-'9' '.' '-']+
     { Some (normalize_host (Lexing.lexeme lexbuf)) }
| ""
     { Some "localhost" }
@


<<signature [[File.request]]>>=
(* file: protocol *)
val request : Www.request -> Document.continuation -> Www.aborter
    (* [request wr cont] returns [abort] *)
@
% a retriever

<<exception [[File.File_error]]>>=
exception File_error of string
@

<<function [[File.document_id]]>>=
let document_id wwwr =
  { document_url = wwwr.www_url; document_stamp = no_stamp}
@
%less: rename mk_did ?

%less: LP split and distribute in two sections below
<<function [[File.request]]>>=
(*
 * Display a file on the local unix file system (file:)
 *  is path really supposed to be absolute ?
 * Note: completely ignores method (GET, POST,...)
 *)

let request wr cont =
  let path = 
    match wr.www_url.path with
    | Some path -> "/" ^ (Lexurl.remove_dots path)
    | None -> "/" 
  in
  <<[[File.request()]] if CGI path>>
  else   (* A bit weird, but we don't want to capture errors from the cont *)
    let st =
      try stat path 
      with _ -> raise (File_error (s_ "cannot stat file")) 
    in
    match st.st_kind with
    | S_REG ->
      begin
      (* check if this is an update *)
        try 
          let since = Http_headers.get_header "if-modified-since" wr.www_headers in
          let ht = Lexdate.ht_of_string since in
          let filet = Http_date.ht_of_stamp st.st_mtime in
          if Http_date.compare filet ht > 0
          then raise Not_found (* fall through *)
          else begin
            let dh = { 
              document_id = document_id wr;
              document_referer = wr.www_link.h_context;
              document_status = 304;
              dh_headers = [ sprintf "Date: %s" (Date.asc_now())];
              document_feed = (let fd = openfile "/dev/null" [O_RDONLY] 0 in
                Feed.make_feed fd (Low.count_read (Unix.read fd)));
              document_fragment = wr.www_fragment;
              document_logger = Document.tty_logger
            } in

            Retype.f dh; (* pad: to get the content type based on the suffix *)

            cont.document_process dh;
            (fun () -> ())
          end
       with
       | Not_found  (* default case *)
       | Lexdate.Invalid_date (_,_) ->
          let s = 
            try openfile path [O_RDONLY] 0
            with Unix_error(_,_,_) -> 
              raise (File_error (s_ "cannot open file")) 
          in
          let dh =
            { document_id = document_id wr;
              document_referer = wr.www_link.h_context;
              document_status = 200;
              dh_headers = 
                [sprintf "Content-Length: %d" st.st_size;
                 sprintf "Date: %s" (Date.asc_now());
                 sprintf "Last-modified: %s" (Date.asc st.st_mtime)
                ];
              document_feed = Feed.make_feed s (Low.count_read (Unix.read s));
              document_fragment = wr.www_fragment;
              document_logger = Document.tty_logger
            } in
           Retype.f dh;
           cont.document_process dh;
           (fun () -> ())
    end
    | S_DIR -> 
        let s = dir path in
        cont.document_process 
          { document_id = document_id wr;
            document_referer = wr.www_link.h_context;
            document_status = 200;
            dh_headers = ["Content-Type: text/html"];
            document_feed = Feed.make_feed s (Low.count_read (Unix.read s));
            document_fragment = wr.www_fragment;
            document_logger = Document.tty_logger
           };
         (fun () -> ())

    | _ -> raise (File_error (s_ "cannot open file"))
@


\subsubsection{Files}

\subsubsection{Directories}

% File.request (DIR case) ->  <>
<<function [[File.dir]]>>=
(* It's easiest to do it asynchronously anyway *)
let dir path =
  try
    let d = opendir path in
    let cin, cout = pipe() in
    match Low.fork() with
    (* child *)
    | 0 -> 
        close cin; dup2 cout stdout; close cout;
        begin
          try 
            d2html path d 
          with e ->
            print_endline (Printexc.to_string e)
        end;
        flush Stdlib.stdout; (* strange bug with our at_exit stuff *)
        (* nosemgrep: do-not-use-exit *)
        exit 0
        (*cin (*duh*) *)
     (* parent *)
     | _n -> closedir d; close cout; cin
  with Unix_error(_,_,_)  -> 
    raise (File_error (s_ "cannot open dir"))
@



% File.dir -> <>
<<function [[File.d2html]]>>=
let d2html path (d : Unix.dir_handle) =
  (* make sure that when path is used in url, it is / terminated *)
  let pathurl =
    let l = String.length path in
    if l = 0 
    then path 
    else
      if path.[l-1] = '/' 
      then path
      else sprintf "%s/" path
  in
  Printf.printf 
"<HTML>
<HEAD><TITLE>%s</TITLE>
<BASE HREF=\"file://localhost%s\">
</HEAD>
<BODY>
<H1>Directory list: %s</H1>
<PRE>" path pathurl path;

  let entries = ref [] in
  begin 
   try
     while true do 
       entries := (readdir d) :: !entries
     done      	
   with  End_of_file -> closedir d
  end;
  entries := List.sort Stdlib.compare !entries;
  !entries |> List.iter (function
    |  "." -> ()
    | ".." ->
       printf "Dir   <A HREF=\"file://localhost%s\">..</A>\n"
              (Filename.concat (dirname (dirname pathurl)) "")
    | f ->
       try
         let fullname = Filename.concat path f in
         let st = stat fullname in
         match st.st_kind with
         | S_DIR -> printf "Dir   <A HREF=\"%s\">%s</A>\n" f f
         | S_REG -> printf "File  <A HREF=\"%s\">%-30s</A>%8d bytes\n" 
                       f f (st.st_size)
         | S_LNK -> printf "Link  <A HREF=\"%s\">%s</A>\n" f f
         | _ -> ()
       with Unix_error(_,_,_) -> ()
    );
  printf "</PRE></BODY></HTML>"
@

% ??? -> <>
<<function [[File.isdir]]>>=
(* 
 * Simulate directory
 *)
let _isdir path f =
  let fullname = Filename.concat path f in
  (stat fullname).st_kind = S_DIR
@
% dead?







\subsection{[[mailto://]]}

<<[[Lexurl.f]] protocol cases>>=
| "MAILTO" ->
    let address = any lexbuf in
    result.protocol <- MAILTO;
    result.path <- address
@

% see extra

<<[[Nav.request.handle_wr()]] match protocol special cases>>=
| MAILTO -> Mailto.f wr
 (* mailto: is really a pain. It doesn't fit the retrieval semantics
  * of WWW requests. *)
@

% this seems to work! there is a new window appearing



<<type [[Mailto.msg]]>>=
type msg = {
  dest    : string;
  subject : string;
  body    : string 
}
@

<<function [[Mailto.f]]>>=
let f wr =
  match wr.www_url.path with
  | Some raw_address ->
      let address = Urlenc.decode raw_address in
      (match wr.www_link.h_method with
      | GET -> get address wr.www_link.h_context
      | POST d ->
          if wr.www_error#choose 
            (s_ "About to send mail with POST data to\n%s" address)
          then
            let subject = 
              match wr.www_link.h_context with
              | None -> "no subject"
              | Some s -> "POST data for "^s 
            in
            sendmail  { dest = address; subject = subject; body = d}
          else ()
     | _ ->
        wr.www_error#f (s_ "Unsupported method for mailto:")
     )
  | None -> wr.www_error#f (s_ "No address given for mailto:")
@

<<constant [[Mailto.mailer]]>>=
let mailer = ref ""
@

<<function [[Mailto.get]]>>=
let get mailaddr referer =
  let subject = 
    match referer with
    | None -> "no subject"
    | Some s -> "About url "^s  
  in
  match !mailer with
   | "" -> internal mailaddr subject
   | s -> 
       Munix.system_eval s ["_", "-s"; "SUBJECT", subject; "TO", mailaddr] true
        |> ignore
@

<<function [[Mailto.internal]]>>=
let internal address referer =
  !internal_backend address referer
@

% who sets that?
<<global [[Mailto.internal_backend]]>>=
let internal_backend = 
  ref (fun _ _ -> failwith "no Mailto.internal defined")
@


<<function [[Mailto.sendmail]]>>=
(* if the mail contains a dot line, we're f*cked *)
let sendmail msg =
  let cmd = try Sys.getenv "MMM_MAIL" with Not_found -> "mail" in
  try
    let (fd_in,fd_out) = pipe() in
    match Low.fork () with
    | 0 -> 
        close fd_out; 
        dup2 fd_in stdin;
        Munix.execvp cmd [| cmd; "-s"; msg.subject; msg.dest |]
    | n -> 
       close fd_in;
       Munix.write_string fd_out msg.body;
       close fd_out;
       (match waitpid [] n with
       | _, WEXITED 0 -> Error.ok (s_ "Mail sent")
       | _, _ -> error msg.body
       )
 with Unix_error(_,_,_) -> error msg.body
@

<<function [[Mailto.error]]>>=
let error body =
  try
    let oc = open_out_bin (Filename.concat (getenv "HOME") "dead.letter") in
    output_string oc body;
    close_out oc;
    Error.f (s_ "Can't send mail (saved in $HOME/dead.letter)")
  with _ -> 
    Error.f (s_ "Can't send mail, can't save dead.letter")
@
%$

\subsection{Proxied protocols}

% proxy are not just for security or speed!
% can translate from unhandled protocol to http for us! :)

<<toplevel [[Protos._1]]>>=
let _ = Hashtbl.add protos Url.FTP (Http.proxy_req, Cache.tobuffer)
@

<<toplevel [[Protos._3]]>>=
let _ = Hashtbl.add protos Url.GOPHER (Http.proxy_req, Cache.tobuffer)
@

<<toplevel [[Protos._4]]>>=
let _ = Hashtbl.add protos Url.NEWS (Http.proxy_req, Cache.tobuffer)
@

<<toplevel [[Protos._5]]>>=
let _ = Hashtbl.add protos Url.NNTP (Http.proxy_req, Cache.tobuffer)
@

<<toplevel [[Protos._6]]>>=
let _ = Hashtbl.add protos Url.WAIS (Http.proxy_req, Cache.tobuffer)
@


<<signature [[Http.proxy_req]]>>=
val proxy_req: < Cap.network; ..> ->
  Www.request -> Document.continuation -> Www.aborter
@

<<function [[Http.prox_req]]>>=
(* Retrieve.f -> <> (via protos) *)
let proxy_req caps wr cont = 
  let cnx = proxy_request caps wr cont in
  (fun () -> cnx#abort)
@
% see Advanced topics chapter on proxy and the proxy_request function

% the gdr-fr article cite an article about proxy saying they can be
% used for old protocols

\subsection{[[ftp://]]}

<<[[Lexurl.f]] protocol cases>>=
| "FTP" -> (* we don't need the detail of path *)
    slashslash lexbuf;
    let u, p = userpass lexbuf in
    let h, po = hostport lexbuf in
    let path = slashpath lexbuf in
    result.protocol <- FTP;
    result.user <- u;
    result.password <- p;
    result.host <- h;
    result.port <- normalize_port (FTP, po);
    result.path <- path
@


<<function [[Lexurl.userpass]]>>=
and userpass = parse
  (* foo:bar@, foo:@ *)
  [^ ':' '/' '@']+ ':' [^ ':' '/' '@']* '@'
    { let lexeme = Lexing.lexeme lexbuf in
      let pos = String.index lexeme ':' in
      Some (String.sub lexeme 0 pos),
      Some (String.sub lexeme (succ pos) (String.length lexeme - 2 - pos))
    }
  (* foo@, @ *)
| [^ ':' '/' '@']* '@'
   { let lexeme = Lexing.lexeme lexbuf in
     Some (String.sub lexeme 0 (String.length lexeme - 1)), None
   }
      
| ""
   { None, None }
@

<<functions [[Lexurl.xxx]]>>=
and slashpath = parse
  "/" { any lexbuf }
| ""  { None }
@

\subsection{[[telnet://]]}

<<[[Lexurl.f]] protocol cases>>=
| "TELNET" ->
    slashslash lexbuf;
    let u,p = userpass lexbuf in
    let h,po = hostport lexbuf in
    result.protocol <- TELNET;
    result.user <- u;
    result.password <- p;
    result.host <- h;
    result.port <- po
@

\subsection{[[nntp://]]}

<<[[Lexurl.f]] protocol cases>>=
| "NNTP" ->
    let h,po = hostport lexbuf in
    let blah = any lexbuf in
    result.protocol <- NEWS;
    result.host <- h;
    result.port <- po;
    result.path <- blah
@


\subsection{Old protocols}

<<[[Lexurl.f]] protocol cases>>=
| "GOPHER" | "GOPHER+" -> (* we don't need the detail of path *)
    slashslash lexbuf;
    let h,po = hostport lexbuf in
    let path = slashpath lexbuf in
    result.protocol <- GOPHER;
    result.host <- h;
    result.port <- po;
    result.path <- path
| "NEWS" ->
    let blah = any lexbuf in
    result.protocol <- NEWS;
    result.path <- blah
| "WAIS" ->
    slashslash lexbuf;
    let h,po = hostport lexbuf in
    let pa,se = pathsearch lexbuf in
    result.protocol <- WAIS;
    result.host <- h;
    result.port <- po;
    result.path <- pa;
    result.search <- se
| "PROSPERO" ->
    slashslash lexbuf;
    let h,po = hostport lexbuf in
    let p = slashpath lexbuf in
    result.protocol <- PROSPERO;
    result.host <- h;
    result.port <- po;
    result.path <- p
@



\section{Gzip decoders}

<<[[Http_headers.suffixes]] elements>>=
"gz",		ContentEncoding  "Content-Encoding: gzip";
"Z",		ContentEncoding  "Content-Encoding: compress";

"asc",	ContentEncoding  "Content-Encoding: pgp";
"pgp",	ContentEncoding  "Content-Encoding: pgp";
@

<<signature [[Decoders.insert]]>>=
val insert  : Document.handle -> Document.handle
@
<<signature [[Decoders.add]]>>=
val add : string -> (Document.handle -> Document.handle) -> unit
@

<<constant [[Decoders.decoders]]>>=
(* Insert a decoding if necessary.
 * We don't do it in http, since we don't want do decompress when we
 * save for example.
 *)
let decoders = Hashtbl.create 37
@


<<toplevel [[Decoders._1]]>>=
let _ =  
  [ "COMPRESS"   , gzip;
    "X-COMPRESS" , gzip;
    "GZIP"       , gzip;
    "X-GZIP"     , gzip
  ] |> List.iter (fun (s,t) -> Hashtbl.add decoders s t)
@


<<function [[Decoders.gzip]]>>=
(* Note: we must use the feed interface to read from the old dh,
 * and not read directly from the feed_internal file descriptor, because
 * the feed might implement side effects (such as caching).
 * Since we are reading and writing to the same process, we might get
 * deadlocked if we don't watch writes.
 *)
let gzip dh =
  let (gread, mwrite) = pipe()
  and (mread, gwrite) = pipe()
  in
  Unix.set_close_on_exec mread;
  Unix.set_close_on_exec mwrite;
  
  match Low.fork() with
    0 ->  
      dup2 gread stdin; dup2 gwrite stdout;
      Munix.execvp "gunzip" [| "gunzip"; "-c" |]
      (* dh (* fake *) *)
  | _n ->  
      close gread; close gwrite;
     (* it is safe to close feed because the son has a copy *)
      let newdh =
       { dh with 
         dh_headers = rem_contentencoding dh.dh_headers;
         document_feed = Feed.make_feed mread (Low.count_read (Unix.read mread));
       }
      in
      let buffer = Bytes.create 4096 in
      let rec copy () =
      try
        let n = dh.document_feed.feed_read buffer 0 4096 in
            if n = 0 then (dclose true dh; close mwrite)
            else begin
          dh.document_feed.feed_unschedule();
          Fileevent.add_fileoutput mwrite
        (fun () -> 
          ignore (write mwrite buffer 0 n);
          Fileevent.remove_fileoutput mwrite;
          dh.document_feed.feed_schedule copy)
        end
      with
        Unix_error(_e,_,_) -> dclose true dh; close mwrite
      in
      dh.document_feed.feed_schedule copy;
      newdh
@


<<constant [[Decoders.add]]>>=
let add = Hashtbl.add decoders
@

<<function [[Decoders.insert]]>>=
let insert dh =
(* CERN proxy sets Content-Encoding when return code = 500 ! *)
  if dh.document_status >= 400 then dh else
  try
    Hashtbl.find decoders (String.uppercase_ascii (contentencoding dh.dh_headers)) dh
  with
    Not_found -> dh
  | Unix_error(_,_,_) -> dh
@


\section{Animaged GIFs}

<<signature [[Img.gif_anim_load]]>>=
val gif_anim_load : bool ref
@

<<constant [[Img.gif_anim_load]]>>=
(* Images are a special case of embedded data, because Tk caches them
   internally. Thus, we attempt to maintain our own cache logic above
   Tk's one 
 *)

let gif_anim_load = ref false
@

<<signature [[Imgload.gif_anim_auto]]>>=
val gif_anim_auto : bool ref
@
<<constant [[Imgload.gif_anim_auto]]>>=
let gif_anim_auto = ref false
@


\section{Audio}
% <audio>

% there is an <audio> in html 5!

<<function [[Audio.fake_embed]]>>=
(* Defines embedded viewer for audio types as re-running the document *)
let fake_embed media_pars w ctx dh =
  Document.dclose true dh;
  try 
    let hlink = Hyper.default_link (Url.string_of dh.document_id.document_url)in
    pack [Label.create w [Text "Redispatched externally"]][];
    ctx#goto hlink
  with 
    Not_found (* goto *) -> 
      pack [Label.create w [Text "No navigation given to us"]][]
  | e ->
      pack [Label.create w [Text (Printexc.to_string e)]][]
@

<<toplevel [[Audio._1]]>>=
let _ =
  Mmm.add_embedded_viewer ("audio", "*") fake_embed
@

% ???

\section{video}
% <video>


\section{[[mmm_remote]]}
% emacsclient

\subsection{Server}

<<[[Main.main()]] locals>>=
let accept_external = ref false in
@
<<[[Main.main()]] command line options>>=
"-external", Arg.Unit (fun () -> accept_external := true),
" Accept remote command (mmm_remote <url>)";
@

<<[[Main.main()]] mmm server initialisation>>=
(* This must occur after most initialisations *)
if !accept_external 
then Cci.init caps;
@

\subsection{Client}

<<function [[Main_remote.request]]>>=
let request sock (cmd : string) (url : string) =
  if cmd <> "" 
  then Unix.write sock (Bytes.of_string cmd) 0 (String.length cmd) |> ignore;

  Unix.write sock (Bytes.of_string url) 0 (String.length url) |> ignore;
  Unix.write sock (Bytes.of_string "\n") 0 1 |> ignore;
  let buf = Bytes.create 1024 in
  try
    while true do
      let n = Unix.read sock buf 0 1024 in
      if n = 0 
      then raise End_of_file 
      else ignore (Unix.write Unix.stdout buf 0 n)
    done
  with End_of_file -> Unix.close sock
@

<<function [[Main_remote.main]]>>=
let main (caps: < caps; Cap.stdout; Cap.stderr; ..>) (argv : string array)
    : Exit.t =
  let file = 
    Filename.concat (Filename.concat (Sys.getenv "HOME") ".mmm") "remote" in
  let cmd = ref "" in
  
  let s = Unix.socket PF_UNIX SOCK_STREAM 0 in
  CapUnix.connect caps s (ADDR_UNIX file);
  Arg_.parse_argv caps argv  [ 
    "-get", Arg.Unit (fun () -> cmd := "GET "), "Get document";
    "-getbody", Arg.Unit (fun () -> cmd := "GETB "), "Get document body";
    "-head", Arg.Unit (fun () -> cmd := "HEAD "), "Get document headers";
    "-show", Arg.Unit (fun () -> cmd := "DISPLAY "), "Open browser on this URL";
  ]
    (fun url -> request s !cmd url)
    "Usage: mmm_remote [-get | -getbody | -head | -show] <url>\n
     The default is -show.";
   Exit.OK
@

<<toplevel [[Main_remote._1]]>>=
let _ = 
  Cap.main (fun (caps : Cap.all_caps) ->
    let argv = CapSys.argv caps in
    Exit.exit caps (Exit.catch (fun () -> main caps argv)))
@


%******************************************************************************
\chapter{Developer tools}
%******************************************************************************

\section{View source}

<<Document menu elements>>=
[Label (s_ "View Source")    ; Command view_source]
@

<<function [[Mmm.navigator.view_source]]>>=
let view_source () =     
  !current_di |> Option.iter (fun di -> di#di_source)
in
@

<<[[Viewers.display_info]] other virtual methods signatures>>=
method virtual di_source : unit 	        (* source viewer *)
@

% easy case, actually could return the whole document
<<[[Plain.plain]] other methods or fields>>=
method di_source = ()
@
% no need return source, you already see the source of the .txt file

<<[[Htmlw.display_html]] other methods or fields>>=
method di_source = self#source

(* The source is attached to this frame so we can destroy the interior widgets*)
method source =
  if pending 
  then Error.f (s_ "Cannot view document source (pending)")
  else Source.view frame did (fun () -> self#redisplay) errors annotations
         feed_read#get_code
@

<<signature [[Source.view]]>>=
val view:
  Widget.widget ->
  Document.id ->
  (unit -> unit) ->
  (Html.location * string) list ref ->
  (Tk.textTag * Html.location) list ref -> 
  Charset.detected_code ->
  unit
@
% argh, very complicated signature

% apparently it also allow to modify the html! nice! mmm is also an html editor!

<<function [[Source.view]]>>=
(* Commit modifies the cache *)
let view attach did redisplay errors annotations _coding =
  try 
    let doc = Cache.find did in
    (* load : take document from cache and put it in text widget
       commit : take source of text widget and store in cache
       save : save to original URL. supported only on file:, could be
              supported on http: with put ?
     *)
    let load, cachesave, saveurl =
      match doc.document_data with
      | FileData (fname,_) ->
          let tmpfile = Msys.mktemp "buf" in
          (* load *)
          (fun t ->
             let ic = open_in !!fname in
             let buf = Bytes.create 2048 in
             try
               while true do
                 let n = input ic buf 0 2048 in
                 if n = 0 
                 then raise End_of_file
                 else Text.insert t textEnd 
                        (if n = 2048 then Bytes.to_string buf else Bytes.sub_string buf 0 n) []
               done
             with End_of_file -> close_in ic
          ),

         (* commit *)
         (fun t ->
            let oc = open_out tmpfile in
            output_string oc
            (Text.get t (TextIndex(LineChar(0,0), [])) textEnd);
            close_out oc;
            (* SWITCH CACHE *)
            doc.document_data <- FileData(Fpath.v tmpfile, true)),

        (* save *)
        Some (fun t ->
          let oc = open_out !!fname in
          output_string oc
            (Text.get t (TextIndex(LineChar(0,0), [])) textEnd);
          close_out oc;
          (* SWITCH CACHE *)
          doc.document_data <- FileData(fname, false)
       )

      | MemoryData buf ->
          (* load *)
          (fun t -> Text.insert t textEnd (Ebuffer.get buf) []),
          (* commit *)
          (fun t -> 
             Ebuffer.reset buf;
             Ebuffer.output_string buf
              (Text.get t (TextIndex(LineChar(0,0), [])) textEnd)),
          None
    in
    let top = Toplevel.create attach [Class "MMMSource"] in
    Wm.title_set top "HTML source display";

    let errorv = Textvariable.create_temporary top in
    let f, t = 
      new_scrollable_text top [Foreground Black; Background White] false in
    let f' = Frame.create_named top "buttons" [] in
    let dismiss = Button.create_named f' "dismiss"
      [Text (s_ "Dismiss"); Command (fun _ -> destroy top)] in
    let commit = Button.create_named f' "commit" [Text (s_ "Commit")] in
    let save = Button.create_named f' "save" [Text (s_ "Save")] in
    let err = Button.create_named f' "errors" [] in
    let ferr = Frame.create top [] in
    let err_msg = 
      Label.create_named ferr "error" 
            [Relief Sunken;TextVariable errorv; Anchor W]
  in

  (* Error display and looping *)
  let error_idx = ref [] in
  let get_msg idx =
    let rec f = function
        [] -> raise Not_found
      | (s,e,msg)::l ->
        if Text.compare t s LE idx && Text.compare t idx LE e then msg
     else f l in
    f !error_idx in
  let show_error = Text.yview_index t in
  (* alternative is : Text.see t but is less practical *)
  let loop_in_errors  = 
    let current = ref None in
    (fun () ->
      match !current with
       None -> (* select the first error *)
      let (s,e,_) = List.hd !error_idx in
       current := Some e;
       show_error s
      | Some s -> (* select the next one *)
        try
         let (s,e) = Text.tag_nextrange t "errors" s textEnd in
       current := Some (TextIndex (e,[]));
       show_error (TextIndex(s,[]))
     with _ -> (* no more *)
       let (s,e,_) = List.hd !error_idx in
        current := Some e;
        show_error s) in

  let mark_errors () =
    error_idx := [];
    List.iter (fun (Loc(s,e),msg) ->
      let idxs = abs_index s
      and idxe = abs_index e in
      Text.tag_add t "errors" idxs idxe;
      error_idx := (idxs, idxe, msg) :: !error_idx)
        !errors;
    match List.length !errors with
      0 ->
       Button.configure err [Text (s_ "No Errors"); State Disabled]
    | _n ->
    Button.configure err
        [Text (s_ "%d errors" (List.length !errors));
         State Normal; Command loop_in_errors]
  and decorate = annotate t
  in
  let reset () =
    (* if we delete the tag, we delete the bindings. 
     * we can't use the old indexes since the buffer might have changed ! *)
     let rec remall = function
        [] -> ()
      | [_x] -> ()
      | s::e::l ->
       Text.tag_remove t "errors" (TextIndex(s,[])) (TextIndex(e,[]));
       remall l
      in
    remall (Text.tag_ranges t "errors");
    errors := [];
    Button.configure err 
       [Text (s_ "Display Errors"); Command mark_errors; State Normal]

  in
     Button.configure commit
        [Command (fun () -> reset(); cachesave t; redisplay())];
     (match saveurl with
        None -> Button.configure save [State Disabled]
      | Some f -> 
          Button.configure save
          [Command (fun () -> reset(); f t; redisplay())]);
     Button.configure err 
       [Text (s_ "Display Errors");
        Command (fun () -> mark_errors(); decorate !annotations);
        State Normal];
     Text.configure t [Background (NamedColor "white")];
     Text.tag_configure t "errors" [Underline true];
     Text.tag_bind t "errors" [[], Enter]
       (BindSet ([Ev_MouseX; Ev_MouseY],
     (fun ei ->
        (* The index of the click position *)
        let i = Text.index t
            (TextIndex (AtXY (ei.ev_MouseX, ei.ev_MouseY), [])) in
          try
        Textvariable.set errorv (get_msg (TextIndex(i,[])))
          with
        Not_found -> ())));
     Text.tag_bind t "errors" [[], Leave]
       (BindSet ([], (fun _ei -> Textvariable.set errorv "")));

      pack [dismiss;commit;save;err][Side Side_Left];
      pack [err_msg] [Side Side_Left; Expand true; Fill Fill_X];
    pack [ferr][Side Side_Top; Fill Fill_X];
    pack [f'][Side Side_Top; Fill Fill_X];
    pack [f][Fill Fill_Both; Expand true; Side Side_Bottom];

  Frx_text.addsearch t;
  load t

  with Not_found ->
    Error.f "document not in cache"
@
% so complicated function again



%******************************************************************************
\chapter{Advanced Topics}
%******************************************************************************

\section{Proxy}

% for security,
% for speed sometimes,
% but also to easily access other protocols,
%  e.g. if don't handle ftp://, then can ask the proxy
%  to translate that into http for us! cool feature.
% TODO: actually works? demo of ftp: via http: ? proxy address?

<<signature [[Http.proxy_xxx]]>>=
val proxy: string ref
val proxy_port: int ref
@
<<global [[Http.proxy]]>>=
(* Default proxy definitions *)
let proxy = ref "no-proxy-defined"
@
<<global [[Http.proxy_port]]>>=
let proxy_port = ref 80
@
<<[[Main.main()]] command line options>>=
"-proxy", Arg.String (fun s -> Http.proxy := s), 
" <hostname> Proxy host";
@
<<[[Main.main()]] command line options>>=
"-port", Arg.Int (fun i -> Http.proxy_port := i),
" <port> Proxy port";
@



<<constant [[Http.always_proxy]]>>=
let always_proxy = ref false
@
% it's a preference

<<[[Http.request()]] if always proxy>>=
if !always_proxy 
then proxy_request caps wr cont
@

<<[[Http.request()]] if http error on [[tcp_connect]], try proxy>>=
proxy_request caps wr cont
@
%old: was the code below, but can factorize!
%tcp_connect !proxy !proxy_port wr.www_logging
%     (start_request true wr cont)
%     (failed_request wr cont.document_finish)


<<function [[Http.proxy_request]]>>=
(* Process an HTTP request using the proxy. We pass on the continuation *)
let proxy_request caps (wr : Www.request) (cont : Document.continuation) =
  tcp_connect caps !proxy !proxy_port wr.www_logging
       (start_request true wr cont)
       (failed_request wr cont.document_finish)
@


% start_request i passed true = proxy_mode, which is
% then passed to async_request and finally to full_request

<<[[Http.full_request()]] url value if proxy mode>>=
if proxy_mode 
then Url.string_of wwwr.www_url
@
% when it's not a proxy, we just send the path and search component!
%  (see distant_path function, the host knows who it is already), 
% but for a proxy
% we need to give the info to the proxy host of the actual
% original host we wanted to reach, so we unparse the full url


\section{Forwarding}

<<Retrieve code behaviour other elements>>=
301, forward_permanent;
302, forward;
(* 304, update; *)
@


<<function [[Retrieve.forward_permanent]]>>=
(* 301 Moved permanently *)
let forward_permanent (wr : Www.request) (dh : Document.handle) =
  try
    let newurl = Http_headers.location dh.dh_headers in
    wr.www_error#ok (s_ "Document moved permanently to\n%s" newurl);
    forward wr dh
  with Not_found -> 
    Error (s_ "No Location: in forwarding header")
@

<<function [[Retrieve.forward]]>>=
(* 302 Moved temporarily *)
let forward (wr : Www.request) (dh : Document.handle) =
  try 
    let newurl = Http_headers.location dh.dh_headers in
    if (* do we forward automatically ?*)
      match wr.www_link.h_method with
      | GET -> true
      | POST _ ->
         (* Do NOT redirect automatically if method was POST *)
         wr.www_error#choose (s_ "Destination for your POST request has changed\n  from %s\nto %s\nConfirm action ?"
            (Url.string_of wr.www_url) newurl)
      | _ -> true 
    then begin (* consider forwarding as a link *)
       wr.www_logging "Forwarding";
       Retry { wr.www_link with h_uri = newurl; }
    end else 
      (* not forwarding a moved POST. We show the document after all,
        since some people (servers ?) use this trick to show the results
        of a POST, despite what the protocol says about this *)
       Ok
  with Not_found -> 
    Error (s_ "No Location: in forwarding header")
@



\section{Encodings}

% base64, 8859, url encode, etc.

\subsection{Base 64}
% could be in appendix in general utilities, independent of mmm

\subsubsection{Decoding}

<<signature [[Base64.decode]]>>=
val decode : string -> string
@
<<function [[Base64.decode]]>>=
let decode s =
  let rpos = ref 0
  and wpos = ref 0
  and len = String.length s in
  let res = Bytes.create (len / 4 * 3) in
    while !rpos < len do
      let v1 = index64.(Char.code s.[!rpos]) in
      let v2 = index64.(Char.code s.[!rpos + 1]) in
      let v3 = index64.(Char.code s.[!rpos + 2]) in
      let v4 = index64.(Char.code s.[!rpos + 3]) in
      (* each char gives 6 bits *)
      let i = (v1 lsl 18) lor (v2 lsl 12) lor (v3 lsl 6) lor v4 in
      Bytes.set res !wpos (Char.chr (i lsr 16));
      Bytes.set res (!wpos+1) (Char.chr ((i lsr 8) land 0xFF));
      Bytes.set res (!wpos+2) (Char.chr (i land 0xFF));
      rpos := !rpos + 4;
      wpos := !wpos + 3
      done;
  let cut = 
    if s.[len - 1] = '=' then
      if s.[len - 2] = '=' then 2
      else 1
    else 0 
  in
  Bytes.sub_string res 0 (Bytes.length res - cut)
@

<<constant [[Base64.index64]]>>=
(* For basic credentials only *)
(* Encoding is [A-Z][a-z][0-9]+/= *)
(* 3 chars = 24 bits = 4 * 6-bit groups -> 4 chars *)

let index64 = Array.make 128 0
@

<<toplevel [[Base64._1]]>>=
(* Init the index *)
let _ =
  for i = 0 to 25 do index64.(i + Char.code 'A') <- i done;
  for i = 0 to 25 do index64.(i + Char.code 'a') <- i + 26 done;
  for i = 0 to 9 do  index64.(i + Char.code '0') <- i + 52 done;
  index64.(Char.code '+') <- 62;
  index64.(Char.code '/') <- 63
@

\subsubsection{Encoding}

<<signature [[Base64.encode]]>>=
(* Base64 encoding (ONLY for Basic authentication) *)
val encode : string -> string
@
<<function [[Base64.encode]]>>=
(* Encoding *)
let encode s =
  let rpos = ref 0 
  and wpos = ref 0 in
  let origlen = String.length s in
  let s,len = match origlen mod 3 with
      0 -> s, origlen
    | 1 -> s ^ "\000\000", origlen + 2
    | 2 -> s ^ "\000", origlen + 1 
    | _ -> assert false
  in
  let res = Bytes.create (len / 3 * 4) in
    while !rpos < len do
      let i1 = Char.code s.[!rpos] in
      let i2 = Char.code s.[!rpos+1] in
      let i3 = Char.code s.[!rpos+2] in
      let i = (i1 lsl 16) lor (i2 lsl 8) lor i3 in
      Bytes.set res (!wpos)  (char64.((i lsr 18) land 0x3f));
      Bytes.set res (!wpos+1) (char64.((i lsr 12) land 0x3f));
      Bytes.set res (!wpos+2) (char64.((i lsr 6) land 0x3f));
      Bytes.set res (!wpos+3) (char64.(i land 0x3f));
      rpos := !rpos + 3;
      wpos := !wpos + 4
      done;
  (* Correct padding *)
  for i = 1 to len - origlen do Bytes.set res (Bytes.length res - i) '=' done;
  Bytes.to_string res
@


<<constant [[Base64.char64]]>>=
let char64 = Array.make 64 'a'
@
<<toplevel [[Base64._2]]>>=
let _ =
  for i = 0 to 25 do char64.(i) <- Char.chr (Char.code 'A' + i) done;
  for i = 0 to 25 do char64.(i+26) <- Char.chr (Char.code 'a' + i) done;
  for i = 0 to 9 do char64.(i+52) <- Char.chr (Char.code '0' + i) done;
  char64.(62) <- '+';
  char64.(63) <- '/'
@



\section{i18n}

<<signature [[I18n.language]]>>=
val language : string ref
@
<<constant [[I18n.language]]>>=
let language = ref ""
@
<<[[Main.main()]] command line options>>=
"-lang", Arg.String (fun s -> I18n.language := s),
" <lang> I18n language";
@


<<signature [[I18n.message_file]]>>=
val message_file : string ref
@
<<constant [[I18n.message_file]]>>=
let message_file = ref ""
@
<<[[Main.main()]] command line options>>=
"-msgfile", Arg.String (fun s -> I18n.message_file := s),
" <file> I18n message file";
@








%less: diff with I18n.language?
<<signature [[Lang.lang]]>>=
val lang : unit -> string
@
<<function [[Lang.lang]]>>=
let lang () =
  "iso8859"
@
%  (* if !japan then "ja" else *)




<<signature [[I18n.sprintf]]>>=
val sprintf: ('a, unit, string) format -> 'a
@

<<signature [[I18n.menu_option]]>>=
@
<<signature [[I18n.menu_pattern]]>>=
@
% dead anyway?




<<function [[I18n.fprintf]]>>=
(* Internationalization (translation of error messages) *)

let fprintf x = 
  Printf.fprintf x
@
%  (* if !Lang.japan then I18nprintf.fprintf x else *)

<<function [[I18n.sprintf]]>>=
let sprintf x = 
  Printf.sprintf x
@
%  (* if !Lang.japan then I18nprintf.sprintf x else *)



<<function [[I18n.read_transl_file]]>>=
let read_transl_file msgfile =
  let ic = open_in msgfile in
  let tag_buffer = Bytes.create 16
  and msg_buffer = Bytes.create 1024 in
  let rec store_tag c i =
    if i >= 16 then i else (Bytes.set tag_buffer i c; succ i)
  and store_msg c i =
    if i >= 1024 then i else (Bytes.set msg_buffer i c; succ i)
  and read_line i =
    match input_char ic with
      '\n' -> i
    | '\\' -> begin match input_char ic with
                '\\' -> read_line(store_msg '\\' i)
              | 'n'  -> read_line(store_msg '\n' i)
              | '\n' -> skip_blanks i
              | c    -> read_line(store_msg c (store_msg '\\' i))
              end
    | c    -> read_line(store_msg c i)
  and skip_blanks i =
    match input_char ic with
      ' '|'\t' -> skip_blanks i
    | c        -> read_line(store_msg c i)
  and read_tag i =
    match input_char ic with
      ':'           -> (i, skip_blanks 0)
    | ' '|'\n'|'\t' -> read_tag i
    | c             -> read_tag(store_tag c i) in
  let transl_tbl = Hashtbl.create 37 in
  let currsrc = ref "" in
  begin try
    while true do
      let (tag_len, msg_len) = read_tag 0 in
      if Bytes.sub_string tag_buffer 0 tag_len = "src" then
        currsrc := Bytes.sub_string msg_buffer 0 msg_len
      else if Bytes.sub_string tag_buffer 0 tag_len = !language then
        Hashtbl.add transl_tbl !currsrc (Bytes.sub_string msg_buffer 0 msg_len)
      else ()
    done
  with End_of_file ->
    close_in ic
  end;
  transl_tbl
@

<<type [[I18n.translation_table]]>>=
type translation_table =
    Unknown
  | NoTranslation
  | Transl of (string, string) Hashtbl.t
@

<<constant [[I18n.transl_table]]>>=
let transl_table = ref Unknown
@

<<function [[I18n.translate]]>>=
let rec translate msg =
  match !transl_table with
    NoTranslation ->
      msg
  | Transl tbl ->
      begin try Hashtbl.find tbl msg with Not_found -> msg end
  | Unknown ->
      transl_table :=
        if String.length !language == 0 then
          NoTranslation
        else begin
          try
            if Sys.file_exists !message_file then	   
              Transl(read_transl_file !message_file)
            else NoTranslation
          with Sys_error _ | Sys.Break ->
            NoTranslation
        end;
      translate msg
@

<<function I18n.fprintf (./commons/i18n.ml)>>=
let _fprintf oc (fmt : ('a, out_channel, unit) format) =
  fprintf oc
    (Obj.magic(translate(Obj.magic fmt : string)) :
                                ('a, out_channel, unit) format)
@

<<function I18n.sprintf (./commons/i18n.ml)>>=
let sprintf (fmt : ('a, unit, string) format) =
  sprintf
    (Obj.magic(translate(Obj.magic fmt : string)) :
                                ('a, unit, string) format)

@

<<function [[I18n.menu_option]]>>=
@

<<exception [[I18n.Found]]>>=
@

<<function [[I18n.menu_pattern]]>>=
@


<<[[Htmlw.display_html]] i18 encoder for forms>>=
(* I18n encoder for Forms *)
(*
if !Lang.japan then begin
  mach#set_i18n_encoder (fun s -> Charset.encoder feed_read#get_code s)
end;
*)
@

%  (* EOF Flags for JP *)
%  let eof = ref 0 in

%<<[[Htmlw.display_html]] private fields>>=
%(* flag for JP force redraw *)
%val mutable force_redrawable = true (* this must not be initialized *)
%@

<<[[Htmlw.display_html]] in feed, [[End_of_file]] exn handler, if japan>>=
@
%(*
%(* I don't know why but in some cases we have more than 1 EOF *)
%if !Lang.japan && full && !eof = 0 then begin
%  (* We should bind for each frames... *)
%  let default = [
%    (fun c -> 
%  force_redrawable <- false;
%  Japan.change_to_jis c), "iso-2022-jp", [
%      [Control], KeyPressDetail "k"; 
%      [Control], KeyPressDetail "j"];
%    (fun c ->
%  force_redrawable <- false;
%  Japan.change_to_iso8859 c), "iso-8859", [
%      [Control], KeyPressDetail "k"; 
%      [Control], KeyPressDetail "l"];
%    (fun c ->
%  force_redrawable <- false;
%  Japan.change_to_euc c), "euc-jp", [
%      [Control], KeyPressDetail "k"; 
%      [Control], KeyPressDetail "e"];
%    (fun c ->
%  force_redrawable <- false;
%  Japan.change_to_sjis c), "sjis", [
%      [Control], KeyPressDetail "k"; 
%      [Control], KeyPressDetail "s"];
%    (fun c ->
%  force_redrawable <- true;
%  Japan.change_to_autodetect c), "autodetect", [
%      [Control], KeyPressDetail "k"; 
%      [Control], KeyPressDetail "a"]]
%  in
%  let my_own = List.map (fun (f,i,devnt) ->
%    f,i,Tkresource.event_sequence ("ChangeEncoding-"^i) devnt)
%      default
%  in
%  (* Heck, this does not work... Key binds for frames... *)
%  (* We have to think about key bindings for each frames. (JPF) *)
%  (* List.iter (fun (f,_,evnt) ->
%    bind frame evnt (BindSetBreakable ([], fun _ -> 
%  f jpn_config; self#redisplay; break())))
%        my_own;
%     *)
%  self#add_extra_header (fun p ->
%    let encodingmenu = Menu.create_named p "encodingmenu" [] in
%    List.iter (fun (f,i,evnt) ->
%  Menu.add_command encodingmenu [ 
%    Label i; Command (fun () -> 
%      f jpn_config;
%      self#redisplay) (*;
%        Accelerator (Tkresource.short_event_sequence evnt)*) ])
%          my_own;
%    Menu.add_cascade p [
%      Menu encodingmenu;
%      Label ("Document encoding: " ^ 
%         try 
%           List.assoc feed_read#get_code 
%                    Japan.detected_code_names
%         with
%       Not_found -> "???")])
%end;
%*)


<<[[Htmlw.display_html]] in feed, [[End_of_file]] exn handler, if japn and charset>>=
@
%(*
%if !Lang.japan && !meta_charset <> None then begin
%  match !meta_charset with
%      | None -> assert false
%      | Some meta_charset ->
%         if Japan.Code meta_charset <> feed_read#get_code && 
%           force_redrawable 
%         then begin
%              force_redrawable <- false;
%              (match meta_charset with
%                Japan.JIS -> Japan.change_to_jis jpn_config 
%              | Japan.SJIS -> Japan.change_to_sjis jpn_config 
%              | Japan.EUC -> Japan.change_to_euc jpn_config 
%              | Japan.ISO8859 -> Japan.change_to_iso8859 jpn_config 
%              | _ -> ());
%              self#redisplay
%            end
%end;
%incr eof
%*)



<<[[Html_disp.machine]] i18 methods>>=
(* For other languages) *)
(* encode the internal i18n strings to corresponding encodings *)
method virtual i18n_encoder : string -> string
method virtual set_i18n_encoder : (string -> string) -> unit
@
<<[[Html_disp.display_machine]] i18n methods>>=
val mutable i18n_encoder = (fun s -> s : string -> string)
method i18n_encoder = i18n_encoder
method set_i18n_encoder enc = i18n_encoder <- enc
@


\subsection{Special characters}

%<<[[latin1_normal]] elements>>=
%"nbsp", 	"\160"; (* non-breaking space *)
%"iexcl",	"\161"; (*  inverted exclamation mark *)
%"cent", 	"\162"; (*  cent sign*)
%"pound",	"\163"; (*  pound sterling sign*)
%"curren",	"\164"; (*  general currency sign*)
%"yen",	"\165"; (*  yen sign*)
%"brvbar",	"\166"; (*  broken (vertical) bar *)
%"sect",	"\167"; (*  section sign *)
%"uml",	"\168"; (*  umlaut (dieresis) *)
%"copy",	"\169"; (*  copyright sign *)
%"ordf",	"\170"; (*  ordinal indicator, feminine *)
%"laquo",	"\171"; (*  angle quotation mark, left *)
%"not",	"\172"; (*  not sign *)
%"shy",	"\173"; (*  soft hyphen *)
%"reg",	"\174"; (*  registered sign *)
%"macr",	"\175"; (*  macron *)
%"deg",	"\176"; (*  degree sign *)
%"plusmn",	"\177"; (*  plus-or-minus sign *)
%"sup2",	"\178"; (*  superscript two *)
%"sup3",	"\179"; (*  superscript three *)
%"acute",	"\180"; (*  acute accent *)
%"micro",	"\181"; (*  micro sign *)
%"para",	"\182"; (*  pilcrow (paragraph sign) *)
%"middot",	"\183"; (*  middle dot *)
%"cedil",	"\184"; (*  cedilla *)
%"sup1",	"\185"; (*  superscript one *)
%"ordm",	"\186"; (*  ordinal indicator, masculine *)
%"raquo",	"\187"; (*  angle quotation mark, right *)
%"frac14",	"\188"; (*  fraction one-quarter *)
%"frac12",	"\189"; (*  fraction one-half *)
%"frac34",	"\190"; (*  fraction three-quarters *)
%"iquest",	"\191"; (*  inverted question mark *)
%"Agrave", 	"\192";	(*  capital A, grave accent *)
%"Aacute", 	"\193";	(*  capital A, acute accent *)
%"Acirc", 	"\194";	(*  capital A, circumflex accent *)
%"Atilde", 	"\195";	(*  capital A, tilde *)
%"Auml", 	"\196";	(*  capital A, dieresis or umlaut mark *)
%"Aring", 	"\197";	(*  capital A, ring *)
%"AElig", 	"\198";	(*  capital AE diphthong (ligature) *)
%"Ccedil", 	"\199";	(*  capital C, cedilla *)
%"Egrave", 	"\200";	(*  capital E, grave accent *)
%"Eacute", 	"\201";	(*  capital E, acute accent *)
%"Ecirc", 	"\202";	(*  capital E, circumflex accent *)
%"Euml", 	"\203";	(*  capital E, dieresis or umlaut mark *)
%"Igrave", 	"\204";	(*  capital I, grave accent *)
%"Iacute", 	"\205";	(*  capital I, acute accent *)
%"Icirc", 	"\206";	(*  capital I, circumflex accent *)
%"Iuml", 	"\207";	(*  capital I, dieresis or umlaut mark *)
%"ETH", 	"\208";	(*  capital Eth, Icelandic *)
%"Ntilde", 	"\209";	(*  capital N, tilde *)
%"Ograve", 	"\210";	(*  capital O, grave accent *)
%"Oacute", 	"\211";	(*  capital O, acute accent *)
%"Ocirc", 	"\212";	(*  capital O, circumflex accent *)
%"Otilde", 	"\213";	(*  capital O, tilde *)
%"Ouml", 	"\214";	(*  capital O, dieresis or umlaut mark *)
%"times",	"\215"; (*  multiply sign*)
%"Oslash", 	"\216";	(*  capital O, slash *)
%"Ugrave", 	"\217";	(*  capital U, grave accent *)
%"Uacute", 	"\218";	(*  capital U, acute accent *)
%"Ucirc", 	"\219";	(*  capital U, circumflex accent *)
%"Uuml", 	"\220";	(*  capital U, dieresis or umlaut mark *)
%"Yacute",	"\221"; (*  capital Y, acute accent *)
%"THORN", 	"\222";	(*  capital THORN, Icelandic *)
%"szlig", 	"\223";	(*  small sharp s, German (sz ligature) *)
%"agrave", 	"\224";	(*  small a, grave accent *)
%"aacute", 	"\225";	(*  small a, acute accent *)
%"acirc", 	"\226";	(*  small a, circumflex accent *)
%"atilde", 	"\227";	(*  small a, tilde *)
%"auml", 	"\228";	(*  small a, dieresis or umlaut mark *)
%"aring", 	"\229";	(*  small a, ring *)
%"aelig", 	"\230";	(*  small ae diphthong (ligature) *)
%"ccedil", 	"\231";	(*  small c, cedilla *)
%"egrave", 	"\232";	(*  small e, grave accent *)
%"eacute", 	"\233";	(*  small e, acute accent *)
%"ecirc", 	"\234";	(*  small e, circumflex accent *)
%"euml", 	"\235";	(*  small e, dieresis or umlaut mark *)
%"igrave", 	"\236";	(*  small i, grave accent *)
%"iacute", 	"\237";	(*  small i, acute accent *)
%"icirc", 	"\238";	(*  small i, circumflex accent *)
%"iuml", 	"\239";	(*  small i, dieresis or umlaut mark *)
%"eth", 	"\240";	(*  small eth, Icelandic *)
%"ntilde", 	"\241";	(*  small n, tilde *)
%"ograve", 	"\242";	(*  small o, grave accent *)
%"oacute", 	"\243";	(*  small o, acute accent *)
%"ocirc", 	"\244";	(*  small o, circumflex accent *)
%"otilde", 	"\245";	(*  small o, tilde *)
%"ouml", 	"\246";	(*  small o, dieresis or umlaut mark *)
%"divide",	"\247"; (*  divide sign *)
%"oslash", 	"\248";	(*  small o, slash *)
%"ugrave", 	"\249";	(*  small u, grave accent *)
%"uacute", 	"\250";	(*  small u, acute accent *)
%"ucirc", 	"\251";	(*  small u, circumflex accent *)
%"uuml", 	"\252";	(*  small u, dieresis or umlaut mark *)
%"yacute", 	"\253";	(*  small y, acute accent *)
%"thorn", 	"\254";	(*  small thorn, Icelandic *)
%"yuml", 	"\255" 	(*  small y, dieresis or umlaut mark *)
%@


<<[[latin1_normal]] elements>>=
(* old: we were generating single-byte latin1 encoding of the special
 * symbols but better to generated instead UTF8 chars as Tk assumes UTF8
 *)
"nbsp", 	"\194\160"; (* U+00A0 non-breaking space *)
"iexcl",	"\194\161"; (* U+00A1 inverted exclamation mark *)
"cent", 	"\194\162"; (* U+00A2 cent sign*)
"pound",	"\194\163"; (* U+00A3 pound sterling sign*)
"curren",	"\194\164"; (* U+00A4 general currency sign*)
"yen",	"\194\165"; (* U+00A5 yen sign*)
"brvbar",	"\194\166"; (* U+00A6 broken (vertical) bar *)
"sect",	"\194\167"; (* U+00A7 section sign *)
"uml",	"\194\168"; (* U+00A8 umlaut (dieresis) *)
"copy",	"\194\169"; (* U+00A9 copyright sign *)
"ordf",	"\194\170"; (* U+00AA ordinal indicator, feminine *)
"laquo",	"\194\171"; (* U+00AB angle quotation mark, left *)
"not",	"\194\172"; (* U+00AC not sign *)
"shy",	"\194\173"; (* U+00AD soft hyphen *)
"reg",	"\194\174"; (* U+00AE registered sign *)
"macr",	"\194\175"; (* U+00AF macron *)
"deg",	"\194\176"; (* U+00B0 degree sign *)
"plusmn",	"\194\177"; (* U+00B1 plus-or-minus sign *)
"sup2",	"\194\178"; (* U+00B2 superscript two *)
"sup3",	"\194\179"; (* U+00B3 superscript three *)
"acute",	"\194\180"; (* U+00B4 acute accent *)
"micro",	"\194\181"; (* U+00B5 micro sign *)
"para",	"\194\182"; (* U+00B6 pilcrow (paragraph sign) *)
"middot",	"\194\183"; (* U+00B7 middle dot *)
"cedil",	"\194\184"; (* U+00B8 cedilla *)
"sup1",	"\194\185"; (* U+00B9 superscript one *)
"ordm",	"\194\186"; (* U+00BA ordinal indicator, masculine *)
"raquo",	"\194\187"; (* U+00BB angle quotation mark, right *)
"frac14",	"\194\188"; (* U+00BC fraction one-quarter *)
"frac12",	"\194\189"; (* U+00BD fraction one-half *)
"frac34",	"\194\190"; (* U+00BE fraction three-quarters *)
"iquest",	"\194\191"; (* U+00BF inverted question mark *)
"Agrave", 	"\195\128"; (* U+00C0 capital A, grave accent *)
"Aacute", 	"\195\129"; (* U+00C1 capital A, acute accent *)
"Acirc", 	"\195\130"; (* U+00C2 capital A, circumflex accent *)
"Atilde", 	"\195\131"; (* U+00C3 capital A, tilde *)
"Auml", 	"\195\132"; (* U+00C4 capital A, dieresis or umlaut mark *)
"Aring", 	"\195\133"; (* U+00C5 capital A, ring *)
"AElig", 	"\195\134"; (* U+00C6 capital AE diphthong (ligature) *)
"Ccedil", 	"\195\135"; (* U+00C7 capital C, cedilla *)
"Egrave", 	"\195\136"; (* U+00C8 capital E, grave accent *)
"Eacute", 	"\195\137"; (* U+00C9 capital E, acute accent *)
"Ecirc", 	"\195\138"; (* U+00CA capital E, circumflex accent *)
"Euml", 	"\195\139"; (* U+00CB capital E, dieresis or umlaut mark *)
"Igrave", 	"\195\140"; (* U+00CC capital I, grave accent *)
"Iacute", 	"\195\141"; (* U+00CD capital I, acute accent *)
"Icirc", 	"\195\142"; (* U+00CE capital I, circumflex accent *)
"Iuml", 	"\195\143"; (* U+00CF capital I, dieresis or umlaut mark *)
"ETH", 	"\195\144"; (* U+00D0 capital Eth, Icelandic *)
"Ntilde", 	"\195\145"; (* U+00D1 capital N, tilde *)
"Ograve", 	"\195\146"; (* U+00D2 capital O, grave accent *)
"Oacute", 	"\195\147"; (* U+00D3 capital O, acute accent *)
"Ocirc", 	"\195\148"; (* U+00D4 capital O, circumflex accent *)
"Otilde", 	"\195\149"; (* U+00D5 capital O, tilde *)
"Ouml", 	"\195\150"; (* U+00D6 capital O, dieresis or umlaut mark *)
"times",	"\195\151"; (* U+00D7 multiply sign*)
"Oslash", 	"\195\152"; (* U+00D8 capital O, slash *)
"Ugrave", 	"\195\153"; (* U+00D9 capital U, grave accent *)
"Uacute", 	"\195\154"; (* U+00DA capital U, acute accent *)
"Ucirc", 	"\195\155"; (* U+00DB capital U, circumflex accent *)
"Uuml", 	"\195\156"; (* U+00DC capital U, dieresis or umlaut mark *)
"Yacute",	"\195\157"; (* U+00DD capital Y, acute accent *)
"THORN", 	"\195\158"; (* U+00DE capital THORN, Icelandic *)
"szlig", 	"\195\159"; (* U+00DF small sharp s, German (sz ligature) *)
"agrave", 	"\195\160"; (* U+00E0 small a, grave accent *)
"aacute", 	"\195\161"; (* U+00E1 small a, acute accent *)
"acirc", 	"\195\162"; (* U+00E2 small a, circumflex accent *)
"atilde", 	"\195\163"; (* U+00E3 small a, tilde *)
"auml", 	"\195\164"; (* U+00E4 small a, dieresis or umlaut mark *)
"aring", 	"\195\165"; (* U+00E5 small a, ring *)
"aelig", 	"\195\166"; (* U+00E6 small ae diphthong (ligature) *)
"ccedil", 	"\195\167"; (* U+00E7 small c, cedilla *)
"egrave", 	"\195\168"; (* U+00E8 small e, grave accent *)
"eacute", 	"\195\169"; (* U+00E9 small e, acute accent *)
"ecirc", 	"\195\170"; (* U+00EA small e, circumflex accent *)
"euml", 	"\195\171"; (* U+00EB small e, dieresis or umlaut mark *)
"igrave", 	"\195\172"; (* U+00EC small i, grave accent *)
"iacute", 	"\195\173"; (* U+00ED small i, acute accent *)
"icirc", 	"\195\174"; (* U+00EE small i, circumflex accent *)
"iuml", 	"\195\175"; (* U+00EF small i, dieresis or umlaut mark *)
"eth", 	"\195\176"; (* U+00F0 small th, Icelandic *)
"ntilde", 	"\195\177"; (* U+00F1 small n, tilde *)
"ograve", 	"\195\178"; (* U+00F2 small o, grave accent *)
"oacute", 	"\195\179"; (* U+00F3 small o, acute accent *)
"ocirc", 	"\195\180"; (* U+00F4 small o, circumflex accent *)
"otilde", 	"\195\181"; (* U+00F5 small o, tilde *)
"ouml", 	"\195\182"; (* U+00F6 small o, dieresis or umlaut mark *)
"divide",	"\195\183"; (* U+00F7 divide sign *)
"oslash", 	"\195\184"; (* U+00F8 small o, slash *)
"ugrave", 	"\195\185"; (* U+00F9 small u, grave accent *)
"uacute", 	"\195\186"; (* U+00FA small u, acute accent *)
"ucirc", 	"\195\187"; (* U+00FB small u, circumflex accent *)
"uuml", 	"\195\188"; (* U+00FC small u, dieresis or umlaut mark *)
"yacute", 	"\195\189"; (* U+00FD small y, acute accent *)
"thorn", 	"\195\190"; (* U+00FE small thorn, Icelandic *)
"yuml", 	"\195\191"  (* U+00FF small y, dieresis or umlaut mark *)
@


\section{Referer}
% it's a security issue?


% Http.full_request -> <>
<<[[Http.full_request()]] helper functions>>=
let write_referer = 
  match wwwr.www_link.h_context with
  | None ->   (fun () -> ())
  | Some r -> (fun () -> if !send_referer then w ("Referer: " ^ r ^ "\r\n"))
in
@

<<constant [[Http.send_referer]]>>=
(*
 * HTTP/1.0
 * Headers should be configurable
 *)

let send_referer = ref false
@


<<[[Document.handle]] other fields>>=
document_referer: string option;
  (* URL of refering document, if any *)
@

% code using that?

\section{Security}

<<[[Www.request]] security field>>=
mutable www_auth : (string * string) list;  (* basic auth *)
@

<<[[Messages.request_message]] other fields>>=
request_auth : (string * string) option;
         (* have we authentified the emitter (authtype, authuser) *)
@

<<Other menu elements>>=
Menu.add_command othersm
  [Label (s_ "Load Authorizations..."); Command Auth.load];
Menu.add_command othersm
  [Label (s_ "Edit Authorizations..."); Command Auth.edit];
Menu.add_command othersm
  [Label (s_ "Save Authorizations..."); Command Auth.save];
@


<<[[Http.full_request()]] write auth stuff>>=
write_realm_auth ();
if proxy_mode 
then write_proxy_auth();
@

<<[[Http.full_request()]] helper functions>>=
(* If the request has an Authorization, write it *)
let write_realm_auth () =
  try
    let cookie = List.assoc "realm" wwwr.www_auth in
    w ("Authorization: Basic "^cookie^"\r\n")
  with Not_found -> ()
in
@

<<[[Http.full_request()]] helper functions>>=
(* For proxy, we don't wait until we get an authorization error *)
let write_proxy_auth () =
  let authspace = Auth.{
    auth_proxy = true;
    auth_host = !proxy;
    auth_port = !proxy_port;
    auth_dir = "";
    auth_realm = ""} 
  in
  try (* do we know the cookie *)
    let cookie = Auth.get authspace in
    w ("Proxy-Authorization: Basic "^cookie^"\r\n")
  with Not_found -> (* is that in the request ? *)
     try
       let cookie = List.assoc "proxy" wwwr.www_auth in
       w ("Proxy-Authorization: Basic "^cookie^"\r\n")
     with Not_found -> ()
in
@

\subsection{Parsing}

<<signature [[Lexheaders.challenge]]>>=
val challenge : Lexing.lexbuf -> Http_headers.authChallenge
@

\subsection{Security challenge}
% auth
% mv in later chapter? Security?


<<signature [[Http_headers.challenge]]>>=
val challenge : Messages.header list -> string
  (* WWW-Authenticate *)
@

<<signature [[Http_headers.proxy_challenge]]>>=
val proxy_challenge : Messages.header list -> string
  (* Proxy-Authenticate *)
@

<<signature [[Http_headers.expires]]>>=
val expires : Messages.header list -> Http_date.http_time option
  (* Expires *)
@

<<type [[Http_headers.authScheme]]>>=
(* Authorisation headers *)
type authScheme =
    AuthBasic
  | AuthExtend of string
@

<<type [[Http_headers.authChallenge]]>>=
type authChallenge =
    { challenge_scheme : authScheme;
      challenge_realm : string;
      challenge_params: (string * string) list
    }
@



<<type [[Auth.authSpace]]>>=
(* Authorizations are remembered on the base of the directory url and realm
 * They are kept during the whole MMM session, with expiration
 *)
type authSpace = {
   auth_proxy: bool;
   auth_host : string;
   auth_port : int;
   auth_dir : string;
   auth_realm : string
  }
@




<<signature [[Auth.lifetime]]>>=
val lifetime : int ref
@

<<signature [[Auth.auth_file]]>>=
val auth_file : string ref
@

<<signature [[Auth.edit]]>>=
val edit : unit -> unit
@

<<signature [[Auth.load]]>>=
val load : unit -> unit
@

<<signature [[Auth.save]]>>=
val save : unit -> unit
@

<<signature [[Auth.add]]>>=
val add : authSpace -> string -> unit
@

<<signature [[Auth.get]]>>=
val get : authSpace -> string
@


<<signature [[Auth.check]]>>=
val check : Www.request -> Http_headers.authChallenge -> authSpace ->
                  (string * bool * authSpace) option
@




<<type [[Auth.authEntry]]>>=
type authEntry = {
   auth_cookie : string;
   mutable auth_lastused : float
   }
@

<<constant [[Auth.authorizations]]>>=
let authorizations = Hashtbl.create 37
@

<<function [[Auth.get]]>>=
let get space = 
  let entry = Hashtbl.find authorizations space in
    entry.auth_lastused <- Unix.time();
    entry.auth_cookie
@

<<constant [[Auth.lifetime]]>>=
(* Lifetime, in minutes. Default is one hour *)
let lifetime = ref 60
@

<<function [[Auth.lookup]]>>=
let rec lookup space = 
  (* Printf.eprintf "%s\n" space.auth_dir; flush Pervasives.stderr; *)
  try
    Hashtbl.find authorizations space
  with
    Not_found ->
     if space.auth_dir = "/" || space.auth_dir = "." 
     then raise Not_found 
     else
      let newdir = Filename.dirname space.auth_dir in
       lookup {auth_proxy = space.auth_proxy;
               auth_host = space.auth_host;
            auth_port = space.auth_port;
        auth_dir = newdir;
        auth_realm = space.auth_realm}
@

<<function [[Auth.ask_cookie]]>>=
let ask_cookie forwhere =
  try
    let u,p = !open_passwd_ref forwhere in
    Base64.encode (u^":"^p)
  with
  | Failure "cancelled" -> 
      failwith "cancelled"
  | _ -> 
      Error.f (s_ "Error in base 64 encoding");
      failwith "cancelled"
@

<<function [[Auth.replace]]>>=
let replace kind cookie l =
  let rec repl acc = function
    [] -> (kind,cookie)::acc
  | (k,_)::l when k = kind -> repl (acc) l
  | p::l -> repl (p::acc) l in
  repl [] l
@

<<function [[Auth.add]]>>=
let add space cookie =
  Log.debug "adding cookie";
  Hashtbl.add authorizations 
      space 
      {auth_cookie = cookie; auth_lastused = Unix.time()}
@

<<function [[Auth.check]]>>=
(* Kind is either: realm or proxy *)
let check wwwr challenge authspace =
  let kind = if authspace.auth_proxy then "proxy" else "realm" in
  match challenge.challenge_scheme with
    AuthExtend _ -> (* we don't know how to do this *) 
       None
  | AuthBasic -> (* params are gleefully ignored *)
     try (* if the passwd request is cancelled *)
      let cookie, isnew =
        if List.mem_assoc kind wwwr.www_auth then begin
           (* we already tried, so the authorization is bad ! *)
           Hashtbl.remove authorizations authspace; (* in case *)
           ask_cookie (s_ "Authorization for %s \"%s\" on \
                                             %s:%d/%s" 
                            kind challenge.challenge_realm 
                            authspace.auth_host authspace.auth_port 
                            authspace.auth_dir),
           true
           end
       else (* ah, it is our first try,  get the authorization *)
         if authspace.auth_proxy then 
            ask_cookie (s_ "Authorization for %s \"%s\" on \
                                             %s:%d/%s" 
                            kind challenge.challenge_realm
                            authspace.auth_host authspace.auth_port 
                            authspace.auth_dir),
            true
         else
           try 
             let entry = lookup authspace in
              entry.auth_lastused <- Unix.time();
              entry.auth_cookie, false
           with Not_found ->
            ask_cookie (s_ "Authorization for %s \"%s\" on \
                                             %s:%d/%s" 
                            kind challenge.challenge_realm
                            authspace.auth_host authspace.auth_port 
                            authspace.auth_dir),
            true
      in
      wwwr.www_auth <- replace kind cookie wwwr.www_auth;
      Some (cookie, isnew, authspace)
     with
      Failure "cancelled" -> None
@

<<function [[Auth.edit]]>>=
(* needs to be refined *)
let edit () =
  !edit_backend ()
@

<<constant [[Auth.auth_file]]>>=
(* Saving authorizations to file *)
let auth_file = ref ""
@

<<function [[Auth.save]]>>=
let save () =
 if !auth_file <> "" then
  let auth_file = Msys.tilde_subst !auth_file in
  try
    let o = openfile auth_file [O_WRONLY; O_CREAT] 0o600 in
    let oc = out_channel_of_descr o in
      output_value oc authorizations;
      flush oc;
      close o
  with
  | Unix_error(e,_,_) ->
      Error.f (s_ "Error in authorisation save\n%s" (Unix.error_message e))
  | Sys_error s ->
      Error.f (s_ "Error in authorisation save\n%s" s)
 else 
   Error.f (s_ "No authorisation file defined")
@

<<function [[Auth.load]]>>=
let load () =
  if !auth_file <> "" then
    let auth_file = Msys.tilde_subst !auth_file in
    try
      let ic = open_in auth_file in
      let table = input_value ic
      and time = Unix.time() in
       Hashtbl.iter
          (fun spacerealm entry ->
           entry.auth_lastused <- time;
           Hashtbl.add authorizations spacerealm entry)
          table;
    close_in ic
    with Sys_error s ->
      Error.f (s_ "Error in authorisation load\n%s" s)
 else 
   Error.f (s_ "No authorisation file defined")
@

<<signature [[Auth.init]]>>=
val init : unit -> unit
@
% main -> <>
<<function [[Auth.init]]>>=
let init () =
  let check () =
    let remove = ref []
    and lifetime = float (60 * !lifetime)
    and time = Unix.time () in
    Hashtbl.iter 
      (fun space entry ->
       let expiration_time = entry.auth_lastused +. lifetime in
    if time > expiration_time then remove := space :: !remove)
      authorizations;
    List.iter (Hashtbl.remove authorizations) !remove
  in
  let rec tim () =
    Timer_.set (!lifetime * 30000) (fun () -> check(); tim ())
  in
  tim ()
@

\subsection{HTTP status}


<<Retrieve code behaviour other elements>>=
401, unauthorized;
407, proxy_unauthorized;
@

<<function [[Retrieve.ask_auth]]>>=
(* 401 Unauthorized *)
let ask_auth (wr : Www.request) (dh : Document.handle) =
  wr.www_logging (s_ "Checking authentication");
  let rawchallenge = Http_headers.challenge dh.dh_headers in
  let challenge = 
    Lexheaders.challenge (Lexing.from_string rawchallenge) in
  let host = match wr.www_url.host with
     Some h -> h
   | None -> ""
  and dir = match wr.www_url.path with
     Some "" -> "/"
   | Some h -> Filename.dirname h
   | None -> "/" 
  and port = match wr.www_url.port with
     Some p -> p
   | None -> 80 (* should never happen *) in

  Auth.check wr challenge
      {auth_proxy = false;
       auth_host = host; 
       auth_port = port;
       auth_dir = dir;
       auth_realm = challenge.challenge_realm}
@

<<function [[Retrieve.unauthorized]]>>=
let unauthorized wr dh =
  match ask_auth wr dh with
    None -> (* no attempt to answer challenge, display the message *)
      Ok
  | Some (cookie, isnew, space) ->
     (* restart the request with a continuation that says first
    to check if authorization was valid, and then proceed
    to the normal intended continuation *)
     Restart (fun newdh ->
        if newdh.document_status <> 401 && isnew then
          Auth.add space cookie;
        (* Put the challenge header again *)
        begin try
          newdh.dh_headers <- ("WWW-Authenticate: "^ (Http_headers.challenge dh.dh_headers))
                              :: newdh.dh_headers
         with
          Not_found -> ()
        end;
                newdh)
@


<<function [[Retrieve.ask_proxy_auth]]>>=
(* 407 Unauthorized *)
(* We dump the realm altogether, because it has no meaning for proxies *)
let ask_proxy_auth (wr : Www.request) (dh : Document.handle) =
  wr.www_logging (s_ "Checking proxy authentication");
  let rawchallenge = Http_headers.proxy_challenge dh.dh_headers in
  let challenge = 
    Lexheaders.challenge (Lexing.from_string rawchallenge) in
  Auth.check wr challenge
      {auth_proxy = true;
       auth_host = !Http.proxy;
       auth_port = !Http.proxy_port;
       auth_dir = "";
       auth_realm = ""}
@

<<function [[Retrieve.proxy_unauthorized]]>>=
let proxy_unauthorized wr dh =
  Log.debug "proxy_unauthorized handler";
  match ask_proxy_auth wr dh with
    None -> (* no attempt to answer challenge, display the message *)
      Ok
  | Some (cookie, isnew, space) ->
     (* restart the request with a continuation that says first
    to check if authorization was valid, and then proceed
    to the normal intended continuation *)
      Restart (fun newdh -> 
         Log.debug "proxy_unauthorized wrapper";
         if newdh.document_status <> 407 && isnew then
           Auth.add space cookie;
         (* Put the challenge header again *)
         begin try
           newdh.dh_headers <- 
              ("Proxy-Authenticate: "^ (Http_headers.proxy_challenge dh.dh_headers))
              :: newdh.dh_headers
          with
           Not_found -> ()
         end;
                 newdh)
@



\section{Optimisations}
% could also have an parallel chapter?

\subsection{Document cache, [[Cache]]}

% pretty important, because network is super slow.
% cache in RAM, and then cache on (local) disk, so
% don't have to fetch over slow network

%rappel:
%let _ = Hashtbl.add protos HTTP (Http.req, Cache.tobuffer)

<<signature [[Cache.tobuffer]]>>=
val tobuffer: Document.handle -> Document.data * cache_fill
@
% ?? -> <> (as ?? <-  ...)
<<function [[Cache.tobuffer]]>>=
let tobuffer _dh =
  let b = Ebuffer.create 1024 in
  MemoryData b, {cache_write = Ebuffer.output b;
                 cache_close = (fun () -> ())}
@


<<function [[Cache.add]]>>=
(* Add a new entry *)
let add did doc =
  if !debug 
  then Log.f (sprintf "Adding new cache entry %s(%d) %s"
                        (Url.string_of did.document_url)
                        did.document_stamp
                        (match doc.document_data with
                        | MemoryData _ -> "in memory"
                        | FileData (f,true) -> !!f
                        | FileData (f,false) -> "fake " ^ !!f)
                        );

  (* Kill the previous entry, if any [for update] *)
  kill did;
  (* Because of frames (not kept in history), we must make room even
   * in history mode
   *)
  if (*not !history_mode && *)!current >= !max_documents 
  then make_room()
  else begin
    if !debug 
    then Log.f (sprintf "Cache size(max): %d(%d)" !current !max_documents);
    incr current;
    memory := (did,
               { cache_document = doc;
                 cache_pending = true;
                 cache_lastused = max_lastused;
                 cache_condition = Condition.create()
               }) :: !memory
  end
@
%bug? I added some begin/end for the last else, was not there before


<<[[Nav.request.handle_wr()]] if use cache>>=
(* If the the document can be cached, then it is with no_stamp *)
let did = Document.{ document_url = wr.www_url; document_stamp = no_stamp } in
try
  specific nav did wr
with Not_found ->
  try
    let doc = Cache.find did in
    try (* display it from source *)
      process nav wr (Cache.make_handle wr doc)
    with 
    | Sys_error s ->
        wr.www_error#f (s_
         "Cache error occurred during save of temporary buffer (%s)"
            s)
    | Unix.Unix_error (e,fname,arg) ->
        wr.www_error#f 
          (s_ "Cache error occurred when opening temporary file\n%s: %s (%s)"
                 fname (Unix.error_message e) arg)
 with Not_found -> (* we don't have the document *)
   retrieve_and_handle wr
@


<<signature [[Nav.dont_check_cache]]>>=
(*-*)
val dont_check_cache : Www.request -> bool
@
% Nav.request -> <>
<<function [[Nav.dont_check_cache]]>>=
(* Some requests should not be looked for in the cache *)
let dont_check_cache (wwwr : Www.request) =
  match wwwr.www_link.h_method with
  | POST _ -> true
  | _ -> false
@



<<[[Mmm.navigator()]] call [[touch_current]] to not swap displayed documents>>=
(* Yet another timer to avoid flushing displayed documents *)
let rec touch_current () =
  if Winfo.exists top then begin
    Cache.touch hist.h_current.h_did;
    Timer.set 10000 touch_current;
  end 
in
touch_current();
@

% Gcache.touch

\subsection{Graphic cache, [[Gcache]]}
% Graphic cache


<<[[Mmm.navigator.show_current()]] start hook>>=
di#di_touch;
@

<<[[Viewers.display_info]] graphic cache methods signatures>>=
method di_touch : unit
method di_last_used : int
@

<<[[Viewers.display_info]] graphic cache methods>>=
val mutable di_last_used = !Low.global_time
method di_last_used = 
  di_last_used
method di_touch = 
  di_last_used <- !Low.global_time
@
% default methods, but overriden sometimes?

<<signature [[Viewers.di_compare]]>>=
val di_compare : display_info -> display_info -> int
@
<<function [[Viewers.di_compare]]>>=
let di_compare di di' = 
  (*di#di_last_used > di'#di_last_used*)
  Stdlib.compare di'#di_last_used di#di_last_used
@

<<[[Nav.process_viewer()]] add in cache and history the document>>=
Gcache.add nav.nav_id dh.document_id di;
@

<<[[Mmm.navigator()]] destroy navigator hook>>=
Gcache.kill hist.h_key;
@
% same than nav.nav_id I think


<<function [[Gcache.remove]]>>=
(* Removes a given dinfo for a cached document
 *   used when adding in the middle of the history
 *)
let remove hkey did =
  if !debug 
  then Log.f (sprintf "Removing %s in window %d" 
                 (Url.string_of did.document_url) hkey);
  try
    let r = Hashtbl.find table hkey in
    let di = List.assoc did !r in
    di#di_abort;
    di#di_destroy;
    r := Mlist.except_assoc did !r;
    if !Cache.history_mode 
    then nocache did
  with Not_found -> 
    Log.debug "Gcache.remove failed !"
@

<<[[Viewers.display_info]] graphic cache virtual methods signatures>>=
method virtual di_destroy : unit	 (* die *)
@

<<[[Plain.plain]] graphic cache destroy methods>>=
method di_destroy = 
  if Winfo.exists frame 
  then Tk.destroy frame
@

<<[[Htmlw.display_html]] graphic cache destroy methods>>=
method di_destroy = 
  if Winfo.exists frame 
  then Tk.destroy frame;
@


<<[[Nav.t]] graphic cache related methods>>=
nav_id : int;  (* key for the gfx cache *)
@
<<[[Mmm.navigator()]] set nav fields>>=
nav_id = hist.h_key;
@

\section{Frames}
% move in earlier chapter when talking about the different tags,
% do its own section

% they are actually obsolete in html5!

<<signature [[Dtd.dtd32f]]>>=
val dtd32f : t
@
% with frame?
<<constant [[Dtd.dtd32f]]>>=
(* Add frames somwhere to dtd32.
 * Luckily we chose sets, and they are functional
 *)
let dtd32f =
  let dtd = {
    dtd_name = "HTML 3.2 + frames";
    contents = Hashtbl.create 101;
    open_omitted = dtd32.open_omitted;
    close_omitted = dtd32.close_omitted;
  } in
  let _omit_open el =
    dtd.open_omitted <- Elements.add el dtd.open_omitted in
  let omit_close el =
    dtd.close_omitted <- Elements.add el dtd.close_omitted in
  let add_elem = 
   Hashtbl.add dtd.contents in

  (* first : copy in the 3.2 contents *)
  Hashtbl.iter add_elem dtd32.contents;

  (* frameset and frames is pretty simple *)
  add_elem "frameset" (sol ["frameset"; "frame"; "noframes"]);
  add_elem "frame" Elements.empty;
  omit_close "frame";
  (* we say that noframes contains the same thing as body in 3.2 *)
  add_elem "noframes" (Hashtbl.find dtd.contents "body");
  (* and we say that frameset can occur in html *)
  let html_contents = Hashtbl.find dtd.contents "html" in
  Hashtbl.remove dtd.contents "html";
  add_elem "html" (Elements.add "frameset" 
             (Elements.add "noframes" html_contents));
  dtd
@

<<toplevel [[Dtd._2]]>>=
let _ = add dtd32f
@


\section{Fake CGI}

<<[[File.request()]] if CGI path>>=
if is_cgi path 
then (fake_cgi wr cont path; (fun () -> ()))
@

<<constant [[File.binary_path]]>>=
(* Pref stuff *)
let binary_path = ref ([] : string list)
@

<<function [[File.is_cgi]]>>=
let is_cgi file =
  match !binary_path with
  | [] -> false
  | path ->
      let l = String.length file in
      List.exists (fun dir ->
    let ldir = String.length dir in
    l > ldir && String.sub file 0 ldir = dir)
    path
(*
 * Display a file on the local unix file system (file:)
 *  is path really supposed to be absolute ?
 * Note: completely ignores method (GET, POST,...)
 *)
@


<<function [[File.fake_cgi]]>>=
(* Not true CGI interface, just a hack *)
(* TODO: headers ? *)
let fake_cgi wwwr cont path =
  try 
    let (cmd_in, cmd_out) = pipe() in
    let cmd, args = 
      try 
       let pos = String.index path '?' in
       let cmd = String.sub path 0 pos in
       if pos + 1 = String.length path 
       then cmd, [| cmd |]
       else cmd, [|cmd; String.sub path (pos+1) (String.length path - pos - 1)|]
      with Not_found -> path, [| path |] 
    in
    match Low.fork() with
    (* child *)
    | 0 -> 
        close cmd_in;
        dup2 cmd_out stdout; close cmd_out;
        begin 
          try execvp cmd args 
          with Unix_error(e, _, _) ->
            Munix.write_string stdout "HTTP/1.0 404 Not found\r\n";
            Munix.write_string stdout "Content-Type: text/html\r\n\r\n";
            Munix.write_string stdout "<H1>Cannot execute local file</H1>";
            Munix.write_string stdout "Command \"";
            Munix.write_string stdout cmd;
            Munix.write_string stdout "\" failed:";
            Munix.write_string stdout (Unix.error_message e);
            Munix.write_string stdout "\n";
            (* nosemgrep: do-not-use-exit *)
            exit 1
         end
   (* parent *)
   | _n ->
      close cmd_out;
      let dh = {document_id = document_id wwwr;
                document_referer = wwwr.www_link.h_context;
                document_status = 0;
                dh_headers = [];
                document_feed = Feed.make_feed cmd_in (Low.count_read (Unix.read cmd_in));
                document_fragment = wwwr.www_fragment;
                document_logger = Document.tty_logger} 
      in
      dh.document_feed.feed_schedule
        (fun () ->
           try
            if dh.dh_headers = [] then begin
            (* it should be the HTTP Status-Line *)
            let l = Low.read_line cmd_in in
              dh.document_status <- (Http_headers.parse_status l).status_code;
              dh.dh_headers <- [l] (* keep it there *)
            end
          else 
            dh.dh_headers <- 
              read_headers (Low.read cmd_in) dh.dh_headers
          with
           | End_of_headers ->
               dh.document_feed.feed_unschedule();
               cont.document_process dh
           | Not_found -> (* No HTTP/ header *)
               dh.document_feed.feed_unschedule();
               dh.document_status <- 200;
               dh.dh_headers <- ["Content-Type: text/plain"];
               cont.document_process dh
           | Unix_error(_,_,_) ->
               dclose true dh;
               raise (File_error (s_ 
                  "Error while reading headers of %s\n%s" path "(read)"))
           | Http_headers.Invalid_header s ->
               dclose true dh;
               raise (File_error (s_ 
                      "Error while reading headers of %s\n%s" path s))
           | End_of_file ->
               dclose true dh;
               raise (File_error (s_ 
                  "Error while reading headers of %s\n%s" path "eof"))
          )
  with Unix_error(_,_,_) -> 
    raise (File_error (s_ "cannot exec file"))
@



%alt: \section{Embedded objects}
% they are used for images and many things, can't be just
% postponed to an advanced topic

\section{Signals}

<<[[Main.main()]] signal handling>>=
Sys.catch_break true;
(* Avoid SIGPIPE completely, in favor of write() errors *)
Sys.set_signal Sys.sigpipe Sys.Signal_ignore;
@

%******************************************************************************
\chapter{Conclusion}
%******************************************************************************


%related: 
% - search engine, see http://queue.acm.org/detail.cfm?id=988407
%   and page/brin article on archi of Google



%###############################################################################
\appendix
%###############################################################################

%******************************************************************************
\chapter{Debugging}
%******************************************************************************

%less: split debugging and logging?

% for Log.debug, and postmortem
<<signature [[Log.debug_mode]]>>=
val debug_mode : bool ref
@
<<constant [[Log.debug_mode]]>>=
let debug_mode = ref true
@
% note that this is set also in the preferences, so the value
% here has no meaning unless you comment the relevant code in the prefs
% (C-s Log.debug_mode)

\section{Logging}
% this is not only for the developer here, it's also useful
% for the user

<<signature [[Log.f]]>>=
val f : string -> unit
@
% fatal? rename Log.print I think
<<function [[Log.f]]>>=
(* flushes ! *)
let f s = 
  try prerr_endline s 
  with _ -> ()
@


<<signature [[Log.debug]]>>=
val debug : string -> unit
@
<<function [[Log.debug]]>>=
let debug s = 
  if !debug_mode 
  then f s
@


\section{Postmortem}

<<[[Main.main()]] after event loop, if debug mode>>=
if !Log.debug_mode then begin
  Cache.postmortem();
  Gcache.postmortem()
end;
@
%less: could put that outside main actually,
% and below do main(); and this code. cleaner.


<<toplevel [[Main._1]]>>=
let _ = 
  Cap.main (fun (caps : Cap.all_caps) ->
    let argv = CapSys.argv caps in
    Exit.exit caps (Exit.catch (fun () -> postmortem caps argv)))
@

<<function [[Main.postmortem]]>>=
let postmortem (caps: < caps; Cap.stdout; Cap.stderr; ..>) 
               (argv : string array) : Exit.t =
  try 
    main caps argv
  with
  | Dynlink.Error err ->
      Logs.err (fun m -> m "dynlink error = %s" (Dynlink.error_message err));
      Exit.Code 1
  | Failure s ->
      Logs.err (fun m -> m "mmm: %s" s);
      Exit.Code 2
  | e -> 
      <<[[Main.main()]] after event loop, if debug mode>>
      raise e
@



<<signature [[Cache.postmortem]]>>=
val postmortem : unit -> unit
@
<<function [[Cache.postmortem]]>>=
(* Debugging *)
let postmortem () =
  Log.f (sprintf "Cache size(max): %d(%d)" !current !max_documents);
  !memory |> List.iter (fun (did, entry) ->
    Log.f (sprintf "%s(%d) %s"
            (Url.string_of did.document_url)
            did.document_stamp
            (match entry.cache_document.document_data with
             | MemoryData _ -> "in memory"
             | FileData (f,true) -> !!f
             | FileData (f,false) -> "fake " ^ !!f)
             );
    entry.cache_document.document_headers
    |> List.rev |> List.iter (fun h -> Log.f (sprintf "%s" h));

    if entry.cache_pending 
    then Log.f "pending ";

    Log.f (sprintf "Last used: %f" entry.cache_lastused);
    Log.f ""
  )
@


\section{Subsystems}

% flow of logging?

% Nav.nav_log (=~ loggingv label update) -> Viewer_context#log -> ???

\subsection{Requests}

% request is first alive entity!

%in retrieve.ml
%(* In all the following, we avoid popping up dialog boxes, and use
% * wwwr logging instead. Otherwise we might get too verbose for
% * in-lined images...
% *)

<<[[Www.request]] logging method>>=
mutable www_logging : string -> unit;	  (* logging *)
@
%todo: who sets it? nobody apparently ...

\subsection{Documents}

<<[[Document.handle]] other fields>>=
mutable document_logger : logger;
  (* how to log information relative to this document processing *)
@
% who sets that again?

<<signature type Document.logger>>=
(* pad: exported for tk_document, but normally should be abstract *)
type logger = {
  logger_destroy : bool -> unit;
  logger_progress : int -> unit;
  logger_msg : string -> unit;
  logger_end : string -> unit
}
@
\ifallcode
<<type [[Document.logger]]>>=
type logger = {
  logger_destroy : bool -> unit;
  logger_progress : int -> unit;
  logger_msg : string -> unit;
  logger_end : string -> unit
}
@
\fi

<<signature [[Document.tty_logger]]>>=
val tty_logger : logger
@

<<constant [[Document.tty_logger]]>>=
let tty_logger = 
  { logger_destroy = (fun _ -> ());
    logger_progress = (fun _ -> ());
    logger_msg = Log.f;
    logger_end = Log.f
   }
@

% who sets something more complex?



\subsection{HTML}

<<signature [[Html.verbose]]>>=
val verbose : bool ref
  (* verbose mode for HTML related stuff *)
@
<<constant [[Html.verbose]]>>=
let verbose = ref false
@

<<[[Htparse.html_lex()]] print token t if verbose>>=
if !verbose 
then begin 
   Html.print t; 
   flush stdout
end
@

<<signature [[Html.warning]]>>=
val warning : string -> location -> unit
@
% ??? -> <>
<<function [[Html.warning]]>>=
let warning s (Loc(n,m)) = 
  if !verbose then begin 
    eprintf "HTML Warning: %s at (%d, %d)\n" s n m;
    flush stderr
   end
@


<<signature [[Html_eval.debug]]>>=
(* HTML Evaluation *)
val debug : bool ref
@
<<constant [[Html_eval.debug]]>>=
let debug = ref false
@

% code using that? can be set via command line?

\subsection{HTTP}

<<constant [[Http.verbose]]>>=
let verbose = ref false
@

<<[[Http.async_request()]] log request string req if verbose>>=
if !verbose 
then Logs.debug (fun m -> m "%s" req);
@


\subsection{Caches}

<<signature [[Cache.debug]]>>=
(* Configurable settings *)
val debug : bool ref
@
<<constant [[Cache.debug]]>>=
let debug = ref false
@

% code using that? can be set via command line?

\subsection{Viewer}

<<[[Viewers.context]] logging methods signatures>>=
method virtual log : string -> unit
@
% usually nav.nav_log

\subsection{Scheduler}

<<signature [[Scheduler.debug]]>>=
val debug : bool ref
@
<<constant [[Scheduler.debug]]>>=
let debug = ref false
@

% who uses that?

\subsection{HTML display}

<<signature [[Html_disp.verbose]]>>=
val verbose : bool ref
@
<<constant [[Html_disp.verbose]]>>=
let verbose = ref false
@

\subsection{GUI}

% main -> <>
<<function [[Debug.init]]>>=
let init () =
  Frx_rpc.register "cb" active_cb;
  Frx_rpc.register "cache"
     (fun _ -> 
       Cache.postmortem();  
       Gcache.postmortem(); 
       flush stderr);
  Frx_rpc.register "images" (fun _ -> 
    Img.ImageData.dump(); 
    flush stderr);
  Frx_rpc.register "camltkdb" (fun _ -> 
    Protocol.debug := not !Protocol.debug)
@
% ????

<<function [[Debug.active_cb]]>>=
let active_cb _ =
  let cnter = ref 0 in
  Hashtbl.iter 
    (fun w id ->
      incr cnter;
      Printf.fprintf stdout "%s %s %b\n"
        (Widget.name w) (string_of_cbid id) (Winfo.exists w)  
    )
    callback_memo_table;
  Printf.fprintf stdout "Memo cb: %d\n" !cnter;
  cnter := 0;
  Hashtbl.iter (fun _ _ -> incr cnter) callback_naming_table;
  Printf.fprintf stdout "Active cb: %d\n" !cnter;
  flush stdout
@
% ???

\section{Dumpers}

\subsection{URLs}

<<signature [[Url.string_of_protocol]]>>=
val string_of_protocol: protocol -> string
  (* maps FTP to "ftp", etc... *)
@

<<function [[Url.string_of_protocol]]>>=
let string_of_protocol = function
 | FTP -> "ftp"
 | HTTP -> "http"
 | HTTPS -> "https"
 | GOPHER -> "gopher"
 | MAILTO -> "mailto"
 | NEWS -> "news"
 | NNTP -> "nntp"
 | TELNET -> "telnet"
 | WAIS -> "wait"
 | FILE -> "file"
 | PROSPERO -> "prospero"
 | OtherProtocol s -> s
@

<<signature [[Url.string_of]]>>=
(* These are used to get "normalized urls" *)
val string_of: t -> string
@


<<function [[Url.string_of]]>>=
let string_of (p : t) : string =
  let buf = Ebuffer.create 128 in
  let ws x = Ebuffer.output_string buf x in
  let wc x = Ebuffer.output_char buf x in
  let write_userpass () =
      match p.user, p.password with
         None, None -> ()
       | Some u, Some p -> ws u; wc ':'; ws p; wc '@'
       | Some u, None ->   ws u; wc ':'; wc '@'
       | None, Some _ -> failwith "url_of_parsed"
  in
  (* hostname is always put in lowercase *)
  let write_hostport def =
      match p.host, p.port with
         None, None -> ()
       | Some h, None -> ws (String.lowercase_ascii h)
       | Some h, Some p when p = def -> ws (String.lowercase_ascii h)
       | Some h, Some p -> 
           ws (String.lowercase_ascii h); wc ':'; ws (string_of_int p)
       | None, Some _ -> failwith "url_of_parsed"	    
  in
  let write_pathsearch () =
      match p.path, p.search with
        None, None -> wc '/'
      | Some p, Some s -> wc '/'; ws p; wc '?'; ws s
      | Some p, None -> wc '/'; ws p
      | None, Some _ -> failwith "url_of_parsed"	    
  in
  let write_slashpath () =
      match p.path with
       None -> ()
      | Some p -> wc '/'; ws p
  in
  let write_path () =
      match p.path with
       None -> ()
      | Some p -> ws p
  in
  let write_fhost () =
      match p.host with
       None -> ws "localhost"
      | Some h -> ws (String.lowercase_ascii h)
  in
  begin match p.protocol with
    FTP ->
      ws "ftp://"; write_userpass (); write_hostport 21; write_slashpath ()
  | HTTP ->
      ws "http://"; write_hostport 80; write_pathsearch ()
  | HTTPS ->
      ws "https://"; write_hostport 443; write_pathsearch ()
  | GOPHER ->
      ws "gopher://"; write_hostport 70; write_slashpath ()
  | MAILTO -> ws "mailto:"; write_path()
  | NEWS -> ws "news:"; write_path()
  | NNTP -> ws "nntp:"; write_hostport 119; write_path()
  | TELNET -> ws "telnet://"; write_userpass(); write_hostport 23
  | WAIS -> ws "wais://"; write_hostport 210; write_pathsearch()
  | FILE ->
    (* for file: we have to transform to ftp: if host is not localhost *)
    begin match p.host with
      None | Some "localhost" ->
        ws "file://"; write_fhost(); write_slashpath()
    | Some _h ->
       p.protocol <- FTP;
        ws "ftp://"; write_userpass (); write_hostport 21; write_slashpath ()
    end
  | PROSPERO -> ws "prospero://"; write_hostport 1525; write_slashpath()
  | OtherProtocol s -> ws s; ws ":"; write_path()
  end;
  Ebuffer.get buf
@

\subsection{Links}

<<signature [[Hyper.string_of]]>>=
val string_of : link -> string
  (* make an absolute URI (including fragment) from link 
     raises Invalid_link(msg) *)
@

<<function [[Hyper.string_of]]>>=
let string_of link =
  let uri = resolve link in
   match uri.uri_fragment with 
      None -> uri.uri_url
    | Some f -> Printf.sprintf "%s#%s" uri.uri_url f
@

\subsection{DTDs}

<<signature [[Dtd.dump]]>>=
val dump : t -> unit
@

<<function [[Dtd.dump]]>>=
let dump dtd =
  dtd.contents |> Hashtbl.iter (fun s contents -> 
      printf "Element %s %s %s\n" s 
             (if Elements.mem s dtd.open_omitted then "O" else "-")
             (if Elements.mem s dtd.close_omitted then "O" else "-");
      printf "Contains:";
      contents |> Elements.iter (fun e -> printf " %s" e);
      printf "\n"
  )
@

\subsection{HTML}

<<signature [[Html.print]]>>=
val print : token -> unit
  (* for debugging, prints an HTML token *)
@


<<function [[Html.print]]>>=
let print = function
    PCData s -> eprintf "PCData: %s\n" s
  | CData s -> eprintf "CData: %s\n" s
  | OpenTag {tag_name = n; attributes = l} ->
            eprintf "Open: %s\n" n;
         List.iter (function (a,v) ->
                   eprintf "%s=%s\n" a v) l
  | CloseTag n -> eprintf "Close: %s\n" n
  | Comment s -> eprintf "Comment: %s\n" s
  | Doctype s -> eprintf "Doctype: %s\n" s
  | EOF -> eprintf "EOF\n"
@

%******************************************************************************
\chapter{Profiling}
%******************************************************************************

%******************************************************************************
\chapter{Error Management}
%******************************************************************************

\section{[[Error.t]]}

<<signature [[Error.f]]>>=
val f : string -> unit
@
% ? fatal?
<<signature [[Error.ok]]>>=
val ok : string -> unit
@
<<signature [[Error.choose]]>>=
val choose : string -> bool
@
% ?
<<signature [[Error.ari]]>>=
val ari : string -> int
@
% ??

%note: I now use those functions instead of !Error.default#xxx 
% that they used to use everywhere. Error.f is far cleaner than
% using explicitly references and oo


<<signature class [[Error.t]]>>=
class virtual t : object
 method virtual f : string -> unit
 method virtual ok : string -> unit
 method virtual choose : string -> bool
 method virtual ari : string -> int
end
@
% why not simply use a record?

<<signature [[Error.default]]>>=
val default : t ref
@
<<constant [[Error.default]]>>=
let default = ref (new x)
@

<<functions [[Error.xxx]]>>=
let f msg = 
  !default#f msg
let ok msg = 
  !default#ok msg
let choose msg = 
  !default#choose msg
let ari msg = 
  !default#ari msg
@

<<class [[Error.t]]>>=
@

\section{Subsystems}

% flow of error?

% Nav.nav_error (=~ Tk_error) -> Www.www_error -> ???

\subsection{Requests}

% usually Nav.nav_error
<<[[Www.request]] error managment method>>=
mutable www_error : Error.t;
@


\section{Exceptions}

\subsection{URL}

<<exception [[Url.Url_Lexing]]>>=
exception Url_Lexing of string * int
@

<<exception [[Url.Invalid_url]]>>=
(*exception Invalid_url of t * string*)
@

\subsection{Links}

<<exception [[Hyper.Invalid_link]]>>=
exception Invalid_link of link_error
@

<<type [[Hyper.link_error]]>>=
type link_error =
  | LinkResolve of string
  | UrlLexing of string * int
@


\subsection{Web requests}

<<exception [[Www.Invalid_request]]>>=
exception Invalid_request of request * string
@

\subsection{HTML}

<<exception [[Html.Html_Lexing]]>>=
exception Html_Lexing of string * int
@

<<exception [[Html.Invalid_Html]]>>=
exception Invalid_Html of string
@


\subsection{HTTP}

<<exception [[Http_headers.Invalid_HTTP_header]]>>=
exception Invalid_header of string
@

<<exception [[Http.HTTP_error]]>>=
exception HTTP_error of string
@


%******************************************************************************
\chapter{A Preferences Library}
%******************************************************************************
% actually it's from Tk

%******************************************************************************
\chapter{Standard Library}
%******************************************************************************
%alt: (Not so) Standard Library

%<<constant Common.spf>>=
%let spf = Printf.sprintf
%@
%
%<<function Common.TODOOPERATOR>>=
%let (|>) o f = f o
%@
% in unlpized common.ml (copy pasted from pfff) now

\section{Lists}

<<signature [[Mlist.hdn]]>>=
(* List utilities *)
val hdn : 'a list -> int -> 'a list
   (* [hdn [a1;a2;...;an;...; ak] returns [a1;a2;...;an] *)
@

<<signature [[Mlist.tln]]>>=
val tln : 'a list -> int -> 'a list
   (* [tln [a1;a2;...;an;...; ak] returns [an+1;...; ak] *)
@

<<signature [[Mlist.except_assoc]]>>=
val except_assoc: 'a -> ('a * 'b) list -> ('a * 'b) list
@

<<signature [[Mlist.exceptq]]>>=
val exceptq: 'a -> 'a list -> 'a list
@

<<signature [[Mlist.rev_do_list]]>>=
val rev_do_list : ('a -> unit) -> 'a list -> unit
@

<<signature [[Mlist.do_listi]]>>=
val do_listi : (int -> 'a -> unit) -> int -> 'a list -> unit
@




<<function [[Mlist.tln]]>>=
(* tln l n *)
let rec tln l = function
   0 -> l
 | n -> if l = [] then [] else tln (List.tl l) (pred n)
@

<<function [[Mlist.hdn]]>>=
let hdn l =
  let rec h l acc = function
    0 -> List.rev acc
  | n -> if l = [] then List.rev acc 
        else h (List.tl l) (List.hd l :: acc) (pred n) in
  h l []
@

<<function [[Mlist.except_assoc]]>>=
let except_assoc x =
  let rec ex acc = function 
      [] -> acc
    | (y,_v)::l when x = y -> ex acc l
    | z :: l -> ex (z::acc) l
  in
  ex []
@

<<function [[Mlist.exceptq]]>>=
let exceptq x =
  let rec ex acc = function
     [] -> acc
   | y::l when y == x -> ex acc l
   | y::l -> ex (y::acc) l
  in
  ex []
@

<<function [[Mlist.rev_do_list]]>>=
(* List.iter from right to left *)
let rev_do_list f = 
 let rec do_list_f = function
     [] -> () | x::l -> do_list_f l; f x in
  do_list_f
@

<<function [[Mlist.do_listi]]>>=
let rec do_listi f n l =
  match l with
    [] -> ()
  | (x::l) -> f n x; do_listi f (succ n) l
@

\section{Strings}

<<signature [[Mstring.split_str]]>>=
(* String utilities *)
val split_str : (char -> bool) -> string -> string list
@

<<signature [[Mstring.get_suffix]]>>=
val get_suffix : string -> string
@

<<signature [[Mstring.hex_to_dec]]>>=
val hex_to_dec : char -> int
@

<<signature [[Mstring.dec_to_hex]]>>=
val dec_to_hex : int -> char
@

<<signature [[Mstring.hex_to_string]]>>=
val hex_to_string : string -> string
@

<<signature [[Mstring.gensym]]>>=
val gensym : string -> string
@

<<signature [[Mstring.egensym]]>>=
val egensym : string -> unit -> string
@

<<signature [[Mstring.rem_trailing_sp]]>>=
val rem_trailing_sp : string -> string
@

<<signature [[Mstring.catenate_sep]]>>=
val catenate_sep : string -> string list -> string
@

<<signature [[Mstring.norm_crlf]]>>=
val norm_crlf : bool -> string -> int -> int -> string * bool
    (* [norm_crlf last_was_cr buf offs len] returns
       buf with CRLF/CR/LF converted to LF, and a flag indicating
       whether last char was CR *)
@




<<function [[Mstring.split_str]]>>=
(* split a string according to char_sep predicate *)
let split_str char_sep str =
  let len = String.length str in
  if len = 0 then [] else
    let rec skip_sep cur =
      if cur >= len then cur
      else if char_sep str.[cur] then skip_sep (succ cur)
      else cur  in
    let rec split beg cur =
      if cur >= len then 
    if beg = cur then []
    else [String.sub str beg (len - beg)]
      else if char_sep str.[cur] 
       then 
         let nextw = skip_sep cur in
          (String.sub str beg (cur - beg))
        ::(split nextw nextw)
       else split beg (succ cur) in
    let wstart = skip_sep 0 in
    split wstart wstart
@

<<function [[Mstring.get_suffix]]>>=
(* extract the . suffix (dot excluded) of a string *)
let get_suffix s =
  try
    let dotpos = succ (String.rindex s '.') in
      String.sub s dotpos (String.length s - dotpos)
  with
    Not_found -> ""
@

<<function [[Mstring.hex_to_dec]]>>=
(* HEX/DEC conversions *)
let hex_to_dec c = match c with
    '0'..'9' -> Char.code c - 48
  | 'a'..'f' -> Char.code c - 87 (* 87 = Char.code 'a' - 10 *)
  | 'A'..'F' -> Char.code c - 55 (* 55 = Char.code 'A' - 10 *)
  | _ -> failwith "hex_to_dec"
@

<<function [[Mstring.dec_to_hex]]>>=
let dec_to_hex i =
  if i < 10 then Char.chr (i + 48)  (* 48 = Char.code '0' *)
  else Char.chr (i + 55)            (* 55 = Char.code 'A' - 10 *)
@

<<function [[Mstring.hex_to_string]]>>=
(* Converting a hex stored string *)
let hex_to_string s =
  let len = String.length s / 2 in
  let res = Bytes.create len in
    for i = 0 to len - 1 do
      Bytes.set res i (Char.chr ( 16 * (hex_to_dec s.[i+i]) + hex_to_dec s.[i+i+1]));
      done;
    Bytes.to_string res
@

<<constant [[Mstring.gensym]]>>=
let gensym =
  let cnter = ref 0 in
  (fun n ->
    incr cnter;
    n ^ string_of_int !cnter)
@

<<function [[Mstring.egensym]]>>=
let egensym s =
  let cnter = ref 0 in
  (fun () ->
    incr cnter;
    s ^ string_of_int !cnter)
@

<<function [[Mstring.rem_trailing_sp]]>>=
let rem_trailing_sp s =
  let l = String.length s in
  let pos = ref (l - 1) in
  while !pos >= 0 && List.mem s.[!pos] [' '; '\t'] do decr pos done;
  if !pos = l - 1 then s
  else String.sub s 0 (succ !pos)
@

<<function [[Mstring.catenate_sep]]>>=
let catenate_sep sep =
  function 
      [] -> ""
    | x::l -> List.fold_left (fun s s' -> s^sep^s') x l
@

<<function [[Mstring.norm_crlf]]>>=
(* Filters CRLF:
 *  CR -> LF
 *  CRLF -> LF
 *  LF -> LF
 * We do this on successive chunks of a stream, so we need to consider
 * the case when the chunk finishes on CR.
 * Assume len > 0
 *)

let norm_crlf lastwascr buf offs len =
  let rpos = ref offs
  and wpos = ref 0
  and dest = Bytes.create (len + 1) (* we need one more char *)
  and limit = offs + len - 1  
  and lastiscr = ref false in
  if lastwascr then
    if buf.[!rpos] = '\n' then begin
      Bytes.set dest !wpos '\n';
      incr rpos; incr wpos
    end
    else begin
      Bytes.set dest !wpos '\n'; incr wpos
    end;

  while !rpos < limit do
    match buf.[!rpos] with
      '\n' -> Bytes.set dest !wpos '\n'; incr rpos; incr wpos
    | '\r' -> 
    if buf.[!rpos + 1] = '\n'
    then begin Bytes.set dest !wpos '\n'; rpos := !rpos + 2; incr wpos end
    else begin Bytes.set dest !wpos '\n'; incr rpos; incr wpos end
    | c -> Bytes.set dest !wpos c; incr rpos; incr wpos 
  done;
  begin match buf.[offs+len-1] with
    '\n' -> Bytes.set dest !wpos '\n'; incr wpos
  | '\r' -> lastiscr := true
  | c -> Bytes.set dest !wpos c; incr wpos
  end;
  Bytes.sub_string dest 0 !wpos, !lastiscr
@

\section{Extensible buffers}

%todo: replaced with the one in ocaml? buffer.mli

<<signature [[Ebuffer.create]]>>=
val create : int -> t
  (* [create n] creates a buffer with initial size [n] *)
@

<<signature [[Ebuffer.output_string]]>>=
val output_string : t -> string -> unit
  (* [output_string buf s] appends [s] to [buf] *)
@

<<signature [[Ebuffer.output_char]]>>=
val output_char : t -> char -> unit
  (* [output_char buf c] appends [c] to [buf] *)
@

<<signature [[Ebuffer.output]]>>=
val output : t -> string -> int -> int -> unit
  (* [output buf s offs len] appends [len] characters of [s], starting
     at offset [offs] to [buf].
     Raises [Invalid_argument] if [offs] and [len] do not designate a
     valid substring of [s] *)
@

<<signature [[Ebuffer.get]]>>=
val get : t -> string
  (* [get buf] returns the current contents of [buf] *)
@

<<signature [[Ebuffer.used]]>>=
val used : t -> int
  (* [used buf] returns the current length of [buf] *)
@

<<signature [[Ebuffer.reset]]>>=
val reset : t -> unit
  (* [reset buf] emties [buf] *)  
@

<<signature [[Ebuffer.t]] abstract>>=
type t 
@


<<type [[Ebuffer.t]]>>=
(* Extensible buffers *)
type t = {
    mutable buffer : bytes;
    mutable pos : int;
    mutable len : int}
@

<<function [[Ebuffer.create]]>>=
let create n = {
   buffer = Bytes.create n;
   pos = 0;
   len = n
   }
@

<<function [[Ebuffer.reset]]>>=
let reset buf =
    buf.pos <- 0
@

<<function [[Ebuffer.newsize]]>>=
let newsize old added =
  if added < old then old + old
  else old + old + added
@

<<function [[Ebuffer.output_string]]>>=
let output_string buf s =
  let l = String.length s in
  if buf.pos + l > buf.len then begin
    let size = newsize buf.len l in
    let news = Bytes.create size in
      Bytes.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  Bytes.unsafe_blit_string s 0 buf.buffer buf.pos l;
  buf.pos <- buf.pos + l
@

<<function [[Ebuffer.output_char]]>>=
let output_char buf c =
  if buf.pos >= buf.len then begin
    let size = newsize buf.len 1 in
    let news = Bytes.create size in
      Bytes.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  Bytes.set buf.buffer buf.pos c;
  buf.pos <- buf.pos + 1
@

<<function [[Ebuffer.output]]>>=
let output buf s ofs l =
  if buf.pos + l > buf.len then begin
    let size = newsize buf.len l in
    let news = Bytes.create size in
      Bytes.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  String.blit s ofs buf.buffer buf.pos l;
  buf.pos <- buf.pos + l
@

<<function [[Ebuffer.get]]>>=
let get buf = 
  Bytes.sub_string buf.buffer 0 buf.pos
@

<<function [[Ebuffer.used]]>>=
let used buf =
  buf.pos
@


\section{Files}

<<signature [[Msys.tilde_subst]]>>=
val tilde_subst : string -> string
    (* substitute ~ at beginning of file path *)
@

<<signature [[Msys.rm]]>>=
val rm: string -> unit
    (* quiet unlink *)
@

<<signature [[Msys.fsize]]>>=
val fsize: string -> int
    (* file size *)
@

<<signature [[Msys.mktemp]]>>=
val mktemp : string -> string
@

<<function [[Msys.next_slash]]>>=
(* skip to next / *)
let rec next_slash s n =
  if  n >= String.length s || s.[n] = '/' 
  then n
  else next_slash s (succ n)
@

<<function [[Msys.tilde_subst]]>>=
let tilde_subst s =
 try
  if s = "" || s.[0] <> '~' then s 
  else
    let len = String.length s in
    if len = 1 then Sys.getenv "HOME"
    else match s.[1] with
      '/' -> 
        Filename.concat (Sys.getenv "HOME") (String.sub s 2 (len - 2))
     | _ ->
       let final = next_slash s 1 in
       let user = String.sub s 1 (pred final) in
       let pwnam = getpwnam user in
         if succ final >= len then pwnam.pw_dir
         else
          Filename.concat pwnam.pw_dir 
               (String.sub s (succ final) (len - (succ final)))
 with
    Unix_error(_,_,_) -> s
  | Sys_error _ -> s
  | Not_found -> s
@

<<function [[Msys.rm]]>>=
(* Quiet unlink *)
let rm s = try unlink s with Unix_error _ -> ()
@

<<function [[Msys.rmdir]]>>=
let rmdir dir =
  try
    let dh = opendir dir 
    and l = ref [] in
    try while true do
      let f = readdir dh in
      if f <> "." && f <> ".." then l := f :: !l
    done
    with
      End_of_file -> 
    closedir dh;
    List.iter (fun f -> rm (Filename.concat dir f)) !l;
    Unix.rmdir dir
  with
    Unix_error _ -> ()
@

<<function [[Msys.fsize]]>>=
let fsize f =
  try (Unix.stat f).st_size
  with Unix_error(_,_,_) -> raise Not_found
@

<<constant [[Msys.tmp_dir]]>>=
let tmp_dir = ref "/tmp"
@

<<constant [[Msys.mktemp]]>>=
(* We know use our own private directory in /tmp, cleared at exit-time,
   so no one can snoop our temporary files *)
let mktemp =
  let cnter = ref 0 
  and pid = Unix.getpid() 
  and id = ref 0 in
  let thisdir = 
    let testdir = ref "" in
    try while true do
      testdir := Filename.concat !tmp_dir ("mmm" ^ string_of_int pid
                         ^ "_" ^ string_of_int !id);
      if not (Sys.file_exists !testdir) then raise Exit;
      incr id;
      if !id >= 16 then 
    raise (Failure ("Too many MMM temporary directory in " ^ !tmp_dir ^
            ". Clean them first."))
    done; "" (* cannot reach *)
    with
      Exit -> !testdir
  in
  Unix.mkdir thisdir 0o700;
  at_exit (fun () -> rmdir thisdir);
  (function prefx -> 
      incr cnter; 
      (Filename.concat thisdir (prefx ^ string_of_int !cnter)))
@


\section{Dates}


<<signature [[Date.asc_wkday]]>>=
val asc_wkday : int -> string
    (* [asc_wkday n] maps 0..6 to Sun..Sat *)
@

<<signature [[Date.asc_month]]>>=
val asc_month : int -> string
    (* [asc_month n] maps 0..11 to Jan..Dec *)
@

<<signature [[Date.asc]]>>=
val asc : float -> string
    (* [asc uxtime] RFC822 of unix time *)
@

<<signature [[Date.asc_now]]>>=
val asc_now : unit -> string
    (* [asc_now ()] RFC822 of now *)
@

<<signature [[Date.commonlog]]>>=
val commonlog : float -> string
  (* Text version (Common log format) of an Unix time value *)
@

<<signature [[Date.compare_time]]>>=
val compare_time : int list * int list -> int
    (* [compare_time l1 l2] compare lists encodings of timestamps
       Encoding must be:
        [year; month; mday; hour; min; sec]
     *)
@



<<function [[Date.asc_wkday]]>>=
let asc_wkday = function
   0 -> "Sun"
 | 1 -> "Mon"
 | 2 -> "Tue"
 | 3 -> "Wed"
 | 4 -> "Thu"
 | 5 -> "Fri"
 | 6 -> "Sat"
 | _ -> assert false
@

<<function [[Date.asc_month]]>>=
let asc_month = function
   0 -> "Jan"
 | 1 -> "Feb"
 | 2 -> "Mar"
 | 3 -> "Apr"
 | 4 -> "May"
 | 5 -> "Jun"
 | 6 -> "Jul"
 | 7 -> "Aug"
 | 8 -> "Sep"
 | 9 -> "Oct"
 | 10 -> "Nov"
 | 11 -> "Dec"
 | _ -> assert false
@

<<function [[Date.asc]]>>=
(* Produces RFC822 style *)
let asc ut =
  let tm = gmtime ut in
    sprintf "%s, %02d %s %d %02d:%02d:%02d GMT"
        (asc_wkday tm.tm_wday)
    tm.tm_mday
    (asc_month tm.tm_mon)
    (tm.tm_year + 1900)
    tm.tm_hour
    tm.tm_min
    tm.tm_sec
@

<<function [[Date.asc_now]]>>=
let asc_now () = asc (time())
@

<<function [[Date.commonlog]]>>=
(* Timezone ??? *)
let commonlog int =
  let tm = localtime int in
  sprintf "%02d/%s/%d:%02d:%02d:%02d"
      tm.tm_mday
      (asc_month tm.tm_mon)
      (tm.tm_year + 1900)
      tm.tm_hour
      tm.tm_min
      tm.tm_sec
@

<<function [[Date.compare_time]]>>=
let rec compare_time = function
   [], [] -> 0
 | (x::xx), (y::yy) when x = y -> compare_time (xx, yy)
 | (x::_), (y::_) when x < y -> -1
 | (x::_), (y::_) when x > y -> 1
 |  _, _ -> assert false
@



%******************************************************************************
\chapter{Extra Code}
%******************************************************************************

#include "mmm_extra.nw"


%\chapter*{Changelog}
%\label{sec:changelog}

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
URL  = Uniform Resource Locator
URI  = Universal Resource Identifier
HTML =
DOM  = Document Object Model
CSS  = Cascading Style Sheets
JS   = Javascript
HTTP =
WWW  = World Wide Web
MIME = Multi-Purpose Internet Mail Extensions

DID  = Document IDentifier
WR   = Web Request
WWWR = Web Request
\end{verbatim}


\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Indexes}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex



%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

% see mmm-gdr-fr.ps biblio, main RFCs are there.

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************
\end{document}
