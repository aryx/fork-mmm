\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - deadcode?

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps (ocaml linker enforces that)
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand web browsers?:
% - ??

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Web Browser [[mmm]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2015 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a web browser.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% chose mmm, written in ocaml, small, elegant.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item mosaic
% maybe good. LOC?
\item gecko (firefox)
% huge
\item khtml/webkit/blink (kconqueror, chrome, safari)
% huge
\item hubhub
%... was used originally by servo
\item servo
% already lots of LOC actually
% https://github.com/servo/servo/wiki/Design
\end{itemize}

% see wikipedia page on history of web browser, pretty good,
% I have it printed.
%todo: my todo-browser/ somewhere

%https://github.com/servo/servo/wiki/Relevant-spec-links

%http://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from MMM, so
those parts are copyright by INRIA.
The prose is mine and is licensed under the GNU Free Documentation
License.

<<copyright header v6>>=
(***********************************************************************)
(*                                                                     *)
(*                           The V6 Engine                             *)
(*                                                                     *)
(*          Francois Rouaix, projet Cristal, INRIA Rocquencourt        *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)
@

\section{Acknowledgments}

I would like to thank of course Francois Rouaix,
the main author of MMM.


\chapter{Overview}

\section{Web browser principles}

% before seing the browser, first expose web principles: world wide web.
% a "web" of interconnected machines with:
%  - html documents (and associated pictures sometimes)
%  - URL to reference a document, a document containing itself possible links
%    to other documents
%  - http protocol to fetch the document
%  - client/server around this protocol

% a web browser is than a special kind of interface on top of that:
% a navigator interface! (history, forward, click etc)

% see mmm-gdr-fr.ps

\section{[[mmm]] services}


<<constant Version.number>>=
(* Version *)
let number = 418
@


<<function Version.about>>=
(* dialog uses an gigantic font ! *)
let about = function
  | "iso8859" ->
"MMM Version 0." ^ version_number ^
"\nWritten by Fran\231ois Rouaix
Contributions by Jun P. Furuse and Jacques Garrigue
Ported to O'Caml 3 by Jun P. Furuse and Pierre Weis
\169 Copyright INRIA

Projet Cristal
INRIA Rocquencourt
Domaine de Voluceau
78153 Le Chesnay Cedex
France

Francois.Rouaix@inria.fr
http://pauillac.inria.fr/~rouaix/
"
  | "ja" -> "\027$B$b!A\027(B Version 0." ^ version_number ^
"\n\027$B:n<T\027(B: Fran\231ois Rouaix
\027$BF|K\\8l2=<T\027(B: \027$B8E@%\027(B \027$B=_\027(B
\027$B4sM?\027(B: \027$B2mMx2l\027(B \027$B<f6j\027(B
O'Caml 3 \027$B$X$N0\\?\"\027(B: \027$B8E@%\027(B \027$B=_!\"\027(B Pierre Weis
\169 Copyright INRIA

Projet Cristal
INRIA Rocquencourt
Domaine de Voluceau
78153 Le Chesnay Cedex
France

Francois.Rouaix@inria.fr
http://pauillac.inria.fr/~rouaix/

Jun.Furuse@inria.fr
http://pauillac.inria.fr/~furuse/
"
  | _ -> assert false
@


\section{HTML document language}

\section{[[hello.html]]}

<<function Version.html>>=
let html = function
  | "iso8859" ->
"<HTML><HEAD><TITLE>MMM 0." ^ version_number ^ "</TITLE></HEAD>
<BODY>
<H1> The MMM navigator Version 0." ^ version_number ^ "</H1>
<H2 ALIGN=CENTER> Written by Fran\231ois Rouaix </H2>
<H2 ALIGN=CENTER> Contributions by Jun P. Furuse and Jacques Garrigue</H2>
<H3 ALIGN=CENTER> Port to O'Caml V3.0 by Jun P. Furuse and Pierre Weis</H3>
<H2 ALIGN=CENTER> \169 Copyright INRIA </H2>

<H4 ALIGN=CENTER> Using Objective Caml \169 Copyright INRIA </H4>
<H4 ALIGN=CENTER> And Tcl8.0/Tk8.0 (John Ousterhout and al.)<BR>
 \169 Copyright The Regents of the University of California<BR>
 and Sun Microsystems, Inc </H4>
<BLOCKQUOTE>
Please note that the software is a product currently being developed.
INRIA shall not be responsible in any way concerning conformity, and in
particular shall not be liable should the software not comply with the
requirements of the user, INRIA not being obliged to repair any
possible direct or indirect damage.
</BLOCKQUOTE>
<P>
The MMM home page is 
<A HREF=\"http://pauillac.inria.fr/mmm/\">here</A>,
and there is also some
<A HREF=\"http://pauillac.inria.fr/mmm/doc.html\">documentation</A>
and
<A HREF=\"http://pauillac.inria.fr/mmm/releases.html\">release notes</A>.
<BR>
Join the author by clicking
<A HREF=\"mailto:Francois.Rouaix@inria.fr\">here.</A>
<P>
<BLOCKQUOTE>
This document is included in your browser. Click on <TT>Reload</TT> to
get an updated copy.
</BLOCKQUOTE>
</BODY>
</HTML>
"
| "ja" -> "<HTML><HEAD><TITLE>MMM 0." ^ version_number ^ "</TITLE></HEAD>
<BODY>
<H1> \027$B%J%S%2!<%?\027(B \027$B$b!A\027(B Version 0." ^ version_number ^ "</H1>
<H2> \027$B:n<T\027(B \027$B!'\027(B Fran&ccedil;ois Rouaix </H2>
<H2> \027$BF|K\\8l2=<T\027(B \027$B!'\027(B \027$B8E@%\027(B \027$B=_\027(B </H2>
<H2> \027$B4sM?\027(B \027$B!'\027(B \027$B2mMx2l\027(B \027$B<f6j\027(B </H2>
<H2> O'Caml 3 \027$B$X$N0\\?\"\027(B: \027$B8E@%\027(B \027$B=_!\"\027(B Pierre Weis </H2>
<H2> &copy; Copyright INRIA (\027$BJ)9q9qN)>pJs<+F02=8&5f=j\027(B) </H2>

<H3> \027$B;HMQ%=%U%H%&%'%\"\027(B </H3>
<H3> Objective Caml &copy; Copyright INRIA </H3>
<H3> Tcl8.0/Tk8.0 (John Ousterhout and al.) &copy; Copyright The Regents of the University of California and Sun Microsystems, Inc </H3>
<BLOCKQUOTE>
\027$B$3$N%=%U%H%&%'%\"$K4X$7$F\027(BINRIA \027$B$O$$$+$J$k7A<0$N@UG$$bIi$$$^$;$s!#\027(B
\027$BFC$K!\"$3$N%=%U%H%&%'%\"$r%f!<%6!<$NI,MW$KJ;$;$k5AL3!\"\027(B
\027$B$^$?;HMQ$7$F@8$8$?$$$+$J$kD>@\\E*$^$?$O4V@\\E*Ho32$N@UG$$bIi$$$+$M$^$9!#\027(B
</BLOCKQUOTE>
<P>
\027$B$b!A$N%[!<%`%Z!<%8$O\027(B
<A HREF=\"http://pauillac.inria.fr/mmm/jmmm/\">\027$B$3$3\027(B</A>\027$B!\"\027(B
\027$B$b!A$N1Q8l$G=q$+$l$?%*%j%8%J%k$N%[!<%`%Z!<%8$O\027(B
<A HREF=\"http://pauillac.inria.fr/mmm/\">\027$B$3$3\027(B</A>\027$B$G$9!#\027(B
<BR>
\027$B6=L#$,$\"$kJ}$O\027(B
<A HREF=\"mailto:Jun.Furuse@inria.fr\">\027$B$3$3\027(B</A>
\027$B$r2!$7$F3+H/$K;22C$7$F2<$5$$!#\027(B
<P>
<BLOCKQUOTE>
\027$B$3$NJ8=q$O%V%i%&%6$KFbB\"$5$l$F$$$^$9!#\027(B<TT>\027$B:FFI\027(B</TT> \027$B$r2!$7$F0lHV?7$7$$J*$r<hF@$7$F2<$5$$!#\027(B
</BLOCKQUOTE>
</BODY>
</HTML>
"
  |  _ -> assert false
@
%$


\section{CSS style language}

\section{[[hello.css]]}

\section{Javascript dynamic language}

\section{[[hello.js]]}

\section{Code organization}

% commons/: utilities
% globals/: config
% www http html: main formats, parsing
% protocols retrieve viewers: fetching stuff
% display: display engine
% gui: interface

% skipped for now: i18n/japan/ applets/ sandbox/ crcs/ demos/ extensions/

\section{Software architecture}

\section{Trace of a mouse click}

% see mmm-gdr-fr.ps
% mouse click -> fetch doc (async), wait server, header parsing, 
%  adequat viewer, 

%###############################################################################

\chapter{Core Data Structures}

\section{DOM}

\section{Request}

\subsection{URIs}

<<type Uri.abs_uri>>=
(* URI utilities. RFC 1630 *)

type abs_uri = {
   uri_url : string;
   uri_frag : string option
 }
@

<<signature Uri.is_absolute>>=
val is_absolute : string -> bool
   (* [is_absolute uri] determines if [uri] is absolute according to
      rules of RFC 1630 *)
@

<<function Uri.is_absolute>>=
(* RFC 1630, partial forms *)
let is_absolute uri =
  try
    let colonpos = String.index uri ':' in
    try 
      let slashpos = String.index uri '/' in
       colonpos < slashpos (* colon must occur before slash *)
    with
      Not_found -> true (* colon occurs before slash *)
  with
    Not_found -> false (* absolute must have a : *)
@

\subsection{URLs}

<<type Url.protocol>>=
(* URLs as defined by RFC 1738 *)

type protocol =
 | HTTP 
 | FILE | MAILTO | FTP
 | GOPHER | NEWS | NNTP | WAIS
 | TELNET 
 | PROSPERO
 | OtherProtocol of string
@

<<type Url.t>>=
(* Relative adressing in anchors, fragments are NOT URLs, but URI *)
type t = 
  { mutable protocol : protocol;

    mutable user : string option;
    mutable password: string option;

    mutable host : string option;
    mutable port : int option;

    mutable path : string option;

    mutable search: string option
  }
@
%(* Not all components are used for all protocols *)


<<signature Url.distant_path>>=
(* For http. The thing we have to send in the request *)
val distant_path : t -> string
@

<<function Url.distant_path>>=
(* For http only *)
let distant_path urlp =
  match urlp.path, urlp.search with
     None, None -> "/"
   | Some p, None -> "/"^p
   | Some p, Some s -> "/"^p^"?"^s
   | None, Some s -> "/?" ^ s (* ??? *)
@

\subsection{Hypertext Links}

<<type Hyper.link>>=
type link = {
  h_uri : string;
  h_context: string option;
  h_method : link_method;		(* default is GET *)
  h_params : (string * string) list
  }
@

<<type Hyper.link_method>>=
(* Contains only the one we support *)
type link_method =
   GET 
 | HEAD
 | POST of string
@

<<signature Hyper.urlconcat>>=
val urlconcat: Url.t -> string -> string
   (* [urlconcat url relurl] resolves the relative URL [relurl] in the
       context of the URL [url]
      Doesn't handle fragments
    *)
@

<<signature Hyper.resolve>>=
val resolve : link -> Uri.abs_uri
  (* raises Invalid_link(msg) *)
@


<<function Hyper.urlconcat>>=
(* NO FRAGMENT HANDLING *)

let urlconcat contextp newuri =
  let l = String.length newuri in 
    if l = 0 then string_of contextp 
    else if l > 2 & newuri.[0] = '/' & newuri.[1] = '/' then
      (* this is probably a gopher relative uri *)
      sprintf "%s:%s" (string_of_protocol contextp.protocol) newuri
    else if newuri.[0] = '/' then (* start from root *)
      string_of {
        protocol = contextp.protocol;
     user = contextp.user;
     password = contextp.password;
        host = contextp.host;
        port = contextp.port;
     path = Some (Urlenc.unquote 
                (String.sub newuri 1 (String.length newuri - 1)));
     search = None }
    else if newuri.[0] = '?' then (* change only search part *)
      string_of {
        protocol = contextp.protocol;
     user = contextp.user;
     password = contextp.password;
        host = contextp.host;
        port = contextp.port;
     path = contextp.path;
     search = Some (String.sub newuri 1 (String.length newuri - 1))}
    else 
      let pathpart,searchpart =
    try
      let n = String.index newuri '?' in
      String.sub newuri 0 n,
      Some (String.sub newuri (n+1) (l - n - 1))
    with
      Not_found -> newuri, None
      in
      match contextp.path with
      None | Some "" -> 
        string_of {
        protocol = contextp.protocol;
        user = contextp.user;
        password = contextp.password;
        host = contextp.host;
        port = contextp.port;
        path = Some (Urlenc.unquote (Lexurl.remove_dots pathpart));
        search = searchpart}
    | Some old ->
        (* only the "dirname" part of the context path is important *)
        (* e.g  .../d/e/f becomes /d/e/ *)
       let path = sprintf "%s/%s" (Filename.dirname old) pathpart in
        (* we then have to remove dots *)
    let reduced = Lexurl.remove_dots path in
        string_of {
        protocol = contextp.protocol;
        user = contextp.user;
        password = contextp.password;
        host = contextp.host;
        port = contextp.port;
        path = Some (Urlenc.unquote reduced);
        search = searchpart}
@

<<function Hyper.resolve>>=
(* Produces an URL *)
let resolve link =
  (* First remove the possible fragment of the uri *)
  let newuri, frag =
    try
      let pos = String.index link.h_uri '#' in
       String.sub link.h_uri 0 pos, 
        Some (String.sub link.h_uri (succ pos) 
                    (String.length link.h_uri - pos - 1))
    with
        Not_found -> link.h_uri, None 
  in
  if Uri.is_absolute newuri then
    try
     {uri_url = Lexurl.normalize newuri;
      uri_frag = frag}
    with
      Url_Lexing _ ->
    raise (Invalid_link
              (LinkResolve (I18n.sprintf "not a legal absolute uri")))

  else begin (* It is a relative uri *)
    let context =
      match link.h_context with 
     None -> 
      raise (Invalid_link (LinkResolve (I18n.sprintf 
                  "no context and not an absolute url")))
       | Some c -> c in

    let contextp = 
       try Lexurl.maken context
       with
    Url_Lexing (err,pos) ->
     raise (Invalid_link (UrlLexing (err,pos)))
       in
    {uri_url = urlconcat contextp newuri;
     uri_frag = frag}
     end
@


\subsection{Request}

<<type Www.request>>=
(*
 * Requests
 *)

type request =  { 
    www_link : Hyper.link;        (* the link that produced this request *)
    www_url : Url.t;	          (* parsed version *)
    www_fragment : string option; (* because viewer is passed down *)

    mutable www_auth : (string * string) list;  (* basic auth *)
    mutable www_headers : string list;		  (* additional headers *)
    mutable www_logging : string -> unit;	  (* logging *)
    mutable www_error : Error.t
  }
@

<<signature Www.make>>=
val make : Hyper.link -> request
  (* raises: 
      Url_Lexing
      Invalid_link
   *)
@


<<constant Www.sp>>=
let sp = Str.regexp "[ \t\n]"
@

<<function Www.make>>=
let make hlink =
  let absuri = Hyper.resolve hlink in 
  let url = Lexurl.make absuri.uri_url in
  try (* search for space in network URI *)
    if List.mem url.protocol [FILE; MAILTO] then raise Not_found
    else
      let n = Str.search_forward sp absuri.uri_url 0 in
      raise (Hyper.Invalid_link (Hyper.UrlLexing ("suspicious white space", n)))
  with
    Not_found -> {
      www_link = hlink;
      www_url = url; (* should not fail ? *)
      www_fragment = absuri.uri_frag;
      www_auth = [];
      www_headers = [];
      www_logging = (fun _ -> ());
      www_error = Error.default
    }
@


\subsection{Document}

<<type Document.document_id>>=
(* Document Id is a reference to a document in the browser.
   For some documents, e.g. results of POST queries, the URL is not a
   sufficient description. Stamp is 0 for unique documents.
*)
type document_id = {
  document_url : Url.t;
  document_stamp : int
  }
@

<<signature Document.no_stamp>>=
val no_stamp : int
@

<<signature Document.new_stamp>>=
val new_stamp : unit -> int
@


<<constant Document.stamp_counter>>=
let stamp_counter = ref 0
@

<<constant Document.no_stamp>>=
let no_stamp = 0
@

<<function Document.new_stamp>>=
let new_stamp () =
  incr stamp_counter; !stamp_counter
@


<<signature Document.document_id>>=
val document_id : Www.request -> document_id
@

<<function Document.document_id>>=
let document_id wwwr =
  match wwwr.www_link.h_method with
    POST _  ->
        { document_url = wwwr.www_url; document_stamp = new_stamp()}
  | _ -> { document_url = wwwr.www_url; document_stamp = no_stamp}
@

\section{Abstract syntax trees}

% html
% css
% js

\subsection{HTML}

<<type Html.attribute_name>>=
(* HTML tokens *)
type attribute_name = string 
@
<<type Html.attribute_value>>=
type attribute_value = string
@

<<type Html.attributes>>=
type attributes = (attribute_name * attribute_value) list
@

<<type Html.tag>>=
type tag = {
  tag_name : string;
  attributes: attributes
}
@

<<type Html.token>>=
type token =
   PCData of string
 | CData of string
 | OpenTag of tag
 | CloseTag of string
 | Comment of string
 | Doctype of string
 | EOF
@

<<type Html.location>>=
type location = Loc of int * int
@



<<constant Html.default_attributes>>=
(* Attribute values *)
let default_attributes = [ 
  ("isindex", "prompt"), "Document is indexed/searchable: ";
  ("a", "methods"), "GET";              (* <A METHODS=GET> *)
  ("ol", "type"), "1";			(* <OL TYPE=1 *)
  ("embed", "methods"), "GET";		(* <EMBED METHODS=GET> *)
  ("embed", "alt"), "[EMBEDDED OBJECT]";(* <EMBED ALT="EMBEDDED OBJECT"> *)
  ("form", "method"), "GET";		(* <FORM METHOD=GET> *)
  ("form", "enctype"), "application/x-www-form-urlencoded";
  ("input", "type"), "TEXT";		(* <INPUT TYPE=TEXT> *)
  ("select", "size"), "5";
  ("textarea", "align"), "bottom";
  ("input", "align"), "bottom";
  ("select", "align"), "bottom";
  ("img", "align"), "bottom";
  (* ("img", "alt"), "[IMAGE]"; *) (* Just "IMAGE" ? Boring... *)
  ("area", "shape"), "rect";
  ("div", "align"), "left";
  ("basefont", "size"), "3";
  (* frames *)
  ("frame", "frameborder"), "0";
  ("frame", "scrolling"), "auto";
  ("frameset", "rows"), "100%";
  ("frameset", "cols"), "100%";
  ]
@


<<function Html.get_attribute>>=
let get_attribute tag attr =
  try
    List.assoc attr tag.attributes 
  with
    Not_found ->
     List.assoc (tag.tag_name, attr) default_attributes
@

<<function Html.has_attribute>>=
let has_attribute tag attr =
     List.mem_assoc attr tag.attributes
  || List.mem_assoc (tag.tag_name, attr) default_attributes
@


\section{HTTP}

\chapter{[[main()]]}

\section{The event loop}

<<signature Glevents.get>>=
val get : string -> (modifier list * xEvent) list 
@

<<signature Glevents.reset>>=
val reset : unit -> unit
@


<<constant Glevents.events>>=
(* A global table for describing events
 * TODO: use virtual events because here we don't change bindings in 
 * place after a preference reload
 *)

let events = Hashtbl.create 37
@

<<constant Glevents.builtin_defaults>>=
let builtin_defaults = [
  (* tachymeter bindings *)
  "tachy_about", [[], ButtonPressDetail 3];
  "tachy_gc",[[], KeyPressDetail "g"; [], KeyPressDetail "c"];
  "tachy_new", [[], ButtonPressDetail 1];
  "tachy_sel", [[], ButtonPressDetail 2];
  (* bindings on inlined images *)
  "loadimage", [[Control], ButtonPressDetail 1];
  "alt_imap", [[],ButtonPressDetail 1];	(* alt mode client side img map *)
  "stopanim",  [[], ButtonPressDetail 2];
  "restartanim", [[Shift], ButtonPressDetail 2];
  "copyimgurl", [[], ButtonPressDetail 2];
  "updateimage", [[Shift], ButtonPressDetail 2];
  (* anchor bindings *)
  "goto", [[], ButtonPressDetail 1];
  "save", [[Shift], ButtonPressDetail 1];
  "gotonew", [[], ButtonPressDetail 3];
  "hypermenu", [[Control], ButtonPressDetail 1];
]
@

<<constant Glevents.get>>=
let get = Hashtbl.find events
@

<<function Glevents.reset>>=
(* This is for preferences *)
let reset () =
  Hashtbl.clear events;
  (* Now: for all names defined in defaults, check a possible overriding value
     in resources *)
  List.iter (fun (name,default) ->
    Hashtbl.add events 
      name (Tkresource.event_sequence (sprintf "bind<%s>" name) default))
    builtin_defaults
@


\chapter{Navigator Interface}
% The chrome

\chapter{Parsing}

\section{URLs}

<<signature Lexurl.f>>=
val f : Lexing.lexbuf -> Url.t
@

<<signature Lexurl.make>>=
val make : string -> Url.t
   (* raise Url_Lexing(msg,pos) *)
@

<<signature Lexurl.maken>>=
val maken : string -> Url.t
   (* raise Url_Lexing(msg,pos) *)
@

<<signature Lexurl.remove_dots>>=
val remove_dots : string -> string
@

<<signature Lexurl.normalize>>=
val normalize : string -> string
@


%todo: lexurl.mll?

\subsection{Paths}

<<signature Lexpath.path_components>>=
(* Path lexer
   Deals with "./" and "../"
 *)

val path_components : Lexing.lexbuf -> string list
  (* in normal order: /a/b/c/ -> [a;b;c] *)
@

<<signature Lexpath.rev_path_components>>=
val rev_path_components : Lexing.lexbuf -> string list
  (* in reverse order: /a/b/c/ -> [c;b;a] *)
@

<<signature Lexpath.build>>=
val build : string -> string list -> string
  (* [build root [a;b;d]] returns path/a/b/c *)
@

<<signature Lexpath.remove_dots>>=
val remove_dots : string -> string
  (* takes path and removes . and .. *)
@

\subsection{Encoding}
% unparsing?

<<signature Urlenc.decode>>=
(* URL encoding *)

val decode : string -> string
@

<<signature Urlenc.encode>>=
val encode : string -> string
    (* encoding and decoding for an arbitrary string *)
@

<<signature Urlenc.strict_form_standard>>=
val strict_form_standard : bool ref
    (* if true, we take RFC1866 8.2.1 case 1 strictly, and encode any 
       non-alphanumeric character in the field name
       else, we encode only values, but not field names *)
@

<<signature Urlenc.form_encode>>=
val form_encode : (string * string) list -> string
@

<<signature Urlenc.form_decode>>=
val form_decode : string -> (string * string) list
    (* application/x-www-form-urlencoded encoding *)
@

<<signature Urlenc.unquote>>=
(*-*)
val unquote : string -> string
@


<<function Urlenc.hexchar>>=
let hexchar c = 
  let s = String.make 3 '%'
  and i = Char.code c in
  s.[1] <- dec_to_hex (i/16);
  s.[2] <- dec_to_hex (i mod 16);
  s
@

<<function Urlenc.decode>>=
(* Note: beware of order of splitting wrt '&' and decoding *)
let decode s =
  let l = String.length s in
  let target = Ebuffer.create l in
  let pos = ref 0 in
  while !pos < l do
    if s.[!pos] = '%' & !pos + 2 < l  then begin
      let c = 16 * hex_to_dec s.[!pos+1] + hex_to_dec s.[!pos+2] in
       Ebuffer.output_char target (Char.chr c);
    pos := !pos + 3
    end
    else if s.[!pos] = '+' then begin
      Ebuffer.output_char target ' ';
      incr pos
      end
    else begin
      Ebuffer.output_char target s.[!pos];
      incr pos
      end
  done;
  Ebuffer.get target
@

<<constant Urlenc.keep_quoted>>=
(* Unquote an url path:
   We decode all % except those corresponding to significative
   characters for parsing: /, ?, #, sp, :
 *)
let keep_quoted = 
  ['/'; '?'; '#'; ' '; '\t'; '\r'; '\n'; ':'; '%'; '&'; '='; '+']
@

<<function Urlenc.unquote>>=
let unquote s =
  try
    (* optim *)
    let _ = String.index s '%' in
    let l = String.length s in
    let target = Ebuffer.create l in
    let pos = ref 0 in
    try
      while !pos < l do
    let perpos = String.index_from s !pos '%' in
    if perpos > !pos then Ebuffer.output target s !pos (perpos - !pos);
    pos := perpos;
       if s.[!pos] = '%' & !pos + 2 < l  then begin
         let c = 16 * hex_to_dec s.[!pos+1] + hex_to_dec s.[!pos+2] in
      let substc = Char.chr c in
      if List.mem substc keep_quoted then
        for i = 0 to 2 do
             Ebuffer.output_char target s.[!pos];
             incr pos
          done
          else begin
             Ebuffer.output_char target (Char.chr c);
          pos := !pos + 3
       end
     end
     else begin
        Ebuffer.output_char target s.[!pos];
        incr pos
     end
      done;
      Ebuffer.get target
    with
      Not_found -> (* no more substitutions *)
    Ebuffer.output target s !pos (l - !pos);
    Ebuffer.get target
  with
    Not_found -> s
@

<<function Urlenc.encode>>=
let encode s =
  let target = Ebuffer.create (String.length s) in
  for pos = 0 to String.length s - 1 do
    match s.[pos] with
      ' ' -> Ebuffer.output_char target '+'
    | '0'..'9' | 'a'..'z' | 'A'..'Z' as c -> Ebuffer.output_char target c
    | '\n' -> Ebuffer.output_string target "%0D%0A"
    | c -> Ebuffer.output_string target (hexchar c)
    done;
  Ebuffer.get target
@

<<constant Urlenc.strict_form_standard>>=
let strict_form_standard = ref true
@

<<function Urlenc.form_encode>>=
let form_encode = function 
  [] -> ""
 | (e,v)::l ->
  let b = Ebuffer.create 512 in
    Ebuffer.reset b;
    Ebuffer.output_string b (encode e);
    Ebuffer.output_char b '=';
    Ebuffer.output_string b (encode v);
    List.iter (fun (e,v) ->
         Ebuffer.output_char b '&';
         Ebuffer.output_string b (
                   if !strict_form_standard then encode e
           else e);
         Ebuffer.output_char b '=';
         Ebuffer.output_string b (encode v))
             l;
    Ebuffer.get b
@

<<constant Urlenc.form_decode>>=
let form_decode =
  let ampersand c = c = '&' and equals c = c = '=' in
  (function  s ->
     List.map (fun encp ->
       match split_str equals encp with
       [x;y] -> (decode x, decode y)
     | [x] -> (decode x, "")
     | _ -> invalid_arg "form_decode")
       (split_str ampersand s))
@

\subsection{Links}

<<signature Hyper.parse_method>>=
val parse_method : string -> link_method
@

<<function Hyper.parse_method>>=
let parse_method = function
   "GET" -> GET
 | "HEAD" -> HEAD
 | "POST" -> POST ""
 | _ -> raise Not_found (* other cases should be caught by caller ! *)
@


\section{HTML}

<<signature Lexhtml.strict>>=
val strict : bool ref
    (* if true, use strict parsing; else, activate leniency on some
       lexing decisisons such as: comments, attribute names and values
     *)
@

<<signature Lexhtml.html>>=
val html : Lexing.lexbuf -> t -> warnings * Html.token * Html.location
@




<<signature Lexhtml.new_data>>=
val new_data : unit -> t
    (* instance data for a lexer; must be allocated for each instance, in
       order to get reentrant lexers
     *)
@

<<type Lexhtml.warnings>>=
type warnings = (string * int) list
@


<<signature Lexhtml.cdata>>=
val cdata : Lexing.lexbuf -> t -> warnings * Html.token * Html.location
@

% lexhtml.mll


\subsection{DTDs}

<<type Dtd.t>>=
type t = {
  dtd_name : string;
  contents : (string, Elements.t) Hashtbl.t;
    (* for each element, give the set of included elements *)
  mutable open_omitted : Elements.t;
    (* set of elements for which opening tag may be omitted *)
  mutable close_omitted : Elements.t
    (* set of elements for which closing tag may be omitted *)
 } 
@

<<signature Dtd.dtd32>>=
val dtd32 : t
@


<<signature Dtd.get>>=
(* A table of DTDs for preferences *)
val get : string -> t
@

<<signature Dtd.add>>=
val add : t -> unit
@

<<signature Dtd.name>>=
val name : t -> string
@

<<signature Dtd.names>>=
val names : unit -> string list
@

<<signature Dtd.current>>=
val current : t ref 
@


<<function Dtd.name>>=
let name t = t.dtd_name
@

<<function Dtd.sol>>=
(* Utils *)
let sol l =
  List.fold_right Elements.add l Elements.empty
@

<<function Dtd.sos>>=
let sos l =
  List.fold_right Elements.union l Elements.empty
@



<<constant Dtd.dtd32>>=
let dtd32 =
  let dtd = {
    dtd_name = "HTML 3.2";
    contents = Hashtbl.create 53;
    open_omitted = Elements.empty;
    close_omitted = Elements.empty
     } in
  let omit_open el =
    dtd.open_omitted <- Elements.add el dtd.open_omitted
  and omit_close el =
    dtd.close_omitted <- Elements.add el dtd.close_omitted
  and add_elem = Hashtbl.add dtd.contents
  in

  let head_misc_E = sol ["script"; "style"; "meta"; "link"]
  and heading_E = sol ["h1"; "h2"; "h3"; "h4"; "h5"; "h6"]
  and list_E = sol ["ul"; "ol"; "dir"; "menu"]
  and preformatted_E = sol ["pre"; "xmp"; "listing"]
  and font_E =
     sol ["tt"; "i"; "b"; "u"; "strike"; "big"; "small"; "sub"; "sup"]
  and phrase_E =
     sol ["em"; "strong"; "dfn"; "code"; "samp"; "kbd"; "var"; "cite"]
  and special_E =
     sol ["a"; "img"; "applet"; "font"; "basefont"; "br"; "script"; "map"]
  and form_E =
     sol ["input"; "select"; "textarea"]
  in
  (* EMBED is not in the original DTD ! *)
  let text_E =
     sos [sol ["#pcdata"; "embed"]; font_E; phrase_E; special_E; form_E]
  in
  Elements.iter (fun e -> add_elem e text_E) font_E;
  Elements.iter (fun e -> add_elem e text_E) phrase_E;
  add_elem "font" text_E;
  add_elem "basefont" Elements.empty;
  omit_close "basefont";
  add_elem "br" Elements.empty;
  omit_close "br";

  let block_E =
    sos [sol ["p"; "dl"; "div"; "center"; "blockquote"; "form"; "isindex";
              "hr"; "table"];
         list_E; preformatted_E]
  in
  let flow_E = sos [text_E; block_E]
  in
  let body_content_E = sos [sol ["address"]; heading_E; text_E; block_E]
  in
  add_elem "body" body_content_E;
  omit_open "body";
  omit_close "body";

  let address_content_E = sos [sol ["p"]; text_E] in
  add_elem "address" address_content_E;
  
  add_elem "div" body_content_E;
  add_elem "center" body_content_E;

  add_elem "a" (Elements.remove "a" text_E);
  
  add_elem "map" (sol ["area"]);
  add_elem "area" Elements.empty;
  omit_close "area";

  add_elem "link" Elements.empty;
  omit_close "link";
   
  add_elem "img" Elements.empty;
  omit_close "img";

  add_elem "applet" (Elements.add "param" text_E);
  add_elem "param" Elements.empty;
  omit_close "param";

  add_elem "hr" Elements.empty;
  omit_close "hr";

  add_elem "p" text_E;
  omit_close "p";

  Elements.iter (fun e -> add_elem e text_E) heading_E;

  let pre_exclusion_E = sol ["img"; "big"; "small"; "sub"; "sup"; "font"]
  in
  add_elem "pre" (Elements.diff text_E pre_exclusion_E);

  List.iter (fun e -> add_elem e (sol ["#cdata"])) ["xmp"; "listing"];

  add_elem "blockquote" body_content_E;

  add_elem "dl" (sol ["dt"; "dd"]);
  add_elem "dt" text_E; omit_close "dt";
  add_elem "dd" flow_E; omit_close "dd";

  List.iter (fun e -> add_elem e (sol ["li"])) ["ol"; "ul"];
  List.iter (fun e -> add_elem e (sol ["li"])) ["dir"; "menu"];

  add_elem "li" flow_E;
  omit_close "li";


  add_elem "form" (Elements.remove "form" body_content_E);
  add_elem "input" Elements.empty;
  omit_close "input";
  add_elem "select" (sol ["option"]);
  add_elem "option" (sol ["#pcdata"]);
  omit_close "option";
  add_elem "textarea" (sol ["#pcdata"]);


  add_elem "table" (sol ["caption"; "tr"]);
  add_elem "tr" (sol ["th"; "td"]);
  omit_close "tr";
  List.iter (fun e -> add_elem e body_content_E; omit_close e) ["th"; "td"];
  add_elem "caption" text_E;


  let head_content_E = sol ["title"; "isindex"; "base"]
  in

  add_elem "head" (Elements.union head_content_E head_misc_E);
  omit_close "head";
  omit_open "head";

  add_elem "title" (sol ["#pcdata"]);
  add_elem "isindex" Elements.empty;
  omit_close "isindex";
  add_elem "base" Elements.empty;
  omit_close "base";
  add_elem "meta" Elements.empty;
  omit_close "meta";

  add_elem "script" (sol ["#cdata"]);
  add_elem "style" (sol ["#cdata"]);

  let html_content_E = sol ["head"; "body"] in

  add_elem "html" html_content_E;
  omit_open "html";
  omit_close "html";

  (* fake element PCDATA for minimisation rules *)
  add_elem "#pcdata" Elements.empty;

  (* embed is an extension *)
  add_elem "embed" Elements.empty;
  omit_close "embed";

  dtd
@

<<constant Dtd.current>>=
let current = ref dtd32
@


<<constant Dtd.table>>=
let table = Hashtbl.create 11
@

<<function Dtd.add>>=
let add t = Hashtbl.add table t.dtd_name t
@

<<constant Dtd.get>>=
let get = Hashtbl.find table
@

<<function Dtd.names>>=
let names () =
  let names = ref [] in
   Hashtbl.iter (fun name _ -> names := name :: !names) table;
   !names
@

<<toplevel Dtd._1>>=
let _ = add dtd20; add dtd32
@

\subsection{Minimization}

<<type Html_eval.minimization>>=
(* Wrapped up lexer to insert open/close tags in the stream of "normal"
   tokens, according to some DTD, in order to always get fully parenthesized
   streams *)

type minimization =
  Legal | Illegal of string
@

<<signature Html_eval.add_html_filter>>=
(* test suit *)
val add_html_filter : ((Html.token -> unit) -> Html.token -> unit) -> unit
(* [add_html_filter filter] adds an HTML filter between the lexing and
  displaying of HTML. So, the filters do not affect the source (and
  the source display), change the content of HTML silently, and affect
  the display. The filter function [filter pfilter] receives a HTML token
  for each time, and do some job, and send a token to the parent filter 
  pfilter if possible. The filters will receive a correct HTML token
  stream (all the tags are placed and closed correctly due to the DTD),
  and they must send the correct stream to the parent filter also. 
*)
@

<<signature Html_eval.sgml_lexer>>=
(* [add_html_filter filter] adds an HTML filter between the lexing and
  displaying of HTML. So, the filters do not affect the source (and
  the source display), change the content of HTML silently, and affect
  the display. The filter function [filter pfilter] receives a HTML token
  for each time, and do some job, and send a token to the parent filter 
  pfilter if possible. The filters will receive a correct HTML token
  stream (all the tags are placed and closed correctly due to the DTD),
  and they must send the correct stream to the parent filter also. 
*)

val sgml_lexer :
  Dtd.t -> Lexing.lexbuf -> 
    ((string * int) list * minimization * Html.token list * Html.location)
@

<<signature Html_eval.automat>>=
val automat : Dtd.t -> (Html.location -> Html.token -> unit)
                    -> Lexing.lexbuf
                    -> (Html.location -> string -> unit)
            -> unit
@





<<exception Html_eval.CantMinimize>>=
exception CantMinimize			            (* bogus HTML *)
@

<<constant Html_eval.initial>>=
(* initial element of the DTD *)
let initial = Elements.add "html" Elements.empty
@

<<function Html_eval.dump_stack>>=
let dump_stack () = function
    (x,_)::(y,_)::(z,_)::_ -> sprintf "..<%s><%s><%s>" z y x
  | [x,_;y,_] -> sprintf "<%s><%s>" y x
  | [x,_] -> sprintf "<%s>" x
  | [] -> "empty stack"
@

<<function Html_eval.ominimize>>=
(* open minimize 
   [ominimize dtd open_tag current_stack]
   returns a list of inferred open/close tags and the new stack
 *)
let ominimize dtd t stack =
  let elem = t.tag_name in

  (* Is elem allowed for the given stack ? *)
  let goodpos = function
      [] -> Elements.mem elem initial
    | (_, cts)::l -> Elements.mem elem cts

  (* Return with inferred and stack.
     The stack has been reduced during the inference, so it is enough
     to push the opened element *)
  (* Special hack when t is fake #pcdata... *)
  and return inferred stack =
    if elem = "#pcdata" then
      List.rev inferred, stack
    else
      List.rev ((OpenTag t) :: inferred),
      (elem, Hashtbl.find dtd.contents elem) :: stack
      
  in
  (* [attempt_close mods_so_far current_stack] *)
  let rec attempt_close accu = function
     [] -> (* reached all the possible closing, attempt to open again *)
        attempt_open accu []
   | ((last, _)::l) as stack ->
       if Elements.mem last dtd.close_omitted then
          (* we can attempt to close the previous element *)
      if goodpos l then 
        (* good position, we're done *)
        return ((CloseTag last) :: accu) l
          else (* attempt to open in this new position *)
        try 
              attempt_open ((CloseTag last) :: accu) l
            with
          CantMinimize -> (* try once more to close *)
             attempt_close ((CloseTag last)::accu) l
       else begin (* since we can't close, try to open *)
      attempt_open accu stack
       end

   (* [attempt_open mods_so_far currentstack] *)
   and attempt_open accu = function
     [] -> 
       (* open HTML, and retry from there *)
       (* should actually iterate on all elements in initial *)
       let newstack = ["html", Hashtbl.find dtd.contents "html"]
       and newaccu = (OpenTag {tag_name = "html"; attributes = []}) :: accu
       in
      if goodpos newstack then return newaccu newstack
          else attempt_open newaccu newstack

   | ((_, cts)::l ) as stack ->
       (* check if, in contents, there is an element with implicit omission
          that would help *)
       let possible = Elements.inter cts dtd.open_omitted in
        match Elements.cardinal possible with
      0 -> (* argh *) raise CantMinimize
        | 1 -> 
      (* open this element and try from there *)
      let newelem = Elements.choose possible in
      let newaccu = (OpenTag {tag_name = newelem; attributes = []})::accu
          and newstack = (newelem, Hashtbl.find dtd.contents newelem)::stack
          in
        if goodpos newstack 
        then return newaccu newstack
        else attempt_open newaccu newstack (* maybe more ? *)
        | n -> (* since we have the choice, examine all possibilities *)
       let elems = Elements.elements possible in
       let rec backtrack = function 
             [] -> raise CantMinimize
        | x::l -> 
        try
          let newaccu = (OpenTag {tag_name = x; attributes = []})::accu
          and newstack = (x, Hashtbl.find dtd.contents x)::stack
                  in
            if goodpos newstack then return newaccu newstack 
            else attempt_open newaccu newstack
        with
         CantMinimize -> backtrack l
           in 
       backtrack elems
  in
   (* now do some error recovery *)   
   try Legal, attempt_close [] stack
   with
     CantMinimize ->
       (* what the hell, dammit, open it anyway, who cares, duh *)
       let current = match stack with (x,_)::l -> x | [] -> "" in
       Illegal (sprintf "illegal <%s> in %a, keep it though"
                t.tag_name dump_stack stack),
       return [] stack
@

<<function Html_eval.cminimize>>=
(* close minimize
   [cminimize dtd elem current_stack]
   returns a list of inferred open/close tags and the new stack
 *)
let cminimize dtd tagname stack =
  (* Is elem allowed for the given stack ? *)
  let goodpos = function
      [] -> false
    | (elem, cts)::l -> tagname = elem

  and return inferred stack =
     List.rev ((CloseTag tagname) :: inferred), stack

  in
  (* [attempt_close mods_so_far current_stack] *)
  let rec attempt_close accu = function
     [] -> raise CantMinimize
   | ((last, _)::l) as stack ->
       if Elements.mem last dtd.close_omitted then
          (* we can attempt to close the previous element *)
      if goodpos l then 
        (* good position, we're done *)
        return (CloseTag last :: accu) (List.tl l)
          else (* close a bit more ? *)
        attempt_close ((CloseTag last)::accu) l
       else 
     (* there's no reason we should have to open a new element in order
        to close the current one, is it ? *)
          raise CantMinimize
  in
  (* error recovery strategy *)
  let rec attempt_matching accu = function
     [] -> raise Not_found (* didn't find a matching open at all ! *)
   | (curelem,_):: l when curelem = tagname ->
     (* so, consider we match this open, and close them all *)
     return accu l
   | (curelem,_):: l  -> (* otherwise, find something up there *)
     attempt_matching (CloseTag curelem :: accu) l
   in
   (* now do some error recovery *)   
   try Legal, attempt_close [] stack
   with
     CantMinimize ->
       try
     Illegal (sprintf "unmatched </%s> in %a, close closest match"
                  tagname dump_stack stack),
         attempt_matching [] stack 
       with
     Not_found -> 
       Illegal (sprintf "unmatched </%s> in %a, skipped"
                    tagname dump_stack stack),
           ([], stack) (* just skip the damn thing *)
@

<<function Html_eval.is_cdata>>=
let is_cdata cts =
     Elements.cardinal cts = 1 
  && Elements.mem "#cdata" cts
@

<<function Html_eval.sgml_lexer>>=
let sgml_lexer dtd =
  let current_lex = ref Lexhtml.html
  and stack = ref [] 
  and lexdata = Lexhtml.new_data ()
  in

  (* currently allowed elements *)
  let allowed () = match !stack with
      [] -> initial
    | (elem, cts)::_ -> cts 
  in
  (* whatever the situation (but close), if the previous element is empty
     with an omittable close, close it *)
  let close_empty () = match !stack with
      [] -> []
    | (elem, ctx)::l ->
    if Elements.is_empty ctx && Elements.mem elem dtd.close_omitted
    then (stack := l; [CloseTag elem])
    else []
  in  
  (fun lexbuf ->
    let warnings, token, loc = !current_lex lexbuf lexdata in
    if !debug then 
      begin prerr_string "got "; Html.print token; prerr_newline() end;
    let status, tokens = 
      match token with
      | OpenTag t ->
          begin try (* first check that we know this element *)
        let contents = Hashtbl.find dtd.contents t.tag_name in
            let extraclose = close_empty() in    
        (* check changing of lexers; this works only if error recovery
           rules imply that the tag will *always* be open
             *)
        if is_cdata contents then current_lex := Lexhtml.cdata
        else current_lex := Lexhtml.html;
        (* is it allowed in here ? *)
        if Elements.mem t.tag_name (allowed()) then begin
              (* push on the stack *)
              stack := (t.tag_name, contents) :: !stack;
          Legal, extraclose @ [token]
              end
            else begin (* minimisation or error *)
              let flag, (res, l) = ominimize dtd t !stack in
        stack := l;
        flag, extraclose @ res
              end
          with
        Not_found -> 
          (* Not in the DTD ! We return it, but don't change our state
         or stack. An applet extension to the HTML display machine
                 can attempt to do something with it *)
          Illegal (sprintf "Element %s not in DTD" t.tag_name),
          [token]
          end
        
      | CloseTag t ->
      begin try (* do we know this element *)
            let _ = Hashtbl.find dtd.contents t in
        match !stack with
          [] -> 
        Illegal(sprintf "Unmatched closing </%s>" t),
        []
            | (elem, cts)::l when elem = t -> (* matching close *)
            stack := l; (* pop the stack *)
                (* the lexer has to be "normal" again, because CDATA
                   can't be nested anyway *)
               current_lex := Lexhtml.html;
        Legal, [token]
            | (elem, cts)::l -> (* unmatched close ! *)
        (* if we were in cdata, change the token to cdata *)
        if is_cdata cts then Legal, [CData (sprintf "</%s>" t)]
        else begin
                 current_lex := Lexhtml.html;
          let flag, (res, l) = cminimize dtd t !stack in
          stack := l;
          flag, res
        end
          with
        Not_found ->
          Illegal (sprintf "Element %s not in DTD" t),
          [token]
          end

      | PCData s ->
          let extraclose = close_empty() in    
      (* is it allowed in here ? *)
      if Elements.mem "#pcdata" (allowed()) then
              Legal, extraclose @ [token]
          (* ignore PCData made of spaces if not relevant to the context *)
      else if issp s then Legal, extraclose
      else
           begin	    
          (* bad hack. make believe that we try to open the #pcdata element *)
        let flag, (res, l) = 
          ominimize dtd {tag_name = "#pcdata"; attributes = []} !stack in
          stack := l;
          flag,  extraclose @ res @ [token]
       end

      (* CData never happens with an empty stack *)
      | CData s ->
          let extraclose = close_empty() in    
      if Elements.mem "#cdata" (allowed()) then
        Legal, extraclose @ [token]
          else
        Illegal(sprintf "Unexpected CDATA in %a" dump_stack !stack),
        extraclose @ [token]
        
      (* See if the stack is empty *)
      | EOF ->
      begin match !stack with
        [] -> Legal, [EOF]
          | l ->
             (* we must be able to close all remaining tags *)
         let rec closethem tokens = function
        [] -> None, EOF :: tokens
          | (last,_) :: l ->
          if Elements.mem last dtd.close_omitted then
            closethem (CloseTag last::tokens) l
          else
            let status, tokens = 
              closethem (CloseTag last::tokens) l in
            let err = sprintf "</%s>" last in
            let newstatus = match status with
              Some s -> Some (err^s)
            | None -> Some err in
            newstatus, tokens
         in
         match closethem [] l with
           None, tokens -> Legal, List.rev tokens
         | Some s, tokens -> Illegal ("Missing "^s), List.rev tokens
          end

      | _ ->  Legal, [token] (* ignore all other cases *)
      
      in
      warnings, status, tokens, loc)
@

<<constant Html_eval.filters>>=
let filters = ref []
@

<<function Html_eval.add_html_filter>>=
let add_html_filter f =
  filters := f :: !filters
@

<<function Html_eval.sgml_lexer (./html/html_eval.ml)>>=
(* Redefine sgml_lexer with filters *)
let sgml_lexer dtd = 
  let org_lexer = sgml_lexer dtd in
  let buf = ref [] in
  let allfilter = 
    List.fold_right (fun f st -> f st) !filters 
      (fun tkn -> buf := !buf @ [tkn]) 
  in
  function lexbuf ->
    let warnings, correct, tokens, loc = org_lexer lexbuf in
    List.iter allfilter tokens; (* inefficient *)
    let tokens = !buf in 
    buf := [];
    warnings, correct, tokens, loc
@

<<function Html_eval.automat>>=
let automat dtd action lexbuf error =
  try
    let lexer = sgml_lexer dtd in
    while true do
      try 
       let warnings, correct, tokens, loc = lexer lexbuf in
    List.iter (fun (reason, pos) -> error (Loc(pos,succ pos)) reason)
              warnings;
    begin match correct with
      Legal -> ()
        | Illegal reason -> error loc reason
        end;
    List.iter 
      (function token -> 
            begin 
          try action loc token
              with Invalid_Html s -> error loc s
            end;
        if token = EOF then failwith "quit_html_eval")
       tokens
      with
        Html_Lexing (s,n) -> error (Loc(n,n+1)) s
    done
  with
    Failure "quit_html_eval" -> ()
@


\subsection{[[htparse]]}

\section{HTTP headers}

\chapter{HTML}

\section{Tables}

\section{Forms}

\section{Maps}

%(* Client-side image maps:
%     the "only" difficulty in implementing client-side image maps is that
%     the map may well come *after* the image in the document. In general,
%     anyway, the map may be an arbitrary URL.
%
%   We thus have to implement a general delay mechanism for maps : the idea
%   here is to use a table of maps, each map being accessed by an URI (that is,
%   an URL plus a fragment).
%
%   PROBLEM: we have no idea in general when to flush this table.
%
% *)


<<type Maps.area_kind>>=
(* The active areas *)
type area_kind = Rect | Circle | Poly | Default
@

<<type Maps.area>>=
(* The area *)
type area = {
  area_kind : area_kind;
  area_coords : int list;
  area_link : Hyper.link;
  area_alt  : string
 }
@

<<type Maps.map>>=
type map = area list
@

<<type Maps.t>>=
(* We merge any kind of map, for we actually are going to support
   maps for arbitrary embedded objects
 *)
type t = 
    ClientSide of Hyper.link		(* usemap link *)
  | ServerSide of Hyper.link		(* ismap *)
  | Direct of Hyper.link			(* inside an anchor *)
  | NoMap				(* no additionnal navigation *)
  | FormMap of (int * int -> Hyper.link)
@

<<type Maps.map_status>>=
(* The table of client-side image maps *)
type map_status =
   KnownMap of map
 | RequestedMap of string
@

<<signature Maps.parse_coords>>=
val parse_coords : string -> int list
@

<<signature Maps.get>>=
val get : string -> map_status
@

<<signature Maps.add>>=
val add : string -> map -> unit
@


<<constant Maps.table>>=
let table = (Hashtbl.create 37 : (string, map_status) Hashtbl.t)
@

<<constant Maps.coord_sep>>=
(* Tolerance: official syntax is "," separated.
   We use instead "[ \t\n]+\|\([ \t\n]*,[ \t\n]*\)"
   that is non empty sequence of whitespace
        or comma with possible surrounding whitespace
 *)
(* let coord_sep = Str.regexp "," *)
let coord_sep = Str.regexp "[ \t\n]+\|\([ \t\n]*,[ \t\n]*\)"
@

<<function Maps.parse_coords>>=
let parse_coords s =
  List.map int_of_string (Str.split coord_sep s)
@

<<function Maps.add>>=
let add name map =
  Log.debug (sprintf "Adding map : %s" name);
  try
    match Hashtbl.find table name with
      KnownMap m -> Log.debug "Map already known !"
    | RequestedMap event ->
       Hashtbl.remove table name; (* remove it *)
       Hashtbl.add table name (KnownMap map); (* add its value *)
       Frx_synth.broadcast event (* trigger all waiting people *)
  with
    Not_found -> (* nobody requested it *)
      Hashtbl.add table name (KnownMap map)
@

<<function Maps.get>>=
let get name =
  Log.debug (sprintf "Asking map : %s" name);
  try
    Hashtbl.find table name 
  with
    Not_found ->
       let m = Mstring.gensym "map" in
         Hashtbl.add table name (RequestedMap m);
     RequestedMap m
@


\chapter{Communication Protocol}
% http

\chapter{Retrieving}

\section{Active}

%(* We need to keep a trace of pending connections, since there is a race
%   condition when the user clicks twice rapidly on an anchor. If the second
%   click occurs before the document is added to the cache, (e.g. because we
%   are waiting for the headers), then the document will be retrieved twice.
%   And naturally, for documents that don't enter the cache we always will
%   duplicate connexions.
%   Retrieve.f is a safe place to add the request to the list of pending
%   connexions, because it is synchronous.
%   Removing an active connexion must take place when we close the 
%   dh.document_fd.
%*)

<<constant Www.active_connexions>>=
let active_connexions = ref UrlSet.empty
@

<<signature Www.is_active_cnx>>=
val is_active_cnx : Url.t -> bool
@
<<signature Www.add_active_cnx>>=
val add_active_cnx : Url.t -> unit
@
<<signature Www.rem_active_cnx>>=
val rem_active_cnx : Url.t -> unit
@

\section{Documents}

<<type Document.handle>>=
(* This is passed around by request continuations. It represents a handle
   on a connexion for retrieving a document *)
type handle = {
  document_id : document_id;
  document_referer : string option;
    (* URL of refering document, if any *)
  mutable document_status : int;
    (* Status code of response *)
  mutable document_headers : string list;
    (* HTTP headers of document, or faked ones *)
  document_feed : Feed.t;
    (* where to get the data *)
  document_fragment : string option;
    (* fragment (#foo) if any *)
  mutable document_logger : logger
    (* how to log information relative to this document processing *)
}
@

<<type Document.document_continuation>>=
type document_continuation = {
  document_process : handle -> unit;
    (* What to do one we have a dh on the real document *)
  document_finish :  bool -> unit
    (* What to do if a request does not yield a document *)
}
@

<<type Document.document_data>>=
(*
 * Information on a document, as could be requested by "other" clients,
 * that is clients not directly on the chain of processes dealing with
 * the handle
 *)

type document_data =
   MemoryData of Ebuffer.t
 | FileData of string * bool (* flag is true if file is temporary *)
@

<<type Document.document>>=
type document = {
  document_address : Url.t;
  mutable document_data : document_data;
  document_info : string list
  }
@

<<signature Document.dclose>>=
val dclose : bool -> handle -> unit
  (* [dclose remactive dh] closes a living dh *)
@

<<signature Document.add_log>>=
val add_log: handle -> string -> (unit -> unit) -> unit
@

<<signature Document.put_log>>=
val put_log : handle -> string -> unit
@

<<signature Document.progress_log>>=
val progress_log : handle -> int -> unit
@

<<signature Document.end_log>>=
val end_log : handle -> string -> unit
@

<<signature Document.destroy_log>>=
val destroy_log : handle -> bool -> unit
  (* logging functions *)
@



<<function Document.dclose>>=
(* Close a connexion. Should be called only by a fileinput callback
      or by somebody attempting to abort the connexion 
   We remove the fd of the select before closing it since we don't want
   a spurious read to happen. This way we are somewhat independant of the
   Tk implementation 
 *)

let dclose remactive dh =
  dh.document_feed.feed_unschedule();
  dh.document_feed.feed_close();
  if remactive then Www.rem_active_cnx dh.document_id.document_url
@


<<function Document.add_log>>=
let add_log dh initmsg abort =
  let t = 
    Toplevel.create Widget.default_toplevel [Class "MMMLog"] in
  Wm.withdraw t;
  Wm.title_set t 
      (I18n.sprintf "Document log %s" 
         (Url.string_of dh.document_id.document_url)); 
  let l = Label.create t 
    [Text initmsg; Justify Justify_Left; WrapLength (Pixels 600)]
  and fprog, set_progress = Frx_fillbox.new_horizontal t 200 10 
  and b = Button.create t 
      [Text (I18n.sprintf "Abort"); 
       Command (fun () -> dclose true dh; abort(); destroy t)] in
    pack [l;fprog;b][];
  let putmsg txt = 
    Label.configure l [Text txt] in
  let finished msg =
    putmsg msg;
    Button.configure b 
       [Text (I18n.sprintf "Ok"); 
         Command (fun () -> if Winfo.exists t then destroy t)] in
  let iconified = ref true in
  let logger = {
    logger_destroy =
      (fun delayed ->
    if Winfo.exists t then
      if !iconified then (* that was fast *)
        destroy t
      else if not delayed then destroy t
      else
              Timer.set 5000 (fun () -> if Winfo.exists t then destroy t));
    logger_progress = 
      (fun n -> if Winfo.exists t then set_progress n);
    logger_msg =
      (fun msg -> if Winfo.exists t then putmsg msg);
    logger_end = 
      (fun msg -> if Winfo.exists t then finished msg) } in

   dh.document_logger <- logger;
   (* The logger appears only after a given delay *)
     Timer.set 3000
      (fun () -> if Winfo.exists t then (Wm.deiconify t; iconified := false))
@

<<function Document.end_log>>=
let end_log dh msg =
    dh.document_logger.logger_end msg;
    destroy_log dh true
@

<<functions Document.xxx_log>>=
let put_log dh = dh.document_logger.logger_msg
let destroy_log dh = dh.document_logger.logger_destroy
let progress_log dh = dh.document_logger.logger_progress
@

<<type Document.display_info>>=
type display_info = {
    di_abort : unit -> unit;
    di_destroy : unit -> unit;
    di_fragment : string option -> unit;
    di_redisplay: unit -> unit;
    di_title : unit -> string;	      (* some title for bookmarks *)
    di_source : unit -> unit;
    di_load_images : unit -> unit
}
@





\chapter{Viewers}

\section{Mime}

\section{[[text/html]]}

\section{[[text/plain]]}

\chapter{Rendering}

\section{Display primitives}

\section{HTML compilation}
% from html lexems to instructions to display engine

\chapter{Concurrency}
% important in browser context, servo was actually started just for that
% could also have an isolation chapter?

\chapter{Optimisations}
% could also have an parallel chapter?

\section{Caches}

\chapter{Advanced Topics}

\section{i18n}

<<signature Lang.lang>>=
val lang : unit -> string
@

<<function Lang.lang>>=
let lang () =
  if !japan then "ja"
  else "iso8859"
@


<<signature I18n.message_file>>=
val message_file : string ref
@

<<signature I18n.language>>=
val language : string ref
@

<<signature I18n.sprintf>>=
val sprintf: ('a, unit, string) format -> 'a
@

<<signature I18n.menu_option>>=
val menu_option: Tk.options list -> Tk.options list
@

<<signature I18n.menu_pattern>>=
val menu_pattern: Tk.options list -> string
@





<<function I18n.fprintf>>=
(* Internationalization (translation of error messages) *)

let fprintf x = 
  if !Lang.japan then I18nprintf.fprintf x else Printf.fprintf x
@

<<function I18n.sprintf>>=
let sprintf x = 
  if !Lang.japan then I18nprintf.sprintf x else Printf.sprintf x
@

<<constant I18n.language>>=
let language = ref ""
@

<<constant I18n.message_file>>=
let message_file = ref ""
@

<<function I18n.read_transl_file>>=
let read_transl_file msgfile =
  let ic = open_in msgfile in
  let tag_buffer = String.create 16
  and msg_buffer = String.create 1024 in
  let rec store_tag c i =
    if i >= 16 then i else (tag_buffer.[i] <- c; succ i)
  and store_msg c i =
    if i >= 1024 then i else (msg_buffer.[i] <- c; succ i)
  and read_line i =
    match input_char ic with
      '\n' -> i
    | '\\' -> begin match input_char ic with
                '\\' -> read_line(store_msg '\\' i)
              | 'n'  -> read_line(store_msg '\n' i)
              | '\n' -> skip_blanks i
              | c    -> read_line(store_msg c (store_msg '\\' i))
              end
    | c    -> read_line(store_msg c i)
  and skip_blanks i =
    match input_char ic with
      ' '|'\t' -> skip_blanks i
    | c        -> read_line(store_msg c i)
  and read_tag i =
    match input_char ic with
      ':'           -> (i, skip_blanks 0)
    | ' '|'\n'|'\t' -> read_tag i
    | c             -> read_tag(store_tag c i) in
  let transl_tbl = Hashtbl.create 37 in
  let currsrc = ref "" in
  begin try
    while true do
      let (tag_len, msg_len) = read_tag 0 in
      if String.sub tag_buffer 0 tag_len = "src" then
        currsrc := String.sub msg_buffer 0 msg_len
      else if String.sub tag_buffer 0 tag_len = !language then
        Hashtbl.add transl_tbl !currsrc (String.sub msg_buffer 0 msg_len)
      else ()
    done
  with End_of_file ->
    close_in ic
  end;
  transl_tbl
@

<<type I18n.translation_table>>=
type translation_table =
    Unknown
  | NoTranslation
  | Transl of (string, string) Hashtbl.t
@

<<constant I18n.transl_table>>=
let transl_table = ref Unknown
@

<<function I18n.translate>>=
let rec translate msg =
  match !transl_table with
    NoTranslation ->
      msg
  | Transl tbl ->
      begin try Hashtbl.find tbl msg with Not_found -> msg end
  | Unknown ->
      transl_table :=
        if String.length !language == 0 then
          NoTranslation
        else begin
          try
            if Sys.file_exists !message_file then	   
              Transl(read_transl_file !message_file)
            else NoTranslation
          with Sys_error _ | Sys.Break ->
            NoTranslation
        end;
      translate msg
@

<<function I18n.fprintf (./commons/i18n.ml)>>=
let fprintf oc (fmt : ('a, out_channel, unit) format) =
  fprintf oc
    (Obj.magic(translate(Obj.magic fmt : string)) :
                                ('a, out_channel, unit) format)
@

<<function I18n.sprintf (./commons/i18n.ml)>>=
let sprintf (fmt : ('a, unit, string) format) =
  sprintf
    (Obj.magic(translate(Obj.magic fmt : string)) :
                                ('a, unit, string) format)

@

<<function I18n.menu_option>>=
let menu_option l =
  let under_pos = ref (-1) 
  and text = ref ""
  in
    List.iter (function 
    UnderlinedChar x -> under_pos := x
      | Text x  -> text := x
      | Label x -> text := x
      |	_ -> () ) l;
    let trans = translate !text in
      let new_text, new_under_pos =
    if !text = trans then !text, !under_pos
    else
      if !under_pos = 0 & 
        String.get !text 0 = String.get trans 0 then trans, 0
      else
        (String.make 1 (String.get !text !under_pos)) ^ ":" ^ trans, 0 
      in
        List.map (function
        UnderlinedChar _ -> UnderlinedChar new_under_pos
      | Text x -> Text new_text
      | Label x -> Label new_text
      | x -> x ) l
@

<<exception I18n.Found>>=
exception Found of string
@

<<function I18n.menu_pattern>>=
let menu_pattern l =
  let l' = menu_option l in
  try
    List.iter (function
      | Text x -> raise (Found x)
      | Label x -> raise (Found x)
      | _ -> ()) l';
    raise (Failure "I18n.menu_pattern : the option list contains no text")
  with
    Found x -> x
@

\subsection{Accents}

<<constant Html.ampersand_table>>=
(* 
 * HTML encoding of ISO-latin1 characters
 *  cf Appendix B - Proposed Entities
 *)

let ampersand_table = (Hashtbl.create 101: (string , string) Hashtbl.t)
@

<<constant Html.latin1_normal>>=
let latin1_normal = [
  "amp", 	"&";
  "gt", 	">";
  "lt" , 	"<";
  "quot", 	"\"";
  "nbsp", 	"\160"; (* non-breaking space *)
  "iexcl",	"\161"; (*  inverted exclamation mark *)
  "cent", 	"\162"; (*  cent sign*)
  "pound",	"\163"; (*  pound sterling sign*)
  "curren",	"\164"; (*  general currency sign*)
  "yen",	"\165"; (*  yen sign*)
  "brvbar",	"\166"; (*  broken (vertical) bar *)
  "sect",	"\167"; (*  section sign *)
  "uml",	"\168"; (*  umlaut (dieresis) *)
  "copy",	"\169"; (*  copyright sign *)
  "ordf",	"\170"; (*  ordinal indicator, feminine *)
  "laquo",	"\171"; (*  angle quotation mark, left *)
  "not",	"\172"; (*  not sign *)
  "shy",	"\173"; (*  soft hyphen *)
  "reg",	"\174"; (*  registered sign *)
  "macr",	"\175"; (*  macron *)
  "deg",	"\176"; (*  degree sign *)
  "plusmn",	"\177"; (*  plus-or-minus sign *)
  "sup2",	"\178"; (*  superscript two *)
  "sup3",	"\179"; (*  superscript three *)
  "acute",	"\180"; (*  acute accent *)
  "micro",	"\181"; (*  micro sign *)
  "para",	"\182"; (*  pilcrow (paragraph sign) *)
  "middot",	"\183"; (*  middle dot *)
  "cedil",	"\184"; (*  cedilla *)
  "sup1",	"\185"; (*  superscript one *)
  "ordm",	"\186"; (*  ordinal indicator, masculine *)
  "raquo",	"\187"; (*  angle quotation mark, right *)
  "frac14",	"\188"; (*  fraction one-quarter *)
  "frac12",	"\189"; (*  fraction one-half *)
  "frac34",	"\190"; (*  fraction three-quarters *)
  "iquest",	"\191"; (*  inverted question mark *)
  "Agrave", 	"\192";	(*  capital A, grave accent *)
  "Aacute", 	"\193";	(*  capital A, acute accent *)
  "Acirc", 	"\194";	(*  capital A, circumflex accent *)
  "Atilde", 	"\195";	(*  capital A, tilde *)
  "Auml", 	"\196";	(*  capital A, dieresis or umlaut mark *)
  "Aring", 	"\197";	(*  capital A, ring *)
  "AElig", 	"\198";	(*  capital AE diphthong (ligature) *)
  "Ccedil", 	"\199";	(*  capital C, cedilla *)
  "Egrave", 	"\200";	(*  capital E, grave accent *)
  "Eacute", 	"\201";	(*  capital E, acute accent *)
  "Ecirc", 	"\202";	(*  capital E, circumflex accent *)
  "Euml", 	"\203";	(*  capital E, dieresis or umlaut mark *)
  "Igrave", 	"\204";	(*  capital I, grave accent *)
  "Iacute", 	"\205";	(*  capital I, acute accent *)
  "Icirc", 	"\206";	(*  capital I, circumflex accent *)
  "Iuml", 	"\207";	(*  capital I, dieresis or umlaut mark *)
  "ETH", 	"\208";	(*  capital Eth, Icelandic *)
  "Ntilde", 	"\209";	(*  capital N, tilde *)
  "Ograve", 	"\210";	(*  capital O, grave accent *)
  "Oacute", 	"\211";	(*  capital O, acute accent *)
  "Ocirc", 	"\212";	(*  capital O, circumflex accent *)
  "Otilde", 	"\213";	(*  capital O, tilde *)
  "Ouml", 	"\214";	(*  capital O, dieresis or umlaut mark *)
  "times",	"\215"; (*  multiply sign*)
  "Oslash", 	"\216";	(*  capital O, slash *)
  "Ugrave", 	"\217";	(*  capital U, grave accent *)
  "Uacute", 	"\218";	(*  capital U, acute accent *)
  "Ucirc", 	"\219";	(*  capital U, circumflex accent *)
  "Uuml", 	"\220";	(*  capital U, dieresis or umlaut mark *)
  "Yacute",	"\221"; (*  capital Y, acute accent *)
  "THORN", 	"\222";	(*  capital THORN, Icelandic *)
  "szlig", 	"\223";	(*  small sharp s, German (sz ligature) *)
  "agrave", 	"\224";	(*  small a, grave accent *)
  "aacute", 	"\225";	(*  small a, acute accent *)
  "acirc", 	"\226";	(*  small a, circumflex accent *)
  "atilde", 	"\227";	(*  small a, tilde *)
  "auml", 	"\228";	(*  small a, dieresis or umlaut mark *)
  "aring", 	"\229";	(*  small a, ring *)
  "aelig", 	"\230";	(*  small ae diphthong (ligature) *)
  "ccedil", 	"\231";	(*  small c, cedilla *)
  "egrave", 	"\232";	(*  small e, grave accent *)
  "eacute", 	"\233";	(*  small e, acute accent *)
  "ecirc", 	"\234";	(*  small e, circumflex accent *)
  "euml", 	"\235";	(*  small e, dieresis or umlaut mark *)
  "igrave", 	"\236";	(*  small i, grave accent *)
  "iacute", 	"\237";	(*  small i, acute accent *)
  "icirc", 	"\238";	(*  small i, circumflex accent *)
  "iuml", 	"\239";	(*  small i, dieresis or umlaut mark *)
  "eth", 	"\240";	(*  small eth, Icelandic *)
  "ntilde", 	"\241";	(*  small n, tilde *)
  "ograve", 	"\242";	(*  small o, grave accent *)
  "oacute", 	"\243";	(*  small o, acute accent *)
  "ocirc", 	"\244";	(*  small o, circumflex accent *)
  "otilde", 	"\245";	(*  small o, tilde *)
  "ouml", 	"\246";	(*  small o, dieresis or umlaut mark *)
  "divide",	"\247"; (*  divide sign *)
  "oslash", 	"\248";	(*  small o, slash *)
  "ugrave", 	"\249";	(*  small u, grave accent *)
  "uacute", 	"\250";	(*  small u, acute accent *)
  "ucirc", 	"\251";	(*  small u, circumflex accent *)
  "uuml", 	"\252";	(*  small u, dieresis or umlaut mark *)
  "yacute", 	"\253";	(*  small y, acute accent *)
  "thorn", 	"\254";	(*  small thorn, Icelandic *)
  "yuml", 	"\255" 	(*  small y, dieresis or umlaut mark *)
  ]
@


\section{Applets}

<<constant Version.applet_init>>=
(* Make it easier to compile both bytecode and native versions *)
let applet_init = ref (fun _ -> ())
@


\chapter{Conclusion}

\appendix

\chapter{Debugging}

<<signature Log.debug_mode>>=
val debug_mode : bool ref
@

<<signature Log.f>>=
val f : string -> unit
@

<<signature Log.debug>>=
val debug : string -> unit
@

<<constant Log.debug_mode>>=
let debug_mode = ref false
@

<<function Log.f>>=
(* flushes ! *)
let f s = try prerr_endline s with _ -> ()
@

<<function Log.debug>>=
let debug s = if !debug_mode then f s 
@

\section{Subsystems}

\subsection{Tty}

<<signature Document.tty_logger>>=
val tty_logger : logger
@

<<type Document.logger>>=
type logger = {
  logger_destroy : bool -> unit;
  logger_progress : int -> unit;
  logger_msg : string -> unit;
  logger_end : string -> unit
}
@

<<constant Document.tty_logger>>=
let tty_logger = 
  { logger_destroy = (fun _ -> ());
    logger_progress = (fun _ -> ());
    logger_msg = Log.f;
    logger_end = Log.f
   }
@

\subsection{HTML}

<<signature Html.verbose>>=
val verbose : bool ref
  (* verbose mode for HTML related stuff *)
@

<<signature Html_eval.debug>>=
(* HTML Evaluation *)

val debug : bool ref
@

<<constant Html_eval.debug>>=
let debug = ref false
@


\section{Dumpers}

\subsection{URLs}

<<signature Url.string_of_protocol>>=
val string_of_protocol: protocol -> string
  (* maps FTP to "ftp", etc... *)
@

<<signature Url.string_of>>=
(* These are used to get "normalized urls" *)
val string_of: t -> string
@


<<function Url.string_of_protocol>>=
let string_of_protocol = function
   FTP -> "ftp"
 | HTTP -> "http"
 | GOPHER -> "gopher"
 | MAILTO -> "mailto"
 | NEWS -> "news"
 | NNTP -> "nntp"
 | TELNET -> "telnet"
 | WAIS -> "wait"
 | FILE -> "file"
 | PROSPERO -> "prospero"
 | OtherProtocol s -> s
@


<<function Url.string_of>>=
let string_of p =
  let buf = Ebuffer.create 128 in
  let ws = Ebuffer.output_string buf
  and wc = Ebuffer.output_char buf in
  let write_userpass () =
      match p.user, p.password with
        None, None -> ()
       | Some u, Some p -> ws u; wc ':'; ws p; wc '@'
       | Some u, None ->   ws u; wc ':'; wc '@'
       | None, Some _ -> failwith "url_of_parsed"
  (* hostname is always put in lowercase *)
  and write_hostport def =
      match p.host, p.port with
        None, None -> ()
       | Some h, None -> ws (String.lowercase h)
       | Some h, Some p when p = def -> ws (String.lowercase h)
       | Some h, Some p -> 
      ws (String.lowercase h); wc ':'; ws (string_of_int p)
       | None, Some _ -> failwith "url_of_parsed"	    

  and write_pathsearch () =
      match p.path, p.search with
       None, None -> wc '/'
      | Some p, Some s -> wc '/'; ws p; wc '?'; ws s
      | Some p, None -> wc '/'; ws p
      | None, Some _ -> failwith "url_of_parsed"	    

  and write_slashpath () =
      match p.path with
       None -> ()
      | Some p -> wc '/'; ws p
  and write_path () =
      match p.path with
       None -> ()
      | Some p -> ws p
  and write_fhost () =
      match p.host with
       None -> ws "localhost"
      | Some h -> ws (String.lowercase h)
  in
  begin match p.protocol with
    FTP ->
      ws "ftp://"; write_userpass (); write_hostport 21; write_slashpath ()
  | HTTP ->
      ws "http://"; write_hostport 80; write_pathsearch ()
  | GOPHER ->
      ws "gopher://"; write_hostport 70; write_slashpath ()
  | MAILTO -> ws "mailto:"; write_path()
  | NEWS -> ws "news:"; write_path()
  | NNTP -> ws "nntp:"; write_hostport 119; write_path()
  | TELNET -> ws "telnet://"; write_userpass(); write_hostport 23
  | WAIS -> ws "wais://"; write_hostport 210; write_pathsearch()
  | FILE ->
    (* for file: we have to transform to ftp: if host is not localhost *)
    begin match p.host with
      None | Some "localhost" ->
        ws "file://"; write_fhost(); write_slashpath()
    | Some h ->
       p.protocol <- FTP;
        ws "ftp://"; write_userpass (); write_hostport 21; write_slashpath ()
    end
  | PROSPERO -> ws "prospero://"; write_hostport 1525; write_slashpath()
  | OtherProtocol s -> ws s; ws ":"; write_path()
  end;
  Ebuffer.get buf
@

\subsection{Links}

<<signature Hyper.string_of>>=
val string_of : link -> string
  (* make an absolute URI (including fragment) from link 
     raises Invalid_link(msg) *)
@

<<function Hyper.string_of>>=
let string_of link =
  let uri = resolve link in
   match uri.uri_frag with 
      None -> uri.uri_url
    | Some f -> Printf.sprintf "%s#%s" uri.uri_url f
@

\subsection{DTDs}

<<signature Dtd.dump>>=
val dump : t -> unit
@

<<function Dtd.dump>>=
let dump dtd =
  Hashtbl.iter (fun s contents -> 
      printf "Element %s %s %s\n" s 
             (if Elements.mem s dtd.open_omitted then "O" else "-")
             (if Elements.mem s dtd.close_omitted then "O" else "-");
      printf "Contains:";
      Elements.iter (fun e -> printf " %s" e) contents;
      printf "\n")
    dtd.contents
@

\subsection{HTML}

<<signature Html.print>>=
val print : token -> unit
  (* for debugging, prints an HTML token *)
@


<<function Html.print>>=
let print = function
    PCData s -> eprintf "PCData: %s\n" s
  | CData s -> eprintf "CData: %s\n" s
  | OpenTag {tag_name = n; attributes = l} ->
            eprintf "Open: %s\n" n;
         List.iter (function (a,v) ->
                   eprintf "%s=%s\n" a v) l
  | CloseTag n -> eprintf "Close: %s\n" n
  | Comment s -> eprintf "Comment: %s\n" s
  | Doctype s -> eprintf "Doctype: %s\n" s
  | EOF -> eprintf "EOF\n"
@

\chapter{Profiling}

\chapter{Error Managment}

\section{[[Error.t]]}

<<signature class Error.t>>=
class t : (Widget.widget) -> object
 method f : string -> unit
 method ok : string -> unit
 method choose : string -> bool
 method ari : string -> int
end
@


<<signature Error.default>>=
val default : t
@
<<constant Error.default>>=
let default = new t default_toplevel
@



<<signature Error.f>>=
val f : string -> unit
@

<<signature Error.ok>>=
val ok : string -> unit
@

<<signature Error.choose>>=
val choose : string -> bool
@

<<signature Error.ari>>=
val ari : string -> int
@


<<class Error.t>>=
class t (top) =
 object
 (* val top = top *)

method f msg =
  let _ =
   Frx_dialog.f top (gensym "error")
     (I18n.sprintf "MMM Error")
     msg
     (Predefined "error") 0 ["Ok"] in
  ()


method ok msg = 
  ignore (
   Frx_dialog.f  top (gensym "error")
     (I18n.sprintf "MMM Notify")
     msg
     (Predefined "info") 0 ["Ok"])

method choose msg =
 0 =
  Frx_dialog.f top (gensym "error")
    (I18n.sprintf "MMM Choice")
    msg
    (Predefined "question") 1 ["Yes"; "No"]

method ari msg =
  Frx_dialog.f top (gensym "error")
    (I18n.sprintf "MMM Error")
    msg
    (Predefined "question") 1 
    [I18n.sprintf "A)bort"; I18n.sprintf "R)etry"; I18n.sprintf "I)gnore"]

end
@

\section{URL}

<<exception Url.Url_Lexing>>=
exception Url_Lexing of string * int
@

\section{Links}

<<type Hyper.link_error>>=
type link_error =
    LinkResolve of string
  | UrlLexing of string * int
@

<<exception Hyper.Invalid_link>>=
exception Invalid_link of link_error
@

\section{Requests}

<<exception Www.Invalid_request>>=
exception Invalid_request of request * string
@

\section{HTML}

<<exception Html.Html_Lexing>>=
exception Html_Lexing of string * int
@

<<exception Html.Invalid_Html>>=
exception Invalid_Html of string
@

\chapter{Standard Library}

<<constant Common.spf>>=
let spf = Printf.sprintf
@

<<function Common.TODOOPERATOR>>=
let (|>) o f = f o
@

\section{Lists}

<<signature Mlist.hdn>>=
(* List utilities *)
val hdn : 'a list -> int -> 'a list
   (* [hdn [a1;a2;...;an;...; ak] returns [a1;a2;...;an] *)
@

<<signature Mlist.tln>>=
val tln : 'a list -> int -> 'a list
   (* [tln [a1;a2;...;an;...; ak] returns [an+1;...; ak] *)
@

<<signature Mlist.except_assoc>>=
val except_assoc: 'a -> ('a * 'b) list -> ('a * 'b) list
@

<<signature Mlist.exceptq>>=
val exceptq: 'a -> 'a list -> 'a list
@

<<signature Mlist.rev_do_list>>=
val rev_do_list : ('a -> unit) -> 'a list -> unit
@

<<signature Mlist.do_listi>>=
val do_listi : (int -> 'a -> unit) -> int -> 'a list -> unit
@




<<function Mlist.tln>>=
(* tln l n *)
let rec tln l = function
   0 -> l
 | n -> if l = [] then [] else tln (List.tl l) (pred n)
@

<<function Mlist.hdn>>=
let hdn l =
  let rec h l acc = function
    0 -> List.rev acc
  | n -> if l = [] then List.rev acc 
        else h (List.tl l) (List.hd l :: acc) (pred n) in
  h l []
@

<<function Mlist.except_assoc>>=
let except_assoc x =
  let rec ex acc = function 
      [] -> acc
    | (y,v)::l when x = y -> ex acc l
    | z :: l -> ex (z::acc) l
  in
  ex []
@

<<function Mlist.exceptq>>=
let exceptq x =
  let rec ex acc = function
     [] -> acc
   | y::l when y == x -> ex acc l
   | y::l -> ex (y::acc) l
  in
  ex []
@

<<function Mlist.rev_do_list>>=
(* List.iter from right to left *)
let rev_do_list f = 
 let rec do_list_f = function
     [] -> () | x::l -> do_list_f l; f x in
  do_list_f
@

<<function Mlist.do_listi>>=
let rec do_listi f n l =
  match l with
    [] -> ()
  | (x::l) -> f n x; do_listi f (succ n) l
@

\section{Strings}

<<signature Mstring.split_str>>=
(* String utilities *)
val split_str : (char -> bool) -> string -> string list
@

<<signature Mstring.get_suffix>>=
val get_suffix : string -> string
@

<<signature Mstring.hex_to_dec>>=
val hex_to_dec : char -> int
@

<<signature Mstring.dec_to_hex>>=
val dec_to_hex : int -> char
@

<<signature Mstring.hex_to_string>>=
val hex_to_string : string -> string
@

<<signature Mstring.gensym>>=
val gensym : string -> string
@

<<signature Mstring.egensym>>=
val egensym : string -> unit -> string
@

<<signature Mstring.rem_trailing_sp>>=
val rem_trailing_sp : string -> string
@

<<signature Mstring.catenate_sep>>=
val catenate_sep : string -> string list -> string
@

<<signature Mstring.norm_crlf>>=
val norm_crlf : bool -> string -> int -> int -> string * bool
    (* [norm_crlf last_was_cr buf offs len] returns
       buf with CRLF/CR/LF converted to LF, and a flag indicating
       whether last char was CR *)
@




<<function Mstring.split_str>>=
(* split a string according to char_sep predicate *)
let split_str char_sep str =
  let len = String.length str in
  if len = 0 then [] else
    let rec skip_sep cur =
      if cur >= len then cur
      else if char_sep str.[cur] then skip_sep (succ cur)
      else cur  in
    let rec split beg cur =
      if cur >= len then 
    if beg = cur then []
    else [String.sub str beg (len - beg)]
      else if char_sep str.[cur] 
       then 
         let nextw = skip_sep cur in
          (String.sub str beg (cur - beg))
        ::(split nextw nextw)
       else split beg (succ cur) in
    let wstart = skip_sep 0 in
    split wstart wstart
@

<<function Mstring.get_suffix>>=
(* extract the . suffix (dot excluded) of a string *)
let get_suffix s =
  try
    let dotpos = succ (String.rindex s '.') in
      String.sub s dotpos (String.length s - dotpos)
  with
    Not_found -> ""
@

<<function Mstring.hex_to_dec>>=
(* HEX/DEC conversions *)
let hex_to_dec c = match c with
    '0'..'9' -> Char.code c - 48
  | 'a'..'f' -> Char.code c - 87 (* 87 = Char.code 'a' - 10 *)
  | 'A'..'F' -> Char.code c - 55 (* 55 = Char.code 'A' - 10 *)
  | _ -> failwith "hex_to_dec"
@

<<function Mstring.dec_to_hex>>=
let dec_to_hex i =
  if i < 10 then Char.chr (i + 48)  (* 48 = Char.code '0' *)
  else Char.chr (i + 55)            (* 55 = Char.code 'A' - 10 *)
@

<<function Mstring.hex_to_string>>=
(* Converting a hex stored string *)
let hex_to_string s =
  let len = String.length s / 2 in
  let res = String.create len in
    for i = 0 to len - 1 do
      res.[i] <- Char.chr ( 16 * (hex_to_dec s.[i+i]) + hex_to_dec s.[i+i+1])
      done;
    res
@

<<constant Mstring.gensym>>=
let gensym =
  let cnter = ref 0 in
  (fun n ->
    incr cnter;
    n ^ string_of_int !cnter)
@

<<function Mstring.egensym>>=
let egensym s =
  let cnter = ref 0 in
  (fun () ->
    incr cnter;
    s ^ string_of_int !cnter)
@

<<function Mstring.rem_trailing_sp>>=
let rem_trailing_sp s =
  let l = String.length s in
  let pos = ref (l - 1) in
  while !pos >= 0 && List.mem s.[!pos] [' '; '\t'] do decr pos done;
  if !pos = l - 1 then s
  else String.sub s 0 (succ !pos)
@

<<function Mstring.catenate_sep>>=
let catenate_sep sep =
  function 
      [] -> ""
    | x::l -> List.fold_left (fun s s' -> s^sep^s') x l
@

<<function Mstring.norm_crlf>>=
(* Filters CRLF:
 *  CR -> LF
 *  CRLF -> LF
 *  LF -> LF
 * We do this on successive chunks of a stream, so we need to consider
 * the case when the chunk finishes on CR.
 * Assume len > 0
 *)

let norm_crlf lastwascr buf offs len =
  let rpos = ref offs
  and wpos = ref 0
  and dest = String.create (len + 1) (* we need one more char *)
  and limit = offs + len - 1  
  and lastiscr = ref false in
  if lastwascr then
    if buf.[!rpos] = '\n' then begin
      dest.[!wpos] <- '\n';
      incr rpos; incr wpos
    end
    else begin
      dest.[!wpos] <- '\n'; incr wpos
    end;

  while !rpos < limit do
    match buf.[!rpos] with
      '\n' -> dest.[!wpos] <- '\n'; incr rpos; incr wpos
    | '\r' -> 
    if buf.[!rpos + 1] = '\n'
    then begin dest.[!wpos] <- '\n'; rpos := !rpos + 2; incr wpos end
    else begin dest.[!wpos] <- '\n'; incr rpos; incr wpos end
    | c -> dest.[!wpos] <- c; incr rpos; incr wpos 
  done;
  begin match buf.[offs+len-1] with
    '\n' -> dest.[!wpos] <- '\n'; incr wpos
  | '\r' -> lastiscr := true
  | c -> dest.[!wpos] <- c; incr wpos
  end;
  String.sub dest 0 !wpos, !lastiscr
@

\section{Files}

<<signature Msys.tilde_subst>>=
val tilde_subst : string -> string
    (* substitute ~ at beginning of file path *)
@

<<signature Msys.rm>>=
val rm: string -> unit
    (* quiet unlink *)
@

<<signature Msys.fsize>>=
val fsize: string -> int
    (* file size *)
@

<<signature Msys.mktemp>>=
val mktemp : string -> string
@

<<function Msys.next_slash>>=
(* skip to next / *)
let rec next_slash s n =
  if  n >= String.length s or s.[n] = '/' 
  then n
  else next_slash s (succ n)
@

<<function Msys.tilde_subst>>=
let tilde_subst s =
 try
  if s = "" or s.[0] <> '~' then s 
  else
    let len = String.length s in
    if len = 1 then Sys.getenv "HOME"
    else match s.[1] with
      '/' -> 
        Filename.concat (Sys.getenv "HOME") (String.sub s 2 (len - 2))
     | _ ->
       let final = next_slash s 1 in
       let user = String.sub s 1 (pred final) in
       let pwnam = getpwnam user in
         if succ final >= len then pwnam.pw_dir
         else
          Filename.concat pwnam.pw_dir 
               (String.sub s (succ final) (len - (succ final)))
 with
    Unix_error(_,_,_) -> s
  | Sys_error _ -> s
  | Not_found -> s
@

<<function Msys.rm>>=
(* Quiet unlink *)
let rm s = try unlink s with Unix_error _ -> ()
@

<<function Msys.rmdir>>=
let rmdir dir =
  try
    let dh = opendir dir 
    and l = ref [] in
    try while true do
      let f = readdir dh in
      if f <> "." && f <> ".." then l := f :: !l
    done
    with
      End_of_file -> 
    closedir dh;
    List.iter (fun f -> rm (Filename.concat dir f)) !l;
    Unix.rmdir dir
  with
    Unix_error _ -> ()
@

<<function Msys.fsize>>=
let fsize f =
  try (Unix.stat f).st_size
  with Unix_error(_,_,_) -> raise Not_found
@

<<constant Msys.tmp_dir>>=
let tmp_dir = ref "/tmp"
@

<<constant Msys.mktemp>>=
(* We know use our own private directory in /tmp, cleared at exit-time,
   so no one can snoop our temporary files *)
let mktemp =
  let cnter = ref 0 
  and pid = Unix.getpid() 
  and id = ref 0 in
  let thisdir = 
    let testdir = ref "" in
    try while true do
      testdir := Filename.concat !tmp_dir ("mmm" ^ string_of_int pid
                         ^ "_" ^ string_of_int !id);
      if not (Sys.file_exists !testdir) then raise Exit;
      incr id;
      if !id >= 16 then 
    raise (Failure ("Too many MMM temporary directory in " ^ !tmp_dir ^
            ". Clean them first."))
    done; "" (* cannot reach *)
    with
      Exit -> !testdir
  in
  Unix.mkdir thisdir 0o700;
  at_exit (fun () -> rmdir thisdir);
  (function prefx -> 
      incr cnter; 
      (Filename.concat thisdir (prefx ^ string_of_int !cnter)))
@


\section{Dates}


<<signature Date.asc_wkday>>=
val asc_wkday : int -> string
    (* [asc_wkday n] maps 0..6 to Sun..Sat *)
@

<<signature Date.asc_month>>=
val asc_month : int -> string
    (* [asc_month n] maps 0..11 to Jan..Dec *)
@

<<signature Date.asc>>=
val asc : float -> string
    (* [asc uxtime] RFC822 of unix time *)
@

<<signature Date.asc_now>>=
val asc_now : unit -> string
    (* [asc_now ()] RFC822 of now *)
@

<<signature Date.commonlog>>=
val commonlog : float -> string
  (* Text version (Common log format) of an Unix time value *)
@

<<signature Date.compare_time>>=
val compare_time : int list * int list -> int
    (* [compare_time l1 l2] compare lists encodings of timestamps
       Encoding must be:
        [year; month; mday; hour; min; sec]
     *)
@



<<function Date.asc_wkday>>=
let asc_wkday = function
   0 -> "Sun"
 | 1 -> "Mon"
 | 2 -> "Tue"
 | 3 -> "Wed"
 | 4 -> "Thu"
 | 5 -> "Fri"
 | 6 -> "Sat"
 | _ -> assert false
@

<<function Date.asc_month>>=
let asc_month = function
   0 -> "Jan"
 | 1 -> "Feb"
 | 2 -> "Mar"
 | 3 -> "Apr"
 | 4 -> "May"
 | 5 -> "Jun"
 | 6 -> "Jul"
 | 7 -> "Aug"
 | 8 -> "Sep"
 | 9 -> "Oct"
 | 10 -> "Nov"
 | 11 -> "Dec"
 | _ -> assert false
@

<<function Date.asc>>=
(* Produces RFC822 style *)
let asc ut =
  let tm = gmtime ut in
    sprintf "%s, %02d %s %d %02d:%02d:%02d GMT"
        (asc_wkday tm.tm_wday)
    tm.tm_mday
    (asc_month tm.tm_mon)
    (tm.tm_year + 1900)
    tm.tm_hour
    tm.tm_min
    tm.tm_sec
@

<<function Date.asc_now>>=
let asc_now () = asc (time())
@

<<function Date.commonlog>>=
(* Timezone ??? *)
let commonlog int =
  let tm = localtime int in
  sprintf "%02d/%s/%d:%02d:%02d:%02d"
      tm.tm_mday
      (asc_month tm.tm_mon)
      (tm.tm_year + 1900)
      tm.tm_hour
      tm.tm_min
      tm.tm_sec
@

<<function Date.compare_time>>=
let rec compare_time = function
   [], [] -> 0
 | (x::xx), (y::yy) when x = y -> compare_time (xx, yy)
 | (x::_), (y::_) when x < y -> -1
 | (x::_), (y::_) when x > y -> 1
 |  _, _ -> assert false
@



\chapter{Extra Code}

\ifallcode
#include "Browser_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
URL  = Uniform Resource Locator
URI  = Universal Resource Identifier
HTML =
DOM  = Document Object Model
CSS  = Cascading Style Sheets
JS   = Javascript
HTTP =
WWW  = World Wide Web
MIME = ??
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

% see mmm-gdr-fr.ps biblio, main RFCs are there.

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

