\section{[[./commons/]]}

\subsection*{[[./commons/common.ml]]}


%-------------------------------------------------------------

<<./commons/common.ml>>=

module StringSet = Set.Make(struct type t = string let compare = compare end)

<<constant Common.spf>>

<<function Common.TODOOPERATOR>>

let pr2 s = prerr_string (s ^ "\n")

@


\subsection*{[[./commons/condition.mli]]}

%todo: replaced with the one in ocaml?

<<signature Condition.create>>=
val create : unit -> t
@
<<signature Condition.wait>>=
val wait : t -> unit
@

<<signature Condition.set>>=
val set : t -> unit
@

<<signature Condition.free>>=
val free : t -> unit
@


%-------------------------------------------------------------

<<./commons/condition.mli>>=
type t

type condition_backend = {
  create: t -> unit;
  set: t -> unit;
  wait: t -> unit;
  free: t -> unit;
}

val backend: condition_backend ref

<<signature Condition.create>>
<<signature Condition.set>>
<<signature Condition.wait>>
<<signature Condition.free>>
@


\subsection*{[[./commons/condition.ml]]}

<<type Condition.t>>=
type t = string
@


%-------------------------------------------------------------

<<./commons/condition.ml>>=
(* Conditions *)
open Common

<<type Condition.t>>

type condition_backend = {
  create: t -> unit;
  set: t -> unit;
  wait: t -> unit;
  free: t -> unit;
}

let default_backend () = {
  create = (fun s -> ());
  set = (fun s -> ());
  wait = (fun s -> ());
  free = (fun s -> ());
}
let backend = ref (default_backend ())
  
let count = ref 0

let create () =
  incr count;
  let var = spf "var%d" !count in
  (!backend).create var;
  var

let set s =
  !backend.set s

let wait s = 
  !backend.wait s

let free s = 
  !backend.free s
@


\subsection*{[[./commons/date.mli]]}

%-------------------------------------------------------------

<<./commons/date.mli>>=
<<copyright header v6>>

<<signature Date.asc_wkday>>

<<signature Date.asc_month>>

<<signature Date.asc>>

<<signature Date.asc_now>>

<<signature Date.commonlog>>

<<signature Date.compare_time>>

@


\subsection*{[[./commons/date.ml]]}


%-------------------------------------------------------------

<<./commons/date.ml>>=
<<copyright header v6>>

open Printf
open Unix

<<function Date.asc_wkday>>

<<function Date.asc_month>>

<<function Date.asc>>

<<function Date.asc_now>>


<<function Date.commonlog>>


<<function Date.compare_time>>
@


\subsection*{[[./commons/ebuffer.mli]]}

%todo: replaced with the one in ocaml? buffer.mli

<<signature Ebuffer.create>>=
val create : int -> t
  (* [create n] creates a buffer with initial size [n] *)
@

<<signature Ebuffer.output_string>>=
val output_string : t -> string -> unit
  (* [output_string buf s] appends [s] to [buf] *)
@

<<signature Ebuffer.output_char>>=
val output_char : t -> char -> unit
  (* [output_char buf c] appends [c] to [buf] *)
@

<<signature Ebuffer.output>>=
val output : t -> string -> int -> int -> unit
  (* [output buf s offs len] appends [len] characters of [s], starting
     at offset [offs] to [buf].
     Raises [Invalid_argument] if [offs] and [len] do not designate a
     valid substring of [s] *)
@

<<signature Ebuffer.get>>=
val get : t -> string
  (* [get buf] returns the current contents of [buf] *)
@

<<signature Ebuffer.used>>=
val used : t -> int
  (* [used buf] returns the current length of [buf] *)
@

<<signature Ebuffer.reset>>=
val reset : t -> unit
  (* [reset buf] emties [buf] *)  
@


%-------------------------------------------------------------

<<./commons/ebuffer.mli>>=
<<copyright header v6>>

(* Extensible buffers *)

type t 

<<signature Ebuffer.create>>

<<signature Ebuffer.output_string>>
<<signature Ebuffer.output_char>>
<<signature Ebuffer.output>>

<<signature Ebuffer.get>>
<<signature Ebuffer.used>>

<<signature Ebuffer.reset>>
@


\subsection*{[[./commons/ebuffer.ml]]}

<<type Ebuffer.t>>=
(* Extensible buffers *)
type t = {
    mutable buffer : string;
    mutable pos : int;
    mutable len : int}
@

<<function Ebuffer.create>>=
let create n = {
   buffer = String.create n;
   pos = 0;
   len = n
   }
@

<<function Ebuffer.reset>>=
let reset buf =
    buf.pos <- 0
@

<<function Ebuffer.newsize>>=
let newsize old added =
  if added < old then old + old
  else old + old + added
@

<<function Ebuffer.output_string>>=
let output_string buf s =
  let l = String.length s in
  if buf.pos + l > buf.len then begin
    let size = newsize buf.len l in
    let news = String.create size in
      String.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  String.unsafe_blit s 0 buf.buffer buf.pos l;
  buf.pos <- buf.pos + l
@

<<function Ebuffer.output_char>>=
let output_char buf c =
  if buf.pos >= buf.len then begin
    let size = newsize buf.len 1 in
    let news = String.create size in
      String.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  buf.buffer.[buf.pos] <- c;
  buf.pos <- buf.pos + 1
@

<<function Ebuffer.output>>=
let output buf s ofs l =
  if buf.pos + l > buf.len then begin
    let size = newsize buf.len l in
    let news = String.create size in
      String.unsafe_blit buf.buffer 0 news 0 buf.pos;
      buf.buffer <- news;
      buf.len <- size
    end;
  String.blit s ofs buf.buffer buf.pos l;
  buf.pos <- buf.pos + l
@

<<function Ebuffer.get>>=
let get buf = 
  String.sub buf.buffer 0 buf.pos
@

<<function Ebuffer.used>>=
let used buf =
  buf.pos
@


%-------------------------------------------------------------

<<./commons/ebuffer.ml>>=
<<copyright header v6>>

<<type Ebuffer.t>>

<<function Ebuffer.create>>

<<function Ebuffer.reset>>

<<function Ebuffer.newsize>>

<<function Ebuffer.output_string>>
<<function Ebuffer.output_char>>

<<function Ebuffer.output>>


<<function Ebuffer.get>>

<<function Ebuffer.used>>
@


\subsection*{[[./commons/error.mli]]}



%-------------------------------------------------------------

<<./commons/error.mli>>=

<<signature class Error.t>>

<<signature Error.default>>

<<signature Error.f>>
<<signature Error.ok>>
<<signature Error.choose>>
<<signature Error.ari>>

@


\subsection*{[[./commons/error.ml]]}


%-------------------------------------------------------------

<<./commons/error.ml>>=
open Common

<<class Error.t>>

class virtual t = object
 method virtual f : string -> unit
 method virtual ok : string -> unit
 method virtual choose : string -> bool
 method virtual ari : string -> int
end

class x = object
  inherit t
  method f _ = pr2 "TODO: Error.x.f"
  method ok _ = pr2 "TODO: Error.x.ok"
  method choose _ = failwith "TODO: Error.x.choose"
  method ari _ = failwith "TODO: Error.x.ari"
end

<<constant Error.default>>

(* backward compatibility *)
<<functions Error.xxx>>
@


\subsection*{[[./commons/i18nprintf.mli]]}

%todo: remove?

<<signature I18nprintf.fprintf>>=
(* Module [Printf]: formatting printing functions *)

val fprintf: out_channel -> ('a, out_channel, unit) format -> 'a
        (* [fprintf outchan format arg1 ... argN] formats the arguments
           [arg1] to [argN] according to the format string [format],
           and outputs the resulting string on the channel [outchan].

           The format is a character string which contains two types of
           objects:  plain  characters, which are simply copied to the
           output channel, and conversion specifications, each of which
           causes  conversion and printing of one argument.

           Conversion specifications consist in the [%] character, followed
           by optional flags and field widths, followed by one conversion
           character. The conversion characters and their meanings are:
-          [d] or [i]: convert an integer argument to signed decimal
-          [u]: convert an integer argument to unsigned decimal
-          [x]: convert an integer argument to unsigned hexadecimal,
                using lowercase letters.
-          [X]: convert an integer argument to unsigned hexadecimal,
                using uppercase letters.
-          [s]: insert a string argument
-          [c]: insert a character argument
-          [f]: convert a floating-point argument to decimal notation,
                in the style [dddd.ddd]
-          [e] or [E]: convert a floating-point argument to decimal notation,
                in the style [d.ddd e+-dd] (mantissa and exponent)
-          [g] or [G]: convert a floating-point argument to decimal notation,
                in style [f] or [e], [E] (whichever is more compact)
-          [b]: convert a boolean argument to the string [true] or [false]
-          [a]: user-defined printer. Takes two arguments and apply the first
                one to [outchan] (the current output channel) and to the second
                argument. The first argument must therefore have type
                [out_channel -> 'b -> unit] and the second ['b].
                The output produced by the function is therefore inserted
                in the output of [fprintf] at the current point.
-          [t]: same as [%a], but takes only one argument (with type
                [out_channel -> unit]) and apply it to [outchan].
-          Refer to the C library [printf] function for the meaning of
           flags and field width specifiers.

           If too few arguments are provided, printing stops just
           before converting the first missing argument. *)
@

<<signature I18nprintf.printf>>=
val printf: ('a, out_channel, unit) format -> 'a
        (* Same as [fprintf], but output on [stdout]. *)
@

<<signature I18nprintf.eprintf>>=
val eprintf: ('a, out_channel, unit) format -> 'a
        (* Same as [fprintf], but output on [stderr]. *)
@

<<signature I18nprintf.sprintf>>=
val sprintf: ('a, unit, string) format -> 'a
        (* Same as [printf], but return the result of formatting in a
           string. *)
@


%-------------------------------------------------------------

<<./commons/i18nprintf.mli>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

<<signature I18nprintf.fprintf>>

<<signature I18nprintf.printf>>

<<signature I18nprintf.eprintf>>

<<signature I18nprintf.sprintf>>
@


\subsection*{[[./commons/i18nprintf.ml]]}

<<function I18nprintf.fprintf>>=
let fprintf outchan format =
  let format = (Obj.magic format : string) in
  let outside_iso8859 = ref false in
  let rec doprn i =
    if i >= String.length format then
      Obj.magic ()
    else begin
      let c = String.unsafe_get format i in
      if c = '\027' then begin
    if i+2 < String.length format &&
       String.unsafe_get format (i+1) = '\040' && 
       String.unsafe_get format (i+2) = '\066' then
         outside_iso8859 := false
    else outside_iso8859 := true
      end;
      if c <> '%' || !outside_iso8859 then begin
        output_char outchan c;
        doprn (succ i)
      end else begin
        let j = skip_args (succ i) in
        match String.unsafe_get format j with
          '%' ->
            output_char outchan '%';
            doprn (succ j)
        | 's' ->
            Obj.magic(fun s ->
              if j <= i+1 then
                output_string outchan s
              else begin
                let p =
                  try
                    int_of_string (String.sub format (i+1) (j-i-1))
                  with _ ->
                    invalid_arg "I18nprintf.fprintf: bad %s format" in
                if p > 0 & String.length s < p then begin
                  output_string outchan
                                (String.make (p - String.length s) ' ');
                  output_string outchan s
                end else if p < 0 & String.length s < -p then begin
                  output_string outchan s;
                  output_string outchan
                                (String.make (-p - String.length s) ' ')
                end else
                  output_string outchan s
              end;
              doprn (succ j))
        | 'c' ->
            Obj.magic(fun c ->
              output_char outchan c;
              doprn (succ j))
        | 'd' | 'o' | 'x' | 'X' | 'u' ->
            Obj.magic(fun n ->
              output_string outchan
                            (format_int (String.sub format i (j-i+1)) n);
              doprn (succ j))
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            Obj.magic(fun f ->
              output_string outchan
                            (format_float (String.sub format i (j-i+1)) f);
              doprn (succ j))
        | 'b' ->
            Obj.magic(fun b ->
              output_string outchan (string_of_bool b);
              doprn (succ j))
        | 'a' ->
            Obj.magic(fun printer arg ->
              printer outchan arg;
              doprn(succ j))
        | 't' ->
            Obj.magic(fun printer ->
              printer outchan;
              doprn(succ j))
        | c ->
            invalid_arg ("I18nprintf.fprintf: unknown format")
      end
    end

  and skip_args j =
    match String.unsafe_get format j with
      '0' .. '9' | ' ' | '.' | '-' -> skip_args (succ j)
    | c -> j

  in doprn 0
@

<<function I18nprintf.sprintf>>=
let sprintf format =
  let format = (Obj.magic format : string) in
  let outside_iso8859 = ref false in
  let rec doprn start i accu =
    if i >= String.length format then begin
      let res = 
        if i > start    
        then String.sub format start (i-start) :: accu
        else accu in
      Obj.magic(String.concat "" (List.rev res))
    end else
      let c = String.unsafe_get format i in
      if c = '\027' then begin
    if i+2 < String.length format &&
       String.unsafe_get format (i+1) = '\040' && 
       String.unsafe_get format (i+2) = '\066' then
         outside_iso8859 := false
    else outside_iso8859 := true
      end;
      if c <> '%' || !outside_iso8859 then
        doprn start (i+1) accu
      else begin
        let accu1 =
          if i > start then
          String.sub format start (i-start) :: accu
          else accu in
        let j = skip_args (succ i) in
        match String.unsafe_get format j with
          '%' ->
            doprn j (succ j) accu1
        | 's' ->
            Obj.magic(fun s ->
              let accu2 =
                if j <= i+1 then
                  s :: accu1
                else begin
                  let p =
                    try
                      int_of_string (String.sub format (i+1) (j-i-1))
                    with _ ->
                      invalid_arg "I18nprintf.fprintf: bad %s format" in
                  if p > 0 & String.length s < p then
                    s :: String.make (p - String.length s) ' ' :: accu1
                  else if p < 0 & String.length s < -p then
                    String.make (-p - String.length s) ' ' :: s :: accu1
                  else
                    s :: accu1
                end in
              doprn (succ j) (succ j) accu2)
        | 'c' ->
            Obj.magic(fun c ->
              doprn (succ j) (succ j) (String.make 1 c :: accu1))
        | 'd' | 'o' | 'x' | 'X' | 'u' ->
            Obj.magic(fun n ->
              doprn (succ j) (succ j)
                    (format_int (String.sub format i (j-i+1)) n :: accu1))
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            Obj.magic(fun f ->
              doprn (succ j) (succ j)
                    (format_float (String.sub format i (j-i+1)) f :: accu1))
        | 'b' ->
            Obj.magic(fun b ->
              doprn (succ j) (succ j) (string_of_bool b :: accu1))
        | 'a' ->
            Obj.magic(fun printer arg ->
              doprn (succ j) (succ j) (printer () arg :: accu1))
        | 't' ->
            Obj.magic(fun printer ->
              doprn (succ j) (succ j) (printer () :: accu1))
        | c ->
            invalid_arg ("I18nprintf.sprintf: unknown format")
      end

  and skip_args j =
    match String.unsafe_get format j with
      '0' .. '9' | ' ' | '.' | '-' -> skip_args (succ j)
    | c -> j

  in doprn 0 0 []
@


%-------------------------------------------------------------

<<./commons/i18nprintf.ml>>=
(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  Automatique.  Distributed only by permission.                      *)
(*                                                                     *)
(***********************************************************************)

external format_int: string -> int -> string = "caml_format_int"
external format_float: string -> float -> string = "caml_format_float"

<<function I18nprintf.fprintf>>

let printf fmt = fprintf stdout fmt
and eprintf fmt = fprintf stderr fmt

<<function I18nprintf.sprintf>>
@


\subsection*{[[./commons/ibtree.mli]]}

%todo: replace with Map?
% have notion of interval? good for anchors?

%(* Exemples
%let anchors = [
% {start = 1,3; stop = 1,7};
% {start = 1,13; stop = 1,17};
% {start = 1,30; stop = 1,70};
% {start = 10,3; stop = 10,7};
% {start = 11,3; stop = 12,1};
% {start = 12,3; stop = 13,17};
% {start = 14,30; stop = 15,7};
% {start = 100,3; stop = 100,7};
% {start = 101,3; stop = 101,7};
% {start = 101,31; stop = 101,37}
% ]
%do_list add_anchor anchors
%
%find_anchor (1,6)
%find_anchor (12,0)
%find_anchor (11,7)
%find_anchor (101,3)
%find_anchor (15,3)
%find_anchor (16,3)
%
%(* A bit long (more than 3 seconds in Caml Light) *)
%for i = 0 to 10000 do 
% add_anchor {start = i, 1+i/2; stop = i, i}
%done
%*)

%-------------------------------------------------------------

<<./commons/ibtree.mli>>=
module type S =
  sig
    type key
    type 'a t
    val empty: 'a t
    val add: (key * key) -> 'a -> 'a t -> 'a t
    val find: key -> 'a t -> 'a

    val find_interval : key -> 'a t -> key * key
  end

module Make(Ord: Map.OrderedType): (S with type key = Ord.t)

@


\subsection*{[[./commons/ibtree.ml]]}


%-------------------------------------------------------------

<<./commons/ibtree.ml>>=
(* Simple binary trees with no redondant elements, and no delete function *)

module type S =
  sig
    type key
    type 'a t
    val empty: 'a t
    val add: (key * key) -> 'a -> 'a t -> 'a t
    val find: key -> 'a t -> 'a
    val find_interval : key -> 'a t -> key * key
  end


module Make(Ord: Map.OrderedType) = struct

type key = Ord.t

type balance = Eq | Le | Ri

type 'a element = {
    interval : key * key;
    image : 'a
  } 

type 'a t =
 | Empty
 | Node of 'a node

and 'a node =
 {balance : balance; height : int;
  left : 'a t; element : 'a element; right : 'a t}

let height = function
  | Empty -> 0
  | Node {height = h} -> h

let create_node l e r =
  let hl = height l in
  let hr = height r in
  Node
   {
     balance = 
       (if hl = hr 
       then Eq 
       else 
         if hl < hr then Ri else Le
        )
     ;
     height = 1 + (if hr > hl then hr else hl);
     left = l; 
     element = e; 
     right = r;
   }

let turn_right = function
 | Empty -> Empty
 | Node
    {left =
      Node
       {balance = Eq | Ri;
        left = lle; element = le;
        right = Node {left = lrle; element = rle; right = rrle}};
     element = e; right = re} ->
      create_node (create_node lle le lrle) rle (create_node rrle e re)
 | Node
    {left =
      Node
       {balance = Le | Eq; left = lle; element = le; right = rle};
     element = e;
     right = re} -> create_node lle le (create_node rle e re)
 | _ -> failwith "turn_right"

and turn_left = function
 | Empty -> Empty
 | Node
    {left = le; element = e;
     right =
      Node
       {balance = Eq | Le;
        left = Node {left = llre; element = lre; right = rlre};
        element = re; right = rre}} ->
     create_node (create_node le e llre) lre (create_node rlre re rre)
 | Node
    {left = le; element = e;
     right =
      Node
       {balance = Ri | Eq; left = lre; element = re; right = rre}} ->
     create_node (create_node le e lre) re rre
 | _ -> failwith "turn_left"

let reball hr l e nr =
 let hnr = height nr and nt = create_node l e nr in
 if hnr > hr then turn_left nt else nt

let rebalr hl nl e r =
 let hnl = height nl and nt = create_node nl e r in
 if hnl > hl then turn_right nt else nt

(* Si les intervalles sont disjoints, la comparaison des bornes inferieures
   est un ordre *)

let compare_elements x y =
  Ord.compare (fst x.interval) (fst y.interval)

let rec insert x t =
 match t with
 | Empty ->
    Node {balance = Eq; height = 1; left = Empty; element = x; right = Empty}
 | Node {balance = b; left = l; element = e; right = r} ->
    let c = compare_elements x e in
    if c = 0 then t else
    if c > 0 then
     if b = Ri then reball (height r) l e (insert x r)
      else create_node l e (insert x r) else
    if b = Le then rebalr (height l) (insert x l) e r
     else create_node (insert x l) e r


let empty = Empty

let rec find pos = function
| Empty -> raise Not_found
| Node {left = l; element = e ; right = r} ->
   let c_start = Ord.compare pos (fst e.interval) in
   if c_start < 0 then find pos l else
   let c_stop = Ord.compare pos (snd e.interval) in
   if c_stop < 0 then e.image else find pos r


let rec find_interval pos = function
| Empty -> raise Not_found
| Node {left = l; element = e ; right = r} ->
   let c_start = Ord.compare pos (fst e.interval) in
   if c_start < 0 then find_interval pos l else
   let c_stop = Ord.compare pos (snd e.interval) in
   if c_stop < 0 then e.interval else find_interval pos r


let add i v = insert {interval = i; image = v}


(* Application to anchors
type position = int * int

type anchor_position = {start : position; stop : position}

let rec anchor_of_pos pos = function
| Empty -> raise Not_found
| Node {left = l; element = e; right = r} ->
   let c_start = compare pos e.start in
   if c_start < 0 then anchor_of_pos pos l else
   let c_stop = compare pos e.stop in
   if c_stop < 0 then e else anchor_of_pos pos r

let anchors_table = ref Empty

let add_anchor a = anchors_table := insert a !anchors_table
let find_anchor mouse_pos = anchor_of_pos mouse_pos !anchors_table

 *)
(* Exemples
let anchors = [
 {start = 1,3; stop = 1,7};
 {start = 1,13; stop = 1,17};
 {start = 1,30; stop = 1,70};
 {start = 10,3; stop = 10,7};
 {start = 11,3; stop = 12,1};
 {start = 12,3; stop = 13,17};
 {start = 14,30; stop = 15,7};
 {start = 100,3; stop = 100,7};
 {start = 101,3; stop = 101,7};
 {start = 101,31; stop = 101,37}
 ]
do_list add_anchor anchors

find_anchor (1,6)
find_anchor (12,0)
find_anchor (11,7)
find_anchor (101,3)
find_anchor (15,3)
find_anchor (16,3)

(* A bit long (more than 3 seconds in Caml Light) *)
for i = 0 to 10000 do 
 add_anchor {start = i, 1+i/2; stop = i, i}
done
*)
end
@


\subsection*{[[./commons/lang.mli]]}

%todo: remove?

%-------------------------------------------------------------

<<./commons/lang.mli>>=
<<signature Lang.lang>>

@


\subsection*{[[./commons/lang.ml]]}


%(* mmm uses this function and Jtk.is_japanse_mode also. *)
%let is_japanese () =
%  let lang = try Sys.getenv "LANG" with _ -> "" in
%  String.length lang >= 2 && String.sub lang 0 2 = "ja"


%-------------------------------------------------------------

<<./commons/lang.ml>>=

<<function Lang.lang>>

(* detect and set LANG information *)

@


\subsection*{[[./commons/lexpath.mli]]}


%\subsection{Paths}
% need that? mv?
% I think it's dead! subsumed by lexurl.mll

<<signature Lexpath.path_components>>=
(* Path lexer
   Deals with "./" and "../"
 *)

val path_components : Lexing.lexbuf -> string list
  (* in normal order: /a/b/c/ -> [a;b;c] *)
@

<<signature Lexpath.rev_path_components>>=
val rev_path_components : Lexing.lexbuf -> string list
  (* in reverse order: /a/b/c/ -> [c;b;a] *)
@

<<signature Lexpath.build>>=
val build : string -> string list -> string
  (* [build root [a;b;d]] returns path/a/b/c *)
@

<<signature Lexpath.remove_dots>>=
val remove_dots : string -> string
  (* takes path and removes . and .. *)
@



%-------------------------------------------------------------

<<./commons/lexpath.mli>>=
<<copyright header v6>>

<<signature Lexpath.path_components>>

<<signature Lexpath.rev_path_components>>

<<signature Lexpath.build>>

<<signature Lexpath.remove_dots>>
@


\subsection*{[[./commons/log.mli]]}


%-------------------------------------------------------------

<<./commons/log.mli>>=
<<signature Log.debug_mode>>

<<signature Log.f>>
<<signature Log.debug>>
@


\subsection*{[[./commons/log.ml]]}


%-------------------------------------------------------------

<<./commons/log.ml>>=
open Printf

<<constant Log.debug_mode>>

<<function Log.f>>

<<function Log.debug>>

@


\subsection*{[[./commons/low.mli]]}

%todo: replace with unix?

<<signature Low.read>>=
val read : file_descr -> string -> int -> int -> int
  (* Unix.read wrapper, to be used when data transferred has to
     be counted by the tachymeter
   *)
@

<<signature Low.fork>>=
val fork : unit -> int
  (* Unix.fork wrapper. Catches zombies *)
@

<<signature Low.add_fileinput>>=
val add_fileinput : file_descr -> (unit -> unit) -> unit
@

<<signature Low.remove_fileinput>>=
val remove_fileinput: file_descr -> unit
  (* Wrapping of Tk fileinput functions, with feedback on the tachymeter *)
@

<<signature Low.busy>>=
val busy : ('a -> 'b) -> 'a -> 'b
  (* Busy feedback during this application *)
@



<<signature Low.update_idletasks>>=
val update_idletasks : unit -> unit
@


%-------------------------------------------------------------

<<./commons/low.mli>>=
open Unix

<<signature Low.read>>

<<signature Low.fork>>

<<signature Low.add_fileinput>>
<<signature Low.remove_fileinput>>

<<signature Low.busy>>

<<signature Low.global_time>>
<<signature Low.add_task>>


class  virtual tachymeter : object
  method virtual report_cnx : int -> unit     (* displays number of active cnx *)
  method virtual report_busy : bool -> unit   (* displays busy status *)
  method virtual report_traffic : int -> int -> int -> unit
       (* [report_traffic tick_duration total sample] displays traffic
          from [total] and [sample] in last [tick_duration] *)
  method virtual quit : unit
end

<<signature Low.cur_tachy>>


<<signature Low.init>>


val update_idletasks_backend: (unit -> unit) ref

<<signature Low.update_idletasks>>
@


\subsection*{[[./commons/low.ml]]}

<<constant Low.cur_tachy>>=
let cur_tachy = ref (new no_tachy :> tachymeter)
@

<<function Low.read>>=
let read fd buf offs l =
  let n = Unix.read fd buf offs l in
    bytes_read := !bytes_read + n;
    sample_read := !sample_read + n;
    n
@

<<function Low.add_fileinput>>=
let add_fileinput fd f =
  incr pending_read;
  !cur_tachy#report_cnx !pending_read;
  Fileevent_.add_fileinput fd f
@

<<function Low.remove_fileinput>>=
let remove_fileinput fd =
  decr pending_read;
  !cur_tachy#report_cnx !pending_read;
  Fileevent_.remove_fileinput fd
@

<<function Low.fork>>=
let fork () =
 begin try
  while 
    let p, s = Unix.waitpid [Unix.WNOHANG] 0 in 
      (*
      Printf.eprintf "%d\n" p;
      begin match s with
        WEXITED n -> Printf.eprintf "Exit %d\n" n
       | WSIGNALED(n,_) -> 
           Printf.eprintf "SIG %d\n" n
       | WSTOPPED n -> Printf.eprintf "Stopped %d\n" n
      end;
      flush Pervasives.stderr;
      *)
      p <> 0
 do () done
 with
  Unix.Unix_error(_,_,_) -> ()
 end;
 (* Don't let children play stupid games *)
 match Unix.fork() with
   0 -> at_exit (fun () -> sys_exit 0); 0
 | n -> n
@

<<function Low.busy>>=
let busy f x =
  !cur_tachy#report_busy true;
  try 
    let v = f x in
    !cur_tachy#report_busy false; v
  with
    e ->
      !cur_tachy#report_busy false;
      raise e
@


<<constant Low.tick_duration>>=
let tick_duration = 500
@



<<function Low.add_task>>=
let add_task f = tasks := f :: !tasks
@


<<constant Low.last_update>>=
(* We need manual refresh for progressive display (?), but we don't
   want to do it too frequently *)
let last_update = ref !global_time
@

<<function Low.update_idletasks>>=
let update_idletasks () =
  if !global_time <> !last_update then begin
    !update_idletasks_backend ();
    last_update := !global_time
  end
@

<<global Low.pending_read>>=
let pending_read = ref 0
@

%-------------------------------------------------------------

<<./commons/low.ml>>=
(* Wrapping of some low-level functions *)
open Common

open Unix

(* Tachymeter support *)
class  virtual tachymeter = object
  method virtual report_cnx : int -> unit     (* displays number of active cnx *)
  method virtual report_busy : bool -> unit   (* displays busy status *)
  method virtual report_traffic : int -> int -> int -> unit
       (* [report_traffic tick_duration total sample] displays traffic
          from [total] and [sample] in last [tick_duration] *)
  method virtual quit : unit
  end

class no_tachy = object
  inherit tachymeter

  method report_cnx cnx = ()
  method report_busy flag = ()
  method report_traffic tick total sample = ()
  method quit = ()
end

<<constant Low.cur_tachy>>

(* for the tachymeter *)
<<global Low.bytes_read>>
<<global Low.sample_read>>

<<function Low.read>>

<<global Low.pending_read>>
let action = ref (fun _ -> ())

<<function Low.add_fileinput>>

<<function Low.remove_fileinput>>

(* We catch dead children here, to avoid large number of zombies.
   I know about SICHLD of course, but I hate interrupted syscalls
 *)

external sys_exit : int -> 'a = "caml_sys_exit"

<<function Low.fork>>


<<function Low.busy>>

<<constant Low.global_time>>
<<constant Low.tick_duration>>

<<constant Low.tasks>>

<<function Low.refresh>>

<<function Low.add_task>>

<<function Low.init>>

let update_idletasks_backend = 
  ref (fun _ -> failwith "no update_idletasks defined")


<<constant Low.last_update>>
<<function Low.update_idletasks>>
@


\subsection*{[[./commons/mlist.mli]]}


%-------------------------------------------------------------

<<./commons/mlist.mli>>=
<<signature Mlist.hdn>>
<<signature Mlist.tln>>

<<signature Mlist.except_assoc>>
<<signature Mlist.exceptq>>
<<signature Mlist.rev_do_list>>

<<signature Mlist.do_listi>>
@


\subsection*{[[./commons/mlist.ml]]}


%-------------------------------------------------------------

<<./commons/mlist.ml>>=
(*
 * List utilities
 *)
<<function Mlist.tln>>

<<function Mlist.hdn>>

<<function Mlist.except_assoc>>

<<function Mlist.exceptq>>



<<function Mlist.rev_do_list>>


<<function Mlist.do_listi>>

@


\subsection*{[[./commons/mstring.mli]]}


%-------------------------------------------------------------

<<./commons/mstring.mli>>=
<<signature Mstring.split_str>>
<<signature Mstring.get_suffix>>

<<signature Mstring.hex_to_dec>>
<<signature Mstring.dec_to_hex>>

<<signature Mstring.hex_to_string>>

<<signature Mstring.gensym>>
<<signature Mstring.egensym>>

<<signature Mstring.rem_trailing_sp>>

<<signature Mstring.catenate_sep>>

<<signature Mstring.norm_crlf>>
@


\subsection*{[[./commons/mstring.ml]]}


%-------------------------------------------------------------

<<./commons/mstring.ml>>=
(*
 * String utilities
 *)

<<function Mstring.split_str>>

<<function Mstring.get_suffix>>

<<function Mstring.hex_to_dec>>

<<function Mstring.dec_to_hex>>

<<function Mstring.hex_to_string>>

<<constant Mstring.gensym>>

<<function Mstring.egensym>>

<<function Mstring.rem_trailing_sp>>

<<function Mstring.catenate_sep>>

<<function Mstring.norm_crlf>>



@


\subsection*{[[./commons/msys.mli]]}



%-------------------------------------------------------------

<<./commons/msys.mli>>=
<<copyright header v6>>

<<signature Msys.tilde_subst>>

<<signature Msys.rm>>

<<signature Msys.fsize>>

<<signature Msys.mktemp>>
@


\subsection*{[[./commons/msys.ml]]}


%-------------------------------------------------------------

<<./commons/msys.ml>>=
<<copyright header v6>>

open Printf
open Unix

(* Tilde substitution *)

<<function Msys.next_slash>>

<<function Msys.tilde_subst>>

<<function Msys.rm>>
<<function Msys.rmdir>>

<<function Msys.fsize>>

<<constant Msys.tmp_dir>>

<<constant Msys.mktemp>>
@


\subsection*{[[./commons/i18n.mli]]}



%-------------------------------------------------------------

<<./commons/i18n.mli>>=
<<signature I18n.message_file>>
<<signature I18n.language>>

<<signature I18n.sprintf>>

<<signature I18n.menu_option>>
<<signature I18n.menu_pattern>>

val translate: string -> string
@


\subsection*{[[./commons/i18n.ml]]}


%-------------------------------------------------------------

<<./commons/i18n.ml>>=

<<function I18n.fprintf>>
<<function I18n.sprintf>>

<<constant I18n.language>>
<<constant I18n.message_file>>

<<function I18n.read_transl_file>>

<<type I18n.translation_table>>

<<constant I18n.transl_table>>

<<function I18n.translate>>

<<function I18n.fprintf (./commons/i18n.ml)>>

<<function I18n.sprintf (./commons/i18n.ml)>>

let printf fmt = fprintf stdout fmt
and eprintf fmt = fprintf stderr fmt

<<function I18n.menu_option>>

<<exception I18n.Found>>

<<function I18n.menu_pattern>>
@


\subsection*{[[./commons/munix.ml]]}

<<function Munix.execvp>>=
(* If execvp fails in one of our children, it may be dangerous to leave
   the program running, since we don't know how Tk would react *)
let execvp s args =
  try 
    execvp s args
  with
    Unix_error(e, _, _) ->
       Printf.eprintf "%s\n" (Unix.error_message e);
       flush Pervasives.stderr;
       exit 1
@

<<constant Munix.quote>>=
let quote = Str.regexp "'"
@

<<function Munix.quote_for_shell>>=
let quote_for_shell s =
  sprintf "'%s'" (Str.global_replace quote "'\\''" s)
@

<<function Munix.system>>=
(* Wrapping of Sys.command with trivial arg quoting *)
let system cmd args back =
  let b = Ebuffer.create 128 in
   Ebuffer.output_string b cmd;
   List.iter (fun s ->
     Ebuffer.output_char b ' ';
     Ebuffer.output_string b (quote_for_shell s))
    args;
   if back then Ebuffer.output_string b " &";
   Sys.command (Ebuffer.get b)
@

<<function Munix.eval_cmd>>=
let eval_cmd cmd args back =
 let _ = system cmd args back in ()
@

<<function Munix.write_string>>=
let write_string fd s =
  ignore (write fd s 0 (String.length s))
@

<<function Munix.read_line>>=
(*
 * Read a line (terminated by \n or \r\n).
 *   strips terminator !
 *)
let read_line fd =
  let rec read_rec buf bufsize offs =
    let n = Low.read fd buf offs 1 in
      if n = 0 then raise End_of_file
      else if buf.[offs] = '\n'
           then (* strips \n and possibly \r  *)
             let len = if offs >= 1 & buf.[offs-1] = '\r' then offs-1 
                       else offs in
               String.sub buf 0 len
           else let offs = succ offs in
                  if offs = bufsize 
                  then read_rec (buf ^ String.create 128) (bufsize + 128) offs
                  else read_rec buf bufsize offs in
  read_rec (String.create 128) 128 0 
@

<<function Munix.full_random_init>>=
let full_random_init () =
  try 
    let env = environment () in
    let vect =
      Array.append (Array.map Hashtbl.hash env)
           [| getpid(); Pervasives.truncate (time()); (* JPF: bogus *)
              getuid(); getgid();
              Hashtbl.hash (getlogin()) |] in
    Random.full_init vect
  with
    _ -> ()
@

<<function Munix.digdir>>=
let rec digdir dir perm =
  (* try to create the directory dir *)
  if Sys.file_exists dir then () 
  else begin
    let pdir = Filename.dirname dir in
    digdir pdir perm;
    Unix.mkdir dir perm
  end
@

<<constant Munix.dns>>=
(* DNS Caching. It really helps on slow lines... *)
let dns = Hashtbl.create 307
@

<<function Munix.gethostbyname>>=
let gethostbyname h =
  try Hashtbl.find dns h
  with
    Not_found ->
      let addr = Unix.gethostbyname h in
        Hashtbl.add dns h addr;
     addr
@

<<toplevel Munix._1>>=
let _ =
  full_random_init()
@

<<constant Munix.vars>>=
(* Hack to run some external command with parameter substitution 
 * The command is a string containing $X
 * The arguments are [X, v]
 * For arguments not substituted, add them at the end,
 *)
let vars = Str.regexp "\\$[A-Z]+"
@

<<function Munix.system_eval>>=
let system_eval cmd args back =
  let replaced = ref []
  and qargs = List.map (fun (x, v) -> x, quote_for_shell v) args
  in
  let replfun s =
    let matched = Str.matched_string s in
    let thevar = String.sub matched 1 (String.length matched - 1) in
    try 
      let res = List.assoc thevar args in
      replaced := thevar :: !replaced;
      res
    with
      Not_found -> matched
  in
  (* replace vars *)
  let scmd = Str.global_substitute vars replfun cmd in
  (* for vars that haven't been replaced, add them at the end 
   * (backward compatibility with our previous versions)
   *)
  let remaining = ref [] in
  List.iter (fun (x,v) -> 
    if not (List.mem x !replaced) then remaining := v :: !remaining)
    args;
  system scmd (List.rev !remaining) back
@


%-------------------------------------------------------------

<<./commons/munix.ml>>=
open Printf
open Unix

(*
 * Simple Unix utilities
 *)


<<function Munix.execvp>>

<<constant Munix.quote>>
<<function Munix.quote_for_shell>>

<<function Munix.system>>

<<function Munix.eval_cmd>>

<<function Munix.write_string>>

<<function Munix.read_line>>


<<function Munix.full_random_init>>

<<function Munix.digdir>>

<<constant Munix.dns>>
<<function Munix.gethostbyname>>

<<toplevel Munix._1>>

<<constant Munix.vars>>

<<function Munix.system_eval>>

@


\subsection*{[[./commons/feed.mli]]}




%-------------------------------------------------------------

<<./commons/feed.mli>>=
<<type Feed.internal>>

<<type Feed.t>>

<<signature Feed.of_fd>>
<<signature Feed.internal>>
@


\subsection*{[[./commons/feed.ml]]}



%-------------------------------------------------------------

<<./commons/feed.ml>>=
<<type Feed.internal>>

<<type Feed.t>>

<<function Feed.of_fd>>
 
<<function Feed.internal>>

@


\subsection*{[[./tk/glevents.mli]]}

%\subsection{[[Glevents]]}

<<signature Glevents.get>>=
val get : string -> (modifier list * xEvent) list 
@

<<signature Glevents.reset>>=
val reset : unit -> unit
@

<<constant Glevents.events>>=
(* A global table for describing events
 * TODO: use virtual events because here we don't change bindings in 
 * place after a preference reload
 *)

let events = Hashtbl.create 37
@

<<constant Glevents.builtin_defaults>>=
let builtin_defaults = [

  (* tachymeter bindings *)
  "tachy_about", [[], ButtonPressDetail 3];
  "tachy_gc",[[], KeyPressDetail "g"; [], KeyPressDetail "c"];
  "tachy_new", [[], ButtonPressDetail 1];
  "tachy_sel", [[], ButtonPressDetail 2];

  (* bindings on inlined images *)
  "loadimage", [[Control], ButtonPressDetail 1];
  "alt_imap", [[],ButtonPressDetail 1];	(* alt mode client side img map *)
  "stopanim",  [[], ButtonPressDetail 2];
  "restartanim", [[Shift], ButtonPressDetail 2];
  "copyimgurl", [[], ButtonPressDetail 2];
  "updateimage", [[Shift], ButtonPressDetail 2];

  (* anchor bindings *)
  "goto", [[], ButtonPressDetail 1];
  "save", [[Shift], ButtonPressDetail 1];
  "gotonew", [[], ButtonPressDetail 3];
  "hypermenu", [[Control], ButtonPressDetail 1];
]
@
% ???

<<constant Glevents.get>>=
let get = Hashtbl.find events
@

<<function Glevents.reset>>=
(* This is for preferences *)
let reset () =
  Hashtbl.clear events;
  (* Now: for all names defined in defaults, check a possible overriding value
     in resources *)
  List.iter (fun (name,default) ->
    Hashtbl.add events 
      name (Tkresource.event_sequence (sprintf "bind<%s>" name) default))
    builtin_defaults
@





%-------------------------------------------------------------

<<./commons/glevents.mli>>=
open Tk

<<signature Glevents.get>>
<<signature Glevents.reset>>
@


\subsection*{[[./tk/glevents.ml]]}


%-------------------------------------------------------------

<<./commons/glevents.ml>>=
open Printf
open Tk

<<constant Glevents.events>>

<<constant Glevents.builtin_defaults>>

<<constant Glevents.get>>

<<function Glevents.reset>>
    
  
@


\subsection*{[[./commons/hotlist.ml]]}

<<constant Hotlist.program>>=
(* A cool module *)
let program = ref ""
@

<<function Hotlist.f>>=
let f url title =
  match !program with 
    "" -> (!Error.default)#f (I18n.sprintf "No hotlist command defined")
  | s -> 
      let _ = Munix.system_eval s ["URL", url; "TITLE", title] true in
      (!Error.default)#ok
    (I18n.sprintf "%s\nadded to hotlist with title\n%s" url title)
@


%-------------------------------------------------------------

<<./commons/hotlist.ml>>=
<<constant Hotlist.program>>

<<function Hotlist.f>>
@



\section{[[./globals/]]}

\subsection*{[[./globals/version.mli]]}


%-------------------------------------------------------------

<<./globals/version.mli>>=
<<signature Version.number>>
<<signature Version.http>>
<<signature Version.about>>
<<signature Version.initurl>>
<<signature Version.helpurl>>
<<signature Version.html>>
<<signature Version.home>>
<<signature Version.applet_init>>
@


\subsection*{[[./globals/version.ml]]}



%-------------------------------------------------------------

<<./globals/version.ml>>=
(* To merge FR and JP strings correctly, you have to encode the characters
 * more than 0x7F, for example "Fran\231ois".
 *) 

<<constant Version.number>>
<<constant Version.version_number>>

<<constant Version.http>>

<<function Version.about>>

<<function Version.home>>

<<function Version.initurl>>

<<function Version.helpurl>>

<<function Version.html>>

<<constant Version.applet_init>>
@


\section{[[./www/]]}

\subsection*{[[./www/uri.mli]]}



%-------------------------------------------------------------

<<./www/uri.mli>>=
<<type Uri.abs_uri>>

<<signature Uri.is_absolute>>
@


\subsection*{[[./www/uri.ml]]}


%-------------------------------------------------------------

<<./www/uri.ml>>=
open Printf
open Mstring

<<type Uri.abs_uri>>

<<function Uri.is_absolute>>
@


\subsection*{[[./www/url.mli]]}


%-------------------------------------------------------------

<<./www/url.mli>>=
<<type Url.protocol>>

<<signature Url.string_of_protocol>>

<<type Url.t>>

<<signature Url.string_of>>

<<signature Url.distant_path>>

<<exception Url.Url_Lexing>>


@


\subsection*{[[./www/url.ml]]}



%-------------------------------------------------------------

<<./www/url.ml>>=
open Printf

<<type Url.protocol>>

<<function Url.string_of_protocol>>


<<type Url.t>>

<<exception Url.Url_Lexing>>
<<exception Url.Invalid_url>>

<<function Url.string_of>>

<<function Url.distant_path>>

@


\subsection*{[[./www/urlenc.mli]]}


%-------------------------------------------------------------

<<./www/urlenc.mli>>=
<<copyright header v6>>

<<signature Urlenc.decode>>
<<signature Urlenc.encode>>

<<signature Urlenc.strict_form_standard>>
<<signature Urlenc.form_encode>>
<<signature Urlenc.form_decode>>

<<signature Urlenc.unquote>>
@


\subsection*{[[./www/urlenc.ml]]}


%-------------------------------------------------------------

<<./www/urlenc.ml>>=
<<copyright header v6>>

open Mstring

<<function Urlenc.hexchar>>

<<function Urlenc.decode>>

<<constant Urlenc.keep_quoted>>
<<function Urlenc.unquote>>

<<function Urlenc.encode>>


<<constant Urlenc.strict_form_standard>>

<<function Urlenc.form_encode>>

<<constant Urlenc.form_decode>>
         
@


\subsection*{[[./www/lexurl.mli]]}


%-------------------------------------------------------------

<<./www/lexurl.mli>>=
<<signature Lexurl.f>>
<<signature Lexurl.make>>
<<signature Lexurl.maken>>

<<signature Lexurl.remove_dots>>
<<signature Lexurl.normalize>>
@


\subsection*{[[./www/hyper.mli]]}



%-------------------------------------------------------------

<<./www/hyper.mli>>=
(* An hypertext(media) link on the Web *)

<<type Hyper.link_method>>

<<signature Hyper.parse_method>>

<<type Hyper.link>>

<<type Hyper.link_error>>

<<exception Hyper.Invalid_link>>

<<signature Hyper.urlconcat>>

<<signature Hyper.resolve>>
<<signature Hyper.string_of>>
  

@


\subsection*{[[./www/hyper.ml]]}



%-------------------------------------------------------------

<<./www/hyper.ml>>=
open Printf
open Mstring
open Uri
open Url

(* An hypertext(media) link on the Web *)

<<type Hyper.link_method>>

<<function Hyper.parse_method>>


<<type Hyper.link>>

<<type Hyper.link_error>>

<<exception Hyper.Invalid_link>>

<<function Hyper.urlconcat>>
          
<<function Hyper.resolve>>

<<function Hyper.string_of>>
@


\subsection*{[[./www/maps.mli]]}


%-------------------------------------------------------------

<<./www/maps.mli>>=
<<type Maps.area_kind>>

<<type Maps.area>>

<<type Maps.map>>

<<type Maps.t>>

<<type Maps.map_status>>

<<signature Maps.parse_coords>>
<<signature Maps.get>>

val broadcast_backend: (string -> unit) ref
<<signature Maps.add>>
@


\subsection*{[[./www/maps.ml]]}



%-------------------------------------------------------------

<<./www/maps.ml>>=
open Printf

(* Client-side image maps:
     the "only" difficulty in implementing client-side image maps is that
     the map may well come *after* the image in the document. In general,
     anyway, the map may be an arbitrary URL.

   We thus have to implement a general delay mechanism for maps : the idea
   here is to use a table of maps, each map being accessed by an URI (that is,
   an URL plus a fragment).

   PROBLEM: we have no idea in general when to flush this table.

 *)

<<type Maps.area_kind>>

<<type Maps.area>>

<<type Maps.map>>

<<type Maps.t>>


<<type Maps.map_status>>

<<constant Maps.table>>

<<constant Maps.coord_sep>>
<<function Maps.parse_coords>>

let broadcast_backend = ref (fun _ev -> failwith "no broadcast defined")

<<function Maps.add>>

<<function Maps.get>>
@


\subsection*{[[./www/www.mli]]}


%-------------------------------------------------------------

<<./www/www.mli>>=
<<type Www.request>>

<<exception Www.Invalid_request>>

<<signature Www.make>>

(* Table of unresolved active connexions *)
module UrlSet : Set.S with type elt = Url.t

<<signature Www.is_active_cnx>>
<<signature Www.add_active_cnx>>
<<signature Www.rem_active_cnx>>

@


\subsection*{[[./www/www.ml]]}



%-------------------------------------------------------------

<<./www/www.ml>>=
open Uri
open Url

<<type Www.request>>

<<exception Www.Invalid_request>>

<<constant Www.sp>>

<<function Www.make>>
 


<<module Www.UrlSet>>

<<constant Www.active_connexions>>
<<functions Www.xxx_active_cnx>>

@


\subsection*{[[./www/document.mli]]}



%-------------------------------------------------------------

<<./www/document.mli>>=
<<type Document.document_id>>

<<signature Document.no_stamp>>
<<signature Document.new_stamp>>

<<signature type Document.logger>>
<<signature Document.tty_logger>>

<<type Document.handle>>

<<type Document.document_continuation>>

<<type Document.document_data>>

<<type Document.document>>

module DocumentIDSet : Set.S with type elt = document_id

<<signature Document.dclose>>

val add_log_backend: (handle -> string -> (unit -> unit) -> unit) ref

<<signature Document.add_log>>
<<signature Document.put_log>>
<<signature Document.progress_log>>
<<signature Document.end_log>>
<<signature Document.destroy_log>>

<<signature Document.document_id>>
@


\subsection*{[[./www/document.ml]]}


%-------------------------------------------------------------

<<./www/document.ml>>=
open Feed
open Www
open Hyper

<<type Document.logger>>

<<type Document.document_id>>

<<module Document.DocumentIDSet>>

<<type Document.handle>>

<<type Document.document_continuation>>

<<type Document.document_data>>

<<type Document.document>>

<<constant Document.stamp_counter>>
<<constant Document.no_stamp>>

<<function Document.new_stamp>>

<<function Document.document_id>>


<<function Document.dclose>>


<<constant Document.tty_logger>>

let add_log_backend = ref (fun _ _ _ -> failwith "no add_log defined")
  
<<function Document.add_log>>
<<functions Document.xxx_log>>
<<function Document.end_log>>


<<type Document.display_info>>

@


\section{[[./html/]]}

\subsection*{[[./html/dtd.mli]]}

<<signature Dtd.dtd20>>=
val dtd20 : t
@

<<signature Dtd.dtd32f>>=
val dtd32f : t
@
% with frame?



%-------------------------------------------------------------

<<./html/dtd.mli>>=
module Elements : Set.S with type elt = string

<<type Dtd.t>>

<<signature Dtd.dtd20>>
<<signature Dtd.dtd32>>
<<signature Dtd.dtd32f>>

<<signature Dtd.get>>
<<signature Dtd.add>>
<<signature Dtd.name>>

<<signature Dtd.names>>

<<signature Dtd.current>>

<<signature Dtd.dump>>
@


\subsection*{[[./html/dtd.ml]]}


<<constant Dtd.dtd20>>=
(* #PCDATA and #CDATA are considered as elements, but they will never
   be pushed on the stack during evaluation. Moreover, since they are
   not in open_omitted/close_omitted, minimization algorithm will not
   attempt to choose them
 *)

let dtd20 =
  let dtd = {
    dtd_name = "HTML 2.0";

    contents = Hashtbl.create 53;
    open_omitted = Elements.empty;
    close_omitted = Elements.empty
     } in

  let omit_open el =
    dtd.open_omitted <- Elements.add el dtd.open_omitted
  and omit_close el =
    dtd.close_omitted <- Elements.add el dtd.close_omitted
  and add_elem = 
    Hashtbl.add dtd.contents
  in

  (* Some entities *)
  (* <!ENTITY % heading "H1|H2|H3|H4|H5|H6"> *)
  let heading_E = sol ["h1"; "h2"; "h3"; "h4"; "h5"; "h6"]
  (* <!ENTITY % list " UL | OL | DIR | MENU " > *)
  and list_E = sol ["ul"; "ol"; "dir"; "menu"] in
  (* <!ENTITY % font " TT | B | I "> *)
  let font_E = sol ["tt"; "b"; "i"]
  (* <!ENTITY % phrase "EM | STRONG | CODE | SAMP | KBD | VAR | CITE "> *)
  and phrase_E = sol ["em"; "strong"; "code"; "samp"; "kbd"; "var"; "cite"] in
  (* <!ENTITY % text "#PCDATA | A | IMG | BR | %phrase | %font"> *)
  (* EMBED added *)
  let text_E =
    sos [sol ["#pcdata"; "a"; "img"; "br"; "embed"]; font_E; phrase_E] in

  (* <!ELEMENT (%font;|%phrase) - - (%text)*> *)
  Elements.iter (fun e -> add_elem e text_E) font_E;
  Elements.iter (fun e -> add_elem e text_E) phrase_E;

  (* <!ENTITY % pre.content "#PCDATA | A | HR | BR | %font | %phrase"> *)
  let pre_content_E = 
       sos [sol ["#pcdata"; "a"; "hr"; "br"]; font_E; phrase_E] in

  (* <!ELEMENT BR    - O EMPTY> *)
  add_elem "br" Elements.empty;
  omit_close "br";

  (* <!ENTITY % A.content   "(%heading|%text)*"> *)
  let a_content_E = sos [heading_E; text_E] in

  (* <!ELEMENT A     - - %A.content -(A)> *)
  add_elem "a" (Elements.remove "a" a_content_E);

  (* <!ELEMENT IMG    - O EMPTY> *)
  add_elem "img" Elements.empty;
  omit_close "img";

  (* <!ELEMENT P     - O (%text)*> *)
  add_elem "p" text_E;
  omit_close "p";

  (* <!ELEMENT HR    - O EMPTY> *)
  add_elem "hr" Elements.empty;
  omit_close "hr";

  (* <!ELEMENT ( %heading )  - -  (%text;)*> *)
  Elements.iter (fun e -> add_elem e text_E) heading_E;

  (* <!ENTITY % block.forms "BLOCKQUOTE | FORM | ISINDEX"> *)
  let block_forms_E = sol ["blockquote"; "form"; "isindex"] in

  (* <!ENTITY % preformatted "PRE"> *)
  let preformatted_E = sol ["pre"] in

  (* <!ENTITY % block "P | %list | DL
      | %preformatted
      | %block.forms"> *)
  let block_E = sos [sol ["p"; "dl"]; list_E; preformatted_E; block_forms_E] in

  (* <!ENTITY % flow "(%text|%block)*"> *)
  let flow_E = sos [text_E; block_E] in

  (* <!ELEMENT PRE - - (%pre.content)*> *)
  add_elem "pre" pre_content_E;


  (* Deprecated but used <!ELEMENT (XMP|LISTING) - -  %literal> *)
  List.iter (fun e -> add_elem e (sol ["#cdata"])) ["xmp"; "listing"];

  (* <!ELEMENT DL    - -  (DT | DD)+> *)
  add_elem "dl" (sol ["dt"; "dd"]);

  (* <!ELEMENT DT    - O (%text)*> *)
  add_elem "dt" text_E;
  omit_close "dt";

  (* <!ELEMENT DD    - O %flow> *)
  add_elem "dd" flow_E;
  omit_close "dd";

  (* <!ELEMENT (OL|UL) - -  (LI)+> *)
  List.iter (fun e -> add_elem e (sol ["li"])) ["ol"; "ul"];

  (* <!ELEMENT (DIR|MENU) - -  (LI)+ -(%block)> *)
  (* isn't that stupid ? *)
  List.iter (fun e -> add_elem e (sol ["li"])) ["dir"; "menu"];

  (* <!ELEMENT LI    - O %flow> *)
  add_elem "li" flow_E;
  omit_close "li";

  (* <!ENTITY % body.content "(%heading | %text | %block |
                 HR | ADDRESS)*"> *)
  let body_content_E =
     sos [heading_E; text_E; block_E; sol ["hr"; "address"]] in
  
  (* <!ELEMENT BODY O O  %body.content> *)
  add_elem "body" body_content_E;
  omit_open "body";
  omit_close "body";

  (* <!ELEMENT BLOCKQUOTE - - %body.content> *)
  add_elem "blockquote" body_content_E;

  (* <!ELEMENT ADDRESS - - (%text|P)*> *)
  add_elem "address" (Elements.add "p" text_E);

  (* <!ELEMENT FORM - - %body.content -(FORM) +(INPUT|SELECT|TEXTAREA)> *)
  add_elem "form"
    (sos [Elements.remove "form" body_content_E;
      sol ["input";"select";"textarea"]]);

  (* <!ELEMENT INPUT - O EMPTY> *)
  add_elem "input" Elements.empty;
  omit_close "input";

  (* <!ELEMENT SELECT - - (OPTION+) -(INPUT|SELECT|TEXTAREA)> *)
  add_elem "select" (sol ["option"]);

  (* <!ELEMENT OPTION - O (#PCDATA)*> *)
  add_elem "option" (sol ["#pcdata"]);
  omit_close "option";

  (* <!ELEMENT TEXTAREA - - (#PCDATA)* -(INPUT|SELECT|TEXTAREA)> *)
  add_elem "textarea" (sol ["#pcdata"]);

  (* <!ENTITY % head.extra "NEXTID? & META* & LINK*">

     <!ENTITY % head.content "TITLE & ISINDEX? & BASE? &
             (%head.extra)"> *)

  let head_extra_E = sol ["nextid"; "meta"; "link"] in
  let head_content_E = 
    sos [sol ["title"; "isindex"; "base"]; head_extra_E] in
  
  (* <!ELEMENT HEAD O O  (%head.content)> *)
  add_elem "head" head_content_E;
  omit_open "head";
  omit_close "head";

  (* <!ELEMENT TITLE - -  (#PCDATA)*> *)
  add_elem "title" (sol ["#pcdata"]);

  (* <!ELEMENT LINK - O EMPTY> *)
  add_elem "link" Elements.empty;
  omit_close "link";

  (* <!ELEMENT ISINDEX - O EMPTY> *)
  add_elem "isindex" Elements.empty;
  omit_close "isindex";

  (* <!ELEMENT BASE - O EMPTY> *)
  add_elem "base" Elements.empty;
  omit_close "base";

  (* <!ELEMENT NEXTID - O EMPTY> *)
  add_elem "nextid" Elements.empty;
  omit_close "nextid";

  (* <!ELEMENT META - O EMPTY> *)
  add_elem "meta" Elements.empty;
  omit_close "meta";

  (* <!ENTITY % html.content "HEAD, BODY"> *)
  let html_content_E = sol ["head"; "body"] in

  (* <!ELEMENT HTML O O  (%html.content)> *)
  add_elem "html" html_content_E;
  omit_open "html";
  omit_close "html";

  (* fake element PCDATA for minimisation rules *)
  add_elem "#pcdata" Elements.empty;

  (* EMBED is an extension *)
  add_elem "embed" Elements.empty;
  omit_close "embed";
  
  dtd
@


%-------------------------------------------------------------

<<./html/dtd.ml>>=
open Printf

<<module Dtd.elements>>

<<type Dtd.t>>

<<function Dtd.name>>


<<function Dtd.sol>>
<<function Dtd.sos>>

<<constant Dtd.dtd20>>


<<function Dtd.dump>>



<<constant Dtd.dtd32>>

<<constant Dtd.current>>

<<constant Dtd.table>>

<<function Dtd.add>>
<<constant Dtd.get>>

<<function Dtd.names>>

<<toplevel Dtd._1>>

<<constant Dtd.dtd32f>>

<<toplevel Dtd._2>>
@


\subsection*{[[./html/html.mli]]}




<<signature Html.beautify>>=
val beautify: bool -> string -> string
  (* [beautify remove_leading_space s] removes sequences of SP *)
@

<<signature Html.beautify2>>=
val beautify2 : string -> string
  (* [beautify2 s] removes leading/trailing space and sequences of SP *)
@

<<signature Html.issp>>=
val issp : string -> bool
  (* [issp s] is true if s is formed only of SP *)
@


<<type Html.length>>=
(* HTML length *)
type length = 
    Nolength
  | LengthPixels of int
  | LengthRatio of float
  | LengthRel of int
@

<<signature Html.length_of_string>>=
val length_of_string : string -> length
@


%-------------------------------------------------------------

<<./html/html.mli>>=
<<type Html.attribute_name>>
<<type Html.attribute_value>>
<<type Html.attributes>>

<<type Html.tag>>

<<type Html.token>>

<<type Html.location>>

<<exception Html.Html_Lexing>>
<<exception Html.Invalid_Html>>


<<signature Html.init>>

<<signature Html.verbose>>

<<signature Html.warning>>

<<signature Html.print>>

<<signature Html.beautify>>

<<signature Html.beautify2>>

<<signature Html.issp>>

<<signature Html.get_entity>>

<<signature Html.get_attribute>>

<<signature Html.has_attribute>>

<<type Html.length>>
      
<<signature Html.length_of_string>>

@


\subsection*{[[./html/html.ml]]}

%?? -> <> 
<<function Html.beautify>>=
(*
 * Remove sequences of white
 *   turns out to be faster than global_replace in libstr
 *   could use String.blit to avoid char copying
 * NOTE: add \0 detection here (we need it for Tk)
 *)
let beautify remove_leading s =
  let j = ref 0
  and white = ref remove_leading in
  for i = 0 to String.length s - 1 do
    match s.[i] with
      ' '|'\t'|'\r'|'\n'|'\000' -> 
    if not !white then begin
       s.[!j] <- ' '; incr j; white := true
       end
    | c -> s.[!j] <- c; white := false; incr j
  done;
  String.sub s 0 !j
@

%?? -> <> 
<<function Html.beautify2>>=
(* Remove also trailing space. Used for OPTION tags and TITLE *)
let beautify2 s =
  let s1 = beautify true s in
   match String.length s1 with
     0 | 1 -> s1
   | n -> if s1.[n-1] = ' ' then String.sub s1 0 (n-1) else s1
@

<<function Html.issp>>=
(* Is SP: when a PCData is only spaces, we skip it *)
let issp s =
  try
    for i = 0 to String.length s - 1 do
      match s.[i] with 
       ' '|'\t'|'\r'|'\n'|'\000' -> ()
      | _ -> failwith "subliminal"
    done;
    true
  with
    Failure "subliminal" -> false
@




<<function Html.length_of_string>>=
(* Either size in pixels or ration in percent *)
let length_of_string s =
  try
    let pos = String.index s '%' in
    try LengthRatio (float_of_string (String.sub s 0 pos) /. 100.)
    with Failure "int_of_string" -> Nolength
  with
    Not_found ->
      try
       let pos = String.index s '*' in
    if pos = 0 then LengthRel 1
    else
      try LengthRel (int_of_string (String.sub s 0 pos))
      with Failure "int_of_string" -> Nolength
      with
    Not_found ->
      try LengthPixels (int_of_string s)
      with Failure "int_of_string" -> Nolength
@


%-------------------------------------------------------------

<<./html/html.ml>>=
open Printf

<<type Html.attribute_name>>
<<type Html.attribute_value>>
<<type Html.attributes>>

<<type Html.tag>>


<<type Html.token>>

<<type Html.location>>

<<exception Html.Html_Lexing>>
<<exception Html.Invalid_Html>>

<<constant Html.verbose>>

<<function Html.warning>>


<<function Html.print>>

<<function Html.beautify>>

<<function Html.beautify2>>


<<function Html.issp>>
  
<<constant Html.ampersand_table>>

<<constant Html.latin1_normal>>

<<function Html.init>>

<<constant Html.get_entity>>


<<constant Html.default_attributes>>

<<function Html.get_attribute>>

<<function Html.has_attribute>>

<<type Html.length>>

<<function Html.length_of_string>>

@


\subsection*{[[./html/lexhtml.mli]]}




%-------------------------------------------------------------

<<./html/lexhtml.mli>>=
<<signature Lexhtml.strict>>

type t
<<signature Lexhtml.new_data>>

<<type Lexhtml.warnings>>

<<signature Lexhtml.html>>
<<signature Lexhtml.cdata>>
@


\subsection*{[[./html/html_eval.mli]]}



%-------------------------------------------------------------

<<./html/html_eval.mli>>=
<<signature Html_eval.debug>>

<<type Html_eval.minimization>>

<<signature Html_eval.add_html_filter>>
<<signature Html_eval.sgml_lexer>>

<<signature Html_eval.automat>>
@


\subsection*{[[./html/html_eval.ml]]}


%-------------------------------------------------------------

<<./html/html_eval.ml>>=
open Printf
open Html
open Dtd

<<type Html_eval.minimization>>

<<constant Html_eval.debug>>

<<exception Html_eval.CantMinimize>>

<<constant Html_eval.initial>>


<<function Html_eval.dump_stack>>

<<function Html_eval.ominimize>>

<<function Html_eval.cminimize>>

<<function Html_eval.is_cdata>>

<<function Html_eval.sgml_lexer>>

<<constant Html_eval.filters>>
<<function Html_eval.add_html_filter>>

<<function Html_eval.sgml_lexer (./html/html_eval.ml)>>
  
  
<<function Html_eval.automat>>
@


\subsection*{[[./html/htparse.ml]]}


%-------------------------------------------------------------

<<./html/htparse.ml>>=
(* Testing the HTML Lexer/evaluator *)
open Html
open Printf

<<toplevel Htparse._1>>

<<type Htparse.mode>>

<<constant Htparse.verbose>>
<<constant Htparse.mode>>

<<function Htparse.error>>


<<function Htparse.line_reporting>>

<<function Htparse.html_lex>>

<<function Htparse.html_nest>>

<<function Htparse.html_indent>>

<<function Htparse.main>>

<<toplevel Htparse._2>>
@


\section{[[./http/]]}

\subsection*{[[./http/base64.mli]]}


%-------------------------------------------------------------

<<./http/base64.mli>>=
<<copyright header v6>>

<<signature Base64.encode>>
<<signature Base64.decode>>
@


\subsection*{[[./http/base64.ml]]}


%-------------------------------------------------------------

<<./http/base64.ml>>=
<<copyright header v6>>

<<constant Base64.index64>>
<<toplevel Base64._1>>

<<function Base64.decode>>


<<constant Base64.char64>>
<<toplevel Base64._2>>

<<function Base64.encode>>

@


\subsection*{[[./http/http_date.mli]]}



%-------------------------------------------------------------

<<./http/http_date.mli>>=
<<copyright header v6>>

(* HTTP Date format *)

<<type Http_date.http_time>>


<<signature Http_date.expired>>

<<signature Http_date.compare>>

<<signature Http_date.string_of_ht>>

<<signature Http_date.tm_of_ht>>
<<signature Http_date.stamp_of_ht>>

<<signature Http_date.ht_of_stamp>>
@


\subsection*{[[./http/http_date.ml]]}


%-------------------------------------------------------------

<<./http/http_date.ml>>=
<<copyright header v6>>

open Printf
open Unix
open Mstring
open Date

<<type Http_date.http_time>>

<<function Http_date.expired>>

<<function Http_date.compare>>

<<function Http_date.string_of_ht>>

<<function Http_date.tm_of_ht>>

<<function Http_date.stamp_of_ht>>


<<function Http_date.ht_of_stamp>>
@


\subsection*{[[./http/messages.mli]]}



%-------------------------------------------------------------

<<./http/messages.mli>>=
<<copyright header v6>>

(* HTTP Messages *)

<<type Messages.request>>

<<type Messages.status>>

<<type Messages.header>>


(* HTTP messages: requests and responses
 *  What a client sends to a server is called a request 
 *  What a server answers is called a response
 *)

<<type Messages.request_message>>

<<type Messages.response_message>>

@


\subsection*{[[./http/http_headers.mli]]}




<<signature Http_headers.location>>=
val location : header list -> string
  (* Location *)
@


<<signature Http_headers.rem_contentencoding>>=
val rem_contentencoding : header list -> header list
@

<<signature Http_headers.status_msg>>=
val status_msg : header list -> string
@





<<signature Http_headers.status_message>>=
val status_message : int -> string
  (* [status_message n] returns Reason-Phrase for code [n] *)
@



<<type Http_headers.media_parameter>>=
(* Media types *)
type media_parameter = string * string
@

<<type Http_headers.media_type>>=
type media_type = string * string
@


<<signature Http_headers.hints>>=
val hints : string -> header list
@


%-------------------------------------------------------------

<<./http/http_headers.mli>>=
open Messages

<<exception Http_headers.Invalid_HTTP_header>>

<<signature Http_headers.parse_status>>

<<signature Http_headers.parse_request>>

<<signature Http_headers.get_header>>

<<signature Http_headers.get_multi_header>>

<<signature Http_headers.merge_headers>>

<<signature Http_headers.remove_headers>>

<<signature Http_headers.header_type>>


<<signature Http_headers.contenttype>>
<<signature Http_headers.contentlength>>
<<signature Http_headers.contentencoding>>
<<signature Http_headers.location>>
<<signature Http_headers.challenge>>
<<signature Http_headers.proxy_challenge>>
<<signature Http_headers.expires>>

<<signature Http_headers.rem_contentencoding>>

<<signature Http_headers.status_msg>>

<<signature Http_headers.http_status>>
<<signature Http_headers.status_message>>

(* 
 * Details for specific headers
 *)

<<type Http_headers.authScheme>>

<<type Http_headers.authChallenge>>

<<type Http_headers.media_parameter>>
<<type Http_headers.media_type>>

<<type Http_headers.hint>>

<<signature Http_headers.hints>>

<<signature Http_headers.read_suffix_file>>
@


\subsection*{[[./http/http_headers.ml]]}






<<function Http_headers.status_msg>>=
let rec status_msg = function
    [] -> raise Not_found
  | s::l -> if String.length s >= 5 (* "HTTP/" *)
          & (String.sub s 0 5) = "HTTP/"
         then (parse_status s).status_message
         else status_msg l
@

<<constant Http_headers.is_contentencoding>>=
let is_contentencoding =
  let l = String.length "Content-Encoding" in
  (fun s ->
       String.length s >= l + 2
    && String.lowercase (String.sub s 0 (l+2)) = "content-encoding: ")
@

<<function Http_headers.rem_contentencoding>>=
let rec rem_contentencoding = function
   [] -> []
 | h::l when is_contentencoding h -> l
 | x::l -> x :: rem_contentencoding l
@







<<function Http_headers.hints>>=
let hints path =
  (* Get the url suffix *)
  let sufx = get_suffix path in
  try
    let v = 
      try 
    Hashtbl.find suffixes sufx 
      with
    Not_found -> 
      Hashtbl.find suffixes (String.lowercase sufx)
    in
      match v with
       ContentType t -> [t] (* good, we have a type *)
     | ContentEncoding e ->
       (* we have an encoding, but do we have a type too ? *)
     let path2 = Filename.chop_suffix path ("."^sufx) in
     let sufx2 = get_suffix path2 in
      begin try let v2 = Hashtbl.find suffixes sufx2 in
        match v2 with
          ContentType t -> (* good, we have a type *)
            [t;e]
        | ContentEncoding _ -> [e] (* nah, forget it *)
      with
        Not_found -> [e] (* no type *)
      end
  with
    Not_found -> [] (* no hint ... *)
@




%-------------------------------------------------------------

<<./http/http_headers.ml>>=
open Printf
open Str
open Mstring
open Messages

<<exception Http_headers.Invalid_HTTP_header>>

<<function Http_headers.parse_status>>

(* Request-Line = Method SP Request-URI SP HTTP-Version CRLF *)
<<function Http_headers.parse_request>>


<<function Http_headers.get_header>>

<<function Http_headers.get_multi_header>>

<<function Http_headers.header_type>>

<<function Http_headers.merge_headers>>

<<function Http_headers.remove_headers>>

<<function Http_headers.status_msg>>

let contentlength l = 
  let h = get_header "content-length" l in
  try int_of_string h with _ -> raise Not_found

let location = get_header "location"
let contentencoding = get_header "content-encoding"
let contenttype = get_header "content-type"
let challenge = get_header "www-authenticate"
let proxy_challenge = get_header "proxy-authenticate"
let expires hs =
  try Some (Lexdate.ht_of_string (get_header "expires" hs))
  with
     Not_found -> None
   | _ -> Log.f ("warning: Can't parse Expires header ");
      None 

<<constant Http_headers.is_contentencoding>>

<<function Http_headers.rem_contentencoding>>



(* 
 * Details for specific headers
 *)

<<type Http_headers.authScheme>>

<<type Http_headers.authChallenge>>

<<type Http_headers.media_parameter>>
<<type Http_headers.media_type>>

<<type Http_headers.hint>>

<<constant Http_headers.suffixes>>

<<function Http_headers.read_suffix_file>>

(* Even if we don't have a suffix file... *)
<<toplevel Http_headers._1>>

<<function Http_headers.hints>>



<<constant Http_headers.status_messages>>
<<toplevel Http_headers._2>>

<<function Http_headers.status_message>>

<<function Http_headers.http_status>>


@


\subsection*{[[./http/auth.mli]]}



%-------------------------------------------------------------

<<./http/auth.mli>>=
open Http_headers

<<type Auth.authSpace>>


<<signature Auth.lifetime>>
<<signature Auth.auth_file>>

val edit_backend: (unit -> unit) ref

(* pad: only for edit_backend *)
type authEntry = {
   auth_cookie : string;
   mutable auth_lastused : float
   }
val authorizations: (authSpace, authEntry) Hashtbl.t

<<signature Auth.edit>>
<<signature Auth.load>>
<<signature Auth.save>>

<<signature Auth.add>>
<<signature Auth.get>>

<<signature Auth.init>>

val open_passwd_ref: (string -> string * string) ref

<<signature Auth.check>>
@


\subsection*{[[./http/auth.ml]]}



%-------------------------------------------------------------

<<./http/auth.ml>>=
(* HTTP Basic Authentication *)
open Printf
open Unix
open Http_headers
open Url
open Www

<<type Auth.authSpace>>

<<type Auth.authEntry>>

<<constant Auth.authorizations>>


<<function Auth.get>>

<<constant Auth.lifetime>>


<<function Auth.lookup>>

let open_passwd_ref = ref (fun _ -> failwith "no Auth.open_passswd defined")
<<function Auth.ask_cookie>>

<<function Auth.replace>>
  

<<function Auth.add>>

<<function Auth.check>>

let edit_backend = ref (fun _ -> failwith "no Auth.edit defined") 

(* Authorisation control *)
<<function Auth.edit>>

<<constant Auth.auth_file>>

<<function Auth.save>>

<<function Auth.load>>


<<function Auth.init>>
       
@


\subsection*{[[./http/lexheaders.mli]]}


%-------------------------------------------------------------

<<./http/lexheaders.mli>>=
open Http_headers

<<signature Lexheaders.media_type>>
<<signature Lexheaders.challenge>>

@


\subsection*{[[./http/retype.mli]]}

<<signature Retype.f>>=
val f : Document.handle -> unit
  (* physically modify the headers, adding ContentType/ContentEncoding
   * from URL suffixes if this information is missing from the headers.
   *)
@


%-------------------------------------------------------------

<<./http/retype.mli>>=
<<signature Retype.f>>

@


\subsection*{[[./http/retype.ml]]}

<<function Retype.f>>=
(* Attempt to find a decent Content-Type *)
let f dh =
  let url = Url.string_of dh.document_id.document_url in
  try
    let ctype = contenttype dh.document_headers in 
    let mtyp,pars = Lexheaders.media_type ctype in
    if mtyp = ("application","octet-stream") then
      dh.document_headers <- merge_headers dh.document_headers (hints url)
  with
    Not_found ->
      dh.document_headers <- merge_headers dh.document_headers (hints url)
@


%-------------------------------------------------------------

<<./http/retype.ml>>=
open Document
open Http_headers

<<function Retype.f>>


@


\subsection*{[[./http/http.ml]]}



%-------------------------------------------------------------

<<./http/http.ml>>=
(* Retrieve an HTTP document *)
open Unix
open Www
open Hyper
open Auth
open Document
open Feed
open Messages
open Http_headers
open Url

<<constant Http.always_proxy>>
<<constant Http.timeout>>

<<global Http.proxy>>
<<global Http.proxy_port>>

<<constant Http.verbose>>

<<exception Http.HTTP_error>>

<<type Http.status>>

class cnx (sock,finish) =
 object (self)
  val mutable status = Writing
  val mutable fd = sock
  (* val finish = finish *)
  val mutable fdclosed = false		(* protect against double close *)
  val mutable aborted = false

  method fd = fd
  method aborted = aborted
  method set_fd newfd = fd <- newfd
  method set_status s = status <- s

  method close =
    if not fdclosed then begin
      close fd;
      fdclosed <- true
      end
  
  method abort =
     if not aborted then begin
       aborted <- true;
       match status with
     Writing -> Fileevent_.remove_fileoutput fd; self#close; finish true
       | Reading dh -> dclose true dh; finish true
       | Discharged -> ()
     end
end


<<function Http.tcp_connect>>

<<constant Http.send_referer>>
<<constant Http.user_agent>>

<<function Http.std_request_headers>>

<<function Http.full_request>>


<<function Http.failed_request>>


(*
 *  Process an HTTP request asynchronously
 *)

<<exception Http.End_of_headers>>

<<function Http.read_headers>>


(* Read headers and run continuation *)
let rec process_response wwwr cont cnx =
  let url = Url.string_of wwwr.www_url in
  wwwr.www_logging (I18n.sprintf "Reading headers...");
  let dh = {document_id = document_id wwwr;
        document_referer = wwwr.www_link.h_context;
            document_status = 0;
        document_headers = [];
        document_feed = Feed.of_fd cnx#fd;
        document_fragment = wwwr.www_fragment;
        document_logger = tty_logger}
  and stuck = ref true in
  cnx#set_status (Reading dh);
  (* set up a timer to abort if server is too far/slow *)
  let rec timout () =
     Timer_.set (1000 * !timeout) 
      (fun () -> 
    if not cnx#aborted && !stuck then
      match wwwr.www_error#ari
            (I18n.sprintf "Timeout while waiting for headers of %s" url) with
        0 -> (* abort *) if !stuck then cnx#abort
      | 1 -> (* retry *) timout ()
      | 2 -> (* ignore *) ()
          | _ -> ()
    ) in

  timout();

  (* reading the headers *)
  dh.document_feed.feed_schedule
    (fun () ->
       stuck := false;
       try
     if dh.document_headers = [] then begin
           (* it should be the HTTP Status-Line *)
        let l = Munix.read_line cnx#fd in
          dh.document_status <- (parse_status l).status_code;
              dh.document_headers <- [l] (* keep it there *)
            end
      else 
            dh.document_headers <- read_headers cnx#fd dh.document_headers
       with
     (* each branch must unschedule *)
     End_of_headers ->
       dh.document_feed.feed_unschedule();
       cnx#set_status Discharged;
       cont.document_process dh
       | Not_found -> (* that's what parse_status raises. HTTP/0.9 dammit *)
       dclose false dh; (* keep it an active cnx since we are retrying *)
       let newcnx = request09 wwwr cont in
         (* the guy up there has the old one !*)
             cnx#set_fd newcnx#fd
       | Unix_error(e,_,_) ->
           cnx#abort;
       wwwr.www_error#f (I18n.sprintf 
                     "Error while reading headers of %s\n%s" url 
                     (error_message e))
       | Invalid_HTTP_header s ->
           cnx#abort;
       wwwr.www_error#f (I18n.sprintf 
                     "Error while reading headers of %s\n%s" url s)
       | End_of_file ->
           cnx#abort;
       wwwr.www_error#f (I18n.sprintf 
                     "Error while reading headers of %s\n%s" url "eof"))

(* The same for HTTP 0.9, so we directly call the continuation *)
and process_response09  wwwr cont cnx =
   let dh =
       {document_id = document_id wwwr;
    document_referer = wwwr.www_link.h_context;
    document_status = 200;
    document_headers = ["Content-Type: text/html"];
    document_feed = Feed.of_fd cnx#fd;
    document_fragment = wwwr.www_fragment;
    document_logger = tty_logger} in
   cnx#set_status Discharged;
   cont.document_process dh



(* Writing the request to the server
 *   TODO:  We might get some error here in write
 *   NOTE: tk doesn't allow two handles on the same fd, thus use CPS
 *         so that reading response is our continuation
 *)
and async_request proxy_mode wwwr cont cnx =
  let b = Ebuffer.create 1024 in
    full_request (Ebuffer.output_string b) proxy_mode wwwr;
  let req = Ebuffer.get b 
  and len = Ebuffer.used b in
  let curpos = ref 0 in
    wwwr.www_logging (I18n.sprintf "Writing request...");
    Fileevent_.add_fileoutput cnx#fd (fun _ ->
      let n = write cnx#fd req !curpos (len - !curpos) in (* blocking ? *)
       curpos := !curpos  + n;
    if !curpos = len then begin
         Fileevent_.remove_fileoutput cnx#fd;
      if !verbose then Log.f req;
         cont cnx
         end)

(* wrappers for request/response transaction *)
and start_request proxy_mode wwwr cont cnx =
  async_request proxy_mode wwwr (process_response wwwr cont) cnx
and start_request09 proxy_mode wwwr cont cnx =
  async_request proxy_mode wwwr (process_response09 wwwr cont) cnx


<<function Http.proxy_request>>
 

and proxy_request09 wr cont =
  tcp_connect !proxy !proxy_port wr.www_logging
          (start_request09 true wr cont)
          (failed_request wr cont.document_finish)

(* Issueing request, with the "retry" logic (unless is "always proxy" mode, 
   we attempt first to connect directly to the host, and if it fails,
   we retry through the proxy
 *)
and request wr cont =
  if !always_proxy then proxy_request wr cont
  else 
   let urlp = wr.www_url in
    if urlp.protocol = HTTP then
      let host = match urlp.host with
      Some h -> h 
    | _ -> raise (HTTP_error (I18n.sprintf "Missing host in url"))
      and port = match urlp.port with
      Some p -> p
    | None -> 80  (* default http port *)
      in 
      try 
    tcp_connect host port wr.www_logging
            (start_request false wr cont)
            (failed_request wr cont.document_finish)
      with
    HTTP_error _ -> (* direct failed, go through proxy *)
      tcp_connect !proxy !proxy_port wr.www_logging
             (start_request true wr cont)
             (failed_request wr cont.document_finish)
    else 
      raise (HTTP_error (I18n.sprintf "INTERNAL ERROR\nHttp.request (not a distant http url): %s" (Url.string_of wr.www_url)))

and request09 wr cont =
  if !always_proxy then proxy_request09 wr cont
  else 
   let urlp = wr.www_url in
    if urlp.protocol = HTTP then
      let host = match urlp.host with
      Some h -> h 
    | _ -> raise (HTTP_error (I18n.sprintf "Missing host in url"))
      and port = match urlp.port with
      Some p -> p
    | None -> 80  (* default http port *)
      in
      try 
    tcp_connect host port wr.www_logging
        (start_request09 false wr cont)
        (failed_request wr cont.document_finish)
      with
    HTTP_error _ ->
     tcp_connect !proxy !proxy_port wr.www_logging
            (start_request09 true wr cont)
        (failed_request wr cont.document_finish)
    else 
      raise (HTTP_error (I18n.sprintf "INTERNAL ERROR\nHttp.request09 (not a distant http url): %s" (Url.string_of wr.www_url)))

(* Wrappers returning the abort callback *)
<<function Http.req>>
<<function Http.prox_req>>
@




\section{[[./protocols/]]}

\subsection*{[[./protocols/cache.mli]]}


<<signature Cache.history_mode>>=
val history_mode : bool ref
@
<<signature Cache.max_documents>>=
val max_documents : int ref
@
<<signature Cache.cleann>>=
val cleann : int ref
@




<<type Cache.cache_fill>>=
type cache_fill = {
  cache_write : string -> int -> int -> unit;
  cache_close : unit -> unit
 }
@

<<exception Cache.DontCache>>=
exception DontCache
@

<<signature Cache.tofile>>=
val tofile : handle -> document_data * cache_fill
@


<<signature Cache.dummy>>=
val dummy : handle  -> document_data * cache_fill
@

<<signature Cache.discard>>=
val discard: cache_fill
@

<<signature Cache.wrap>>=
val wrap: cache_fill -> handle -> handle
@

<<signature Cache.patch>>=
val patch : document_id -> string list -> unit
@

<<signature Cache.cutlinks>>=
val cutlinks : (document_id -> unit) list ref
@

<<signature Cache.make_handle>>=
val make_handle : Www.request -> document -> handle
@

<<signature Cache.renew_handle>>=
val renew_handle : handle -> handle
@

<<signature Cache.make_embed_handle>>=
val make_embed_handle : document -> handle
@


%-------------------------------------------------------------

<<./protocols/cache.mli>>=
(* Document and image cache *)
open Document

<<signature Cache.debug>>
<<signature Cache.history_mode>>
<<signature Cache.max_documents>>
<<signature Cache.cleann>>

<<signature Cache.init>>

<<signature Cache.add>>
<<signature Cache.find>>
<<signature Cache.finished>>
<<signature Cache.touch>>
<<signature Cache.kill>>

<<signature Cache.postmortem>>

<<type Cache.cache_fill>>

<<exception Cache.DontCache>>

<<signature Cache.tofile>>
<<signature Cache.tobuffer>>
<<signature Cache.dummy>>

<<signature Cache.discard>>
<<signature Cache.wrap>>

<<signature Cache.patch>>

<<signature Cache.cutlinks>>

<<signature Cache.make_handle>>
<<signature Cache.renew_handle>>
<<signature Cache.make_embed_handle>>
@


\subsection*{[[./protocols/cache.ml]]}


<<constant Cache.history_mode>>=
let history_mode = ref false
  (* history mode means that we keep only the documents present in some
     navigator window. This mode is meant to be used in conjunction with
     a caching proxy *)
@

<<constant Cache.max_lastused>>=
let max_lastused = 100000000000.0
@

<<constant Cache.cutlinks>>=
(* A list of operations to do when we remove a document from the cache. *)
let cutlinks = ref []
@

<<type Cache.cache_fill (./protocols/cache.ml)>>=
type cache_fill = {
  cache_write : string -> int -> int -> unit;
  cache_close : unit -> unit
 }
@


<<exception Cache.DontCache (./protocols/cache.ml)>>=
exception DontCache
@




<<function Cache.internal_kill>>=
(* Kills a document: stop and destroy all its dinfo
 * The caller is responsible for possible removing the document itself
 * from the memory.
 *)
let internal_kill did e =
   (* Remove pointers to in-lined images and other goodies *)
   List.iter (fun f -> f did) !cutlinks
@

<<function Cache.make_room>>=
let make_room () =
  if !debug then Log.f "Trying to make room in cache";
  (* Sort.list according to lru *)
  memory := Sort.list 
            (fun (_,e) (_,e') -> e.cache_lastused < e'.cache_lastused)
         !memory;
  (* if the more recent entry has lu max_lastused, then we have to augment 
     the cache, since this means that only pending connexions are
     in the cache *)
  begin match !memory with
    [] -> ()
  | (_,e)::l ->
     if e.cache_lastused = max_lastused then max_documents := !max_documents + 5
     else (* cleanup the oldests entries *)
       let rec rem1 n l = 
        if n = 0 then l
     else match l with
       [] -> []
    | (did, e)::l ->
         internal_kill did e;
         decr current;
         rem1 (n-1) l
        in
      memory := rem1 !cleann !memory
  end;
  if !debug then begin
     Log.f (sprintf "Cache size(max): %d(%d)" !current !max_documents);
     Log.f "Cache contents:";
     postmortem()
  end
@

<<function Cache.finalize>>=
(* Remove the document source. *)
let finalize = function
   FileData (f, true) -> Msys.rm f
 | _ -> () (* gc ! *)
@

<<function Cache.kill_entry>>=
(* kill: removes a document from the cache
 *   Used by Reload. It can fail to find url in memory !
 *   It can also be used to remove something from the file cache
 *)
let kill_entry did e =
  if !debug then
    Log.f (sprintf  "Killing cache entry %s(%d)"
         (Url.string_of did.document_url)
         did.document_stamp);
  internal_kill did e;	(* kill dinfo in all windows *)
  finalize e.cache_document.document_data;	(* remove source *)
  memory := Mlist.except_assoc did !memory;
  decr current
@

<<function Cache.kill>>=
let kill did =
  try
    let e = List.assoc did !memory in
      kill_entry did e
  with
    Not_found -> ()
@


<<function Cache.finished>>=
(* since they have lu = max_lastused *)
let finished did =
  if !debug then
     Log.f (sprintf "%s completed" (Url.string_of did.document_url));
  try
    let entry = List.assoc did !memory in
      entry.cache_lastused <- Unix.time();
      entry.cache_pending <- false;
      Condition.set entry.cache_condition
  with
    Not_found -> ()
@

<<function Cache.touch>>=
let touch did =
  try
    let entry = List.assoc did !memory in
      entry.cache_lastused <- max (Unix.time()) entry.cache_lastused
  with
    Not_found -> ()
@

<<function Cache.patch>>=
(* Patch the headers of an existing entry *)
let patch did headers =
  try
    let entry = List.assoc did !memory in
    let newd = {
      document_address = entry.cache_document.document_address;
      document_data = entry.cache_document.document_data;
      document_info = merge_headers entry.cache_document.document_info headers
      } in
     entry.cache_document <- newd;
    entry.cache_lastused <- max (Unix.time()) entry.cache_lastused
  with
    Not_found -> () (* is this an error ? *)
@


<<function Cache.tofile>>=
(* Cache savers *)
let tofile dh =
  let f = Msys.mktemp "mmmcache" in
  let oc = open_out_bin f in
    FileData (f,true), 
      {cache_write = output oc;
       cache_close = (fun () -> close_out oc)}
@


<<constant Cache.discard>>=
let discard =
    {cache_write = (fun buf offs len -> ());
     cache_close = (fun () -> ())}
@

<<function Cache.dummy>>=
(* Pseudo-caching for documents that can be obtained from the local
   file system. Relies on trailing slash for directories !
 *)

let dummy dh =
  let url = dh.document_id.document_url in
   match url.protocol with
     FILE -> 
       begin match url.path with
     None -> tobuffer dh
       | Some "" -> tobuffer dh
       | Some p ->
      if p.[String.length p - 1] = '/' then tobuffer dh
      else FileData ("/"^p, false), discard
       end
   | _ -> raise DontCache
@

<<function Cache.replace>>=
let replace = function
   MemoryData b ->
    Ebuffer.reset b; 
    {cache_write = Ebuffer.output b; cache_close = (fun () -> ())}
 | FileData (f, _) ->
  let oc = open_out_bin f in
    {cache_write = output oc;
     cache_close = (fun () -> close_out oc)}
@

<<function Cache.wrap>>=
(* Wrap a feed with cache saving *)
let wrap c dh = 
  let wfeed = {
    feed_read = 
      (fun buf offs len ->
        let r = dh.document_feed.feed_read buf offs len in
     if r <> 0 then c.cache_write buf offs r;
     r);
    feed_schedule = dh.document_feed.feed_schedule;
    feed_unschedule = dh.document_feed.feed_unschedule;
    feed_close =
      (fun () ->
        dh.document_feed.feed_close();
     c.cache_close();
     finished dh.document_id);
    feed_internal = dh.document_feed.feed_internal
    }
  in
  {document_id = dh.document_id;
   document_referer = dh.document_referer;
   document_status = dh.document_status;
   document_headers = dh.document_headers;
   document_feed = wfeed;
   document_fragment = dh.document_fragment;
   document_logger = dh.document_logger
  }
@

<<function Cache.fd_of_doc>>=
(* This is stupid: to display a source that we have in the cache, we must
 * save it to disk in order to get a file descriptor...
 *)

let fd_of_doc doc =
  match doc.document_data with
    MemoryData buf ->
      let f = Msys.mktemp "mmmbuf" in
      let oc = open_out f in
      output_string oc (Ebuffer.get buf);
      close_out oc;
      let fd = openfile f [O_RDONLY] 0 in
      Msys.rm f;
      fd
  | FileData (f,_) -> openfile f [O_RDONLY] 0
@

<<function Cache.make_handle>>=
let make_handle wwwr doc =
  { document_id = { document_url = wwwr.www_url; document_stamp = no_stamp};
    document_referer = wwwr.www_link.h_context;
    document_status = 200;
    document_headers = doc.document_info;
    document_feed = Feed.of_fd (fd_of_doc doc);
    document_fragment = wwwr.www_fragment;
    document_logger = tty_logger}
@

<<function Cache.renew_handle>>=
(* The same, if we kept the old dh *)
let renew_handle dh =
  let did = dh.document_id in
  let doc = find did in
  { document_id = dh.document_id;
    document_referer = dh.document_referer;
    document_status = dh.document_status;
    document_headers = doc.document_info;
    document_feed = Feed.of_fd (fd_of_doc doc);
    document_fragment = dh.document_fragment;
    document_logger = dh.document_logger}
@

<<function Cache.make_embed_handle>>=
(* Same for embedded objects (but we don't have wwwr handy) *)
let make_embed_handle doc =
  let fd =
    match doc.document_data with
      MemoryData buf ->
    let f = Msys.mktemp "mmmbuf" in
      let oc = open_out f in
        output_string oc (Ebuffer.get buf);
        close_out oc;
    let fd = openfile f [O_RDONLY] 0 in
      Msys.rm f;
      fd
    | FileData (f,_) -> openfile f [O_RDONLY] 0
  in
    {document_id = 
    { document_url = doc.document_address; document_stamp = no_stamp};
     document_referer = None;
     document_status = 200;
     document_headers = doc.document_info;
     document_feed = Feed.of_fd fd;
     document_fragment = None;
     document_logger = tty_logger}
@

<<function Cache.cleanup>>=
let cleanup () =
  List.iter 
    (fun (did, entry) ->
      match entry.cache_document.document_data with
       FileData (f, true) -> Msys.rm f
      | _ -> ())
    !memory
@

<<toplevel Cache._1>>=
let _ = at_exit cleanup
@


%-------------------------------------------------------------

<<./protocols/cache.ml>>=
(* Document caching (in memory !) *)
open Printf
open Unix
open Url
open Www
open Hyper
open Document
open Feed
open Http_headers

<<constant Cache.debug>>
<<constant Cache.history_mode>>

<<constant Cache.max_lastused>>

(* The max values refer documents kept in memory *)
let max_documents = ref 30
and cleann = ref 5
and current = ref 0

<<constant Cache.cutlinks>>

<<type Cache.cache_fill (./protocols/cache.ml)>>

<<type Cache.entry>>

<<exception Cache.DontCache (./protocols/cache.ml)>>

<<constant Cache.memory>>

<<function Cache.postmortem>>


<<function Cache.find>>

<<function Cache.internal_kill>>

<<function Cache.make_room>>


<<function Cache.finalize>>

<<function Cache.kill_entry>>

<<function Cache.kill>>

<<function Cache.add>>



(* Pending documents should never be removed from the cache *)
<<function Cache.finished>>

<<function Cache.touch>>

<<function Cache.patch>>

<<function Cache.init>>


<<function Cache.tofile>>

<<function Cache.tobuffer>>

<<constant Cache.discard>>

<<function Cache.dummy>>

<<function Cache.replace>>

<<function Cache.wrap>>

(* Obtain a dh from a cache entry *)
<<function Cache.fd_of_doc>>

<<function Cache.make_handle>>

<<function Cache.renew_handle>>


<<function Cache.make_embed_handle>>

   
<<function Cache.cleanup>>

<<toplevel Cache._1>>
@


\subsection*{[[./protocols/file.mli]]}



%-------------------------------------------------------------

<<./protocols/file.mli>>=
<<signature File.request>>
<<exception File.File_error>>

(* pad: for tk_file.ml *)
val binary_path: string list ref

<<signature File.pref_init>>
<<signature File.pref_set>>
@


\subsection*{[[./protocols/file.ml]]}


% ???
<<signature File.pref_init>>=
@
<<signature File.pref_set>>=
@


<<function File.pref_init>>=
@

<<function File.pref_set>>=
@

<<constant File.r>>=
let r = Str.regexp ":"
@

%-------------------------------------------------------------

<<./protocols/file.ml>>=
(* The file: protocol *)
open Printf
open Unix
open Filename
open Mstring
open Hyper
open Www
open Url
open Messages
open Http_headers
open Http
open Document
open Feed

<<exception File.File_error>>

<<function File.isdir>>

<<function File.d2html>>

<<function File.dir>>
  

<<function File.document_id>>

<<function File.fake_cgi>>

<<constant File.binary_path>>
<<constant File.r>>
<<function File.pref_init>>
<<function File.pref_set>>

<<function File.is_cgi>>
<<function File.request>>
@


\subsection*{[[./protocols/mailto.ml]]}

<<constant Mailto.mailer>>=
let mailer = ref ""
@

<<type Mailto.msg>>=
type msg = {
  dest : string;
  subject : string;
  body : string 
  }
@

<<function Mailto.error>>=
let error body =
  try
    let oc = open_out_bin (Filename.concat (getenv "HOME") "dead.letter") in
     output_string oc body;
     close_out oc;
     !Error.default#f (I18n.sprintf "Can't send mail (saved in $HOME/dead.letter)")
  with
     _ -> 
      !Error.default#f (I18n.sprintf "Can't send mail, can't save dead.letter")
@
%$

<<function Mailto.sendmail>>=
(* if the mail contains a dot line, we're f*cked *)
let sendmail msg =
 let cmd = try Sys.getenv "MMM_MAIL" with Not_found -> "mail" in
 try
  let (fd_in,fd_out) = pipe() in
  match Low.fork () with
    0 -> close fd_out; dup2 fd_in stdin;
     Munix.execvp cmd [| cmd; "-s"; msg.subject; msg.dest |]
  | n -> close fd_in;
     Munix.write_string fd_out msg.body;
     close fd_out;
     begin match waitpid [] n with
       _, WEXITED 0 -> !Error.default#ok (I18n.sprintf "Mail sent")
     | _, _ -> error msg.body
     end
 with
   Unix_error(_,_,_) -> error msg.body
@

<<function Mailto.internal>>=
let internal address referer =
  !internal_backend address referer
@

<<function Mailto.get>>=
let get mailaddr referer =
 let subject = match referer with
     None -> "no subject"
   | Some s -> "About url "^s  in
  match !mailer with
     "" ->
       internal mailaddr subject
   | s -> 
       ignore
        (Munix.system_eval s 
          ["_", "-s"; "SUBJECT", subject; "TO", mailaddr] true)
@

<<function Mailto.f>>=
let f wr =
  match wr.www_url.path with
    None -> wr.www_error#f (I18n.sprintf "No address given for mailto:")
  | Some rawaddress ->
     let address = Urlenc.decode rawaddress in
       match wr.www_link.h_method with
     GET -> get address wr.www_link.h_context
       | POST d ->
       if wr.www_error#choose 
           (I18n.sprintf "About to send mail with POST data to\n%s"
                 address)
       then
         let subject = match wr.www_link.h_context with
         None -> "no subject"
           | Some s -> "POST data for "^s in
          sendmail 
        { dest = address; subject = subject; body = d}
       else ()
       | _ ->
       wr.www_error#f (I18n.sprintf "Unsupported method for mailto:")
@


%-------------------------------------------------------------

<<./protocols/mailto.ml>>=
(* mailto: *)
open Sys
open Unix
open Www
open Hyper
open Url

<<constant Mailto.mailer>>

<<type Mailto.msg>>

<<function Mailto.error>>

<<function Mailto.sendmail>>

let internal_backend = ref (fun _ _ -> failwith "no Mailto.internal defined")
<<function Mailto.internal>>


   
<<function Mailto.get>>

<<function Mailto.f>>
@


\subsection*{[[./protocols/protos.mli]]}

%-------------------------------------------------------------

<<./protocols/protos.mli>>=

<<signature Protos.get>>
@

\subsection*{[[./protocols/protos.ml]]}

%todo: no protos.mli?





%-------------------------------------------------------------

<<./protocols/protos.ml>>=
open Url

<<constant Protos.protos>>

<<toplevel Protos._1>>
<<toplevel Protos._2>>
<<toplevel Protos._3>>
<<toplevel Protos._4>>
<<toplevel Protos._5>>
<<toplevel Protos._6>>
<<toplevel Protos._7>>

<<constant Protos.get>>
@


\section{[[./retrieve/]]}

\subsection*{[[./retrieve/progress.mli]]}



%-------------------------------------------------------------

<<./retrieve/progress.mli>>=
<<signature Progress.no_meter>>
<<signature Progress.meter>>
@


\subsection*{[[./retrieve/progress.ml]]}



%-------------------------------------------------------------

<<./retrieve/progress.ml>>=
<<constant Progress.no_meter>>

<<function Progress.meter>>
@


\subsection*{[[./retrieve/retrieve.mli]]}


%-------------------------------------------------------------

<<./retrieve/retrieve.mli>>=
(* Document retrieval *)
open Document

<<type Retrieve.retrievalStatus>>

<<signature Retrieve.f>>

<<type Retrieve.behaviour>>

<<signature Retrieve.add_http_processor>>
@


\subsection*{[[./retrieve/retrieve.ml]]}


<<function Retrieve.wrap_cache>>=
(* What do we cache ? : text/html and text/plain in memory *)
let wrap_cache cache dh =
  Log.debug (sprintf "Wrapping cache for %s(%d)"
             (Url.string_of dh.document_id.document_url)
             dh.document_id.document_stamp);
  Retype.f dh;
  try
    match Lexheaders.media_type (contenttype dh.document_headers) with
    | ("text","html"),_ 
    | ("text","plain"),_ ->
        begin 
      try
        let doc, c = cache dh in
          Cache.add dh.document_id
                 {document_address = dh.document_id.document_url;
                  document_data = doc; document_info = dh.document_headers};
          Cache.wrap c dh
          with
            Cache.DontCache -> dh
        end
    | _ -> dh
  with
    Not_found -> dh
@


<<function Retrieve.code204>>=
(* 204 No Content: we should modify the headers of the referer ? *)
let code204 wwwr dh =
  Stop (I18n.sprintf "Request fulfilled.\n(%s)"
                    (status_msg dh.document_headers))
@

<<function Retrieve.forward>>=
(* 302 Moved temporarily *)
let forward wwwr dh =
  try 
   let newurl = Http_headers.location dh.document_headers in
     if (* do we forward automatically ?*)
    match wwwr.www_link.h_method with
      GET -> true
    | POST _ ->
        (* Do NOT redirect automatically if method was POST *)
        wwwr.www_error#choose (I18n.sprintf 
         "Destination for your POST request has changed\n\
              from %s\nto %s\nConfirm action ?"
            (Url.string_of wwwr.www_url) newurl)
    | _ -> true 
     then begin (* consider forwarding as a link *)
       wwwr.www_logging "Forwarding";
       Retry {h_uri = newurl;
          h_context = wwwr.www_link.h_context;
          h_method = wwwr.www_link.h_method;
          h_params = wwwr.www_link.h_params
         }
       end
     else 
      (* not forwarding a moved POST. We show the document after all,
        since some people (servers ?) use this trick to show the results
        of a POST, despite what the protocol says about this *)
       Ok
  with 
    Not_found -> 
      Error (I18n.sprintf "No Location: in forwarding header")
@

<<function Retrieve.forward_permanent>>=
(* 301 Moved permanently *)
let forward_permanent wwwr dh =
  try
    let newurl = Http_headers.location dh.document_headers in
      wwwr.www_error#ok (I18n.sprintf "Document moved permanently to\n%s"
                          newurl);
      forward wwwr dh
  with
    Not_found -> 
      Error (I18n.sprintf "No Location: in forwarding header")
@


<<function Retrieve.ask_auth>>=
(* 401 Unauthorized *)
let ask_auth wwwr dh =
  wwwr.www_logging (I18n.sprintf "Checking authentication");
  let rawchallenge = challenge dh.document_headers in
  let challenge = 
    Lexheaders.challenge (Lexing.from_string rawchallenge) in
  let host = match wwwr.www_url.host with
     Some h -> h
   | None -> ""
  and dir = match wwwr.www_url.path with
     Some "" -> "/"
   | Some h -> Filename.dirname h
   | None -> "/" 
  and port = match wwwr.www_url.port with
     Some p -> p
   | None -> 80 (* should never happen *) in

  Auth.check wwwr challenge
      {auth_proxy = false;
       auth_host = host; 
       auth_port = port;
       auth_dir = dir;
       auth_realm = challenge.challenge_realm}
@

<<function Retrieve.unauthorized>>=
let unauthorized wwwr dh =
  match ask_auth wwwr dh with
    None -> (* no attempt to answer challenge, display the message *)
      Ok
  | Some (cookie, isnew, space) ->
     (* restart the request with a continuation that says first
    to check if authorization was valid, and then proceed
    to the normal intended continuation *)
     Restart (fun newdh ->
        if newdh.document_status <> 401 & isnew then
          Auth.add space cookie;
        (* Put the challenge header again *)
        begin try
          newdh.document_headers <- 
             ("WWW-Authenticate: "^ 
                   (challenge dh.document_headers))
             :: newdh.document_headers
         with
          Not_found -> ()
        end;
                newdh)
@

<<function Retrieve.ask_proxy_auth>>=
(* 407 Unauthorized *)
(* We dump the realm altogether, because it has no meaning for proxies *)
let ask_proxy_auth wwwr dh =
  wwwr.www_logging (I18n.sprintf "Checking proxy authentication");
  let rawchallenge = proxy_challenge dh.document_headers in
  let challenge = 
    Lexheaders.challenge (Lexing.from_string rawchallenge) in
  Auth.check wwwr challenge
      {auth_proxy = true;
       auth_host = !proxy;
       auth_port = !proxy_port;
       auth_dir = "";
       auth_realm = ""}
@

<<function Retrieve.proxy_unauthorized>>=
let proxy_unauthorized wwwr dh =
  Log.debug "proxy_unauthorized handler";
  match ask_proxy_auth wwwr dh with
    None -> (* no attempt to answer challenge, display the message *)
      Ok
  | Some (cookie, isnew, space) ->
     (* restart the request with a continuation that says first
    to check if authorization was valid, and then proceed
    to the normal intended continuation *)
      Restart (fun newdh -> 
         Log.debug "proxy_unauthorized wrapper";
         if newdh.document_status <> 407 & isnew then
           Auth.add space cookie;
         (* Put the challenge header again *)
         begin try
           newdh.document_headers <- 
              ("Proxy-Authenticate: "^ 
                                    (proxy_challenge dh.document_headers))
              :: newdh.document_headers
          with
           Not_found -> ()
         end;
                 newdh)
@



%-------------------------------------------------------------

<<./retrieve/retrieve.ml>>=
(* Document retrieval *)
open Printf
open Www
open Hyper
open Url
open Document
open Http
open Http_headers
open Auth

<<type Retrieve.retrievalStatus>>

<<type Retrieve.behaviour>>

<<constant Retrieve.http_process>>

<<constant Retrieve.add_http_processor>>

<<function Retrieve.wrap_cache>>

(* 
 * Dispatch according to status code
 *  retry: how to re-emit a request
 *  cont: what to do with the response 
 *)
let rec http_check cache retry cont wwwr dh =
  Log.debug "Retrieve.http_check";
  try (* the appropriate behavior *)
    let behav = Hashtbl.find http_process dh.document_status in
      match behav wwwr dh with
    Ok -> 
      (* do I cache ? *)
      let cacheable = wwwr.www_link.h_method = GET in
            cont.document_process
          (if cacheable then wrap_cache cache dh else dh)
      | Stop msg ->
          dclose true dh;
          cont.document_finish false;
          wwwr.www_error#ok msg
      | Error msg ->
          dclose true dh;
          cont.document_finish false;
          wwwr.www_error#f msg
      | Retry hlink ->
          dclose true dh;
          cont.document_finish false;
      retry hlink
      | Restart transform ->
      dclose true dh;
          f wwwr retry {document_finish = cont.document_finish;
            document_process = (fun dh ->
                cont.document_process (transform dh))};
          () (* we should probably do something of the result ! *)
  with
    Not_found ->
     (* default behavior is to call the normal continuation 
    BUT WE DON'T CACHE !
        e.g. 404 Not found, 500, ...
      *)
      cont.document_process dh

(*
 * Emitting a request:
 *   we must catch here all errors due to protocols and remove the
 *   cnx from the set of active cnx.
 *)
and f request retry cont = 
  Log.debug "Retrieve.f";
  if Www.is_active_cnx request.www_url then InUse
  else begin
   Www.add_active_cnx request.www_url;
   try 
     let req,cache = Protos.get request.www_url.protocol in
      Started (req request
        {document_finish = cont.document_finish;
        document_process = http_check cache retry cont request})

   with Not_found ->
      Www.rem_active_cnx request.www_url;
      raise (Invalid_request (request, I18n.sprintf "unknown protocol"))
    | Http.HTTP_error s ->
      Www.rem_active_cnx request.www_url;
      raise (Invalid_request (request, I18n.sprintf "HTTP Error \"%s\"" s))
    | File.File_error s ->
      Www.rem_active_cnx request.www_url;
      raise (Invalid_request (request, s))
   end


(* In all the following, we avoid popping up dialog boxes, and use
 * wwwr logging instead. Otherwise we might get too verbose for
 * in-lined images...
 *)

<<function Retrieve.code200>>

<<function Retrieve.code204>>

<<function Retrieve.forward>>

<<function Retrieve.forward_permanent>>

(* 304 : Response to a conditional GET, the document is not modified
let update wwwr dh =
   Cache.patch dh.document_id dh.document_headers;
   Stop (I18n.sprintf "Document %s has not changed.\n"
                  (Url.string_of wwwr.www_url))
Because of recursive update, this has moved elsewhere.
*)

<<function Retrieve.code400>>

<<function Retrieve.ask_auth>>

<<function Retrieve.unauthorized>>

<<function Retrieve.ask_proxy_auth>>

<<function Retrieve.proxy_unauthorized>>

<<toplevel Retrieve._1>>
@


\subsection*{[[./retrieve/img.mli]]}

<<signature Img.gif_anim_load>>=
val gif_anim_load : bool ref
@



%-------------------------------------------------------------

<<./retrieve/img.mli>>=
open Document
<<signature Img.gif_anim_load>>

module ImageData : sig
  type t = Tkanim.imageType

  val gamma : float ref
  val jpeg_converter : string ref
  val verbose : bool ref

  val load : handle -> document_id list -> string -> Tkanim.imageType
  val cache_access : Url.t -> document_id -> Tkanim.imageType
  val error :
      Url.t -> (document_id * ((Url.t -> Tkanim.imageType -> unit) * Scheduler.progress_func)) list -> unit
    val error_msg : Www.request * string -> unit
    val remove_reference : document_id -> unit
    val dump: unit -> unit
  end

module ImageScheduler : Scheduler.S with
    type shared_data = ImageData.t

<<signature Img.get>>
<<signature Img.update>>
@


\subsection*{[[./retrieve/img.ml]]}

<<constant Img.gif_anim_load>>=
(* Images are a special case of embedded data, because Tk caches them
   internally. Thus, we attempt to maintain our own cache logic above
   Tk's one 
 *)

let gif_anim_load = ref false
@

<<toplevel Img._1>>=
(* Advertise ourselfs to the internal cache *)
let _ =
 Cache.cutlinks := ImageData.remove_reference :: !Cache.cutlinks
@



%-------------------------------------------------------------

<<./retrieve/img.ml>>=
(* Image cache and scheduled image downloading *)
open Printf
open Unix
open Tk
open Tkanim
open Mstring
open Document
open Www
open Hyper
open Url
open Http_headers

<<constant Img.gif_anim_load>>

module ImageData =
  struct
    
    type t = Tkanim.imageType

    let gamma = ref 1.0
    let jpeg_converter = ref "djpeg"
    let verbose = ref false

   (* 
    * The image cache
    *)


    let set_of_list l = List.fold_right DocumentIDSet.add l DocumentIDSet.empty

    (* url -> (option for tk configure, set of referers, headers) *)
    let img_cache = 
       (Hashtbl.create 53 : (Url.t, 
                 Tkanim.imageType * DocumentIDSet.t ref
                   * string list) Hashtbl.t)

    (* Debugging *)
    let dump () =
      Hashtbl.iter (fun url (_,r, _) ->
       Log.f (sprintf "IMG %s" (Url.string_of url));
    DocumentIDSet.iter 
         (fun did -> Log.f (sprintf "\tref: %s"
                         (Url.string_of did.document_url)))
         !r)
    img_cache

    let add url imgdesc referers headers =
      Hashtbl.add img_cache url (imgdesc, ref (set_of_list referers), headers)

    (* Raises Not_found *)
    let cache_access url from =
      let img, refs, _ = Hashtbl.find img_cache url in
    refs := DocumentIDSet.add from !refs;
    img

    let direct_cache_access  = Hashtbl.find img_cache

    (* Delete an image from the cache *)
    let delete_image img =
      if !verbose then Log.f (sprintf "Removing img %s" (Url.string_of img));
      match Hashtbl.find img_cache img with
    Still x, _, _ ->
      begin match x with
        Bitmap _ -> ()
      | ImageBitmap n ->
          Imagebitmap.delete n; Hashtbl.remove img_cache img
      | ImagePhoto n ->
          Imagephoto.delete n; Hashtbl.remove img_cache img
      | _ -> assert false
      end
      |	Animated anm, _, _ -> Tkanim.delete anm; Hashtbl.remove img_cache img

    (* Remove reference to an image, clean *)
    let remove_reference referer =
      if !verbose then 
     Log.f (sprintf "Removing img references from %s(%d)" 
            (Url.string_of referer.document_url)
             referer.document_stamp);
      let delete_them = ref [] in
      Hashtbl.iter
    (fun img (o, refs, _) ->
        refs := DocumentIDSet.remove referer !refs;
        if DocumentIDSet.is_empty !refs then
         delete_them := img :: !delete_them)
    img_cache;
      List.iter delete_image !delete_them

    let broken_data = Still (Bitmap (Predefined "error"))

    (* load an image *)
    (* For GIFs, we use JPF's Tkanim package first *)
    let tk_load_gif file =
      try
    if !gif_anim_load then Tkanim.create file
    else Still (ImagePhoto (Imagephoto.create [File file; Gamma !gamma]))
      with Protocol.TkError _ -> broken_data

    (* For JPEG, we attempt internal load first, because we might have
       an extension for loading them *)
    let tk_load_jpeg file =
      try Still (ImagePhoto (Imagephoto.create [File file; Gamma !gamma]))
      with Protocol.TkError _ ->
    let pnmfile = Msys.mktemp "pnm" in
    let cmd = (!jpeg_converter^" "^file^" > "^pnmfile) in
    try match Sys.command cmd with
      0 ->
        let img = Still (ImagePhoto (Imagephoto.create
                     [File pnmfile; Gamma !gamma])) in
        Msys.rm pnmfile;
        img
    | _ -> Msys.rm pnmfile; broken_data
    with
      Protocol.TkError _ ->
        Msys.rm pnmfile;
        Still (Bitmap (Predefined "question"))

    (* other formats *)
    let tk_load_other file =
      Still (
        try ImageBitmap (Imagebitmap.create [File file])
    with
      Protocol.TkError _ ->
        try ImagePhoto (Imagephoto.create [File file; Gamma !gamma])
        with
         Protocol.TkError _ -> Bitmap (Predefined "question"))

    let load dh referers file =
      Retype.f dh;
      match dh.document_status with
    200 ->
      let url = dh.document_id.document_url in
      let img = 
        try
          let ctype = contenttype dh.document_headers in
          match Lexheaders.media_type ctype with
           ("image","jpeg"), _ -> Low.busy tk_load_jpeg file
          | ("image","gif"), _ -> Low.busy tk_load_gif file
          | _,_ -> Low.busy tk_load_other file
        with
        | Not_found -> Low.busy tk_load_other file 
        | Invalid_HTTP_header _ -> Msys.rm file; broken_data
          in
      if !verbose then
        Log.f (sprintf "Loaded %s as %s" file (Url.string_of url));
      Msys.rm file;
      add url img referers dh.document_headers;
      img
      |	304 -> (* we did an update an a document, and it induced a 
          recursive update. The document didn't change *)
      begin try 
        Msys.rm file;
        cache_access dh.document_id.document_url (List.hd referers)
      with
        Not_found -> broken_data
      end
        
      | _ -> (* other cases *)
      Msys.rm file; broken_data
      
      (* error during img downloading *)
    let error url job =
      Log.f (sprintf "Could not load image at %s" (Url.string_of url));
      let img = Still (Bitmap (Predefined "error")) in
      add url img (List.map fst job) [];
      List.iter (fun (_, (cont,_)) -> cont url img) job
    
      (* Invalid urls in images are silently ignored *)
    let error_msg (w, msg) = 
      Log.f (sprintf "Invalid image request: %s (%s)" 
           (Url.string_of w.www_url) msg);
      
  end
    

module ImageScheduler = Scheduler.Make(ImageData)


<<toplevel Img._1>>

<<function Img.get>>

<<function Img.update>>

@


\subsection*{[[./retrieve/scheduler.mli]]}




%-------------------------------------------------------------

<<./retrieve/scheduler.mli>>=
<<signature Scheduler.debug>>

<<type Scheduler.progress_func>>

module type Data =
  sig
   type t
        (* Type of shared objects
         * The table of objects in managed in this module
         *)
   val load : 
     Document.handle -> Document.document_id list -> string -> t
        (* [load dh referers file]
     *   is responsible for creating the shared handle
         *)
   val cache_access : Url.t -> Document.document_id -> t
        (* [cache_access url referer]
         *   attempts to find a shared handle for an URL.
         *   Raises Not_found
         *)       	     
   val error : 
        Url.t -> 
      (Document.document_id * ((Url.t -> t -> unit) * progress_func)) list -> unit
        (* [error url [(did,(cont,progress))]]
         *  if an error occurs, then each pending continuation is called
         *  (if necessary) as required (e.g. with "default" information)
         *)
   val error_msg : Www.request * string -> unit
       (* Retrieval produces Invalid_url *)
  end
   

module type S =
  sig
    type shared_data
    val add_request : Www.request -> Document.document_id ->
                      (Url.t -> shared_data -> unit) -> progress_func -> unit
        (* [add_request delayed wr referer cont progress_func]
         *   returns job handle that can subsequently by awakened
         *)

    val stop : Document.document_id -> unit
        (* [stop did]
         *   stops jobs for which did is the only referer
         *)

    (* Delayed queues for this scheduler *)
    type delayed
    val new_delayed : unit -> delayed
    val add_delayed : 
       delayed -> Www.request -> Document.document_id -> 
            (Url.t -> shared_data -> unit) -> progress_func -> unit
    val flush_delayed : delayed -> unit
    val flush_one : delayed -> Url.t -> unit
    val is_empty : delayed -> bool
    val maxactive : int ref
    val maxsamehost : int ref
  end


module Make(J : Data):(S with type shared_data = J.t)
@


\subsection*{[[./retrieve/scheduler.ml]]}


%-------------------------------------------------------------

<<./retrieve/scheduler.ml>>=
(* Scheduled downloading *)
open Printf
open Unix
open Www
open Document
open Url
open Feed
open Retrieve
open Http_headers

<<constant Scheduler.debug>>

<<type Scheduler.progress_func>>

(* Handling of data downloaded by this scheduler *)
module type Data =
  sig
   type t

   val load : handle -> document_id list -> string -> t
        (* [load dh referers file] *)
   val cache_access : Url.t -> document_id -> t
        (* [cache_access url referer] *)       	     
   val error : Url.t -> 
      (document_id * ((Url.t -> t -> unit) * progress_func)) list ->  unit
        (* [error url conts] *)
   val error_msg : (Www.request * string) -> unit
       (* Retrieval produces Invalid_url *)
  end
   

module type S =
  sig
    type shared_data
    val add_request : 
       Www.request -> document_id -> (Url.t -> shared_data -> unit) -> 
      progress_func -> unit
        (* [add_request wwwr ref_did cont progress_func] *)
    val stop : document_id -> unit
        (* [stop ref_did] *)

    (* Delayed queues for this scheduler *)
    type delayed
    val new_delayed : unit -> delayed
    val add_delayed : 
       delayed -> Www.request -> document_id -> 
      (Url.t -> shared_data -> unit) -> progress_func -> unit
    val flush_delayed : delayed -> unit
    val flush_one : delayed -> Url.t -> unit
    val is_empty : delayed -> bool
    val maxactive : int ref
    val maxsamehost : int ref
  end   


module Make(J: Data) = struct

  type shared_data = J.t

  let maxactive = ref 10
  let maxsamehost = ref 2

  (* A job is: a list of referers, with the continuations *)
  type job = {
      mutable stop : unit -> unit;
      mutable conts : (document_id * 
             ((Url.t -> shared_data -> unit) * progress_func)) list;
      mutable bytes_loaded : int;
      mutable contentlength : int option  
    }

  (* The list of active requests : this is used to share the requests
     for all jobs on the same Url. *)
  let active = ref 0
  and actives = (Hashtbl.create 11 : (Url.t, job) Hashtbl.t)

  (* We need a two-level queue system, so that 
     1- we respect the image loading order for each document
     2- we can use maxactive connexions
     3- there is a max of maxsamehost connexions on the same host
     *)
    
  let samehost = (Hashtbl.create 11 : (string, int ref) Hashtbl.t)
    (* count of cnx on each host (IP number is best choice), but for
       performance reason (DNS lookups), we take FQDN *)

  let addhost url =
    let s = match url.host with Some s -> s | None -> "" in
    try
      let count = Hashtbl.find samehost s in
      if !count < !maxsamehost then (incr count; true) else false
    with
      Not_found -> 
    Hashtbl.add samehost s (ref 1);
    true (* assumes maxsamehost >= 1 *)

  let remhost url =
    let s = match url.host with Some s -> s | None -> "" in
    try 
      let r = Hashtbl.find samehost s in
      decr r;
      if !r <= 0 then Hashtbl.remove samehost s
    with Not_found -> () (* that's an error actually *)

  type queue = (request * document_id * (Url.t -> shared_data -> unit) * progress_func ) Queue.t
    (* queue for one batch of docs *)

  let queues = (ref [] : queue list ref)
    (* pending queues for documents *)

  (* How we pick the next request *)
      
  exception Busy

  let skip_cache wr =
    try
      get_header "pragma" wr.www_headers = "no-cache" 
    with
      Not_found -> false

  let pick() =
    let pick_in_batch q =
      try
    let (wr,_,_,_) = Queue.peek q in
    let url = wr.www_url in
    if addhost url then Some (Queue.take q) else None
      with
    Queue.Empty -> (* this batch is empty *)
      raise Queue.Empty
    in
    let rec walk_batches remaining = function
      | [] ->
      (* we've reached the end : reset the remaining scheduled jobs *)
      queues := List.rev remaining;
      raise Busy
      |	x::l -> 
      try match pick_in_batch x with
      | Some r -> r
      | None -> (* nothing pickable yet, look further *)
          walk_batches (x::remaining) l
      with Queue.Empty -> (* this queue is empty ! *)
        walk_batches remaining l
    in
    walk_batches [] !queues

  (* Whenever we add something in the queue, we must call this *)
  (* Whenever a job finished, we must call this *)
  let rec next_request () =
    if !active < !maxactive then
      try
        let j = pick() in
        process_request j;
        next_request() (* check if more can be done *)
      with
        Busy -> ()

  (* when adding a request individually (meant to be treated ASAP), we
     use a new singleton queue *)
  and add_request wr did cont prog =
    let q = Queue.create() in
    Queue.add (wr, did, cont, prog) q;
    queues := q :: !queues;
    next_request()

  (* error during data downloading *)
  and error url job =
    job.stop();
    J.error url job.conts;
    if !debug then 
      Log.f (sprintf "Retrieval of %s failed\n" (Url.string_of url));
    next_request()

  (* process_request always follows pick, thus hostcount has always been
   * incremented for the URL of this request *)
  and process_request (wr, did, cont, prog) =
    try (* if we are in the cache of shared objects, apply continuation *)
      if skip_cache wr then raise Not_found
      else begin
       let data = J.cache_access wr.www_url did in
       remhost wr.www_url; (* we're done *)
       cont wr.www_url data
      end
    with
      Not_found ->
        (* find out if we are in the active jobs *)
        let url = wr.www_url in
        try
          let oldjob = Hashtbl.find actives url in
      (* then add a new continuation *)
          oldjob.conts <- (did, (cont, prog)) :: oldjob.conts;
      remhost wr.www_url;       (* we're done *)
        with
          Not_found -> begin (* start a new job *)
            if !debug then
              Log.f (sprintf "Starting job for %s" (Url.string_of url));
            let job = {
              stop = (fun () ->
        Hashtbl.remove actives url;
        decr active;
        remhost url);
              conts =  [did, (cont, prog)];
              contentlength = None;
          bytes_loaded = 0
            } in
            (* Add to set of active *)
            incr active;
            Hashtbl.add actives url job;

           (* We are now going to run the retrieval process *)

           (* Continuations for the retrieval *)
            let handle_data dh =
          (* add more things to do in stop *)
          let oldstop = job.stop in
          job.stop <- (fun () -> dclose true dh; oldstop());
              try
                (* open the temporary file in which doc is to be saved *)
                let file = Msys.mktemp "data" in
                let oc = open_out file 
                and buffer = String.create 2048 in

        (* JPF HACK -- for Image retrieval progress meter *)
        begin try 
          job.contentlength <-
            Some (Http_headers.contentlength dh.document_headers)
        with
          Not_found -> ()
        end;

        (* actually start sucking data *)
                dh.document_feed.feed_schedule (fun _ ->
          try
            let n = dh.document_feed.feed_read buffer 0 2048 in

            (* JPF HACK -- for Image retrieval progress meter *)
            job.bytes_loaded <- job.bytes_loaded + n;
              List.iter (fun (_,(_,prog)) -> 
                prog job.contentlength job.bytes_loaded) 
                  job.conts;

            if n <> 0 then output oc buffer 0 n
            else begin (* end of document *)
              dclose true dh; (* see comment below *)
              close_out oc;
              (* proceed to load and run continuations *)
              let referers = List.map fst job.conts in
              begin
            try 
                         let data = J.load dh referers file in
              List.iter (fun (referer,(cont,_)) -> 
                try Printexc.print 
                (cont dh.document_id.document_url) data
                with _ -> flush Pervasives.stderr)
                           job.conts
            with (* load failed *)
              e -> 
                Log.f (sprintf "Load error %s" 
                                          (Printexc.to_string e));
                           J.error url job.conts
              end;
              (* we must remove from active only after 
             loading because otherwise, if loading is interactive,
             there could be a moment during which the document 
             is not marked as loaded, but not active either.
             This would cause multiple retrievals.
             But then dh has to be closed otherwise the
             callback will we called indefinitely *)
              oldstop();
              if !debug then
            Log.f (sprintf "Finished job for %s" 
                           (Url.string_of url));
              (* proceed with more requests *)
              next_request()
            end
          with (* errors in retrieval *)
            Unix_error(code,s,s') -> 
              Log.f (sprintf "Unix error (%s) in scheduler %s %s"
                         (error_message code) s s');
              close_out oc;
              error url job
                 | Sys_error s ->
              Log.f (sprintf "IO error (%s) in scheduler" s);
                     close_out oc;
              error url job
                 | e -> 
              Log.f (sprintf "Bug in scheduler %s"
                         (Printexc.to_string e));
                     close_out oc;
              error url job)
              with (* error creating tmp file *)
        Sys_error s -> 
          Log.f (sprintf "Can't create temporary file (%s)" s);
                 error url job
          | e -> 
          Log.f (sprintf "Bug in scheduler %s" (Printexc.to_string e));
          error url job

           (* Data has moved. The best way to do this properly is to 
              reschedule the job conts as new requests *)
        and retry_data hlink =
          try
        job.stop();
        let newr = Www.make hlink in
        newr.www_error <- wr.www_error;
        newr.www_logging <- wr.www_logging;
        List.iter (fun (did,(cont,prog)) ->
          add_request newr did cont prog)
          job.conts
          with (* can't proceed with retry *)
        _ -> error url job
            in
       (* Okay, go for the retrieval now *)
        try 
          match Retrieve.f wr retry_data
               {document_process = handle_data;
                document_finish = (fun f -> if f then error url job)}
              with
        Retrieve.Started _ -> ()
          | Retrieve.InUse ->
          (* somebody else has started a request bypassing the
             scheduler, dammit. Our only hope is that he's going
             to set the cache properly, so we can reschedule 
             ourself and try later *)
          job.stop();
          List.iter (fun (did,(cont,prog)) -> 
            add_request wr did cont prog)
            job.conts
        with
          Invalid_request(w,msg) -> (* retrieve failed *)
            J.error_msg (w,msg);
        error url job
      end 



  (*
   * And now, various utilities
   *)

  (* remove pending requests whose referer is did *)
  let stop did =
    (* For all queues, for all request in the queue, if the request matches
       the predicate, it is removed from the queue. *)
    queues := 
       List.map (fun q ->
     let newq = Queue.create () in
     Queue.iter (function
       | (wr, didr, cont, progress) when did = didr -> ()
       | r -> Queue.add r newq)
       q;
     newq)
     !queues;

    (* If the request is active, remove the particular continuation, and if it
       was the only continuation, kill the job
    *)
    let rem = ref [] in (* jobs to kill *)
    Hashtbl.iter 
      (fun url job ->
    try 
      job.conts <- Mlist.except_assoc did job.conts;
      if job.conts = [] then rem := job :: !rem
    with
      Not_found -> ())
      actives;
    (* each stop closes the cnx properly and remove the job from actives *)
    List.iter (fun job -> job.stop()) !rem;
    if !rem <> [] then next_request()

  
  (*
   * Delayed queues
   *)
  type delayed = queue

  let new_delayed = Queue.create

  let is_empty q = 
    try Queue.peek q; false with Queue.Empty -> true

  (* add a new request in the queue *)
  (* Actually, if the document is already in the cache, then process
     the continuation *)
  let add_delayed q wr did cont progress =
    try 
      if skip_cache wr then raise Not_found
      else cont wr.www_url (J.cache_access wr.www_url did)
    with Not_found -> Queue.add (wr,did,cont,progress) q

  (* Put the queue in the list of queues *)
  let flush_delayed q =
    (* Queue.iter (function (_,_,_,prog) -> prog None 0) q;(* create the gauge *) *)
    queues := !queues @ [q];
    next_request()

  (* Flush a particular request from a queue : we do it in place 
     because we don't know if the queue has been put in the list yet
   *)
  let flush_one l url =
    let flushedqueue = Queue.create()
    and restqueue = Queue.create() in
    (* split in two *)
    Queue.iter (function
      | (wr,did,cont,prog) when wr.www_url = url ->
      prog None 0; (* create the gauge *)
      Queue.add (wr,did,cont,prog) flushedqueue
      | r -> Queue.add r restqueue)
      l;
    (* the flushed goes at the beginning *)
    queues := flushedqueue :: !queues;
    (* copy back the remaining in l (MUST BE THE SAME l) *)
    Queue.clear l;
    Queue.iter (fun r -> Queue.add r l) restqueue;
    (* try to process the flushed items *)
    next_request()

end
@


\section{[[./viewers/]]}

\subsection*{[[./viewers/decoders.mli]]}



%-------------------------------------------------------------

<<./viewers/decoders.mli>>=
(* Decoders *)
open Document

<<signature Decoders.insert>>
<<signature Decoders.add>>

@


\subsection*{[[./viewers/decoders.ml]]}


<<function Decoders.gzip>>=
(* Note: we must use the feed interface to read from the old dh,
 * and not read directly from the feed_internal file descriptor, because
 * the feed might implement side effects (such as caching).
 * Since we are reading and writing to the same process, we might get
 * deadlocked if we don't watch writes.
 *)
let gzip dh =
  let (gread, mwrite) = pipe()
  and (mread, gwrite) = pipe()
  in
  Unix.set_close_on_exec mread;
  Unix.set_close_on_exec mwrite;
  
  match Low.fork() with
    0 ->  
      dup2 gread stdin; dup2 gwrite stdout;
      Munix.execvp "gunzip" [| "gunzip"; "-c" |];
      dh (* fake *)
  | n ->  
      close gread; close gwrite;
     (* it is safe to close feed because the son has a copy *)
      let newdh =
       { document_id = dh.document_id;
      document_referer = dh.document_referer;
          document_status = dh.document_status;
      document_headers = rem_contentencoding dh.document_headers;
      document_feed = Feed.of_fd mread;
      document_fragment = dh.document_fragment;
      document_logger = dh.document_logger }
      in
      let buffer = String.create 4096 in
      let rec copy () =
      try
        let n = dh.document_feed.feed_read buffer 0 4096 in
            if n = 0 then (dclose true dh; close mwrite)
            else begin
          dh.document_feed.feed_unschedule();
          Fileevent.add_fileoutput mwrite
        (fun () -> 
          ignore (write mwrite buffer 0 n);
          Fileevent.remove_fileoutput mwrite;
          dh.document_feed.feed_schedule copy)
        end
      with
        Unix_error(e,_,_) -> dclose true dh; close mwrite
      in
      dh.document_feed.feed_schedule copy;
      newdh
@


<<constant Decoders.add>>=
let add = Hashtbl.add decoders
@

<<function Decoders.insert>>=
let insert dh =
(* CERN proxy sets Content-Encoding when return code = 500 ! *)
  if dh.document_status >= 400 then dh else
  try
    Hashtbl.find decoders
       (String.uppercase (contentencoding dh.document_headers)) dh
  with
    Not_found -> dh
  | Unix_error(_,_,_) -> dh
@


%-------------------------------------------------------------

<<./viewers/decoders.ml>>=
open Unix
open Document
open Feed
open Http_headers

<<constant Decoders.decoders>>

<<function Decoders.gzip>>
  

<<toplevel Decoders._1>>

<<constant Decoders.add>>

<<function Decoders.insert>>

@


\subsection*{[[./viewers/embed.mli]]}





%-------------------------------------------------------------

<<./viewers/embed.mli>>=
module EmbeddedScheduler : Scheduler.S with
  type shared_data = Document.document

<<signature Embed.add_viewer>>

<<signature Embed.rem_viewer>>

<<type Embed.embobject>>

<<signature Embed.add>>
<<signature Embed.update>>
@


\subsection*{[[./viewers/embed.ml]]}



<<constant Embed.embedded>>=
(* Remember all current embedded objects by their frame *)
let embedded = (Hashtbl.create 101 : (string, embobject) Hashtbl.t)
@

<<function Embed.add_embed>>=
(* add and notify *)
let add_embed emb = 
  Hashtbl.add embedded (Widget.name emb.embed_frame) emb;
  Frx_synth.send "setembed" emb.embed_frame
@

<<function Embed.when_destroyed>>=
(* when the frame gets destroyed, remove us from the table *)
let when_destroyed w =
  Hashtbl.remove embedded (Widget.name w)
@

<<toplevel Embed._1>>=
let _ =
  Protocol.add_destroy_hook when_destroyed
@

<<function Embed.add>>=
(* Queueing an embed *)
let add ({ embed_hlink = link;
       embed_frame = frame;
       embed_context = embed_ctx;
       embed_map = m;
       embed_alt = alt_txt} as emb) =
  (* Put up the ALT text *)
  List.iter Tk.destroy (Winfo.children frame);
  pack [Label.create_named frame "alt" [Text alt_txt]][];
  (* Check if the type is defined and a viewer available *)
  try
   let given_type = List.assoc "type" embed_ctx#params in
   let ((typ,subtyp), parms) = Lexheaders.media_type given_type in
   try
     let viewer = 
       try Hashtbl.find embedded_viewers (typ,subtyp)
       with Not_found -> Hashtbl.find embedded_viewers (typ, "*")
     in
       EmbeddedScheduler.add_request
       (Www.make link)
       (embed_ctx#base)
       (* the continuation: it will receive the document *)
       (fun url doc ->
     let doc = {
       document_address = doc.document_address;
       document_data = doc.document_data;
       document_info = Http_headers.merge_headers doc.document_info
                        ["Content-Type: " ^ given_type]
       }  in
         (* Destroy the alt window *)
     List.iter Tk.destroy (Winfo.children frame);
     (* Add to our table/notify *)
     add_embed emb;
     viewer parms frame embed_ctx doc)
       (Tk_progress.meter frame)
   with
     Not_found -> (* no viewer for this *)
      let t = 
        I18n.sprintf "Embed Error: no viewer for type %s" given_type in
      pack[Label.create frame [Text t]][]
   | Invalid_request (w,msg) ->
       let t = I18n.sprintf "Embed Error: %s\n(%s)"
                (Url.string_of w.www_url) msg in
       pack [Message.create frame [Text t]][]
   | Invalid_link err ->
       let t = I18n.sprintf "Embed Error: invalid link" in
       pack [Message.create frame [Text t ]][]
  with
     Not_found -> (* not type given, we have to retrieve to know *)
       (* Firing the request *)
       try
     EmbeddedScheduler.add_request
     (Www.make link)
     (embed_ctx#base)
     (* the continuation: it will receive the document *)
     (* In general, we don't know the type before we get the document *)
     (fun url doc -> embedded_viewer frame embed_ctx doc)
     (Tk_progress.meter frame)
       with
     Invalid_request (w,msg) ->
       let t = I18n.sprintf "Embed Error: %s\n(%s)"
                (Url.string_of w.www_url) msg in
       pack [Message.create frame [Text t]][]
       | Invalid_link err ->
       let t = I18n.sprintf "Embed Error: invalid link" in
       pack [Message.create frame [Text t ]][]
@

<<function Embed.update>>=
let update frame embed_ctx doc notchanged =
  try
    (* find the date of previous download, (or last-modified ?) *)
    let date_received = get_header "date" doc.document_info in
    let rewrite_wr wr =
      wr.www_headers <- 
     ("If-Modified-Since: "^date_received) :: wr.www_headers;
      wr.www_headers <- "Pragma: no-cache" :: wr.www_headers;
      wr
    in
    let link = { h_uri = Url.string_of doc.document_address;
         h_context = None;
         h_method = GET;
         h_params = []} in
    (* wrapped viewer : decide if we need to redisplay or not *)
    let smart_viewer stdviewer frame embed_ctx newdoc =
      let newdate = 
    try get_header "date"  newdoc.document_info with Not_found -> "foo"
      in if newdate <> date_received then begin
    List.iter Tk.destroy (Winfo.children frame);
    stdviewer frame embed_ctx newdoc
      end else notchanged()
    in
  (* Check if the type is defined and a viewer available *)
    try
      let given_type = List.assoc "type" embed_ctx#params in
      let ((typ,subtyp), parms) = Lexheaders.media_type given_type in
      try
      let viewer = 
      try Hashtbl.find embedded_viewers (typ,subtyp)
      with Not_found -> Hashtbl.find embedded_viewers (typ, "*")
      in
       EmbeddedScheduler.add_request
       (rewrite_wr (Www.make link))
       (embed_ctx#base)
       (* the continuation: it will receive the document *)
       (fun url doc ->
     let doc = {
       document_address = doc.document_address;
       document_data = doc.document_data;
       document_info = Http_headers.merge_headers doc.document_info
                        ["Content-Type: " ^ given_type]
       }  in
     smart_viewer (viewer parms) frame embed_ctx doc)
       (Tk_progress.meter frame)
      with
      Not_found -> (* no viewer for this *)
      let t = 
            I18n.sprintf "Embed Error: no viewer for type %s" given_type in
      pack[Label.create frame [Text t]][]
      | Invalid_request (w,msg) ->
      let t = I18n.sprintf "Embed Error: %s\n(%s)"
          (Url.string_of w.www_url) msg in
      pack [Message.create frame [Text t]][]
      | Invalid_link err ->
      let t = I18n.sprintf "Embed Error: invalid link" in
      pack [Message.create frame [Text t ]][]
    with
      Not_found -> (* not type given, we have to retrieve to know *)
       (* Firing the request *)
        try
      EmbeddedScheduler.add_request
        (rewrite_wr (Www.make link))
        (embed_ctx#base)
     (* the continuation: it will receive the document *)
     (* In general, we don't know the type before we get the document *)
        (fun url doc -> smart_viewer embedded_viewer frame embed_ctx doc)
        (Tk_progress.meter frame)
        with
      Invalid_request (w,msg) ->
        let t = I18n.sprintf "Embed Error: %s\n(%s)"
        (Url.string_of w.www_url) msg in
        pack [Message.create frame [Text t]][]
        | Invalid_link err ->
        let t = I18n.sprintf "Embed Error: invalid link" in
        pack [Message.create frame [Text t ]][]
  with
    Not_found -> (* Document has no Date: header *)
      notchanged() 
@


%-------------------------------------------------------------

<<./viewers/embed.ml>>=
(* Embedded documents *)
open Tk
open Document
open Www
open Hyper
open Url
open Http_headers

(* Assume any kind of data could be embedded 
 * The normal retrieval, used by the scheduler, makes its own decision
 * about the need to cache the document (basically, it caches html and text)
 * Thus, we want to decide here if we want to cache documents retrieved
 * via Embed.
 *)
module EmbeddedData =
  struct

    type t = document

    let cache_access url referer =
      let did =  {document_url = url; document_stamp = no_stamp} in
      (* look in the cache *)
      Cache.find did

    (* The document is here in the file. Either it's been cached, and
       then we just get its cache value, or we add it to the cache 
       dh is closed; we use only the headers
       NOTE: if we are updating over an old version, fix the cache
     *)
    let load dh referers file =
      Retype.f dh;
      match dh.document_status with
    200 ->
      begin try 
        let doc = Cache.find dh.document_id in
        let this_date = get_header "date" dh.document_headers
        and cache_date = get_header "date" doc.document_info in
        if this_date <> cache_date then raise Not_found
        else doc
      with
        Not_found ->
          let doc = { document_address = dh.document_id.document_url;
                 document_data = FileData (file, true);
                 document_info = dh.document_headers} in
          Cache.add dh.document_id doc;
          Cache.finished dh.document_id;
          doc
      end
      |	304 -> (* return the previous version *)
      begin try 
        Msys.rm file;
        cache_access dh.document_id.document_url (List.hd referers)
      with
        Not_found -> failwith "load"
      end

      |	_ -> failwith "load"

    let error url jobs = 
      !Error.default#f (I18n.sprintf "Can't find embedded document %s" 
                        (Url.string_of url))

    let error_msg (_,_) = ()
  end


(* The embedded data scheduler *)
module EmbeddedScheduler = Scheduler.Make(EmbeddedData)


<<constant Embed.embedded_viewers>>
let add_viewer = Hashtbl.add embedded_viewers 
and rem_viewer = Hashtbl.remove embedded_viewers


<<function Embed.embedded_viewer>>


<<type Embed.embobject>>

<<constant Embed.embedded>>

<<function Embed.add_embed>>

<<function Embed.when_destroyed>>
<<toplevel Embed._1>>

<<function Embed.add>>


<<function Embed.update>>
@


\subsection*{[[./viewers/save.mli]]}

<<signature Save.interactive>>=
val interactive : (string -> unit) -> Document.handle -> unit
@

<<signature Save.transfer>>=
val transfer : Www.request -> Document.handle -> (Unix.file_descr * bool) option -> unit
@

<<signature Save.tofile>>=
val tofile : (string -> unit) -> Document.handle -> string -> string -> unit
@

<<signature Save.document>>=
val document : Document.document_id -> string option -> unit
@

<<signature Save.print_command>>=
val print_command : string ref
@


%-------------------------------------------------------------

<<./viewers/save.mli>>=
<<signature Save.interactive>>
<<signature Save.transfer>>
<<signature Save.tofile>>


<<signature Save.document>>
<<signature Save.print_command>>
@


\subsection*{[[./viewers/save.ml]]}

<<function Save.f>>=
(* unprotected against Sys_error *)
let f cont dh fname endmsg =
  let oc = open_out_bin fname in
  let buffer = String.create 1024
  and red = ref 0 
  and size =   
    try Http_headers.contentlength dh.document_headers
    with Not_found -> 40000 (* duh *)
  in
  dh.document_feed.feed_schedule
    (fun () ->
      try
    let n = dh.document_feed.feed_read buffer 0 1024 in
    if n = 0 then begin
      dclose true dh;
      close_out oc;
      Document.end_log dh endmsg;
      cont fname (* cont is responsible for deleting fname *)
    end
    else begin
          output oc buffer 0 n;
         red := !red + n;
      Document.progress_log dh (!red * 100 / size)
    end
      with
    Unix_error(_,_,_) | Sys_error _ ->
      dclose true dh;
      close_out oc;
      Document.destroy_log dh false;
      Msys.rm fname;
      !Error.default#f (I18n.sprintf
                 "Error during retrieval of %s" 
                 (Url.string_of dh.document_id.document_url))
        )
@

<<function Save.tofile>>=
(* Used for external viewers in batch mode. Deprecated *)
let tofile cont dh fname endmsg =
  try
    f cont dh fname endmsg
  with Sys_error msg -> 
    dclose true dh;
    Document.destroy_log dh false;
    !Error.default#f (I18n.sprintf "Cannot save to %s\n(%s)" fname msg)
@

<<function Save.interactive>>=
let rec interactive cont dh =
  (* The initial content of the requester *)
  let url = Url.string_of dh.document_id.document_url in
  let path = 
    match dh.document_id.document_url.path with Some p -> p | None -> "" in

  Fileselect.f (I18n.sprintf "Save document")
    (function 
    [] ->
      (* by closing dh, we might break the cache *)
          dclose true dh
      | [fname] ->
      begin try 
        let endmsg = (I18n.sprintf "URL %s\nsaved as %s" url fname) in
        f cont dh fname endmsg;
        Document.add_log dh 
              (I18n.sprintf "Saving %s\nto %s" url fname)
          (* channel is not closed ! *)
              (fun () -> Msys.rm fname)
      with Sys_error msg -> 
        !Error.default#f (I18n.sprintf "Cannot save to %s\n(%s)" fname msg);
        interactive cont dh
      end
      | l -> raise (Failure "multiple selection"))
    "*"
    (Filename.basename path)
    false false    
@

<<function Save.transfer>>=
let transfer wr dh dest =
  wr.www_logging (I18n.sprintf "Saving...");
  match dest with
    None -> interactive (fun s -> wr.www_logging "") dh
  | Some (fd, flag) ->
      (* if flag we should output the headers as well *)
      if flag then begin
    List.iter (fun h -> 
      Munix.write_string fd h; Munix.write_string fd "\n")
      (List.rev dh.document_headers);
    Munix.write_string fd "\n";
      end;
      let buffer = String.create 1024 in
      dh.document_feed.feed_schedule
       (fun () ->
      try
        let n = dh.document_feed.feed_read buffer 0 1024 in
        if n = 0 then begin
          dclose true dh;
          close fd;
        end
     else ignore (write fd buffer 0 n)
    with
     Unix_error(_,_,_) | Sys_error _ ->
       dclose true dh;
       close fd;
       !Error.default#f (I18n.sprintf
           "Error during retrieval of %s" 
          (Url.string_of dh.document_id.document_url))
       )
@

<<function Save.save_from_string>>=
let save_from_string url s f =
  try
   let oc = open_out_bin f in
     begin try
      output_string oc s;
      !Error.default#ok (I18n.sprintf "Document %s\nsaved in\n%s"
                         (Url.string_of url) f)
     with
       Sys_error e ->
        !Error.default#f (I18n.sprintf "Cannot save to %s\n(%s)" f e)
     end;
     close_out oc
  with
    Sys_error e ->
        !Error.default#f (I18n.sprintf "Cannot save to %s\n(%s)" f e)
@

<<function Save.copy_file>>=
let copy_file url src dst =
  try
    let ic = open_in_bin src
    and oc = open_out_bin dst 
    and buf = String.create 2048 in
    let rec copy () =
      let n = input ic buf 0 2048 in
      if n <> 0 then begin output oc buf 0 n; copy() end
    in
    begin try 
     copy();
     !Error.default#ok (I18n.sprintf "Document %s\nsaved in\n%s"
                        (Url.string_of url) dst)
    with 
     Sys_error e ->
      !Error.default#f (I18n.sprintf "Cannot save to %s\n(%s)" dst e)
    end;
    close_in ic; 
    close_out oc
  with
    Sys_error e ->
      !Error.default#f (I18n.sprintf "Cannot save to %s\n(%s)" dst e)
@

<<function Save.pipe_from_string>>=
(* Cmd can be composite. We add the URL at the end *)
let pipe_from_string url data cmd =
  let urls = Url.string_of url in
  try
    (* we have to open a pipe and write to it *)
    let fd_in, fd_out = pipe() in
    let len = String.length data and pos = ref 0 in
    (* now fork the command *)
    match Low.fork() with
      0 ->
    dup2 fd_in stdin; close fd_in; close fd_out;
    ignore (Munix.system_eval cmd ["URL", urls] false);
    exit 0
    | n ->
    close fd_in;
       Fileevent.add_fileoutput fd_out (fun () ->
      if !pos < len then begin
        let n = min 512 (len - !pos) in
        try
          let w = write fd_out data !pos n in
          pos := !pos + w
        with
          Unix_error (_,_,_) -> (* can't write *)
        Fileevent.remove_fileoutput fd_out;
        close fd_out;
        !Error.default#f (I18n.sprintf "Error during |%s in %s" cmd urls)
      end else begin (* we're done *)
        Fileevent.remove_fileoutput fd_out;
        close fd_out
      end)
  with
  | Unix_error(_,_,_) -> (* pipe failed, fork failed *)
      !Error.default#f (I18n.sprintf "Can't execute command %s for %s" cmd urls)
@

<<function Save.pipe_from_file>>=
let pipe_from_file url f cmd =
  let urls = Url.string_of url in
  try
    (* just open the file and read from it *)
    match Low.fork() with
      0 ->
    let fd = openfile f [O_RDONLY] 0 in
    dup2 fd stdin; close fd;
    ignore (Munix.system_eval cmd ["URL", urls] false);
    exit 0
    | n ->
    ()
  with
  | Unix_error(_,_,_) -> (* pipe failed, fork failed *)
      !Error.default#f (I18n.sprintf "Can't execute command %s for %s" cmd urls)
@

<<function Save.document>>=
let document did arg =
  let open_selection_box act =
    Fileselect.f (I18n.sprintf "Save or pipe to file")
      (function [] -> ()
             | [s] -> act s
          | l -> raise (Failure "multiple selection"))
      "*" (* should be better *)
      (Filename.basename (Url.string_of did.document_url))
      false
      true
  in
  let proceed f = match arg with
    None -> open_selection_box f
  | Some s -> f s
  in
  try
    match Cache.find did with
      {document_data = MemoryData buf} ->
        proceed
      (fun s ->
        if String.length s <> 0 && s.[0] == '|' then
          pipe_from_string did.document_url (Ebuffer.get buf)
        (String.sub s 1 (String.length s - 1))
        else
          save_from_string did.document_url (Ebuffer.get buf) s)
      
    |  {document_data = FileData (f, _)} ->
        proceed 
      (fun s ->
        if String.length s <> 0 && s.[0] == '|' then
          pipe_from_file did.document_url f 
        (String.sub s 1 (String.length s - 1))
        else
          copy_file did.document_url f s)
  with
    Not_found ->
      !Error.default#f ("Document is not in cache.")
@

<<constant Save.print_command>>=
let print_command = ref ""
@


%-------------------------------------------------------------

<<./viewers/save.ml>>=
open Lexing
open Unix
open Document
open Url
open Www
open Feed

(* Save to file fname, and apply continuation cont to this file *)
<<function Save.f>>

<<function Save.tofile>>

<<function Save.interactive>>


<<function Save.transfer>>

<<function Save.save_from_string>>

<<function Save.copy_file>>


<<function Save.pipe_from_string>>


<<function Save.pipe_from_file>>

<<function Save.document>>
    
<<constant Save.print_command>>
@


\subsection*{[[./viewers/viewers.mli]]}



%-------------------------------------------------------------

<<./viewers/viewers.mli>>=
open Www
open Document
open Http_headers

<<type Viewers.vparams>>
<<type Viewers.frame_targets>>

<<signature Viewers.frame_adopt>>
<<signature Viewers.frame_fugue>>

<<type Viewers.hyper_func>>

(* list of additionnal parameters for the viewer, according to its
   activation point *)
  
(* The context given to a viewer *)
(* Standard hyper functions are: "goto", "save", "gotonew" *)
class  virtual context : (Document.document_id * vparams) -> object ('a)
  method base : Document.document_id
  method params : vparams
  method goto : Hyper.link -> unit
  method gotonew : Hyper.link -> unit
  method save : Hyper.link -> unit
  method invoke : string -> Hyper.link -> unit    
  method virtual log : string -> unit
  method add_nav : string * hyper_func -> unit
  (*-*)
  method for_embed : vparams -> frame_targets -> 'a
  method in_embed : Document.document_id -> 'a
  method hyper_funs : (string * hyper_func) list

  (* pad: this is just because of some bugs in camlp4o *)
  method with_target: frame_targets -> 'a
  method with_viewer_params: (string * string) list -> 'a

end

class  virtual display_info : (unit) -> object ('a)
  method virtual di_widget : Widget.widget
  method virtual di_abort : unit		(* stop display *)
  method virtual di_destroy : unit		(* die *)
  method virtual di_fragment : string option -> unit	(* for # URIs *)
  method virtual di_redisplay : unit		(* redisplay *)
  method virtual di_title : string		(* some visible title *)
  method virtual di_source : unit 	        (* source viewer *)
  method virtual di_load_images : unit	        (* load images *)
  method virtual di_update : unit
  method di_last_used : int
  method di_touch : unit
end


class trivial_display : (Widget.widget * Url.t) -> object
  method di_abort : unit
  method di_destroy : unit
  method di_fragment : string option -> unit
  method di_last_used : int
  method di_load_images : unit
  method di_redisplay : unit
  method di_source : unit
  method di_title : string
  method di_touch : unit
  method di_widget : Widget.widget
  method di_update : unit
end


<<signature Viewers.di_compare>>

<<type Viewers.t>>

<<signature Viewers.add_viewer>>

<<signature Viewers.add_builtin>>

<<signature Viewers.rem_viewer>>

<<signature Viewers.view>>

<<signature Viewers.reset>>
@


\subsection*{[[./viewers/viewers.ml]]}


<<function Viewers.frame_adopt>>=
let frame_adopt w targets = 
  List.map (function 
    | "_self",_ -> "_self", w
    | "_parent", _ -> "_parent", Winfo.parent w
    | s, f -> s, f)
    targets
@

<<function Viewers.frame_fugue>>=
let frame_fugue targets =
  let rec ff accu = function
      [] -> accu
    | ("_self", _) :: l -> ff accu l
    | ("_parent", _) :: l -> ff accu l
    | p :: l -> ff (p::accu) l
  in
  ff [] targets
@

<<function Viewers.di_compare>>=
let di_compare di di' = di#di_last_used > di'#di_last_used
@

<<function Viewers.metamail>>=
(* Metamail options
   -b : not an RFC822 message
   -z : delete when finished 
   -x : not on a tty 
 *)
let metamail ctype file =
  ignore (Munix.system "metamail -b -z -x -c" [ctype; file] true)
@

<<function Viewers.extern_batch>>=
(* Batch version: we transfer everything and then run metamail *)
let extern_batch dh ctype = 
  let outfile = Msys.mktemp "mmm" in
  Document.add_log dh (
    I18n.sprintf "Saving %s\nfor external display with MIME type %s"
          (Url.string_of dh.document_id.document_url) ctype)
    (fun () -> Msys.rm outfile);
  let endmsg =
    I18n.sprintf "Running metamail with MIME media-type: %s" ctype in
    Save.tofile (metamail ctype) (Decoders.insert dh) outfile endmsg
@

<<function Viewers.extern>>=
(* "interactive" version: 
 *    send data to metamail as it arrives, but allow abort
 * NOTE: There are sometimes weird errors when the child dumps core
 *     	 between fork/exec with no apparent reason (on SunOS4.1 only)
 *)
let extern dh ctype =
  let (pin, pout) = pipe() in
  (* children must not keep pout open *)
  Unix.set_close_on_exec pout;
  match Low.fork() with
    0 ->
      dup2 pin stdin; close pin;
      Munix.execvp "metamail" [| "metamail"; "-b"; "-x"; "-c"; ctype |]
  | pid ->  
      close pin;
      let kill () = 
         try Unix.kill pid 2
        with Unix_error (e,_,_) ->
         Log.f (sprintf "Can't kill child (%s)" (Unix.error_message e))
             in
      let url = Url.string_of dh.document_id.document_url in
      Document.add_log dh (
    I18n.sprintf "Retrieving %s\nfor external display with MIME type %s"
             url ctype)
       kill;

      let red = ref 0 
      and size =   
       try Http_headers.contentlength dh.document_headers 
       with Not_found -> 40000 (* duh *)
      and buffer = String.create 4096 in
      dh.document_feed.feed_schedule
       (fun () ->
      try
       let n = dh.document_feed.feed_read buffer 0 4096 in
       if n = 0 then begin
           dclose true dh;
           close pout;
           Document.end_log dh (I18n.sprintf "End of transmission")
           end
       else begin
         ignore (write pout buffer 0 n);
         red := !red + n;
         Document.progress_log dh (!red * 100 / size)
         end
      with
       Unix_error(e,_,_) ->
         Log.f (sprintf "Error writing to viewer (%s)"
                    (Unix.error_message e));
         dclose true dh;
         kill();
         close pout;
         Document.destroy_log dh false;
         !Error.default#f (I18n.sprintf "Error during retrieval of %s" url)
       )
@







%-------------------------------------------------------------

<<./viewers/viewers.ml>>=
(*
 * Multimedia
 *)
open Printf
open Unix
open Lexing
open Url
open Http_headers
open Document
open Feed
open Www
open Hyper

(* The context given to a viewer *)
<<type Viewers.vparams>>
<<type Viewers.frame_targets>>

<<function Viewers.frame_adopt>>

<<function Viewers.frame_fugue>>

<<type Viewers.hyper_func>>

class  virtual context ((did : Document.document_id), 
               (v : vparams)) =
 object (self : 'a)

  val base = did
  method base = base

  val viewer_params = v
  method params = viewer_params

  val mutable (*private*) funs = ([] : (string * hyper_func ) list)
  method hyper_funs = funs

  val targets = []

  method goto hlink = self#invoke "goto" hlink
  method gotonew hlink = self#invoke "gotonew" hlink
  method save hlink = self#invoke "save" hlink
  method invoke name hlink =
    try (List.assoc name funs).hyper_func targets hlink
    with Not_found -> ()

  method add_nav (fname, hf) =
    funs <- (fname, hf) :: funs

  method with_target x = {< targets = x >}
  method with_viewer_params x = {< viewer_params = x >}

  (* apply this on a copy ! *)
  method for_embed (vparams: vparams) (newtargets : frame_targets) : 'a =
    (* for debug *)
    let _oldtargetsTODO = targets in
    let res = 
      match newtargets with 
      | [] -> 
          (* keep exactly the same environment *)
          targets
      | l -> 
          (* assume I'm given new _self and _parent *)
      l @ frame_fugue targets 
    in
    (* old:
       {< 
       targets = res;
       viewer_params = vparams;       
       >}
    *)
    (* pad: the code below works perfectly but when I want to do 
     * make dotall I get an error because ocamldoc -pp camlp4o (which
     * I need for certain files) has a type error on this file
     * at this line. Indeed when run
     * 
     *   ocamldoc -pp camlp4o -I ../commons -I ../globals -I ../www -I ../http -I ../protocols -I ../retrieve -I /home/pad/packages/Linux/stow/ocaml-3.12/lib/ocaml/camltk viewers.ml
     * 
     * manually camlp4 geneate a weird thing for the code below.
     * so I just introduced those ugly with_target and with_viewer
     * to avoid the pb. UGLY
     * 
     *)
     (self#with_target res)#with_viewer_params vparams

  method in_embed did =
    {< base = did >}

  method virtual log : string -> unit
end



(* The object created/returned by a viewer *)
class  virtual display_info () =
 object (_self : 'a)
  method virtual di_widget : Widget.widget
  method virtual di_abort : unit		(* stop display *)
  method virtual di_destroy : unit		(* die *)
  method virtual di_fragment : string option -> unit	(* for # URIs *)
  method virtual di_redisplay : unit		(* redisplay *)
  method virtual di_title : string		(* some visible title *)
  method virtual di_source : unit 	        (* source viewer *)
  method virtual di_load_images : unit	        (* load images *)
  method virtual di_update : unit	        (* update embedded objects *)
  val mutable di_last_used = !Low.global_time
  method di_last_used = di_last_used
  method di_touch = di_last_used <- !Low.global_time
end

class trivial_display (w, url) =
 object
  inherit display_info ()
  (* val w = w *)
  (* val url = url *)
  method di_widget = w
  method di_abort = ()
  method di_destroy = if Winfo.exists w then Tk.destroy w
  method di_fragment f = ()
  method di_redisplay = ()
  method di_title = Url.string_of url
  method di_source = ()
  method di_load_images = ()
  method di_update = ()
end

<<function Viewers.di_compare>>

(* 
 * The default external viewer
 *)

<<function Viewers.metamail>>

<<function Viewers.extern_batch>>

<<function Viewers.extern>>

(*
 * Viewer control
 * Specify on the base of MIME type if we want to
 *   - use an internal displayer (assumed to exist)
 *   - use an external displayer (metamail or other)
 *   - save to file
 *)

(* Table of viewers, according to media-type (MIME)
 * Actually, this is only for internal viewers, since the rest
 * will be passed to metamail.
 *)

<<type Viewers.t>>

<<type Viewers.spec>>

<<constant Viewers.viewers>>

(* That's for internal viewers only *)
let add_viewer ctype viewer =
  Hashtbl.add viewers ctype (Internal viewer)

let rem_viewer ctype =
  Hashtbl.remove viewers ctype

let rec unknown frame ctx dh =
  match Frx_dialog.f frame (Mstring.gensym "error")
         (I18n.sprintf "MMM Warning")
     (I18n.sprintf
       "No MIME type given for the document\n%s"
       (Url.string_of dh.document_id.document_url))
         (Tk.Predefined "question") 0
     [I18n.sprintf "Retry with type";
      I18n.sprintf "Save to file";
      I18n.sprintf "Abort"] with
   0 ->
    let v = Textvariable.create_temporary frame in
     Textvariable.set v "text/html";
     if Frx_req.open_simple_synchronous (I18n.sprintf "MIME type") v then
       let ctype = Textvariable.get v in
        dh.document_headers <- 
         ("Content-Type: " ^ ctype) :: dh.document_headers;
        view frame ctx dh
     else begin
       Save.interactive (fun _ -> ()) dh;
       None
     end
 | 1 ->
      Save.interactive (fun _ -> ()) dh; None
 | 2 -> dclose true dh; None
 | _ -> assert false (* property of dialogs *)

and interactive frame ctx dh ctype =
  match Frx_dialog.f frame (Mstring.gensym "error")
         (I18n.sprintf "MMM Viewers")
     (I18n.sprintf
       "No behavior specified for MIME type\n%s\ngiven for the document\n%s"
        ctype
        (Url.string_of dh.document_id.document_url))
         (Tk.Predefined "question") 0
     [I18n.sprintf "Retry with another type";
      I18n.sprintf "Display with metamail";
      I18n.sprintf "Save to file";
      I18n.sprintf "Abort"] with
  | 0 ->
      let v = Textvariable.create_temporary frame in
      Textvariable.set v "text/html";
      if Frx_req.open_simple_synchronous (I18n.sprintf "MIME type") v then
        let ctype = Textvariable.get v in
       dh.document_headers <- 
          ("Content-Type: " ^ ctype) :: dh.document_headers;
       view frame ctx dh
      else begin
        Save.interactive (fun _ -> ()) dh;
        None
      end
  | 1 -> extern (Decoders.insert dh) ctype; None
  | 2 -> Save.interactive (fun _ -> ()) dh; None
  | 3 -> dclose true dh; None
  | _ -> assert false (* property of dialogs *)

(* the meat *)
and view frame ctx dh =
  try 
    let ctype = contenttype dh.document_headers in
    let (typ,sub),pars = Lexheaders.media_type ctype in
    try (* Get the viewer *)
      let viewer =
  try Hashtbl.find viewers (typ,sub)
    with
      Not_found -> Hashtbl.find viewers (typ,"*")
      in
      match viewer with
      |	Internal viewer ->
      ctx#log (I18n.sprintf "Displaying...");
         viewer pars frame ctx (Decoders.insert dh)
      |	External ->
      ctx#log (I18n.sprintf "Displaying externally");
      extern (Decoders.insert dh) (sprintf "%s/%s" typ sub);
      None
      |	Interactive ->
      interactive frame ctx dh ctype
      |	Save ->
      Save.interactive (fun _ -> ()) dh;
      None
    with
    | Failure "too late" -> (* custom for our internal viewers *)
    dclose true dh;
    Document.destroy_log dh false;
    None
    | Not_found -> 
        (* we don't know how to handle this *)
    ctx#log (I18n.sprintf "Displaying externally");
    interactive frame ctx dh ctype
  with 
  | Invalid_HTTP_header e ->
      ctx#log (I18n.sprintf "Malformed type: %s" e);
      unknown frame ctx dh
  | Not_found -> 
    (* Content-type was not defined in the headers *)
    (* and could not be computed from url *)
    unknown frame ctx dh


<<constant Viewers.builtin_viewers>>
<<function Viewers.add_builtin>>

<<function Viewers.reset>>
    
@


\subsection*{[[./viewers/plain.ml]]}



%-------------------------------------------------------------

<<./viewers/plain.ml>>=
open Tk
open Unix
open Frx_text
open Document
open Viewers
open Feed

class plain ((top : Widget.widget),
         (ctx : Viewers.context),
         (dh : Document.handle)) =
 object (self)
  inherit Viewers.display_info () as di  (* gives us basic features *)
  inherit Htmlw.viewer_globs (ctx,dh)

  val frame = if not (Winfo.exists top) then failwith "too late"
    else Frame.create top [Class "Plain"]
  method frame = frame
  
  val mutable pending = true

  (* to redisplay, we have to destroy all widgets, then restart, except
     that we don't use the feed, but rather the cache *)
  method redisplay =
    try
      dh <- Decoders.insert (Cache.renew_handle dh);
      List.iter destroy (Winfo.children frame);
      self#init
    with
      Not_found ->
    Error.default#f (I18n.sprintf "Document not in cache anymore")

  (* [finish abort?] *)
  val mutable (*private*) terminated = false
  method finish abort =
    if not terminated then begin
      terminated <- true;
      self#ctx#log (if abort then "Aborted" else "");
      dclose true dh;
    end

  val mutable (*private*) tw = Widget.default_toplevel

  (* progress report *)
  val mutable set_progress = Progress.no_meter
  method set_progress = set_progress

  method add_text s =
    if s = "" then pending <- false else
    if Winfo.exists tw then begin
      Text.configure tw [State Normal];
      Text.insert tw textEnd s [];
      Text.configure tw [State Disabled]
    end

  method init =
    let hgbas, progf = Htmlw.progress_report frame ctx in
    set_progress <- progf;
    pack [hgbas] [Side Side_Bottom; Fill Fill_X];
    let (headgroup,_,_,_,_) = 
      Htmlw.html_head_ui dh.document_headers (fun () -> ()) (ref false)
       frame ctx in 
    pack [headgroup][Side Side_Top; Fill Fill_X];
    (* Scrollable text widget *)
    let hgroup = Frame.create_named frame "textw" [Class "Plain"]
    in
    let ftext, text = 
      Frx_text.new_scrollable_text hgroup [Wrap WrapWord; State Disabled] true 
    in
    (* Tk4.0pl3 fix, + avoid cb to scrollbar *)
    Text.configure text [TakeFocus true; InsertOffTime 0];
    Frx_text.addsearch text;
    (* IN THIS ORDER -- RESIZING *)
    pack [ftext][Side Side_Left; Fill Fill_Both; Expand true];
    pack [hgroup][Fill Fill_Both; Expand true];

    (* pick up the fixed font *)
    let attrs_fixed = Styles.get_font "fixed" in
    let attrs_default = Styles.get_font "default" in
    let fd = 
      Fonts.merge (Fonts.merge !Fonts.default attrs_default) attrs_fixed in
    let (_, opts) = Fonts.compute_tag fd in
    Text.configure text opts;
    tw <- text;

    let buffer = String.create 2048
    and red = ref 0
    and size = 
      try Some (Http_headers.contentlength dh.document_headers)
      with Not_found -> None (* duh *) 
    in

    let lastwascr = ref false in
    dh.document_feed.feed_schedule
      (fun () ->
     try let n = dh.document_feed.feed_read buffer 0 2048 in
       if n = 0 then begin
         if !lastwascr then self#add_text "\n";
         self#add_text ""; (* special case to indicate end *)
         self#set_progress (Some !red) !red;
         self#finish false
         end
       else begin
         red := !red + n;
         self#set_progress size !red;
         let s,flag = Mstring.norm_crlf !lastwascr buffer 0 n in
         lastwascr := flag;
         self#add_text s
       end
     with
       Unix_error(_,_,_) ->
         self#set_progress size (-1);
         self#finish true
       );

  method di_widget = frame
  method di_abort = self#finish true
  method di_destroy = if Winfo.exists frame then destroy frame
  method di_redisplay = self#redisplay
  method di_title =
    Url.string_of dh.document_id.document_url
  method di_source = ()
  method di_load_images = ()
  method di_fragment f = ()
  method di_update = ()
end

<<function Plain.display_plain>>

<<toplevel Plain._1>>
@


\section{[[./display/]]}

\subsection*{[[./display/attrs.mli]]}

<<signature Attrs.color_mappings>>=
val color_mappings : (string, string) Hashtbl.t
@

<<signature Attrs.html_color>>=
val html_color : string -> string
@

<<signature Attrs.circle_data>>=
val circle_data : string
@

<<signature Attrs.disc_data>>=
val disc_data : string
@

<<signature Attrs.square_data>>=
val square_data : string
@

<<signature Attrs.bullet_table>>=
val bullet_table : (string, Tk.options) Hashtbl.t
@

<<signature Attrs.init>>=
val init : string -> unit
@


%-------------------------------------------------------------

<<./display/attrs.mli>>=
module TagSet : Set.S with type elt = string

class tags :
  Widget.widget ->
  object
    val mutable configured : TagSet.t
    val mutable decorations : (Tk.textTag * Tk.textIndex * Tk.textIndex) list
    val mutable onhold : (TagSet.elt * Tk.options list) list
    val wid : Widget.widget
    method add : Tk.textTag * Tk.textIndex * Tk.textIndex -> unit
    method change : TagSet.elt -> Tk.options list -> unit
    method define : TagSet.elt -> Tk.options list -> unit
    method flush : unit
  end
module LocMap :
  sig
    type key = Tk.index
    type 'a t
    val empty : 'a t
    val add : key * key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val find_interval : key -> 'a t -> key * key
  end
class anchortags :
  Widget.widget ->
  object
    val mutable anchor_table : Hyper.link LocMap.t
    val mutable configured : TagSet.t
    val mutable decorations : (Tk.textTag * Tk.textIndex * Tk.textIndex) list
    val mutable mappings : (Tk.textIndex * Tk.textIndex * Hyper.link) list
    val mutable onhold : (TagSet.elt * Tk.options list) list
    val wid : Widget.widget
    method add : Tk.textTag * Tk.textIndex * Tk.textIndex -> unit
    method add_anchor : Tk.textIndex -> Tk.textIndex -> Hyper.link -> unit
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method change : TagSet.elt -> Tk.options list -> unit
    method define : TagSet.elt -> Tk.options list -> unit
    method flush : unit
    method getlink : Tk.eventInfo -> Hyper.link
    method getrange : LocMap.key -> LocMap.key * LocMap.key
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end
class virtual ['a] nested :
  < add : string * Tk.textIndex * Tk.textIndex -> 'b;
    define : string -> Tk.options list -> 'c; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> 'a -> unit
    method virtual pop_convert : 'a -> unit
    method push : Tk.textIndex -> 'a -> unit
    method virtual push_convert : 'a -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end
class align :
  < add : string * Tk.textIndex * Tk.textIndex -> 'a;
    define : string -> Tk.options list -> 'b; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> string -> unit
    method pop_convert : string -> unit
    method push : Tk.textIndex -> string -> unit
    method push_convert : string -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end
class margin :
  < add : string * Tk.textIndex * Tk.textIndex -> 'a;
    define : string -> Tk.options list -> 'b; .. > ->
  object
    val mutable current : int
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> int -> unit
    method pop_convert : int -> unit
    method push : Tk.textIndex -> int -> unit
    method push_convert : int -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end
class font :
  < add : string * Tk.textIndex * Tk.textIndex -> 'a;
    define : string -> Tk.options list -> 'b; .. > ->
  object
    val mutable basefont : Fonts.fontDesc
    val mutable font_stack : Fonts.fontDesc list
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> Fonts.fontAttrs -> unit
    method pop_all : Tk.textIndex -> unit
    method pop_convert : Fonts.fontAttrs -> unit
    method push : Tk.textIndex -> Fonts.fontAttrs -> unit
    method push_convert : Fonts.fontAttrs -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
    method set_base : Tk.textIndex -> int -> unit
  end
<<signature Attrs.color_mappings>>
<<signature Attrs.html_color>>
class fgcolor :
  < add : string * Tk.textIndex * Tk.textIndex -> 'a;
    define : string -> Tk.options list -> 'b; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> string -> unit
    method pop_convert : string -> unit
    method push : Tk.textIndex -> string -> unit
    method push_convert : string -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end
class bgcolor :
  < add : string * Tk.textIndex * Tk.textIndex -> 'a;
    define : string -> Tk.options list -> 'b; .. > ->
  object
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> string -> unit
    method pop_convert : string -> unit
    method push : Tk.textIndex -> string -> unit
    method push_convert : string -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end
class offset :
  < add : string * Tk.textIndex * Tk.textIndex -> 'a;
    define : string -> Tk.options list -> 'b; .. > ->
  object
    val mutable cur_offset : int
    val mutable last_change : Tk.textIndex
    val mutable stack : string list
    method pop : Tk.textIndex -> int -> unit
    method pop_convert : int -> unit
    method push : Tk.textIndex -> int -> unit
    method push_convert : int -> string * Tk.options list
    method put : Tk.textIndex -> string -> unit
  end
class misc :
  < add : 'a * Tk.textIndex * Tk.textIndex -> unit; define : 'a -> 'b -> 'c;
    .. > *
  'a * 'b ->
  object
    val mutable start_pos : Tk.textIndex
    val tagname : 'a
    method pop : Tk.textIndex -> unit
    method push : Tk.textIndex -> unit
  end
class spacing :
  < add : string * Tk.textIndex * Tk.textIndex -> 'a;
    define : string -> Tk.options list -> 'b; .. > ->
  object
    method pop : Tk.textIndex -> int -> unit
    method push : Tk.textIndex -> int -> unit
  end

<<signature Attrs.circle_data>>
<<signature Attrs.disc_data>>
<<signature Attrs.square_data>>
<<signature Attrs.bullet_table>>
<<signature Attrs.init>>
@


\subsection*{[[./display/attrs.ml]]}

<<constant Attrs.color_mappings>>=
(* Special mapping of pre-defined HTML3.2 colors *)
let color_mappings = Hashtbl.create 37
@

<<toplevel Attrs._1>>=
let _ = List.iter (fun (name, value) -> Hashtbl.add color_mappings name value)
  [ "black",   "#000000";
    "silver",  "#c0c0c0";
    "gray",    "#808080";
    "white",   "#ffffff";
    "maroon",  "#800000";
    "red",     "#ff0000";
    "purple",  "#800080";
    "fuchsia", "#ff00ff";
    "green",   "#008000";
    "lime",    "#00ff00";
    "olive",   "#808000";
    "yellow",  "#ffff00";
    "navy",    "#000080";
    "blue",    "#0000ff";
    "teal",    "#008080";
    "aqua",    "#00ffff" ]
@

<<function Attrs.html_color>>=
let html_color s =
  try Hashtbl.find color_mappings (String.lowercase s)
  with Not_found -> s
@

<<constant Attrs.circle_data>>=
(* Bullet images *)
let circle_data = 
"#define circle_width 9
#define circle_height 9
static unsigned char circle_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x44, 0x00, 0x44, 0x00, 0x44, 0x00,
   0x38, 0x00, 0x00, 0x00, 0x00, 0x00};"
@

<<constant Attrs.disc_data>>=
let disc_data =
"#define disc_width 9
#define disc_height 9
static unsigned char disc_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x38, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00,
   0x38, 0x00, 0x00, 0x00, 0x00, 0x00};"
@

<<constant Attrs.square_data>>=
let square_data = 
"#define square_width 9
#define square_height 9
static unsigned char square_bits[] = {
   0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00, 0x7c, 0x00,
   0x7c, 0x00, 0x00, 0x00, 0x00, 0x00};"
@

<<constant Attrs.bullet_table>>=
let bullet_table = Hashtbl.create 11
@

<<function Attrs.init>>=
let init bg =
  let _bgTODO = Background (NamedColor bg) in
  Hashtbl.add bullet_table
     "circle" (ImageBitmap(Imagebitmap.create [Data circle_data]));
  Hashtbl.add bullet_table
     "disc" (ImageBitmap(Imagebitmap.create [Data disc_data]));
  Hashtbl.add bullet_table
     "square" (ImageBitmap(Imagebitmap.create [Data square_data]))
@


%-------------------------------------------------------------

<<./display/attrs.ml>>=
open Common

(* Utilities for tags and attributes *)

open Printf
open Protocol
open Tk
open Frx_text
open Fonts

open Htmlfmt

(* Delayed and shared configuration of tags *)

module TagSet = Common.StringSet

class tags (thtml) =
 object
  val mutable onhold = []
  val mutable configured = TagSet.empty
  val mutable decorations = []
  val wid = thtml

  (* define a new tag *)
  method define tagname attrs =
    if TagSet.mem tagname configured then ()
    else begin
      onhold <- (tagname,attrs) :: onhold;
      configured <- TagSet.add tagname configured
    end

  (* change a tag value *)
  method change tagname attrs =
    onhold <- (tagname,attrs) :: onhold;
    configured <- TagSet.add tagname configured

  method add deco =
    decorations <- deco :: decorations

  (* flush tag definitions *)
  method flush =
    onhold |> List.rev |> List.iter (fun (t,d) -> 
      try Text.tag_configure wid t d with TkError _ -> ());
    decorations |> List.rev |> List.iter (fun (t,d,e) -> 
      Text.tag_add wid t d e);
    onhold <- [];
    decorations <- []
end

module LocMap = Ibtree.Make(struct
  type t = index
  let compare = compare
  end)

class anchortags (thtml) =
 object (self)
  inherit tags (thtml) as tags
  inherit Htbind.hypertext (thtml)

  val mutable mappings = []
  val mutable anchor_table = LocMap.empty

  method add_anchor s e h =
    tags#add ("anchor", s, e);
    mappings <- (s,e,h) :: mappings

  method flush =
    tags#flush;
    mappings |> List.iter (fun (s,e,h) ->
      let loc1 = Text.index wid s
      and loc2 = Text.index wid e
      in
      anchor_table <- LocMap.add (loc1,loc2) h anchor_table
    );
    mappings <- []

  method getlink ei =
     (* The index of the click position *)
     let i = 
       Text.index thtml (TextIndex (AtXY (ei.ev_MouseX,ei.ev_MouseY), [])) in
     LocMap.find i anchor_table

  method getrange i = LocMap.find_interval i anchor_table

end


(* Conversion of moral attributes to Tk attributes.
 * This virtual class has to be instantiated for each converter.
 * 'a is an logical attribute description (or "delta")
 *)
class  virtual ['a] nested (tagdef) =
 object (self)
  val mutable last_change = TextIndex(LineChar(0,0),[])
  val mutable stack = []
  (* val tagdef = tagdef *)

  method virtual push_convert : 'a -> string * Tk.options list
  method virtual pop_convert : 'a -> unit

  method put current_pos tagname =
   if last_change <> current_pos then begin
     tagdef#add (tagname, last_change, current_pos);
     last_change <- current_pos
   end

  (* Push some new attribute. *)
  method push current_pos desc =
    let tag, attr = self#push_convert desc in
    tagdef#define tag attr;
    begin match stack with
       [] -> 
        (* no current definition, don't issue a put *)
        last_change <- current_pos
     | curtag::l ->
        self#put current_pos curtag
    end;
    stack <- tag :: stack;

(* Doesn't check the nature of desc *)
  method pop current_pos (desc : 'a) =
     self#pop_convert desc;
     match stack with
       [] ->
        last_change <- current_pos
     | c::l ->
    stack <- l;
        self#put current_pos c
end

(* 
 * Alignment attribute is left/right/center
 *)
class align (tagdef) =
 object
  inherit [string] nested tagdef
  method push_convert ad =
    match String.lowercase ad with
     "right" -> "right", [Justify Justify_Right]
       | "center" -> "center", [Justify Justify_Center]
       | _ -> "left", [Justify Justify_Left]
  method pop_convert ad = ()
end

(*
 * Margin attribute is cumulative
 *)
class margin (tagdef) =
 object
  inherit [int] nested tagdef
  val mutable current = 0
  method push_convert ad =
    current <- current + ad;
    sprintf "margin%d" current, 
    [LMargin1 (Pixels current); LMargin2 (Pixels current)]
  method pop_convert ad =
    current <- current - ad
end


(*
 * Font attributes
 *)

class font (tagdef) =
 object (self)
  inherit [fontInfo list] nested tagdef
  val mutable font_stack = []
  val mutable basefont = !Fonts.default
  method push_convert fil = 
    let curfd = match font_stack with
      [] -> basefont
    | x::l -> x in
    let newfd = Fonts.merge curfd fil in
      font_stack <- newfd :: font_stack;
      Fonts.compute_tag newfd

  method pop_convert _ = 
    match font_stack with
      [] -> ()
    | x::l -> font_stack <- l

  (* by changing the base, we should be changing both the current default size 
     and the behaviour of subsequent FONT SIZE tags. The size changes is easy.
     The header styles being defined with an absolute font, they are not 
     affected
     It's logical also to push this as the current font, but the problem
     is that it doesn't work because basefont do not obey nesting rules
     (consider <FONT> <BASEFONT> </FONT> !). We do deal with this situation.
   *)
  method set_base current_pos n =
    basefont <- { basefont with pxlsz= n };
    self#push current_pos [FontIndex n];

  method pop_all current_pos =
    while font_stack <> [] do
      self#pop current_pos []
    done

end


<<constant Attrs.color_mappings>>
<<toplevel Attrs._1>>

<<function Attrs.html_color>>

(*
 * Foreground color
 *)

class fgcolor (tagdef) =
 object
  inherit [string] nested tagdef 
  method push_convert s =
    let colordef = html_color s in
    if Frx_color.check colordef then
      s, [Foreground (NamedColor colordef)]
    else
      s, []
  method pop_convert s = 
    ()
end

(*
 * Background color
 *)

class bgcolor (tagdef) =
 object
  inherit [string] nested tagdef 
  method push_convert s =
    let colordef = html_color s in
    if Frx_color.check colordef then
      s, [Background (NamedColor colordef)]
    else 
      s, []
  method pop_convert s = 
    ()
end

(*
 * Super and sub script.
 * BOGUS: should depend on current font size
 *)
class offset (tagdef) =
 object
  inherit [int] nested tagdef
  val mutable cur_offset = 0
  method push_convert n =
    cur_offset <- cur_offset + n;
    sprintf "offset%d" cur_offset, [Offset (Pixels cur_offset)]
  method pop_convert n =
    cur_offset <- cur_offset - n
end
(* 
 * Other stuff where nesting is not important
*)
class misc (tagdef, tagname, attr) =
 object (self)
  
  val mutable start_pos = TextIndex(LineChar(0,0),[])
  (* val tagdef = tagdef *)
  val tagname = let _ = tagdef#define tagname  attr in
     tagname

  method pop current_pos =
   if start_pos <> current_pos then begin
     tagdef#add (tagname, start_pos, current_pos)
   end

  method push current_pos  =
     start_pos <- current_pos

end

(* 
 * Spacing is specific, due to Tk's line model and BR
 *  push corresponds to top spacing for the first line
 *  pop corresponds to bottom spacing for the first line
 *)

class spacing (tagdef) =
 object
  (* val tagdef = tagdef *)
 
  method push current_pos n =
    let topname = sprintf "topspace%d" n in
     tagdef#define topname [Spacing1 (Pixels n)];
     match current_pos with
       TextIndex(base,[x]) ->
     tagdef#add (topname, TextIndex(base, [x;LineStart]),
                      TextIndex(base, [x;LineEnd]));
     ()
     | _ -> assert false

  method pop current_pos n =
    let botname = sprintf "botspace%d" n in
    tagdef#define botname [Spacing3 (Pixels n)];
     match current_pos with
       TextIndex(base,[x]) ->
     tagdef#add (botname, TextIndex(base, [x;LineStart]),
                      TextIndex(base, [x;LineEnd]));
     ()
     | _ -> assert false
end

<<constant Attrs.circle_data>>

<<constant Attrs.disc_data>>

<<constant Attrs.square_data>>

<<constant Attrs.bullet_table>>
<<function Attrs.init>>
@


\subsection*{[[./display/cmap.ml]]}

<<exception Cmap.Syntax>>=
(* Client Side Image Maps
   We must have two modes: one when the image has not been loaded.
   In that case, we need something like a popup menu. And then, when
   the image is loaded, we use a canvas
   *)

exception Syntax of string
@

<<function Cmap.alt_mode>>=
let alt_mode emb m l =
  Log.debug (sprintf "Alt mode map for %s" (Widget.name l));
  let menu = Menu.create_named l "map" [] in
  List.iter (fun area ->
    Menu.add_command menu
      [Label (if area.area_alt = "" then 
    area.area_link.h_uri
      else area.area_alt);
    Command (fun () -> emb.embed_context#goto area.area_link)])
    m;
  bind l (Glevents.get "alt_imap")
    (BindSet ([Ev_RootX; Ev_RootY],
          (fun ei -> Menu.popup menu ei.ev_RootX ei.ev_RootY)))
@

<<function Cmap.printTagOrId>>=
let printTagOrId = function
  | Id n -> Log.f (sprintf "Id %d" n)
  | Tag s -> Log.f (sprintf "Tag %s" s)
@

<<function Cmap.gfx_mode>>=
(* This is called when the image has been loaded *)
let gfx_mode emb map c =
  Log.debug (sprintf "Gfx mode map for %s" (Widget.name c));

  (* Build the canvas items corresponding to active zones *)

  (* For points *inside* rects and circle items to be actually considered
     inside for the purpose of activation, we must use both an empty outline
     and an empty fill. *)
  let opts = [Outline (NamedColor ""); FillColor (NamedColor "")] in

  let items = 
    List.map (fun area ->
      try
        match area.area_kind with
      Default -> Id 1, area.area_link (* the image itself *)
        | Rect -> 
        begin match area.area_coords with
        | [x1;y1;x2;y2] ->
           Canvas.create_rectangle c
          (Pixels x1) (Pixels y1) (Pixels x2) (Pixels y2) 
          opts,
           area.area_link
        | _ -> 
        raise (Syntax "rect")
        end
        | Circle ->
        begin match area.area_coords with
        | [x;y;r] ->
           Canvas.create_oval c
          (Pixels (x-r)) (Pixels (y-r))
          (Pixels (x+r)) (Pixels (y+r))
          opts,
           area.area_link
        | _ -> raise (Syntax "circle")
        end
        | Poly ->
        let l = List.length area.area_coords in
        (* there must be at least three points, and by pair *)
        if l < 6 or l mod 2 <> 0 then begin
          Log.f "Invalid coords for polygon shape";
          raise (Syntax "polygon")
        end
        else
          Canvas.create_polygon c
               (List.map (fun x -> Pixels x) area.area_coords)
               opts,
          area.area_link
      with 
      |	Syntax s ->
      Log.f (sprintf "Wrong syntax in area mapping (%s)" s);
      Tag "area error", area.area_link
      | Protocol.TkError s -> 
      Log.f (sprintf "Error in area mapping (%s)" s);
      Tag "area error", area.area_link
     )
     map
  in
  Canvas.lower_bot c (Id 1);
  let htobj = new imap(c,items) in
    htobj#init emb.embed_context
@


%-------------------------------------------------------------

<<./display/cmap.ml>>=
open Printf
open Tk
open Embed
open Maps
open Hyper
open Viewers

<<exception Cmap.Syntax>>

<<function Cmap.alt_mode>>

<<function Cmap.printTagOrId>>


(* See Htbind for semantics of this class *)
class imap (c, items) =
 object (self)
 inherit Htbind.active () as super

 (* val items = items *)
 (* val c = c *)
 method widget = c

 method getlink ei =
   let cx = truncate (Canvas.canvasx c (Pixels ei.ev_MouseX))
   and cy = truncate (Canvas.canvasy c (Pixels ei.ev_MouseY)) in
     match Canvas.find c [Closest (Pixels cx, Pixels cy)] with
       [id] -> List.assoc id items
     |  _ -> raise Not_found

 method binder = Canvas.bind c (Tag "current") 

 method highlight _ = ()
 method markused ei = ()

 method init ctx =
   super#init ctx;
   self#binder [[], Motion]
    (BindSet ([Ev_MouseX; Ev_MouseY], 
          (fun ei ->
            try
              let link = self#getlink ei in
              ctx#invoke "pointsto" link
            with
              Not_found -> ())))
end
 



<<function Cmap.gfx_mode>>


@


\subsection*{[[./display/fit.mli]]}

<<signature Fit.debug>>=
val debug : bool ref
@

<<signature Fit.set_initial_width>>=
val set_initial_width : Widget.widget -> int option
@

<<signature Fit.set_initial_height>>=
val set_initial_height: Widget.widget -> unit
@

<<signature Fit.horiz>>=
(* [horiz textw stop continuation] returns [scrollcommand, check] *)
val horiz: 
  Widget.widget -> (unit -> bool) -> (unit -> unit) ->
  (float -> float -> unit) * (unit -> unit)
@

<<signature Fit.vert>>=
val vert: 
  Widget.widget -> 
  (float -> float -> unit) * (unit -> unit)
@

<<signature Fit.bound_check>>=
val bound_check : Widget.widget -> int -> (unit -> bool)
@

<<signature Fit.fixed_horiz>>=
val fixed_horiz : Widget.widget -> int -> unit
@


%-------------------------------------------------------------

<<./display/fit.mli>>=

<<signature Fit.debug>>

<<signature Fit.set_initial_width>>
<<signature Fit.set_initial_height>>

<<signature Fit.horiz>>

<<signature Fit.vert>>

<<signature Fit.bound_check>>

<<signature Fit.fixed_horiz>>
@


\subsection*{[[./display/fit.ml]]}

<<constant Fit.debug>>=
let debug = ref false
@

<<function Fit.set_initial_width>>=
(* initial width : a nested formatter starts with w=1 h=1
 * if the only contents is an embedded window, it's a bit short
 * thus we check for max width of embedded windows
 * We take an arbitrary width of 10 pixels per char.
 *)
let set_initial_width wid =
  let ewidth = ref 0 in
  List.iter (fun w -> ewidth := max (Winfo.reqwidth w) !ewidth) 
            (Text.window_names wid);
  if !ewidth > 10 then begin
    let w = !ewidth / 10 in
    if !debug then
      Log.f (sprintf "Setting initial width of %s to %d"
                 (Widget.name wid) w);
    Text.configure wid [TextWidth w];
    Some w
  end
  else
    None
@

<<function Fit.wheight>>=
(* I still don't understand the difference between height and reqheight *)
let wheight w = max (Winfo.height w) (Winfo.reqheight w)
@

<<function Fit.set_initial_height>>=
let set_initial_height wid =
  match Text.index wid (TextIndex(End,[])) with
    LineChar (l,_) ->
      let height = ref (l-1) in
      for i = 0 to l - 1 do
    match Text.index wid (TextIndex(LineChar(i,0), [LineEnd])) with
      LineChar (_,c) -> height := !height + c / 100
    | _ -> ()
      done;
      begin
    let embedded = Text.window_names wid in
    if embedded = [] then () 
    else begin
      let lines = Hashtbl.create (List.length embedded) in
      let addh l h =
        try
          let r = Hashtbl.find lines l in
          r := max h !r
        with
          Not_found -> Hashtbl.add lines l (ref h)
      in
      List.iter (fun w ->
        match Text.index wid (TextIndex(Embedded w, [])) with
          LineChar(l,_) -> addh l (wheight w)
        | _ -> assert false)
        embedded;
      Hashtbl.iter (fun _ r -> height := !height + !r / 15) lines
       end;
     let curheight = int_of_string (cget wid CHeight) in
    if !height > curheight then begin
      if !debug then 
        Log.f (sprintf "Setting initial height of %s to %d (%d)"
                       (Widget.name wid) !height (l-1));
         Text.configure wid [TextHeight (!height)]
    end else if !debug then 
        Log.f (sprintf "Initial height of %s is %d (%d)"
                       (Widget.name wid) !height (l-1))
      end
  | _ -> ()
@

<<function Fit.fixed_horiz>>=
(* Grow horizontally until we reached the maxium authorized width 
 * (or bound is reached)
 *)
let rec fixed_horiz wid maxw =
  let curw = Winfo.reqwidth wid in
  if  curw >= maxw then ()
  else begin
    let w = (succ (int_of_string (cget wid CWidth))) in
    if !debug then
      Log.f (sprintf "Growing %s to %d (w=%d) (max=%d)"
                 (Widget.name wid) w curw maxw);
    Text.configure wid [TextWidth w];
    fixed_horiz wid maxw
  end
@

<<function Fit.horiz>>=
let horiz wid stop continuation =
  (* all conditions for stopping *)
  let finished visible = visible >= 0.999 || stop()
  (* bail out *)
  and over () = 
   (* deconnect ourselves *)
   (*Text.configure wid [XScrollCommand (fun _ _ -> ())];*)
   continuation()
  and last_visible = ref 0.0 
  in
  (* if we want to restart after we were disconnected*)
  let rec check () = 
    let first, last = Text.xview_get wid in 
     scroll first last
  (* binding to XScrollCommand *)
  and scroll first last =
    let curwidth = int_of_string (cget wid CWidth)
    and visible = last -. first in
    (* Don't attempt anything if widget is not visible *)
    (* Especially, DO NOT DECIDE TO STOP *)
    if not (Winfo.viewable wid) then begin
      if !debug then
    Log.f (sprintf "%s HC %d %f %f notviewable"
                   (Widget.name wid) curwidth first last);
      (* Try again later *)
      bind wid [[], Expose] (BindSet ([], fun _ ->
    bind wid [[], Expose] BindRemove;
    check()))
    end
    else if finished visible then over()
    else if visible = !last_visible then 
      (* it didn't change since our last resize ! *)
      ()
    else begin
      (* how much do we need to grow
     This code is disabled because it causes masking of table cells
     (we don't have a reasonable estimation of a minimum horiz growth
      that would avoid masking). We now grow by 1, despite the 
      slowness.
      let delta = 
    if last = 0.0 then 1
        else begin
      last_visible := visible;
      let visible = max 0.2 visible in
      let missing = 1. -. visible in
      (* at least one char, but not too much *)
      let computed = truncate (float curwidth *. missing /. visible) in
      if computed = 0 then 1 else min 5 computed
        end
      in
      let newsize = curwidth + delta in
     *)
      last_visible := visible;
      let newsize = curwidth + (if visible < 0.1 then 5 else 1) in
      if !debug then
       Log.f (sprintf "%s H %d %f %f newsize: %d"
                   (Widget.name wid) curwidth first last newsize);
      Text.configure wid [TextWidth newsize];
    end
    
  in
  scroll, check
@

<<function Fit.vert>>=
(* somehow we need to do it differently : resize is delayed *)
let vert wid =
  let finished visible = visible >= 0.999
  and last_visible = ref (-1.0)   (* last value of visible *)
  and stuck = ref false     (* last resize didn't have an effect *)
  and pending_check = ref false
  and delayed = ref false   (* we have a binding on Expose *)
  and pending_resize = ref false (* a resize is pending *)
  and newsize = ref 0
  in
  let rec check () = 
    if Winfo.exists wid then begin (* we must check since we use a delay *)
    let first, last = Text.yview_get wid in 
      pending_check := false;
      scroll first last
    end
  and scroll first last =
    let curheight = int_of_string (cget wid CHeight)
    and visible = last -. first in
    (* Don't attempt anything if widget is not visible *)
    if not (Winfo.viewable wid) then begin
      if !debug then
    Log.f (sprintf "%s VC %d %f %f notviewable"
                   (Widget.name wid) curheight first last);
      (* Try again later *)
      if not !delayed then begin
    delayed := true;
       bind wid [[], Expose] (BindSet ([], fun _ ->
      bind wid [[], Expose] BindRemove;
      delayed := false;
      check()))
      end
    end
    else if finished visible then ()
    else if !stuck then
      if !pending_check then ()
      else begin
      (* last check had same last value than before *)
      pending_check := true;
      if !debug then Log.f (sprintf "Stuck %s" (Widget.name wid));
      Timer.set 50 (fun () -> stuck := false; Frx_after.idle check)
      end
    else begin
      let delta = 
  if visible = !last_visible then (stuck := true; 1) 
        else if last = 0.0 then (last_visible := 0.0; 1)
    else begin
      last_visible := visible; stuck := false;
          (* never to more than double *)
      let visible = max 0.5 visible in
      let missing = 1. -. visible in
      (* at least one char, but not too much *)
      let computed = truncate (float curheight *. missing /. visible) in
      if computed = 0 then 1 else min 5 computed
        end 
      in
      newsize := max (curheight + delta) !newsize;
      (* Since we may not be fully visible anyway, decouple the loop *)
      if !pending_resize then ()
      else begin
    if !debug then 
      Log.f (sprintf "Scheduling resize of %s" (Widget.name wid));
    pending_resize := true;
        Timer.set 50 (fun () -> Frx_after.idle (resize first last))
      end
    end
  and resize first last () =
    pending_resize := false;
    let curheight = int_of_string (cget wid CHeight) in
    if !newsize > curheight then begin
      if !debug then
       Log.f (sprintf "%s V %d %f %f newsize: %d"
               (Widget.name wid) curheight first last !newsize);
      Text.configure wid [TextHeight !newsize]
    end
  in
  scroll, check
@

<<function Fit.bound_check>>=
let bound_check wid width =
  let stop_now = ref false in
  bind wid [[], Configure]
    (BindExtend([Ev_Width], (fun ei ->
      if !debug then
    Log.f (sprintf "Configure %s width is %d (max %d) (req %d)"
                  (Widget.name wid) ei.ev_Width width
                  (Winfo.reqwidth wid));
      if ei.ev_Width >= width then begin
    stop_now := true;
  bind wid [[], Configure] BindRemove
      end)));
  (fun () -> !stop_now)
@


%-------------------------------------------------------------

<<./display/fit.ml>>=
open Printf
open Tk
open Protocol

<<constant Fit.debug>>

<<function Fit.set_initial_width>>

(* initial height: we have to grow at least to the number of
 * lines of text so that the entire text is visible. Moreover,
 * large lines will fold so adjust. Moreover, embedded window
 * provide height.
 *)
<<function Fit.wheight>>

<<function Fit.set_initial_height>>


<<function Fit.fixed_horiz>>

<<function Fit.horiz>>


<<function Fit.vert>>

<<function Fit.bound_check>>

@


\subsection*{[[./display/fonts.mli]]}

<<type Fonts.fontInfo>>=
type fontInfo =
  | Family of string
  | Weight of string
  | Slant of string
  | FontIndex of int
  | FontDelta of int
@

<<type Fonts.fontAttrs>>=
type fontAttrs = fontInfo list
@

<<type Fonts.fontDesc>>=
type fontDesc = { 
  pattern: Jpf_font.pattern;
  mutable pxlsz: int;
}
@

<<signature Fonts.default>>=
val default: fontDesc ref
@

<<signature Fonts.print_fontAttrs>>=
val print_fontAttrs: fontAttrs -> unit
@

<<signature Fonts.merge>>=
val merge: fontDesc -> fontAttrs -> fontDesc
@

<<signature Fonts.compute_tag>>=
val compute_tag: fontDesc -> string * Tk.options list
@

<<signature Fonts.font_index>>=
val font_index: int -> int
@

<<signature Fonts.pxlsz>>=
val pxlsz: int -> int
@

<<signature Fonts.default_sizes>>=
(*-*)
val default_sizes: string list
@

<<signature Fonts.reset>>=
val reset: unit -> unit
@


%-------------------------------------------------------------

<<./display/fonts.mli>>=

<<type Fonts.fontInfo>>

<<type Fonts.fontAttrs>>

<<type Fonts.fontDesc>>

<<signature Fonts.default>>

<<signature Fonts.print_fontAttrs>>

<<signature Fonts.merge>>
<<signature Fonts.compute_tag>>

<<signature Fonts.font_index>>
<<signature Fonts.pxlsz>>

<<signature Fonts.default_sizes>>

<<signature Fonts.reset>>
@


\subsection*{[[./display/fonts.ml]]}

<<type Fonts.fontDesc (./display/fonts.ml)>>=
(* Font manipulation *)

type fontDesc = 
    { pattern: Jpf_font.pattern;
      mutable pxlsz: int (* not pxlsz, but font index *)
    }
@

<<type Fonts.fontInfo (./display/fonts.ml)>>=
type fontInfo =
   Family of string
 | Weight of string
 | Slant of string
 | FontIndex of int
 | FontDelta of int
@

<<type Fonts.fontAttrs (./display/fonts.ml)>>=
type fontAttrs = fontInfo list
@

<<function Fonts.copy>>=
let copy fd = { pattern= Jpf_font.copy fd.pattern;
        pxlsz= fd.pxlsz }
@

<<function Fonts.print_fontAttrs>>=
let print_fontAttrs attrs =
  List.iter (function 
    Family s -> prerr_string ("family: " ^ s ^ " ")
  | Weight s -> prerr_string ("weight: " ^ s ^ " ")
  | Slant s -> prerr_string ("slant: " ^ s ^ " ")
  | FontIndex i -> prerr_string ("index: " ^ string_of_int i ^ " ")
  | FontDelta i -> prerr_string ("delta: " ^ string_of_int i ^ " ")) attrs;
  prerr_endline "";
@

<<function Fonts.merge>>=
(* Merge font attributes in a fontDesc *)
let merge fd fil =
  let newfd = copy fd in
  List.iter (function
      Family s -> newfd.pattern.family <- Some s
    | Weight s -> newfd.pattern.weight <- Some s
    | Slant s -> newfd.pattern.slant <- Some s
    | FontIndex i -> newfd.pxlsz <- i
    | FontDelta n -> newfd.pxlsz <- newfd.pxlsz + n
    )
    fil;
  newfd
@

<<constant Fonts.default_sizes>>=
(* List of authorized pixel sizes *)
let default_sizes = ["8"; "10"; "12"; "14"; "15"; "16"; "18"; "20"; "24"; "26"; "28"]
@

<<constant Fonts.sizes>>=
let sizes = ref (Array.of_list (List.map int_of_string default_sizes))
@

<<function Fonts.get_index>>=
(* Given a size in pixels, find out the corresponding index array 
   (which is the max of defined sized lower than argument)
 *)
let get_index size =
  let len = Array.length !sizes in
  let rec walk n =
    if n >= len then len - 1
    else if !sizes.(n) > size then n-1
    else walk (succ n)
  in 
  let idx = walk 0 in
  if idx < 0 then 0 else idx
@

<<constant Fonts.base_index>>=
let base_index = ref (get_index 15)
@

<<function Fonts.font_index>>=
(* Convert a pxlsz to an absolute font 
 * (the base_index is always the absolute font 3 byte defintion of HTML)
 *)
let font_index pxlsz =
  (get_index pxlsz) - (!base_index - 3)
@

<<function Fonts.pxlsz>>=
(* Convert an absolute font to a pxlsz *)
let pxlsz absfont =
  let font_idx = absfont + (!base_index - 3) in
  let safe_idx = 
    if font_idx < 0 then 0
    else if font_idx >= Array.length !sizes then Array.length !sizes - 1
    else font_idx in
@

<<constant Fonts.tags>>=
(*
 * Tag names for fonts (this table is shared by all widgets)
 * We share tags for fonts, but this requires combinations of all
 * possible styles (weight, slant and size). The tag attribute is computed 
 * on demand. Each widget must do its "tag configure" separately, since these
 * are not shared by all text widgets (even in a same class)
 *)


let tags = Hashtbl.create 37
@

<<constant Fonts.default>>=
let default = ref 
    { pattern= Jpf_font.copy Jpf_font.empty_pattern;
      pxlsz = 3 }
@

<<function Fonts.compute_tag>>=
(* For a given fontDesc, return the name of the tags and its attributes *)
let rec compute_tag fd =
  let font_key = 
    Jpf_font.string_of_pattern fd.pattern ^ string_of_int fd.pxlsz 
  in
  try 
    Hashtbl.find tags font_key
  with Not_found ->
    let tagdesc =
      let pxlsz = pxlsz fd.pxlsz in
      let pattern = {fd.pattern with pixelSize= Some pxlsz} in
      try
        let display = 
          match Protocol.default_display () with
            "" -> None | x -> Some x
        in
        let fontid, fontname =
              (* find latin font *)
          let xlfd = Jpf_font.nearest_pixel_size display true pattern in
          let latin_f = Jpf_font.string_of_valid_xlfd xlfd in
          xlfd.family^xlfd.weight^xlfd.slant^(string_of_int pxlsz), latin_f
        in
    
        (*    
        (* japanese mode, search jp fonts *)
        if !Lang.japan then begin
         (*
          let pattern = { Jpf_font.empty_pattern with
                          registry= Some "jisx0208.1983";
                          pixelSize= Some pxlsz } in
          *)
          let retry pattern =
            let xlfd = Jpf_font.nearest_pixel_size display (pxlsz > 20) 
            pattern 
            in
            let japan_f = Jpf_font.string_of_valid_xlfd xlfd in
            fontid, [Font (Font.create [Compound [ fontname; japan_f ]])]
          in
    
          (* fst retry *)
          let pattern = { fd.pattern with
                          foundry= None;
                          family= None;
                          registry= Some "jisx0208.1983";
                          pixelSize= Some pxlsz } 
          in
          try retry pattern with _ ->
          
              (* snd retry *)
          let pattern = { pattern with slant= None } in
          try retry pattern with _ ->
            
              Log.f (I18n.sprintf "Japanese font for %s is not available" (Jpf_font.string_of_pattern pattern));
          fontid, [Font fontname] (* we should do more... *)
        end else 
          *)

        fontid, [Font fontname]
      with (* Invalid_argument f *) _ ->  (* font is not available *)
        Log.f (I18n.sprintf "Font for %s is not available" 
                 (Jpf_font.string_of_pattern pattern));
        if fd = !default 
        then ("fixedfont", [Font "fixed"])
        else compute_tag !default
     in
     Hashtbl.add tags font_key tagdesc;
     tagdesc
@

<<function Fonts.reset>>=
(* Mapping with preferences : *fontPixels is also used to define our array 
 * We use a mute preference handler to synchronize : this handler is called
 * after the loading of the resource file.
 *)
let reset () =
  Hashtbl.clear tags; (* since tags use font index *)
  let l = Tkresource.stringlist "fontPixels" default_sizes in
  sizes := Array.of_list (List.map (fun x -> 
    try 
      int_of_string x 
    with 
      e -> 
    Log.f ("Fonts.reset error for size "^x); 
    raise e) l);
  (* now we need to compute the base (we need to know some of Prefs internal)*)
  let b = Tkresource.string "prefDefaultFont" "" in
  if b = "" then base_index := get_index 15
  else
    let tokens = Mstring.split_str (fun c -> c='-') b in
    base_index := get_index (
       try int_of_string (List.nth tokens 6)
       with Failure "int_of_string" | Failure "nth" -> 15)
@


%-------------------------------------------------------------

<<./display/fonts.ml>>=
open Tk80
open Tk
open Jpf_font

<<type Fonts.fontDesc (./display/fonts.ml)>>

<<type Fonts.fontInfo (./display/fonts.ml)>>

<<type Fonts.fontAttrs (./display/fonts.ml)>>

<<function Fonts.copy>>

<<function Fonts.print_fontAttrs>>
;;

<<function Fonts.merge>>

(* HTML3.2 specifies that absolute font size are ranging from 1 to 7, 
   the default basefont, used for "normal" text, being 3.

   The preference settings allow:
    - definition of list of pixel sizes
    - definition of default size   
    - definition of header size.

   To compute the HTML fonts [1..7], we look for the default
   pixel size in the list of the given sizes: this defines the 
   default base (3).

   We map these sizes to X Font Pxlsz, keeping some latitude for
   mapping the base. The lowest reasonable font is 8
 *)

<<constant Fonts.default_sizes>>
<<constant Fonts.sizes>>

<<function Fonts.get_index>>


<<constant Fonts.base_index>>

<<function Fonts.font_index>>


<<function Fonts.pxlsz>>
   !sizes.(safe_idx)

<<constant Fonts.tags>>

<<constant Fonts.default>>

<<function Fonts.compute_tag>>



<<function Fonts.reset>>
@


\subsection*{[[./display/hr.mli]]}

<<signature Hr.create_named>>=
val create_named: 
  Widget.widget -> string -> Html.length -> int -> bool -> 
  Widget.widget
@


%-------------------------------------------------------------

<<./display/hr.mli>>=

<<signature Hr.create_named>>
@


\subsection*{[[./display/hr.ml]]}

<<function Hr.create_named>>=
(* When creating an HR in a nested window (eg table cell), reqwidth is
   probably the width of 1 character
 *)
let create_named top name length height solid =
  let fr = Frame.create_named top name [] in
  let width = match length with
    Nolength | LengthRel _-> truncate (float (Winfo.reqwidth top) *. 0.95)
  | LengthRatio r -> truncate (float (Winfo.reqwidth top) *. r)
  | LengthPixels n -> n
  in
  Frame.configure fr [Width (Pixels width)];
  if solid then
    Frame.configure fr [BorderWidth (Pixels 0); Height (Pixels height)]
  else
    Frame.configure fr [Relief Groove;
            BorderWidth (Pixels 2); Height (Pixels (height+2))];
  fr
@


%-------------------------------------------------------------

<<./display/hr.ml>>=
open Tk
open Html

<<function Hr.create_named>>

@


\subsection*{[[./display/htbind.mli]]}


%-------------------------------------------------------------

<<./display/htbind.mli>>=

class virtual active :
  unit ->
  object
    method virtual binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method virtual getlink : Tk.eventInfo -> Hyper.link
    method virtual highlight : bool -> unit
    method init : Viewers.context -> unit
    method virtual markused : Tk.eventInfo -> unit
    method virtual widget : Widget.widget
  end

class virtual hypertext :
  Widget.widget ->
  object
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method virtual getlink : Tk.eventInfo -> Hyper.link
    method virtual getrange : Tk.index -> Tk.index * Tk.index
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end

class directmap :
  Widget.widget * Hyper.link ->
  object
    val link : Hyper.link
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method getlink : Tk.eventInfo -> Hyper.link
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end

class servermap :
  Widget.widget * Hyper.link ->
  object
    val link : Hyper.link
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method getlink : Tk.eventInfo -> Hyper.link
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end

class formmap :
  Widget.widget * (int * int -> Hyper.link) ->
  object
    val formlink : int * int -> Hyper.link
    method binder :
      (Tk.modifier list * Tk.xEvent) list -> Tk.bindAction -> unit
    method getlink : Tk.eventInfo -> Hyper.link
    method highlight : bool -> unit
    method init : Viewers.context -> unit
    method markused : Tk.eventInfo -> unit
    method widget : Widget.widget
  end
@


\subsection*{[[./display/htbind.ml]]}


%-------------------------------------------------------------

<<./display/htbind.ml>>=
(* Bindings for hypernavigation *)
open Printf
open Tk
open Hyper
open Viewers

(*
An active object is assumed to have the following methods:
*)    


class  virtual active () =
 object (self)
 method virtual widget : Widget.widget
      (* returns the widget to which an hypermenu can be attached *)
 method virtual getlink : eventInfo -> Hyper.link
      (* returns the link pointed to by the object *)
 method virtual binder : (modifier list * xEvent) list -> bindAction -> unit
      (* binds events on the object *)
 method virtual highlight : bool -> unit
      (* user feedback (mostly cursor) indicating that object is active *)
 method virtual markused : eventInfo -> unit
      (* say that we've activated this link *)

 method init (ctx : Viewers.context) =
  (* Install all navigation bindings *)
  List.iter (fun hyname ->
    try 
      let _hyperfTODO = List.assoc hyname ctx#hyper_funs in
      self#binder (Glevents.get hyname)
    (BindSet ([Ev_MouseX; Ev_MouseY],
          (fun ei -> 
             try let link = self#getlink ei in
                  self#markused ei;
                  ctx#invoke hyname link;
             with Not_found -> ())))
    with
      Not_found -> ())
    ["goto"; "save"; "gotonew"];

  (* Install the menu (created by need only) *)
  let menulink = ref None
  and menuei = ref None in
  let hypermenu = Frx_misc.autodef (fun () ->
     let m = Menu.create_named self#widget "hypermenu" [] in
        (* The first entry has its text replaced by the link url *)
        Menu.add_command m [Label ""];
        Menu.add_separator m;
    List.iter (fun (fname, f) ->
             if f.hyper_visible then
              Menu.add_command m
               [Label f.hyper_title; 
                Command (fun () -> 
                  match !menuei, !menulink with
                Some ei, Some link ->
                  self#markused ei;
                  ctx#invoke fname link
                  |	_, _ -> ())])
          ctx#hyper_funs;
    m) in
  self#binder (Glevents.get "hypermenu")
   (BindSet ([Ev_MouseX; Ev_MouseY; Ev_RootX; Ev_RootY], 
       (fun ei -> 
     try
       let link = self#getlink ei in
       menuei := Some ei; menulink := Some link;
       let m = hypermenu() in
       Menu.configure_command m (Number 1) [Label (Hyper.string_of link)];
       Menu.popup m ei.ev_RootX ei.ev_RootY
     with
       Not_found -> ())));

  (* Install the pointsto internal bindings *)
  self#binder [[], Enter]
    (BindExtend ([Ev_MouseX; Ev_MouseY], 
         (fun ei ->
           try
             let link = self#getlink ei in
             self#highlight true;
             ctx#invoke "pointsto" link
           with Not_found -> ())));
  let fakehlink =
    {h_uri = ""; h_context = None; h_method = GET; h_params = [] } in
  self#binder [[], Leave]
    (BindSet ([Ev_MouseX; Ev_MouseY], 
          (fun ei ->
        self#highlight false;
        ctx#invoke "clearpointsto" fakehlink)))
end

(*
 * The various active objects
 *)

(* Text widget with anchors marked as tags *)

class  virtual hypertext (thtml) =
 object (self)
  inherit active () as super
  (* val thtml = thtml *)  (* keep our own copy *)

  method widget = thtml

  method virtual getlink : eventInfo -> Hyper.link

  method binder = Text.tag_bind thtml "anchor" 

  method highlight flag = 
    if flag then
      Text.configure thtml [Cursor (XCursor "hand2")]
    else
      Text.configure thtml [Cursor (XCursor "xterm")]

  method virtual getrange : index -> index * index

  method markused ei =
     (* The index of the click position *)
     let i = 
       Text.index thtml (TextIndex (AtXY (ei.ev_MouseX,ei.ev_MouseY), [])) in
     (* Tags at this place *)
     let s,e = self#getrange i in
       Text.tag_add thtml "visited" (TextIndex (s,[])) (TextIndex (e,[]))

  (* we don't get Enter/Leave when tags are contiguous, so the 
     pointed link displayed in pointsto is no always correct
     Thus, extend initialisation to bind pointsto on motion
   *)
  method init ctx =
    super#init ctx;
    self#binder [[], Motion]
      (BindSet ([Ev_MouseX; Ev_MouseY], 
        (fun ei ->
          try
            let link = self#getlink ei in
            ctx#invoke "pointsto" link
          with
            Not_found -> ())))
end


(* embedded objects with direct map *)
class directmap (frame, link) =
 object (self)
  inherit active ()
  (* val frame = frame *)
  method widget = frame
  val link = (link : Hyper.link)
  method getlink (ei : eventInfo) = link
  method binder = bind frame
  method highlight (flag : bool) = ()  (* we already set up the cursor *)
  method markused ei =
    Frame.configure frame [Relief Sunken]
end

(* embedded objects with server map (ISMAP) *)
(* pointsto will get some arbitrary value for x,y... *)
class servermap (frame,link) =
 object (self)
  inherit active ()
  inherit directmap (frame, link)
  method getlink ei = 
    {h_uri = sprintf "%s?%d,%d" link.h_uri
                                ei.ev_MouseX ei.ev_MouseY;
     h_context = link.h_context;
     h_method = GET;
     h_params = link.h_params}
end

(* embedded objects with form submission *)
class formmap (frame,formlink) =
 object (self)
  inherit active ()
  (* val frame = frame *)
  method widget = frame
  val formlink = (formlink : int * int -> Hyper.link)
  method getlink ei = formlink (ei.ev_MouseX, ei.ev_MouseY)
  method binder = bind frame
  method highlight (flag : bool) = ()  (* we already set up the cursor *)
  method markused ei =
    Frame.configure frame [Relief Sunken]
end


(* Client side image maps are defined in Cmap *)
@


\subsection*{[[./display/source.mli]]}

<<signature Source.annotate>>=
val annotate: 
  Widget.widget -> (Tk.textTag * Html.location) list -> unit
@

<<signature Source.view>>=
val view:
  Widget.widget ->
  Document.document_id ->
  (unit -> unit) ->
  (Html.location * string) list ref ->
  (Tk.textTag * Html.location) list ref -> 
  Japan.detected_code -> 
  unit
@


%-------------------------------------------------------------

<<./display/source.mli>>=

<<signature Source.annotate>>

<<signature Source.view>>
@


\subsection*{[[./display/source.ml]]}

<<function Source.annotate>>=
(* HTML source viewer/editor *)
let annotate txt =
  Hashtbl.iter (fun elem _  ->
    let color = Tkresource.string (sprintf "Source<%s>" elem) "white" in
    Text.tag_configure txt elem [Background (NamedColor color)])
    !Dtd.current.Dtd.contents;
    (fun annotations ->
      List.iter (function (name,Loc(s,e)) ->
    let idxs = abs_index s
    and idxe = abs_index e in
    Text.tag_add txt name idxs idxe)
      annotations)
@

<<function Source.view>>=
(* Commit modifies the cache *)
let view attach did redisplay errors annotations coding =
  try 
    let doc = Cache.find did in
    (* load : take document from cache and put it in text widget
       commit : take source of text widget and store in cache
       save : save to original URL. supported only on file:, could be
              supported on http: with put ?
     *)
    let load, cachesave, saveurl =
      match doc.document_data with
    FileData (fname,_) ->
     let tmpfile = Msys.mktemp "buf" in
     (* load *)
     (fun t ->
        (*
        if !Lang.japan then begin
          (* In Japanese mode, We must insert line by line. *) 
         let ic = open_in fname 
         and buf = String.create 2048
         and prevbuf = ref ""
         in
          try
             while true do
               let n = input ic buf 0 2048 in
                   let txt = 
                     if n = 2048 then begin
                       (* try to find last newline *)
                       let pos = 
                     try String.rindex buf '\n' + 1 
                     with Not_found -> 0
                       in
                       let txt = !prevbuf ^ (String.sub buf 0 pos) in
                       prevbuf := String.sub buf pos 
                          (String.length buf - pos);
                       txt
                     end else begin
                       let txt = !prevbuf ^ (String.sub buf 0 n) in
                       prevbuf := "";
                       txt
                     end
                   in
                   (* if coding = ISO8859 or JIS, the chars > \127
                    * must be preceded with esc sequence 
                    *)
                   let txt =
                     if coding = Japan.Code Japan.ISO8859 || 
                        coding = Japan.Code Japan.JIS then
                       let buf = Ebuffer.create (String.length txt * 2) in
                       for i = 0 to String.length txt - 1 do
                     if txt.[i] > '\127' then 
                       (* sorry for hard coding *)
                       Ebuffer.output_string buf "\027\040\066";
                     Ebuffer.output_char buf txt.[i]
                       done;
                       Ebuffer.get buf
                     else txt
                   in
                   Text.insert t textEnd txt [];
                   (* Then EOF check *)
                   if n = 0 then raise End_of_file
             done
       with End_of_file -> close_in ic
     end else 
     *)
     begin
         let ic = open_in fname 
         and buf = String.create 2048
         in
          try
             while true do
               let n = input ic buf 0 2048 in
                if n = 0 then raise End_of_file
                else
                Text.insert t textEnd (
                  if n = 2048 then buf else String.sub buf 0 n)
                  []
             done
          with End_of_file -> close_in ic
     end
     ),
     (* commit *)
      (fun t ->
        let oc = open_out tmpfile in
         output_string oc
          (Text.get t (TextIndex(LineChar(0,0), [])) textEnd);
         close_out oc;
         (* SWITCH CACHE *)
         doc.document_data <- FileData(tmpfile, true)),
     (* save *)
     Some (fun t ->
        let oc = open_out fname in
         output_string oc
          (Text.get t (TextIndex(LineChar(0,0), [])) textEnd);
         close_out oc;
         (* SWITCH CACHE *)
         doc.document_data <- FileData(fname, false))

      | MemoryData buf ->
     (* load *)
     (fun t -> Text.insert t textEnd (Ebuffer.get buf) []),
     (* commit *)
     (fun t -> 
        Ebuffer.reset buf;
        Ebuffer.output_string buf
        (Text.get t (TextIndex(LineChar(0,0), [])) textEnd)),
         None
    in
  let top = Toplevel.create attach [Class "MMMSource"] in
    Wm.title_set top "HTML source display";
  let errorv = Textvariable.create_temporary top in
  let f, t = new_scrollable_text top [Foreground Black; Background White] false
  and f' = Frame.create_named top "buttons" [] in
  let dismiss = Button.create_named f' "dismiss"
    [Text (I18n.sprintf "Dismiss"); Command (fun _ -> destroy top)] 
  and commit = Button.create_named f' "commit" [Text (I18n.sprintf "Commit")]
  and save = Button.create_named f' "save" [Text (I18n.sprintf "Save")]
  and err = Button.create_named f' "errors" []
  in
  let ferr = Frame.create top [] in
  let err_msg = 
    Label.create_named ferr "error" 
            [Relief Sunken;TextVariable errorv; Anchor W]
  in

  (* Error display and looping *)
  let error_idx = ref [] in
  let get_msg idx =
    let rec f = function
        [] -> raise Not_found
      | (s,e,msg)::l ->
        if Text.compare t s LE idx && Text.compare t idx LE e then msg
     else f l in
    f !error_idx in
  let show_error = Text.yview_index t in
  (* alternative is : Text.see t but is less practical *)
  let loop_in_errors  = 
    let current = ref None in
    (fun () ->
      match !current with
       None -> (* select the first error *)
      let (s,e,_) = List.hd !error_idx in
       current := Some e;
       show_error s
      | Some s -> (* select the next one *)
        try
         let (s,e) = Text.tag_nextrange t "errors" s textEnd in
       current := Some (TextIndex (e,[]));
       show_error (TextIndex(s,[]))
     with _ -> (* no more *)
       let (s,e,_) = List.hd !error_idx in
        current := Some e;
        show_error s) in

  let mark_errors () =
    error_idx := [];
    List.iter (fun (Loc(s,e),msg) ->
      let idxs = abs_index s
      and idxe = abs_index e in
      Text.tag_add t "errors" idxs idxe;
      error_idx := (idxs, idxe, msg) :: !error_idx)
        !errors;
    match List.length !errors with
      0 ->
       Button.configure err [Text (I18n.sprintf "No Errors"); State Disabled]
    | n ->
    Button.configure err
        [Text (I18n.sprintf "%d errors" (List.length !errors));
            State Normal; Command loop_in_errors]
  and decorate = annotate t
  in
  let reset () =
    (* if we delete the tag, we delete the bindings. 
     * we can't use the old indexes since the buffer might have changed ! *)
     let rec remall = function
        [] -> ()
      | [x] -> ()
      | s::e::l ->
       Text.tag_remove t "errors" (TextIndex(s,[])) (TextIndex(e,[]));
       remall l
      in
    remall (Text.tag_ranges t "errors");
    errors := [];
    Button.configure err 
       [Text (I18n.sprintf "Display Errors"); Command mark_errors;
        State Normal]

  in
     Button.configure commit
        [Command (fun () -> reset(); cachesave t; redisplay())];
     (match saveurl with
        None -> Button.configure save [State Disabled]
      | Some f -> 
          Button.configure save
          [Command (fun () -> reset(); f t; redisplay())]);
     Button.configure err 
       [Text (I18n.sprintf "Display Errors");
     Command (fun () -> mark_errors(); decorate !annotations);
        State Normal];
     Text.configure t [Background (NamedColor "white")];
     Text.tag_configure t "errors" [Underline true];
     Text.tag_bind t "errors" [[], Enter]
       (BindSet ([Ev_MouseX; Ev_MouseY],
     (fun ei ->
        (* The index of the click position *)
        let i = Text.index t
            (TextIndex (AtXY (ei.ev_MouseX, ei.ev_MouseY), [])) in
          try
        Textvariable.set errorv (get_msg (TextIndex(i,[])))
          with
        Not_found -> ())));
     Text.tag_bind t "errors" [[], Leave]
       (BindSet ([], (fun ei -> Textvariable.set errorv "")));

      pack [dismiss;commit;save;err][Side Side_Left];
      pack [err_msg] [Side Side_Left; Expand true; Fill Fill_X];
    pack [ferr][Side Side_Top; Fill Fill_X];
    pack [f'][Side Side_Top; Fill Fill_X];
    pack [f][Fill Fill_Both; Expand true; Side Side_Bottom];

  Frx_text.addsearch t;
  load t

  with
    Not_found ->
     !Error.default#f "document not in cache"
@


%-------------------------------------------------------------

<<./display/source.ml>>=
open Printf
open Tk
open Frx_text
open Document
open Html

<<function Source.annotate>>

<<function Source.view>>

@


\subsection*{[[./display/ctext.mli]]}

<<signature Ctext.create>>=
(* [create parent opts nav_keys] creates a text widget
 * with "pixel scrolling". Based on a trick learned from Steve Ball.
 * Returns (frame widget, text widget).
 *)
val create :
  Widget.widget -> Tk.options list -> bool -> 
  Widget.widget * Widget.widget
@

<<signature Ctext.init>>=
val init : unit -> unit
@


%-------------------------------------------------------------

<<./display/ctext.mli>>=

<<signature Ctext.create>>

<<signature Ctext.init>>
@


\subsection*{[[./display/ctext.ml]]}

<<constant Ctext.tag_name>>=
let tag_name = "CTEXT_RO"
@

<<function Ctext.navigation_keys>>=
let navigation_keys tx =
  let tags = bindtags_get tx in
  match tags with
  | (WidgetBindings t)::l when t = tx ->
      Canvas.configure (Winfo.parent t) [YScrollIncrement (Pixels 15)];
      bindtags tx ((WidgetBindings tx) :: (TagBindings tag_name) :: l)
  | _ -> ()
@

<<function Ctext.create>>=
let create top opts navigation =
  let f = Frame.create_named top "smoothf" [] in
  let lf = Frame.create_named f "left" [] in
  let rf = Frame.create_named f "right" [] in
  let c = Canvas.create_named lf "smoothc" [BorderWidth (Pixels 0); TakeFocus true]
  and xscroll = Scrollbar.create_named lf "x" [Orient Horizontal]
  and yscroll = Scrollbar.create_named rf "y" [Orient Vertical] 
  and secret = Frame.create_named rf "secret" []
  in
  (* automatic scrollbars *)
  let has_x = ref false
  and has_y = ref false
  in
  let putx () = 
    pack [xscroll] [Before c; Side Side_Bottom; Fill Fill_X];
    pack [secret] [Before yscroll; Side Side_Bottom];
    has_x := true
  and remx () = 
    Pack.forget [xscroll; secret];
    has_x := false
  and puty () = 
    pack [rf] [Before lf; Side Side_Right; Fill Fill_Y];
    has_y := true
  and remy () = Pack.forget [rf]; has_y := false
  in

  let wrap_scroll isthere put rem scrollcmd   =
    fun first last ->
      scrollcmd first last;
      if !isthere then 
       if first = 0.0 && last = 1.0 then rem() else ()
      else
       if first <> 0.0 || last <> 1.0 then put() else ()
  in
  let t = Text.create_named c "smootht" (BorderWidth(Pixels 0) :: opts) in
    if navigation then navigation_keys t;
 
    (* Make the text widget an embedded canvas object *)
    ignore (
      Canvas.create_window c (Pixels 0) (Pixels 0)
       [Anchor NW; Window t; Tags [Tag "main"]]);
    Canvas.focus c (Tag "main");
    Canvas.configure c 
    [YScrollCommand (wrap_scroll has_y puty remy (Scrollbar.set yscroll))];
    (* The horizontal scrollbar is directly attached to the
     * text widget, because h scrolling works properly *)
    Scrollbar.configure xscroll [ScrollCommand (Text.xview t)];
    (* But vertical scroll is attached to the canvas *)
    Scrollbar.configure yscroll [ScrollCommand (Canvas.yview c)];
    let scroll, check = Fit.vert t in
    Text.configure t [
       XScrollCommand (wrap_scroll has_x putx remx (Scrollbar.set xscroll));
        YScrollCommand (fun first last ->
          scroll first last;
       let x,y,w,h = Canvas.bbox c [Tag "main"] in
         Canvas.configure c 
              [ScrollRegion (Pixels x, Pixels y, Pixels w, Pixels h)]);
        ];
    (* B2 Scrolling : based on std script text.tcl 
     * Since t has the focus, it will handle the event, even if we play
     * with bindtags. Thus ev_MouseX/Y are given in the "full" text.
     * Moreover, as the text scrolls, the re-positionning of the text
     * affects the event fields (non-monotonicity !)
     * However, since "scan" is interested only in relative positions,
     * we can use root coordinates directly
     *)
    let x = ref 0
    and y = ref 0
    in
    bind t [[], ButtonPressDetail 2]
      (BindSetBreakable ([Ev_RootX; Ev_RootY],
        (fun ei -> 
          x := ei.ev_RootX;
          y := ei.ev_RootY;
          Canvas.scan_mark c !x !y)));
    bind t [[Button2], Motion]
      (BindSetBreakable ([Ev_RootX; Ev_RootY],
        (fun ei -> 
          let dx = ei.ev_RootX
          and dy = ei.ev_RootY
          in 
          if dx <> !x || dy <> !y then
            Canvas.scan_dragto c dx dy)));

    bind c [[],Configure] (BindSet ([Ev_Width], (fun ei ->
      Canvas.configure_window c (Tag "main") [Width (Pixels ei.ev_Width)])));

    pack [c] [Side Side_Left; Fill Fill_Both; Expand true];
    pack [lf] [Side Side_Left; Fill Fill_Both; Expand true];
    (* pack [secret] [Side Side_Bottom]; *)
    pack [yscroll] [Side Side_Top; Fill Fill_Y; Expand true];
    (* pack [rf] [Side Side_Right; Fill Fill_Y]; *)
    (* pack [xscroll] [Side Side_Bottom; Fill Fill_X]; *)
    f, t
@

<<function Ctext.init>>=
(* We use Mod1 instead of Meta or Alt *)
let init () = 
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> page_up ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "BackSpace"];
        [[], KeyPressDetail "Delete"];
        [[], KeyPressDetail "Prior"];
        [[], KeyPressDetail "b"];
        [[Mod1], KeyPressDetail "v"]
       ];
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> page_down ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "space"];
        [[], KeyPressDetail "Next"];
        [[Control], KeyPressDetail "v"]
       ];
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> line_up ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "Up"];
        [[Mod1], KeyPressDetail "z"]
       ];
  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> line_down ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "Down"];
        [[Control], KeyPressDetail "z"]
       ];

  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> top ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "Home"];
        [[Mod1], KeyPressDetail "less"]
       ];

  List.iter (function ev ->
            tag_bind tag_name ev 
                 (BindSetBreakable ([Ev_Widget], 
                                (fun ei -> bottom ei.ev_Widget; break()))))
       [
        [[], KeyPressDetail "End"];
        [[Mod1], KeyPressDetail "greater"]
       ]
@


%-------------------------------------------------------------

<<./display/ctext.ml>>=
(* A trick by Steve Ball to do pixel scrolling on text widgets *)
(* USES frx_fit *)
open Tk

<<constant Ctext.tag_name>>

<<function Ctext.navigation_keys>>


<<function Ctext.create>>


(* Same as frx_text, but work on canvas instead of text for scrolling *)
let page_up tx   =  Canvas.yview (Winfo.parent tx) (ScrollPage (-1))
and page_down tx =  Canvas.yview (Winfo.parent tx) (ScrollPage 1)
and line_up tx   =  Canvas.yview (Winfo.parent tx) (ScrollUnit (-1))
and line_down tx =  Canvas.yview (Winfo.parent tx) (ScrollUnit 1)
and top tx = Canvas.yview (Winfo.parent tx) (MoveTo 0.0)
and bottom tx = Canvas.yview (Winfo.parent tx) (MoveTo 1.0)

<<function Ctext.init>>
@


\subsection*{[[./display/htmlfmt.mli]]}

<<type Htmlfmt.gattr>>=
type gattr =
  |  Margin of int
  |  Justification of string
  |  Font of fontInfo		        (* mostly size and face *)
  |  FgColor of string
  |  BgColor of string
  |  Underlined
  |  Striked
  |  Spacing of int
  |  Superscript
  |  Lowerscript
@

<<type Htmlfmt.formatterSpec>>=
type formatterSpec = 
  | TopFormatter of bool		(* flag is pixel-scrolling mode *)
  | NestedFormatter
  | FrameFormatter of (string * string) list (* decoration ... *)
@

<<type Htmlfmt.formatter>>=
type formatter = {
  (* Text primitives of the device *)
  new_paragraph: unit -> unit;  	(* Open a new paragraph *)
    (* make sure the following text will start on a new line *)
  close_paragraph: unit -> unit;  	(* Close a paragraph *)
    (* make sure there is an eol after the current text *)
  print_newline : bool -> unit;		(* Force a line break *)
  print_verbatim : string -> unit;	(* Print as-is *)
  format_string : string -> unit;	(* Line wrap, newlines don't count *)
  flush : unit -> unit;			(* Flush the device *)
  (* Predefined Images *)
  hr : length -> int -> bool -> unit;  (* [hr width height solid] *)
  bullet : string -> unit;
  (* Graphical attributes *)
  set_defaults : string -> gattr list -> unit;     (* bg, fg, links *)
  push_attr : gattr list -> unit;
  pop_attr : gattr list -> unit;
  (* Structure primitives *)
  isindex : string -> string -> unit;         (* <ISINDEX> *)
  start_anchor : unit -> unit;
  end_anchor : Hyper.link -> unit;
  add_mark : string -> unit;
  (* Embedding primitives *)
  create_embedded : 
     string -> int option -> int option -> Widget.widget;
       (* [create_embedded align w h ]: 
      returns a widget that we can pass as target to the embed manager.
      Should respect background color ?
    *)
  (* Re-centering on a fragment *)
  see_frag : string option -> unit;
}
@

<<type Htmlfmt.input_kind>>=
(* Form manager *)
type input_kind = EntryInput | FileInput | OtherInput
@

<<type Htmlfmt.width_constraint>>=
(* Table manager *)
type width_constraint =
  | TopWidth				(* toplevel window size*)
  | FixedWidth of int			(* width is given in pixels *)
  | UnknownWidth of (unit -> bool)	(* constraint to satisfy *)
@


%-------------------------------------------------------------

<<./display/htmlfmt.mli>>=
(* HTML  "display device" *)
open Html
open Www
open Fonts
open Embed

<<type Htmlfmt.gattr>>

<<type Htmlfmt.formatterSpec>>

<<type Htmlfmt.formatter>>

module type GfxHTML = sig
 val create : 
    (unit -> string) ->
    formatterSpec -> Widget.widget -> Viewers.context -> 
      formatter * Widget.widget
 end

(* Manager for in-lined images *)
module type ImgDisplay = sig
   (* Various configuration stuff *)
   type mode =
       DuringDoc
     | AfterDocAuto
     | AfterDocManual

   val mode : mode ref
   val no_images : bool ref

   class loader : (unit) -> object
     method add_image : embobject -> unit	 (* add one image *)
     method flush_images : unit	         (* flush when document is loaded *)
     method load_images : unit		 (* manual flush *)
     method update_images : unit
   end

   val create : unit -> loader
 end

<<type Htmlfmt.input_kind>>
    
class  virtual form_behaviour : (unit) -> object
    method virtual add_get : input_kind -> (unit -> (string * string) list) -> unit
    method virtual add_reset : (unit -> unit) -> unit
    method virtual submit : (string * string) list -> Hyper.link
    method virtual single_submit : Hyper.link option
    method virtual reset : unit
end

module type FormDisplay = sig
   (* A form manager *)
   type t = {
     text_input : Widget.widget -> tag -> unit;
     (* [text_input top tag] *)
     checkbox_input : Widget.widget ->  tag -> unit;
     (* [input top tag] *)
     radio_input : Widget.widget ->  tag -> unit;
     (* [input top tag] *)
     image_input : Widget.widget ->  tag -> embobject;
     (* [input top tag] *)
     submit_input : Widget.widget ->  tag -> unit;
     (* [input top tag] *)
     reset_input : Widget.widget ->  tag -> unit;
     (* [input top tag] *)
     select : Widget.widget -> (string * string * bool) list -> tag -> unit;
     (* [select top elements tag] *)
     textarea:  Widget.widget -> string -> tag -> unit
     (* [textarea top initial attrs] *)
     }

   val create : string -> form_behaviour -> Viewers.context -> t
      (* [create base behaviour ctx] *)

 end


<<type Htmlfmt.width_constraint>>

module type TableDisplay = sig
    type cell_type = HeaderCell | DataCell
    type t = {
      table_master : Widget.widget;
      add_col : Html.tag -> unit;
      open_row : Html.tag -> unit;
      close_row : unit -> unit;
      close_table : unit -> unit;
      new_cell : 
      cell_type -> Html.tag -> Widget.widget -> string -> width_constraint;
      bound : unit -> bool
      }

    val create : Widget.widget -> Html.tag -> width_constraint -> t

    val topwidth : Widget.widget -> int

 end
@


\subsection*{[[./display/imgload.mli]]}

<<type Imgload.mode>>=
type mode =
  | DuringDoc
  | AfterDocAuto
  | AfterDocManual
@

<<signature Imgload.mode>>=
val mode : mode ref
@

<<signature Imgload.no_images>>=
val no_images : bool ref
@

<<signature Imgload.gif_anim_auto>>=
val gif_anim_auto : bool ref
@

<<signature Imgload.create>>=
val create : unit -> loader
@


%-------------------------------------------------------------

<<./display/imgload.mli>>=

<<type Imgload.mode>>

<<signature Imgload.mode>>
<<signature Imgload.no_images>>
<<signature Imgload.gif_anim_auto>>

class loader : (unit) -> object
  method add_image : Embed.embobject -> unit	 (* add one image *)
  method flush_images : unit	         (* flush when document is loaded *)
  method load_images : unit		 (* manual flush *)
  method update_images : unit
end

<<signature Imgload.create>>

@


\subsection*{[[./display/imgload.ml]]}

<<type Imgload.mode (./display/imgload.ml)>>=
(* Images are embedded objects, with a twist *)
type mode =
    DuringDoc
  | AfterDocAuto
  | AfterDocManual
@

<<constant Imgload.mode>>=
(* Preference settings *)
let mode = ref AfterDocManual
@

<<constant Imgload.no_images>>=
let no_images = ref false
@

<<constant Imgload.gif_anim_auto>>=
let gif_anim_auto = ref false
@

<<function Imgload.display>>=
(* Utilities *)
let display emb i =
  let prop = ref false in
  begin
  if Winfo.exists emb.embed_frame then
  match emb.embed_map with
    ClientSide hlink -> (* kill'em all *)
      begin try
    List.iter destroy (Winfo.children emb.embed_frame);
    let w, h =
     match i with
       Still x -> 
         begin match x with
           ImageBitmap i -> Imagebitmap.width i, Imagebitmap.height i
         | ImagePhoto  i -> Imagephoto.width i, Imagephoto.height i
         | _ -> failwith "invalid image" 
         end
     | Animated anm -> Tkanim.width anm, Tkanim.height anm in
    let c = Canvas.create emb.embed_frame 
           [Width (Pixels w); Height (Pixels h)] in
    prop := true; (*fit the size to the image*)
    Tk.bindtags c ((WidgetBindings emb.embed_frame)::Tk.bindtags_get c);
      pack [c][];
    let ii = Canvas.create_image c (Pixels 0) (Pixels 0)
                   [Anchor NW] in
    begin
      match i with
        Still x -> Canvas.configure_image c ii [x]
      | Animated anm -> 
          begin
        let f = Tkanim.animate_canvas_item c ii anm in
        (* binding on c is bad... *)
        bind c (Glevents.get "stopanim") (BindSet ([], (fun _ ->
          f false)));
        bind c (Glevents.get "restartanim") (BindSet ([], (fun _ ->
          f true)));
        (* I am sure it doesn't work *)
        Canvas.configure c [Cursor (XCursor "watch")];
        if !gif_anim_auto then f false
          end
    end;
    (* now we have the image displayed in a canvas.
       and we can create the client side map *)
    let uri = Hyper.resolve hlink in
    let name =
      match uri.uri_frag with 
        None -> uri.uri_url
      | Some frag -> sprintf "%s#%s" uri.uri_url frag
    in
      match Maps.get name with
        KnownMap m -> Cmap.gfx_mode emb m c
      | RequestedMap event ->
         Frx_synth.bind c event 
         (fun c -> 
            match Maps.get name with
              RequestedMap _ ->
             Log.f "INTERNAL ERROR: delayed_client_side"
            | KnownMap m -> Cmap.gfx_mode emb m c)
      with
    e -> Log.f (sprintf "INTERNAL ERROR in display (%s)"
                    (Printexc.to_string e))
      end

  | _ ->
    (* in all other cases, get the alt label, and configure it *)
    (* WARNING: there may be an hypermenu here *)
    List.iter (function w ->
      match Winfo.class_name w with
    "Label" ->
    (* remove its border *)
    Label.configure w [BorderWidth (Pixels 0)];
    begin match i with
      Still x -> 
        Label.configure w [x];
        begin match x with
          ImageBitmap _ | ImagePhoto _ ->
        prop := true; (*fit the size to the image*)
        | _ -> () (*We cannot restore the origianl size of the window...*)
        end;
        (* Utility to copy the img url in the selection buffer *)
        bind w (Glevents.get "copyimgurl")
          (BindSet ([], (fun _ ->
        emb.embed_context#invoke "copy" emb.embed_hlink)));
        (* Updating an image *)
        begin
          try 
        let url = 
          Lexurl.make (Hyper.resolve emb.embed_hlink).uri_url in
         bind w (Glevents.get "updateimage")
          (BindSet ([], (fun _ -> Img.update url)))
          with
        Url.Url_Lexing _ -> ()
        end

    | Animated anm -> 
        begin
          let f = Tkanim.animate w anm in
          bind w (Glevents.get "stopanim") (BindSet ([], (fun _ ->
        f false)));
          bind w (Glevents.get "restartanim") (BindSet ([], (fun _ ->
        f true)));
        Label.configure w [Cursor (XCursor "watch")];
          if !gif_anim_auto then f false;
          prop := true (*fit the size to the image*)
        end
    end
      |	"Canvas" -> destroy w (* delete the progress meter *)
      |	_ -> ())
      (Winfo.children emb.embed_frame)
  end;
  if !prop then Pack.propagate_set emb.embed_frame true
@

<<function Imgload.put_alt>>=
(* put up the alternate text *)
let put_alt emb =
  let m = Label.create_named emb.embed_frame "alt" [Text emb.embed_alt] in
  (* make sure all bindings we put on the frame are attached there *)
  Tk.bindtags m ((WidgetBindings emb.embed_frame)::Tk.bindtags_get m);
  pack [m][Fill Fill_Both; Expand true];
  if not (Pack.propagate_get emb.embed_frame) then begin (* with width and height *)
    if Winfo.reqwidth emb.embed_frame < Winfo.reqwidth m then
      Frame.configure emb.embed_frame [Width (Pixels (Winfo.reqwidth m))];
    if Winfo.reqheight emb.embed_frame < Winfo.reqheight m then
      Frame.configure emb.embed_frame [Height (Pixels (Winfo.reqheight m))];
(* Buggy
    let wf = Winfo.reqwidth emb.embed_frame 
    and wm = Winfo.reqwidth m
    and hf = Winfo.reqheight emb.embed_frame 
    and hm = Winfo.reqheight m
    in
    if wf < wm || hf < hm then begin
      bind emb.embed_frame [[], Enter] (BindExtend ([], (fun _ ->
    if wf < wm then
      Frame.configure emb.embed_frame [Width (Pixels wm)];
    if hf < hm then
      Frame.configure emb.embed_frame [Height (Pixels hm)])));
      bind emb.embed_frame [[], Leave] (BindExtend ([], (fun _ ->
    Frame.configure emb.embed_frame [Width (Pixels wf)];
    Frame.configure emb.embed_frame [Height (Pixels hf)])))
    end
*)
  end
@

<<function Imgload.make_auto>>=
(* for delayed load, add binding *)
let make_auto delayed emb =
  try
    let url = (Www.make emb.embed_hlink).www_url in
    bind emb.embed_frame
      (Glevents.get "loadimage")
      (BindSet ([], (fun _ -> Img.ImageScheduler.flush_one delayed url)))
  with
    e -> Log.f (sprintf "Can't compute image link (%s)" (Printexc.to_string e))
@

<<function Imgload.make_map>>=
(* If the object is clickable, make it visible *)

let make_map emb =
  let visible = [
    BorderWidth (Pixels (Tkresource.int "clickableBorderWidth" 2)); 
    Relief (Tkresource.relief "clickableRelief" Raised); 
    Cursor (XCursor (Tkresource.string "clickableCursor" "hand2"));
    Background (NamedColor (Tkresource.string "clickableBackground" "white"))]
  and visible_map = [
    BorderWidth (Pixels (Tkresource.int "clickableBorderWidth" 2)); 
    Relief (Tkresource.relief "clickableRelief" Raised); 
    Cursor (XCursor (Tkresource.string "clickableMapCursor" "left_ptr"));
    Background (NamedColor (Tkresource.string "clickableBackground" "white"))]
  in
  let reconfigure_frame f =
    let internal_width = try int_of_string (cget f CWidth) with _ -> 0 
    and internal_height = try int_of_string (cget f CHeight) with _ -> 0
    and border_width = try int_of_string (cget f CBorderWidth) with _ -> 0
    in
    if internal_width = 0 || internal_height = 0 then ()
    else
      Frame.configure f [ Width (Pixels (internal_width + border_width * 2));
              Height (Pixels (internal_height + border_width * 2))]
  in
  match emb.embed_map with
    ClientSide hlink ->
      Frame.configure emb.embed_frame visible_map;
      reconfigure_frame emb.embed_frame; 
     (* At this moment, we assume that we are in alt mode.
    If the image gets loaded, the label gets destroyed and
    the callback will never be invoked. Instead, it will
    be called from "display" *)
      begin try
       match Winfo.children emb.embed_frame with
    [l] when Winfo.class_name l = "Label" ->
      let uri = Hyper.resolve hlink in
      let name =
        match uri.uri_frag with 
          None -> uri.uri_url
        | Some frag -> sprintf "%s#%s" uri.uri_url frag in
      begin match Maps.get name with
        KnownMap m -> Cmap.alt_mode emb m l
      | RequestedMap event ->
         Frx_synth.bind l event 
         (fun l -> 
            match Maps.get name with
              RequestedMap _ -> Log.f 
             "INTERNAL ERROR: delayed_client_side"
            | KnownMap m -> Cmap.alt_mode emb m l)
      end
       | _ -> Log.f "make_map. children not a label"
      with
    _ -> ()
      end
  | ServerSide link ->
      Frame.configure emb.embed_frame visible;
      reconfigure_frame emb.embed_frame; 
      (new Htbind.servermap (emb.embed_frame, link))#init emb.embed_context
  | Direct link -> 
      Frame.configure emb.embed_frame visible;
      reconfigure_frame emb.embed_frame; 
      (new Htbind.directmap (emb.embed_frame, link))#init emb.embed_context
  | NoMap -> ()
  | FormMap getlink ->
      Frame.configure emb.embed_frame visible;
      reconfigure_frame emb.embed_frame; 
      (new Htbind.formmap (emb.embed_frame, getlink))#init emb.embed_context
@

<<function Imgload.create>>=
let create () =
   if !no_images then new loader ()
   else match !mode with
     DuringDoc -> (new synchronous () :> loader)
   | AfterDocAuto -> (new auto() :> loader)
   | AfterDocManual -> (new manual() :> loader)
@


%-------------------------------------------------------------

<<./display/imgload.ml>>=
open Printf
open Tk
open Tkanim
open Www
open Uri
open Hyper
open Maps
open Embed
open Img
open Viewers

<<type Imgload.mode (./display/imgload.ml)>>

<<constant Imgload.mode>>
<<constant Imgload.no_images>>
<<constant Imgload.gif_anim_auto>>

<<function Imgload.display>>

<<function Imgload.put_alt>>

<<function Imgload.make_auto>>

(* for manual load, add binding
let make_manual emb =
  try
    let url = (Www.make emb.embed_hlink).www_url in
    bind emb.embed_frame
      (Glevents.get "loadimage")
      (BindSet ([], (fun _ -> activate emb)))
  with
    e -> Log.f (sprintf "Can't compute image link (%s)" (Printexc.to_string e))
 *)

<<function Imgload.make_map>>


(* The default behavior *)
class loader () =
 object (self)
  val mutable loaded = UrlSet.empty

  method private add_loaded url = 
    loaded <- UrlSet.add url loaded

  method add_image emb =
    put_alt emb; (* make the alt widget*)
    make_map emb (* and possible bindings *)

  method private activate emb =
    Log.debug "Activating image";
    try
      Img.get emb.embed_context#base
    emb.embed_hlink
        (fun url i -> 
      display emb i;
      self#add_loaded url)
        (Tk_progress.meter emb.embed_frame)
    with
      e -> Log.f (sprintf "Can't load image (%s)" (Printexc.to_string e))

  method flush_images = ()
  method load_images = ()
  method update_images = 
    UrlSet.iter Img.update loaded
end

class synchronous () =
 object
  inherit loader () as super

  method add_image emb =
    super#add_image emb; super#activate emb
end

class auto () =
 object (self)
  inherit loader () as super
  val q = ImageScheduler.new_delayed()

  method add_image emb =
     super#add_image emb;
     try
       let wr = Www.make emb.embed_hlink in
       wr.www_headers <- "Accept: image/*" :: wr.www_headers;
       ImageScheduler.add_delayed q
     wr
     emb.embed_context#base
     (fun url i -> display emb i; self#add_loaded url)
     (Tk_progress.meter emb.embed_frame)
     with
       e -> Log.f (sprintf "Can't compute image link (%s)"
                   (Printexc.to_string e))

  method flush_images = ImageScheduler.flush_delayed q
end

class manual () =
 object
  inherit auto () as super

  method add_image emb =
    super#add_image emb;
    make_auto q emb
 
  method flush_images = ()

  method load_images = ImageScheduler.flush_delayed q
end

<<function Imgload.create>>

@


\subsection*{[[./display/html_form.mli]]}


%-------------------------------------------------------------

<<./display/html_form.mli>>=

class behaviour :
  string * Html.tag * string option * (string -> string) ->
  object
    val action : string
    val mutable elem_reset : (unit -> unit) list
    val mutable elem_value :
      (Htmlfmt.input_kind * (unit -> (string * string) list)) list
    val encoding : string
    val mutable entries : int
    val fmethod : string
    val h_params : (string * string) list
    method add_get :
      Htmlfmt.input_kind -> (unit -> (string * string) list) -> unit
    method add_reset : (unit -> unit) -> unit
    method reset : unit
    method single_submit : Hyper.link option
    method submit : (string * string) list -> Hyper.link
  end

module Make :
  functor (FormDisplay : Htmlfmt.FormDisplay) ->
    sig
      val init :
        < add_tag : string ->
                    (Htmlfmt.formatter -> Html.tag -> unit) ->
                    (Htmlfmt.formatter -> unit) -> unit;
          base : string; ctx : Viewers.context;
          i18n_encoder : string -> string;
          imgmanager : < add_image : Embed.embobject -> unit; .. >;
          pop_action : unit; push_action : (string -> unit) -> unit;
          remove_tag : string -> unit; target : string option; .. > ->
        unit
    end
@


\subsection*{[[./display/html_form.ml]]}


%-------------------------------------------------------------

<<./display/html_form.ml>>=
open Printf
open Hyper
open Www
open Html
open Htmlfmt


(*
 * Level 2 stuff (forms)
 *)

(* The behaviour of a form *)

class behaviour (base, formtag, deftarget, i18n_encoder) =
 object (self)
  val mutable (*private*) elem_value = ([] : (input_kind * (unit -> (string * string) list)) list)
  val mutable (*private*) elem_reset = ([] : (unit -> unit) list)
  val (*private*) fmethod = String.uppercase (get_attribute formtag "method")    
  val (*private*) encoding = get_attribute formtag "enctype"
  (* val i18n_encoder = i18n_encoder *)
  val (*private*) action = try get_attribute formtag "action" with Not_found -> base
  (* val base = base *)
  val (*private*) h_params = try ["target", get_attribute formtag "target"]
    with
      Not_found ->
    match deftarget with
      Some s -> ["target", s]
    | None -> []

  val mutable (*private*) entries = 0 (* number of text entries *)

  (* Contribute a value to the form *)
  method add_get kind f = 
    elem_value <- (kind, f) :: elem_value;
    if kind = EntryInput then  entries <- entries + 1

  (* How to reset the element *)
  method add_reset f = elem_reset <- f :: elem_reset

  (* The link for a given submit activation *)
  method submit l = 
    let values = List.flatten (List.map (function (_,f)  -> f()) elem_value) in
    let values = l @ values in
    (* These values must be encoded in the same Kanji code of the source here,
     * if it is Japanese mode. And the difficulty is the Kanji code of the
     * document is usually lazily determined. --- JPF 
     *)
    let values_i18n = List.map (fun (t,v) -> t, i18n_encoder v) values in
    let evalues = Urlenc.form_encode (List.rev values_i18n) in
     match fmethod with
       "POST" -> {h_uri = action;
          h_context = Some base;
          h_method = POST evalues;
          h_params = h_params
                 }
     | _ -> 
       let uri = 
         let l = String.length action in 
         if l = 0 then sprintf "?%s" evalues
     else if action.[l-1] = '?' then action ^ evalues
         else sprintf "%s?%s" action evalues
       in
            {h_uri = uri;
             h_context = Some base;
         h_method = GET;
         h_params = h_params}

  (* Submit if only one entry in the form. This may not be the proper test. *)
  method single_submit =
    if entries = 1 then Some (self#submit []) else None

  (* Resetting the form *)
  method reset = List.iter (fun f -> f ()) elem_reset

end

module Make(FormDisplay : FormDisplay) = 
 struct
  open FormDisplay
(*
 * <!ELEMENT FORM - - %body.content -(FORM)>
 * <!ATTLIST FORM
 *         action %URL #REQUIRED -- server-side form handler --
 *         method (%HTTP-Method) GET -- see HTTP specification --
 *         enctype %Content-Type; "application/x-www-form-urlencoded"
 *         >
 *)


let init mach =
mach#add_tag "form"
 (fun fo tform ->
  let behav = new behaviour (mach#base, tform, mach#target, mach#i18n_encoder)
  in
  let fm = FormDisplay.create mach#base behav mach#ctx in

  (* 8.1.2 Input Field : INPUT *)
  let open_input fo t =
    let inputtype = String.uppercase (get_attribute t "type") in
    (* Special case for hidden, since there is no formatting *)
    (* HTML 3.2 doesn't specify that NAME and VALUE are required, but
       this is stupid *)
    if inputtype = "HIDDEN" then
    begin try 
      let name = get_attribute t "name" in
      let v = get_attribute t "value" in
            behav#add_get OtherInput (fun () -> [name, v])
    with
      Not_found -> 
         raise (Invalid_Html "missing NAME or VALUE in input HIDDEN")
        end
    else (* Other cases *)
      let fr = fo.create_embedded (get_attribute t "align") None None in
       match inputtype with
      "TEXT" | "PASSWORD" ->  fm.text_input fr t
        | "CHECKBOX" -> fm.checkbox_input fr t
        | "RADIO" -> fm.radio_input fr t
        | "IMAGE" -> mach#imgmanager#add_image (fm.image_input fr t)
        | "SUBMIT" -> fm.submit_input fr t
        | "RESET" -> fm.reset_input fr t
    (* TODO: file *)
        | s -> raise (Invalid_Html ("Invalid INPUT TYPE="^s))
  in
  mach#add_tag "input" open_input (fun _ -> ());

  (* 8.1.3 Selection : SELECT *)
  (* the /SELECT does all the job, so we have to transmit the info ! *)
  let options = ref []       (* the components from which to select *)
  and tselect = ref {tag_name = "select"; attributes = []}
  in
  let open_select fo t =
    options := [];
    tselect := t;
    mach#add_tag "option"
       (fun fo tag ->
      mach#push_action 
           (fun s ->
           let s = beautify2 s in
           (* the val is by default the "content" of the tag *)
               let va = try get_attribute tag "value" with Not_found -> s in
           options := (va, s,
                          has_attribute tag "selected") :: !options;
           ))
       (fun _ -> mach#pop_action)
  and close_select fo =
    mach#remove_tag "option";
    let fr = fo.create_embedded (get_attribute !tselect "align") None None in
       fm.select fr (List.rev !options) !tselect
  in

  mach#add_tag "select" open_select close_select;

  (* 8.1.4 Text Area: TEXTAREA *)
  let textarea_initial = Ebuffer.create 128 
  and ttextarea = ref {tag_name = "textarea"; attributes = []} in
  let open_textarea fo tag =
    ttextarea := tag;
    Ebuffer.reset textarea_initial;
    mach#push_action (fun s -> Ebuffer.output_string textarea_initial s)
  and close_textarea fo =
    mach#pop_action;
    let name = get_attribute !ttextarea "name" in
    let fr = 
      fo.create_embedded (get_attribute !ttextarea "align") None None in
        fm.textarea fr (Ebuffer.get textarea_initial) !ttextarea

  in

  mach#add_tag "textarea" open_textarea  close_textarea
  )

(function fo -> List.iter mach#remove_tag ["input"; "select"; "textarea"])

end
@


\subsection*{[[./display/htmlw.mli]]}

<<signature Htmlw.frames_as_links>>=
val frames_as_links : bool ref
@

<<signature Htmlw.pscrolling>>=
val pscrolling : bool ref
@

<<signature Htmlw.ignore_meta_charset>>=
val ignore_meta_charset : bool ref
@

<<signature Htmlw.progress_report>>=
val progress_report : 
    Widget.widget -> Viewers.context -> Widget.widget * Scheduler.progress_func
@

<<signature Htmlw.html_head_ui>>=
val html_head_ui :
    string list -> (unit -> unit) -> bool ref -> Widget.widget ->
      Viewers.context ->
    Widget.widget * (string -> unit) * (string -> Hyper.link -> unit) *
    (string -> string -> unit) * ((Widget.widget -> unit) -> unit)
(* [html_head_ui headers redisplay scrollmode top ctx]
   returns 
   hgroup, set_title, add_link, add_header, add_extra_header
*)
@

<<signature Htmlw.display_html>>=
(* [html_head_ui headers redisplay scrollmode top ctx]
   returns 
   hgroup, set_title, add_link, add_header, add_extra_header
*)

val display_html :
  Http_headers.media_parameter list ->
  Widget.widget ->
  Viewers.context -> Document.handle -> Viewers.display_info option
@


%-------------------------------------------------------------

<<./display/htmlw.mli>>=

<<signature Htmlw.frames_as_links>>
<<signature Htmlw.pscrolling>>
<<signature Htmlw.ignore_meta_charset>>

class  virtual viewer_globs : (Viewers.context * Document.handle) -> object
  (* val ctx : Viewers.context *)
  val mutable dh : Document.handle
  val did : Document.document_id
  method ctx : Viewers.context
  method dh : Document.handle
  method did : Document.document_id
end

<<signature Htmlw.progress_report>>

<<signature Htmlw.html_head_ui>>
<<signature Htmlw.display_html>>
@


\subsection*{[[./display/htmlw.ml]]}

<<constant Htmlw.frames_as_links>>=
(* Prefs globals *)
let frames_as_links = ref false
@

<<constant Htmlw.pscrolling>>=
let pscrolling = ref false
@

<<constant Htmlw.ignore_meta_charset>>=
let ignore_meta_charset = ref false
@

<<constant Htmlw.scroll_icon>>=
let scroll_icon ="
#define mini-scroll-arrows_width 16
#define mini-scroll-arrows_height 14
static char mini-scroll-arrows_bits[] = {
 0x80,0x00,0xc0,0x01,0xc0,0x01,0xe0,0x03,0xf0,0x07,0xf0,0x07,0x00,0x00,0x00,
 0x00,0xf0,0x07,0xf0,0x07,0xe0,0x03,0xc0,0x01,0xc0,0x01,0x80,0x00};
"
@

<<constant Htmlw.scroll_image>>=
let scroll_image = 
@

<<function Htmlw.progress_report>>=
(* Builds the progress report and pointsto zone.
 * Adds ctx nav function for pointsto
 *)
let progress_report top ctx =
  let f = Frame.create_named top "progress" [] in
  let pointstov = Textvariable.create_temporary f in
  let pointsto = Textvariable.set pointstov in
  let lpoint = 
    Label.create_named f "pointsto" [TextVariable pointstov; Anchor W]
  and fprog = Frame.create_named f "fr" [Width (Pixels 200); Height (Pixels 5)]
  in
  (* progress meter requires an alt widget, but we don't have to pack it *)
  let fakealt = Label.create_named fprog "alt" [] in
  pack [fprog][Side Side_Left];
  pack [lpoint][Side Side_Left; Fill Fill_X];
  (* hack to avoid lpoint forcing the navigator to grow like hell *)
  Frame.configure f
    [ Width (Pixels (Winfo.reqwidth (Winfo.toplevel f)));
      Height (Pixels (Winfo.reqheight lpoint))];
  Pack.propagate_set f false;

  ctx#add_nav ("pointsto" ,
           { hyper_visible = false;
         hyper_title = "Show target";
         hyper_func = (fun _ h -> 
           let target = 
             try Hyper.string_of h
             with Invalid_link msg -> "invalid link" in
           pointsto target)});
  ctx#add_nav ("clearpointsto" ,
           { hyper_visible = false;
         hyper_title = "Clear target";
         hyper_func = (fun _ h -> pointsto "")
           });
  
  f, Tk_progress.meter fprog
@

<<function Htmlw.html_head_ui>>=
let html_head_ui headers redisplay pscroll top ctx =
  (* The frame for all head UI elements *)
  let headgroup = Frame.create_named top "head" [] in
  (* The menubar frame *)
  let bargroup = Frame.create_named headgroup "menubar" [] in
  let titlev = Textvariable.create_temporary headgroup in

  let headersb = Menubutton.create_named bargroup "headers" 
      [TextVariable titlev; TextWidth 80]
  in
  let headersm = Menu.create_named headersb "menu" [] in
  Menubutton.configure headersb [Menu headersm];

  (* The link button and menu *)
  let linkb = 
    Menubutton.create_named bargroup "links" [Text "Links"; State Disabled] in
  let linkmenu = Menu.create_named linkb "linkmenu" [] in
  Menubutton.configure linkb [Menu linkmenu];

  (* The scroll-mode button *)
  let scrollv = Textvariable.create_temporary bargroup in
  Textvariable.set scrollv 
      (if !pscroll then "1" else "0");
  let scrollb = 
    Checkbutton.create_named bargroup "smoothScroll" 
      [ Variable scrollv; Lazy.force scroll_image;
    IndicatorOn false; Command (fun () ->
      match Textvariable.get scrollv with
        "1" -> pscroll := true; redisplay()
      | _ -> pscroll := false; redisplay())]
  in
  (* bargroup IN THIS ORDER -- RESIZING *)
  pack [linkb][Side Side_Right];
  pack [scrollb][Side Side_Right; Fill Fill_Y];
  pack [headersb][Side Side_Left; Fill Fill_X; Expand true];
  pack [bargroup][Side Side_Top; Fill Fill_X];

  let set_title t =
    let tl = Winfo.toplevel top
    and title = I18n.sprintf "MMM Browser@%s" t in
    if Widget.known_class tl = "toplevel" then
      (Wm.title_set tl title; Wm.iconname_set tl title);
    Textvariable.set titlev t

  and add_link title hlink = 
    Menubutton.configure linkb [State Normal];
    Menu.add_command linkmenu [ Label title; 
                Command (fun () -> ctx#goto hlink)]
      
  in
  
  (* Extra headers: META tags should be parsed by *servers*, not by clients.
     TODO: find interface so we can export this feature to applets/modules
     *)
  let sep_added = ref false in
  let add_header h v =
    if not !sep_added then (sep_added := true; Menu.add_separator headersm);
    let txt = sprintf "%s: %s" h v in
    match String.lowercase h with
      "refresh" ->
       begin try
          let pos = String.index v ';'
          and pos2 = String.index v '=' in
          let delay = int_of_string (String.sub v 0 pos)
          and url = String.sub v (pos2+1) (String.length v - pos2 - 1) in
      Menu.add_command headersm 
        [Label txt;
          Command (fun () -> ctx#goto {
        h_uri = url;
        h_context = Some (Url.string_of ctx#base.document_url);
        h_method = GET;
            h_params = []})]
    with Not_found | Failure "int_of_string" -> ()
    end
    | _ -> Menu.add_command headersm [Label txt] 

  in
  (* the head menu is a good place to put some other information and ui *)
  (* you must be sure that this function is used after all the head ui
   * stuff using add_header are finished. 
   *)  
  let sep_extra_added = ref false in 
  let add_extra_header f =
    if not !sep_extra_added then
       (sep_extra_added := true; Menu.add_separator headersm);
    f headersm
  in

  set_title (Url.string_of ctx#base.document_url);
  List.iter (function h -> Menu.add_command headersm [Label h])
    (List.rev headers);
  
  headgroup, set_title, add_link, add_header, add_extra_header
@

<<function Htmlw.ignore_open>>=
(*
 * Extend a display machine to interpret HEAD elements with
 * an influence on the HEAD ui display.
 * NOTE: some other HEAD elements interpretation *must* be done
 * even if we don't have UI for HEAD (e.g. base)
 *)
let ignore_open _ _ = ()
@

<<function Htmlw.ignore_close>>=
let ignore_close _ = ()
@

<<function Htmlw.head_hook>>=
let head_hook (headgroup,set_title,add_link,add_header) mach =
  mach#add_tag "title" 
    (fun fo t ->
      mach#push_action
    (fun s -> 
      set_title (Html.beautify2 s);
      mach#pop_action))
    ignore_close;
      
  mach#add_tag "isindex"
    (fun fo tag ->
      let prompt = get_attribute tag "prompt" in
      let action s =
    mach#ctx#goto { h_uri = "?" ^ Urlenc.encode s;
               h_context = Some mach#base;
               h_method = GET;
               h_params = []} in
      let f,e = Frx_entry.new_label_entry headgroup prompt action in
      pack [f] [Fill Fill_X])
    ignore_close;

  mach#add_tag "link"
    (fun fo tag ->
      try
        let href = get_attribute tag "href" in
    let name = 
      try get_attribute tag "title"
      with Not_found ->
        try get_attribute tag "rel"
        with Not_found -> 
          try get_attribute tag "rev"
          with Not_found -> href in
    let h_params =
      try ["target", get_attribute tag "target"]
      with
        Not_found ->
          match mach#target with
        Some s -> ["target", s]
          |	None -> []
        in
        add_link name { h_uri = href; h_context = Some mach#base;
            h_method = GET; h_params = h_params}
      with
    Not_found -> () (* no href *))
    ignore_close;

  begin
    let old =
      try
    let oldo, c = mach#get_tag "meta" in oldo
      with
    Not_found -> ignore_open in
    mach#add_tag "meta"
      (fun fo tag ->
       try 
      old fo tag;
      add_header 
        (get_attribute tag "http-equiv")
        (get_attribute tag "content")
       with Not_found -> ())
      ignore_close;
  end;

  (* Non standard extensions *)
  if !frames_as_links  then
    mach#add_tag "frame"
      (fun fo tag ->
    try
         let src = get_attribute tag "src" in
         let name =
        sprintf "Frame %s" 
          (try get_attribute tag "name"
          with Not_found -> "unnamed")
      in
      add_link name { h_uri = src; h_context = Some mach#base;
              h_method = GET; h_params = []}
    with
      Not_found -> () (* no src *))
      ignore_close
@

<<function Htmlw.display_html>>=
let display_html mediapars top ctx dh =
  let imgmanager = Imgload.create() in
  let viewer = new display_html (top,ctx,mediapars,imgmanager,dh) in
  viewer#init true;
  Some (viewer :> Viewers.display_info)
@

<<function Htmlw.embedded_html>>=
(* TODO: we should be able to share the imgmanager, but I don't see
 *  where we can get it from (except by adding something in ctx)
 *)
let embedded_html mediapars top ctx doc =
  let imgmanager = Imgload.create() in
  let dh = Decoders.insert (Cache.make_embed_handle doc) in
  let ctx = ctx#in_embed dh.document_id in
  let viewer = new display_html (top,ctx,mediapars,imgmanager,dh) in
  viewer#init false;
  pack [viewer#di_widget][Expand true; Fill Fill_Both];
  (* set for events *)
  Frx_synth.bind viewer#di_widget "load_images" 
    (fun top -> viewer#di_load_images);
  Frx_synth.bind viewer#di_widget "update" 
    (fun _ -> Embed.update top ctx doc (fun () -> viewer#di_update))
@

<<toplevel Htmlw._1>>=
let _ =
  Viewers.add_builtin ("text","html") display_html;
  Embed.add_viewer ("text", "html") embedded_html
@


%-------------------------------------------------------------

<<./display/htmlw.ml>>=
open Printf
open Tk
open Html
open Html_eval
open Hyper
open Document
open Viewers
open Htmlfmt
open Feed
open Embed
open Htframe

<<constant Htmlw.frames_as_links>>
<<constant Htmlw.pscrolling>>
<<constant Htmlw.ignore_meta_charset>>

<<constant Htmlw.scroll_icon>>

<<constant Htmlw.scroll_image>>
  lazy (ImageBitmap(Imagebitmap.create [Data scroll_icon]))

module F = Html_disp.Make(Textw_fo)(Form)(Table)

<<function Htmlw.progress_report>>

<<function Htmlw.html_head_ui>>


<<function Htmlw.ignore_open>>
<<function Htmlw.ignore_close>>

<<function Htmlw.head_hook>>

(* This class only defines globals *)
class  virtual viewer_globs ((ctx : Viewers.context),
                (dh' : Document.handle)) =
 object

  (* copy params *)
  (* val ctx = ctx *)           
  method ctx = ctx

  val mutable dh = dh'
  method dh = dh

  val did = dh'.document_id
  method did = did
end

(* We still need dh at construction for the definition of feed_red *)
class  virtual html_parse (dh) =
 object (self)
  (* red tape for progress report *)
  val mutable red = 0
  val mutable size = try Some (Http_headers.contentlength dh.document_headers)
    with Not_found -> None (* duh *);
  val mutable feed_read = new Japan.read_i18n (fun s o n -> 0)

  val mutable (*private*) lexbuf = Lexing.from_string "" (* duh *)
  method lexbuf = lexbuf  

  val mutable lexer = sgml_lexer !Dtd.current

  (* Japanese parse configuration *)
  val jpn_config = Japan.default_config ()

  method parse_init =
    red <- 0;
    feed_read <-
       (*
       if !Lang.japan 
       then Japan.create_read_japanese self#dh.document_feed.feed_read jpn_config
       else 
       *)
       Japan.create_read_native self#dh.document_feed.feed_read;
    (* Q: do we need to restart a new sgml_lexer ? *)
    lexer <- sgml_lexer !Dtd.current;
    lexbuf <- 
       Lexing.from_function (fun buf n -> 
     let r = feed_read#read buf 0 n in
     red <- red + r;
     self#set_progress size red;
     r)
end

class  virtual html_body () =
 object (self)

  method virtual mach : Html_disp.machine

  val current_scroll_mode = ref !pscrolling
  method current_scroll_mode = current_scroll_mode

  (* hack for frames on incorrect html *)
  val mutable body_frame = None
  method body_init full =
    (* Install a tag handler for body that will actually create the
       a formatter and install it *)
    let body_formatter = ref None in
    self#mach#add_tag "body" 
      (fun fo t ->
    match !body_formatter with
    | None -> (* it's the first body *)
        let format, fhtml = 
          self#mach#create_formatter 
           (if full then (TopFormatter !current_scroll_mode) 
           else FrameFormatter self#ctx#params)
           self#frame
        in
        self#mach#push_formatter format;
        body_formatter := Some format;
        body_frame <- Some fhtml;
        pack [fhtml][Side Side_Left; Expand true; Fill Fill_Both];
         List.iter (function
          | "bgcolor", color -> 
             format.set_defaults "background" [BgColor color]
          | "text", color -> 
          format.set_defaults "foreground" [FgColor color]
          | "link", color ->
          format.set_defaults "link" [FgColor color]
          | "alink", color ->
          format.set_defaults "alink" [FgColor color]
          | "vlink", color ->
          format.set_defaults "vlink" [FgColor color]
          | _,_ -> ())
             t.attributes
    | Some f -> (* multiple body... *)
        self#mach#push_formatter f
     )
      (fun t -> 
    ignore self#mach#pop_formatter)
end

(* geek stuff *)
class  virtual bored () =
 object (self)
  method bored_init hgbas =
    let bored = 
      Resource.get Widget.default_toplevel "bored" "bored" = "yes"
    || begin try
       ignore (
         Str.search_forward (Str.regexp_case_fold "sandra") self#mach#base 0);
       Resource.add "*bored" "yes" Interactive;
       true
    with Not_found -> false
    end in
    if bored then begin
      let b = Button.create hgbas [
       Text "\182"; BorderWidth (Pixels 0);
       Command (fun () ->
      self#ctx#goto {
      h_uri = "http://www.columbiatristar.co.uk/the_net/contents.html";
      h_context = None;
      h_method = GET;
      h_params = []})] in
      let l  = Winfo.children hgbas in
      pack [b][After (List.hd l); Side Side_Right]
    end

end

class display_html ((top : Widget.widget),
            (ctx : Viewers.context),
            (mediapars : (string * string) list),
            imgmanager,
            dh') =
 object (self)
  inherit Viewers.display_info () as di  (* gives us basic features *)
  inherit viewer_globs (ctx, dh')
  inherit html_parse (dh')
  inherit html_body () as body
  inherit bored ()

  val frame = if not (Winfo.exists top) then failwith "too late"
    else Frame.create_named top (Mstring.gensym "html") [Class "Html"]
      (* this might as well fail if the window was destroyed before we
     finally could get the headers of the document.
     *)
  method frame = frame

  (* val imgmanager = imgmanager *)
  val mutable mach = F.create (ctx, imgmanager)
  method mach = mach

  val mutable init_mode = true
  val mutable pending = true

  (* [finish abort?] *)
  val mutable (*private*) terminated = false
  method finish abort =
    if not terminated then begin
      terminated <- true;
      ctx#log (if abort then "Aborted" else "");
      dclose true dh
    end;
    (* This has to happen even if we already finished displaying the document *)
    if abort then begin
      Img.ImageScheduler.stop dh.document_id;
      Embed.EmbeddedScheduler.stop dh.document_id
      (* TODO we should also require embedded objects to abort *)
    end;

  (* error reporting *)
  val (*private*) errors = ref []
  method record_error loc msg =
    errors := (loc,msg) :: !errors;
    self#set_progress size (-1)

  (* progress report *)
  val mutable set_progress = Progress.no_meter
  method set_progress = set_progress
      
  val (*private*) annotations = ref []
  method annotate loc = function
    | OpenTag {tag_name=name} ->
    annotations := (name, loc) :: !annotations
    | CloseTag name ->
    annotations := (name, loc) :: !annotations
    | _ -> ()

  val mutable add_extra_header = fun f -> ()
  method add_extra_header = add_extra_header

  (* to redisplay, we have to destroy all widgets, then restart, except
     that we don't use the initial feed, but rather the cache *)
  method redisplay =
    if pending then 
      !Error.default#f (I18n.sprintf "Cannot redisplay document (pending)")
    else
      try
       dh <- Decoders.insert (Cache.renew_handle dh);
       List.iter destroy (Winfo.children frame);
       self#init init_mode
      with
       Not_found ->
      !Error.default#f (I18n.sprintf "Document not in cache anymore")

  (* The source is attached to this frame so we can destroy the interior
     widgets *)
  method source =
    if pending then
      !Error.default#f (I18n.sprintf "Cannot view document source (pending)")
    else Source.view frame did (fun () -> self#redisplay) errors annotations
           feed_read#get_code

  val mutable title = Url.string_of ctx#base.document_url

  method load_frames frames =
    (* all targets defined in all framesets in this document *)
    let targets = 
      List.map (function frdesc, w -> frdesc.frame_name, w) frames
    in
      List.iter (function (frdesc, w) ->
    let thistargets =
      ("_self", w) (* ourselves *)
      :: ("_parent", Winfo.parent w) (* our direct parent *)
      :: targets (* common targets *)
    in
    let ectx = ctx#for_embed frdesc.frame_params thistargets in
    (* add frame parameters and targets to our ctx *)
    (* NOTE: there is a redundancy between embed_frame and _self in ctx,
       but frames are only an instance of embedded objects so we should
       no rely on the existence of _self for embed display machinery *)
    mach#add_embedded {
    embed_hlink = { h_uri = frdesc.frame_src;
                h_context = Some (Url.string_of ctx#base.document_url);
            h_method = GET;
            h_params = []};
    embed_frame = w;
    embed_context = ectx;
    embed_map = Maps.NoMap;
    embed_alt = frdesc.frame_name
      }	)
      frames

  (* flag for JP force redraw *)
  val mutable force_redrawable = true (* this must not be initialized *)

  (* since we may be called multiple times, we have to clear some of the
     instance variables *)
  method init full =
    let meta_charset = ref None in
    errors := []; annotations := []; terminated <- false; pending <- true;
    set_progress <- Progress.no_meter;
    init_mode <- full;
    mach <- F.create (ctx, imgmanager);
    
    (* <META HTTP-EQUIV="Content-Type" CONTENT="*/*;CHARSET=*"> stuff *)
    if not !ignore_meta_charset then begin 
      mach#add_tag "meta"
   (fun fo tag ->
     try 
       let h = get_attribute tag "http-equiv"
       and v = get_attribute tag "content"
       in
       match String.lowercase h with
         "content-type" ->
    begin try
      let (t,h), l = Lexheaders.media_type v in
      if String.lowercase t <> "text" ||
         String.lowercase h <> "html" then begin
           Log.f ("Unknown meta content-type = "^t^"/"^h);
           raise Exit
         end;
      try 
        List.iter (fun (h,v) ->
          if String.lowercase h = "charset" then begin
     let v = String.lowercase v in
     Log.f ("MetaCharset detect : " ^ v);
     begin try
              let code = 
                let code = ref Japan.Unknown in
                try List.iter (fun (x,c) -> 
                  if Str.string_match (Str.regexp x) v 0 then begin
                code := c;
                raise Exit
                  end) Japan.encode_table ;
                  raise Not_found
                with
                  Exit -> !code
              in
       (* feed_read#set_code code; this does not work... *)
              meta_charset := Some code
     with
       Not_found ->
         Log.f (v ^ ": I don't know this charset")
     end;
     raise Exit
          end) l;
      with
        Exit -> ()
    with
      _ -> () (* if failed to parse, ignore it *)
    end
       | _ -> ()
     with Not_found -> ())
   ignore_close
    end;

    (* We have full display, so put up progress report and head UI *)
    if full then begin 
      let hgbas, progf = progress_report frame ctx in
      set_progress <- progf;
      self#bored_init hgbas;
      pack [hgbas] [Side Side_Bottom; Fill Fill_X];
      let headgroup, set_title, add_link, add_header, add_ext_header =
    html_head_ui dh.document_headers (fun () -> self#redisplay) 
      self#current_scroll_mode frame ctx
      in
      add_extra_header <- add_ext_header;
      pack [headgroup] [Side Side_Top; Fill Fill_X];
      let set_title s = title <- s; set_title s in
      head_hook (headgroup, set_title, add_link, add_header) self#mach
    end;
    self#body_init full;
    if not !frames_as_links then
      Htframe.add_frames (self#load_frames) 
    (fun () ->
      match body_frame with
        None -> ()
      | Some f -> destroy f)
    frame mach;
    (* Asynchronous parsing and display, token by token *)
    self#parse_init;

    (* I18n encoder for Forms *)
    (*
    if !Lang.japan then begin
      mach#set_i18n_encoder (fun s -> Japan.encoder feed_read#get_code s)
    end;
    *)

    (* EOF Flags for JP *)
    let eof = ref 0 in
    dh.document_feed.feed_schedule (fun () ->
      try 
       let warnings, correct, tokens, loc = lexer self#lexbuf in
       List.iter (fun (reason, pos) -> 
      self#record_error (Loc(pos,succ pos)) reason)
      warnings;
       begin match correct with
       | Legal -> ()
       | Illegal reason -> self#record_error loc reason
       end;
    (* We annotate only the last token, which is normally the one
       from the original token stream *)
    let rec annot_last = function
      | [] -> ()
      | [x] -> self#annotate loc x
      | x::l -> annot_last l
    in
    annot_last tokens;
       List.iter 
      (function token -> 
        begin try mach#send token
        with Invalid_Html s -> self#record_error loc s
        end;
        if token = EOF then begin
          pending <- false;
          imgmanager#flush_images;
          raise End_of_file
        end)
      tokens
      with End_of_file ->
      (*
      (* I don't know why but in some cases we have more than 1 EOF *)
      if !Lang.japan && full && !eof = 0 then begin
        (* We should bind for each frames... *)
        let default = [
          (fun c -> 
        force_redrawable <- false;
        Japan.change_to_jis c), "iso-2022-jp", [
            [Control], KeyPressDetail "k"; 
            [Control], KeyPressDetail "j"];
          (fun c ->
        force_redrawable <- false;
        Japan.change_to_iso8859 c), "iso-8859", [
            [Control], KeyPressDetail "k"; 
            [Control], KeyPressDetail "l"];
          (fun c ->
        force_redrawable <- false;
        Japan.change_to_euc c), "euc-jp", [
            [Control], KeyPressDetail "k"; 
            [Control], KeyPressDetail "e"];
          (fun c ->
        force_redrawable <- false;
        Japan.change_to_sjis c), "sjis", [
            [Control], KeyPressDetail "k"; 
            [Control], KeyPressDetail "s"];
          (fun c ->
        force_redrawable <- true;
        Japan.change_to_autodetect c), "autodetect", [
            [Control], KeyPressDetail "k"; 
            [Control], KeyPressDetail "a"]]
        in
        let my_own = List.map (fun (f,i,devnt) ->
          f,i,Tkresource.event_sequence ("ChangeEncoding-"^i) devnt)
            default
        in
        (* Heck, this does not work... Key binds for frames... *)
        (* We have to think about key bindings for each frames. (JPF) *)
        (* List.iter (fun (f,_,evnt) ->
          bind frame evnt (BindSetBreakable ([], fun _ -> 
        f jpn_config; self#redisplay; break())))
              my_own;
           *)
        self#add_extra_header (fun p ->
          let encodingmenu = Menu.create_named p "encodingmenu" [] in
          List.iter (fun (f,i,evnt) ->
        Menu.add_command encodingmenu [ 
          Label i; Command (fun () -> 
            f jpn_config;
            self#redisplay) (*;
              Accelerator (Tkresource.short_event_sequence evnt)*) ])
                my_own;
          Menu.add_cascade p [
            Menu encodingmenu;
            Label ("Document encoding: " ^ 
               try 
                 List.assoc feed_read#get_code 
                          Japan.detected_code_names
               with
             Not_found -> "???")])
      end;
      *)
      self#set_progress (Some red) red;
         self#finish false;
      mach#see_frag dh.document_fragment;
      (*
      if !Lang.japan && !meta_charset <> None then begin
        match !meta_charset with
            | None -> assert false
            | Some meta_charset ->
               if Japan.Code meta_charset <> feed_read#get_code && 
                 force_redrawable 
               then begin
                    force_redrawable <- false;
                    (match meta_charset with
                      Japan.JIS -> Japan.change_to_jis jpn_config 
                    | Japan.SJIS -> Japan.change_to_sjis jpn_config 
                    | Japan.EUC -> Japan.change_to_euc jpn_config 
                    | Japan.ISO8859 -> Japan.change_to_iso8859 jpn_config 
                    | _ -> ());
                    self#redisplay
                  end
      end;
      *)
      incr eof
      | Html_Lexing (s,n) ->
          (* this should not happen if Lexhtml was debugged *)
      self#record_error (Html.Loc(n,n+1)) s
      | Unix.Unix_error(_,_,_) ->
      self#finish true
      | e ->
          Log.f (sprintf "FATAL ERROR (htmlw) %s" (Printexc.to_string e));
      self#finish true
        )

  (* What is exported ? *)
  method di_widget = frame
  method di_abort = self#finish true
  method di_destroy = if Winfo.exists frame then destroy frame;
  method di_title = title
  method di_fragment = mach#see_frag
  method di_redisplay = self#redisplay
  method di_source = self#source
  method di_load_images = 
    (* load our images *)
    imgmanager#load_images;
    (* Recursively, for all embedded objects, send the load_images event *)
    (* Because we work on the children of the frame, the *currently* 
       displayed document in this frame gets the event *)
    (* NOTE: because of textvariable handlings, we can NOT send the
       event again during the processing of the event... *)
    Frx_after.idle (fun () ->
    List.iter (fun {embed_frame = f} ->
      List.iter (Frx_synth.send "load_images") (Winfo.children f))
      mach#embedded)
  method di_update =
    imgmanager#update_images;
    Frx_after.idle (fun () ->
    List.iter (fun {embed_frame = f} ->
      List.iter (Frx_synth.send "update") (Winfo.children f))
      mach#embedded)
end
      
<<function Htmlw.display_html>>

<<function Htmlw.embedded_html>>

<<toplevel Htmlw._1>>

@


\subsection*{[[./display/form.mli]]}

<<signature Form.form_bg>>=
val form_bg : string ref
@

<<type Form.t>>=
type t = {
  text_input : Widget.widget -> Html.tag -> unit;
      (* [text_input top tag] *)
  checkbox_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  radio_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  image_input : Widget.widget ->  Html.tag -> Embed.embobject;
      (* [input top tag] *)
  submit_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  reset_input : Widget.widget ->  Html.tag -> unit;
      (* [input top tag] *)
  select : Widget.widget -> (string * string * bool) list -> Html.tag -> unit;
      (* [select top elements tag] *)

  textarea:  Widget.widget -> string -> Html.tag -> unit
      (* [textarea top initial attrs] *)
}
@

<<signature Form.create>>=
val create: 
  string -> Htmlfmt.form_behaviour -> Viewers.context -> t
@


%-------------------------------------------------------------

<<./display/form.mli>>=

<<signature Form.form_bg>>

<<type Form.t>>

<<signature Form.create>>

@


\subsection*{[[./display/form.ml]]}

<<constant Form.form_bg>>=
let form_bg = ref "#d9d9d9"
@

<<type Form.t (./display/form.ml)>>=
type t = {
  text_input : Widget.widget -> tag -> unit;
      (* [text_input top tag] *)
  checkbox_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  radio_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  image_input : Widget.widget ->  tag -> embobject;
      (* [input top tag] *)
  submit_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  reset_input : Widget.widget ->  tag -> unit;
      (* [input top tag] *)
  select : Widget.widget -> (string * string * bool) list -> tag -> unit;
      (* [select top elements tag] *)
  textarea:  Widget.widget -> string -> tag -> unit
      (* [textarea top initial attrs] *)
  }
@

<<function Form.mapi>>=
(* mapi (fun n x -> ...) n0 l *)
let rec mapi f n l =
  match l with
    [] -> [] 
  | x::l -> let v = f n x in v::(mapi f (succ n) l)
@

<<function Form.focus_link>>=
(* Do our own Tab/Shift-Tab : don't call it for Text widgets ! *)
let focus_link prev w =
  match !prev with
    None -> prev := Some w;
  | Some old ->
      bind old [[], KeyPressDetail "Tab"]
       (BindSetBreakable ([], fun ei -> try Focus.set w with _ -> ()));
      bind w [[Shift], KeyPressDetail "Tab"]
       (BindSetBreakable ([], fun ei -> try Focus.set old with _ -> ()));
      prev := Some w
@

<<function Form.text_input>>=
(* TODO: MAXLENGTH *)
let text_input prev_widget ctx behav top tag =
  try
    let name = get_attribute tag "name"
    and inputtype = get_attribute tag "type" in
    (* Create an entry widget : don't take focus unless we click in it *)
    let e = Entry.create top [ExportSelection false; TakeFocus false; 
                  Background (NamedColor !form_bg)] in
    (* Check for size *)
    begin try 
     let s = get_attribute tag "size" in
      try Entry.configure e [TextWidth (int_of_string s)]
      with Failure "int_of_string" ->
     Log.f (sprintf "%s not a valid val for SIZE" s)
    with Not_found -> ()
    end;
    (* Check for passwd *)
    if String.lowercase inputtype = "password" then 
      Entry.configure e [Show '*'];
    (* The behaviours *)
    let reset = 
      try
    let v = get_attribute tag "value" in
     Entry.insert e End v;
     (fun () -> Entry.delete_range e (Number 0) End;
            Entry.insert e End v)
      with Not_found ->
     (fun () -> Entry.delete_range e (Number 0) End)
    (* spec says we could omit if empty *)
    and get_value () = [name, Entry.get e]
    in
      focus_link prev_widget e;
      pack [e][];
      behav#add_get EntryInput get_value;
      behav#add_reset reset;
     (* single-entry : enter submits the form *)
      Tk.bind e [[], KeyPressDetail "Return"] 
         (BindSet ([], (fun _ -> 
       match behav#single_submit with
         Some h -> ctx#goto h
       | None -> ())))
  with
    Not_found ->
      raise (Invalid_Html "Missing NAME in TEXT or PASSWORD")
@

<<function Form.checkbox_input>>=
(* A CHECKBOX input *)
let checkbox_input prev_widget behav top tag =
  try
    let name = get_attribute tag "name" in
    let v = Textvariable.create_temporary top in  (* variable val is 1/0 *)
    let c = Checkbutton.create top [Variable v; TakeFocus false] in
    let reset =
      if has_attribute tag "checked" then begin
    Checkbutton.select c;
    (fun () -> Checkbutton.select c)
    end
      else (fun () -> Checkbutton.deselect c)
    and get_value =
      let value = 
    try get_attribute tag "value" 
    with Not_found ->
         (* other browsers seem to use "on". Thanks to Dave Love for pointing
            this out *)
     Log.f "no VALUE given for input CHECKBOX, using \"on\"";
     "on" in
      (* spec says we SHOULD omit when not selected *)
      (fun () -> 
     match Textvariable.get v with 
       "1" -> [name, value]
     | _ -> [])
    in
      focus_link prev_widget c;
      pack [c][];
      behav#add_get OtherInput get_value;
      behav#add_reset reset
  with
    Not_found ->
      raise (Invalid_Html "Missing NAME in CHECKBOX")
@

<<function Form.radio_input>>=
(* ONLY THE FIRST BUTTON RESET/GET_VALUE IS USED *)
let radio_input prev_widget behav = 
  (* Table of radio names *)
  let radios = Hashtbl.create 17 in
  (fun top tag ->
     try
       let name = get_attribute tag "name" in
       let r = Radiobutton.create top [TakeFocus false]
       and checked = has_attribute tag "checked"
       and va = try get_attribute tag "value" with Not_found -> "on"
       in
       try
     let v, sel = Hashtbl.find radios name in
       (* We already have a radiobutton with this name *)
       Radiobutton.configure r [Variable v; Value va];
       if checked then begin 
         Radiobutton.select r; (* select it *)
         sel := r (* store it in table for reset *)
       end;
       (* no need to add behaviour *)
       focus_link prev_widget r;
       pack [r][]
       with
     Not_found ->
       (* this is the first radio button with this name *)
       (* it this thus assumed checked *)
        let v = Textvariable.create_temporary top in
         Hashtbl.add radios name (v, ref r);
        let get_value () = [name, Textvariable.get v]
        and reset () = 
           (* to reset, we must lookup the table *)
          let _, sel = Hashtbl.find radios name in
        Radiobutton.select !sel 
        in
        Radiobutton.configure r [Variable v; Value va];
        Radiobutton.select r; (* assume selected *)
        focus_link prev_widget r;
        pack [r][];
        behav#add_get OtherInput get_value;
        behav#add_reset reset
    with
      Not_found ->
    raise (Invalid_Html "Missing NAME in RADIO"))
@

<<function Form.image_input>>=
(* An IMAGE input 
 * Q: no target here ?
 *)
let image_input prev_widget ctx base behav top tag =
  try
    let n = get_attribute tag "name" in
    let src = get_attribute tag "src" in
    let alt = 
       try get_attribute tag "alt"
       with Not_found -> "[INPUT IMAGE]"
    in
      {
      embed_hlink = 
          { h_uri = src; h_context = Some base; h_method = GET; h_params =[] };
      embed_frame = top;
      embed_context = ctx; (* pass as is... *)
      embed_map = FormMap (fun (x, y) ->
                 let subargs =
                                [sprintf "%s.x" n, string_of_int x;
                                 sprintf "%s.y" n, string_of_int y] in
                   behav#submit subargs);
      embed_alt = alt}
  with
  Not_found ->
    raise (Invalid_Html "missing NAME or SRC in input IMAGE")
@

<<function Form.submit_input>>=
(* A Submit button *)
let submit_input prev_widget ctx behav top tag = 
  let l = 
    try get_attribute tag "value"
    with Not_found -> I18n.sprintf "Submit"
  in
  try
    let n = get_attribute tag "name" in
    pack [Button.create top [Text l; TakeFocus false;
         Command (fun () -> ctx#goto (behav#submit [n,l]))]]
         []
  with
    Not_found ->
     (* if name is not present, the button does not contribute a value *)
     pack [Button.create top [Text l; TakeFocus false;
          Command (fun () -> ctx#goto (behav#submit []))]]
      []
@

<<function Form.reset_input>>=
let reset_input prev_widget behav top tag = 
  let l = 
    try get_attribute tag "value"
    with Not_found -> I18n.sprintf "Reset" in
  let b = Button.create top [Text l; TakeFocus false;
                 Command (fun () -> behav#reset)] in
    pack[b][]
@

<<function Form.select>>=
(* options is: (val, displayed thing, selected) list *)    
let select prev_widget behav top options tag =
  let name = get_attribute tag "name" in
  let ssize = get_attribute tag "size" in
  let size =
     try int_of_string ssize
     with _ -> 
    Log.f (sprintf "%s not a valid val for SIZE" ssize);
    5 in
  let multiple = has_attribute tag "multiple" in
  (* assume 20 vertical pixels per menu item *)
  let fit_vertical n = 20 * n < Winfo.screenheight top in
  if size = 1 && not multiple && fit_vertical (List.length options)
  then begin (* menus larger than screen are bad, use an optionmenu *)
    let vard = Textvariable.create_temporary top   (* var to display *)
    and varv = Textvariable.create_temporary top   (* var for val *)
    in
    let m = Menubutton.create top 
         [TextVariable vard; Relief Raised; Anchor Center; TakeFocus false] in
    let mmenu = Menu.create m [TearOff false] in
     Menubutton.configure m [Menu mmenu];
     let initial =
       match options with
     [] -> raise (Invalid_Html ("No OPTION in SELECT"))
       | opt :: _ -> ref opt in
     List.iter (function (v,d,s) as x ->
        Menu.add_command mmenu
            [Label d;
             Command (fun () -> 
                   Textvariable.set varv v;
                   Textvariable.set vard d
                  )];
        if s then initial := x
        )
          options;
     let reset () =
       match !initial with
    (v,d,_) -> 
         Textvariable.set varv v;
         Textvariable.set vard d
     and get_value () = [name, Textvariable.get varv] in
       reset();
       focus_link prev_widget m;
       pack [m][];
       behav#add_get OtherInput get_value;
       behav#add_reset reset
     end
  else begin (* use a listbox *)
   (* listbox indices start at 0 *)
   (* we must not ExportSelection, otherwise one unique listbox can *)
   (* have a current selection *)
    let nth_entry n l =
      let (v,_,_) = List.nth l n in v in
    let f,lb = Frx_listbox.new_scrollable_listbox top 
      [TextHeight size; TextWidth 0; (* automatic size *)
       (if multiple then SelectMode Multiple else SelectMode Single);
       ExportSelection false; Background (NamedColor !form_bg)] in
      Listbox.configure lb [TakeFocus false];
    let initial = ref [] in
    let entries =
     mapi (fun i (_,v,s) -> 
           if s then initial := i :: !initial;
           v) 0 options in
      Listbox.insert lb End entries;
    if !initial = [] then initial := [0];
    let reset () = 
       Listbox.selection_clear lb (Number 0) End;
       List.iter (fun i ->
         Listbox.selection_set lb (Number i)(Number i))
           !initial
    and get_value () =
       List.map (function
          Number n -> name, nth_entry n options
        | _ -> name, nth_entry 0 options (* fatal error ! *))
       (Listbox.curselection lb)
    in
      reset (); 
      focus_link prev_widget f;
      pack [f][];
      behav#add_reset reset;
      behav#add_get OtherInput get_value
    end
@

<<function Form.textarea>>=
let textarea prev_widget behav top initial tag = 
  try 
    let name = get_attribute tag "name" in
    let f,t = 
       Frx_text.new_scrollable_text top
           [ExportSelection false; TakeFocus false] false in
    Text.configure t [Background (NamedColor !form_bg)];
    begin try
      let w = get_attribute tag "cols" in
      try Text.configure t [TextWidth (int_of_string w)]
      with Failure "int_of_string" ->
    Log.f (sprintf "%s not a valid val for COLS" w)
    with Not_found -> ()
    end;
    begin try
      let h = get_attribute tag "rows" in
      try Text.configure t [TextHeight (int_of_string h)]
      with Failure "int_of_string" ->
    Log.f (sprintf "%s not a valid val for ROWS" h)
    with Not_found -> ()
    end;
    Text.insert t Frx_text.textEnd initial [];
    let reset () =
      Text.delete t (TextIndex(LineChar(0,0), [])) Frx_text.textEnd;
      Text.insert t Frx_text.textEnd initial []
    and get_value () =
      [name, Text.get t (TextIndex(LineChar(0,0), [])) 
           (TextIndex(End, [CharOffset (-1)]))]
    in
       pack [f][];
       behav#add_reset reset;
       behav#add_get EntryInput get_value
  with
    Not_found -> raise (Invalid_Html "Missing NAME in TEXTAREA")
@

<<function Form.create>>=
let create base behav ctx =
  let prev_widget = ref None in
  { text_input = text_input prev_widget ctx behav;
    checkbox_input = checkbox_input prev_widget behav;
    radio_input = radio_input prev_widget behav;
    image_input = image_input prev_widget ctx base behav;
    submit_input = submit_input prev_widget ctx behav;
    reset_input = reset_input prev_widget behav;
    select = select prev_widget behav;
    textarea = textarea prev_widget behav
  }
@


%-------------------------------------------------------------

<<./display/form.ml>>=
(* Tk based FormDisplay  *)
open Printf
open Tk
open Hyper
open Www
open Html
open Htmlfmt
open Maps
open Embed
open Viewers

<<constant Form.form_bg>>

<<type Form.t (./display/form.ml)>>

(* Most of the widgets created here are created with [TakeFocus false];
 * The reason is that otherwise, in "focus follows mouse" mode, when scrolling
 * a text widget containing form elements, the mouse may come over one of
 * these elements; it would then set the focus to the element, and break
 * further scrolling. Instead, with [TakeFocus false], the user has to
 * click explicitly in the widgets (especially entries and text) in order
 * to fill them.
 * However, we do attempt to re-implement the Tab/Shift-Tab system that we
 * inevitably broke by setting [TakeFocus false].
 * Phew.
 *)


<<function Form.mapi>>

<<function Form.focus_link>>

(* A TEXT or PASSWORD input *)
<<function Form.text_input>>


<<function Form.checkbox_input>>


(* A RADIO input *)
<<function Form.radio_input>>


<<function Form.image_input>>


<<function Form.submit_input>>


<<function Form.reset_input>>



 (* TODO: FILE (RFC 1867) *)



(* A SELECT list *)
<<function Form.select>>

<<function Form.textarea>>


<<function Form.create>>
@


\subsection*{[[./display/html_table.mli]]}


%-------------------------------------------------------------

<<./display/html_table.mli>>=
module Make :
  functor (TableDisplay : Htmlfmt.TableDisplay) ->
    sig
      val init :
        < add_tag : string ->
                    (Htmlfmt.formatter -> Html.tag -> unit) ->
                    (Htmlfmt.formatter -> unit) -> unit;
          create_formatter : Htmlfmt.formatterSpec ->
                             Widget.widget -> 'a * Widget.widget;
          pop_formatter : 'b; push_formatter : 'a -> 'c;
          remove_tag : string -> unit; .. > ->
        unit
    end
@


\subsection*{[[./display/html_table.ml]]}


%-------------------------------------------------------------

<<./display/html_table.ml>>=
open Html
open Htmlfmt

(* 
HTML Tables are defined by RFC1942, e.g.
  <URL:ftp://ds.internic.net/rfc/rfc1942.txt>

This code *assumes* that minimisation rules are used for
cells (td and th) and for rows.
 *)


module Make (TableDisplay: TableDisplay) =
struct
open TableDisplay

let init mach =

  (* Tables may be nested, so we need to remember *)
  let table_stack = ref ([] : TableDisplay.t list) in

  (* Access to the stack *)
  let tm () = match !table_stack with
      tm::_ -> tm
    | [] -> raise (Invalid_Html "Table element outside <TABLE></TABLE>")
  and pop_table () = match !table_stack with
    | tm::l -> table_stack := l
    | [] -> raise (Invalid_Html "Unmatched </TABLE>")
  and push_table tm = table_stack := tm :: !table_stack
  and is_nested () = 
    match !table_stack with
      [] -> false
    | _ -> true
  in

  (* Layout information : the current constraint width *)

  let widths = ref [] in (* because tables are nested *)
  let current_width () = 
    match !widths with
      [] -> TopWidth
    | x::l -> x
  and push_width w =
    widths := w :: !widths
  and pop_width () = 
    match !widths with
      [] -> ()
    | x::l -> widths := l
  in
  (* <TABLE> starts a table *)
  let open_table fo t =
    fo.new_paragraph();
    (* Create the widget for embedding this table *)
    let fr = fo.create_embedded "" None None in
    (* And the table manager *)
    let tm = TableDisplay.create fr t (current_width()) in 
    (* push the table on the stack *)
    push_table tm;
    (* define behavior of other tags *)
    (* align/valign attributes *)
    let current_row_align = ref None
    and current_row_valign = ref None
    in
    let change_aligns t =
      current_row_align := 
     (try Some (String.lowercase (get_attribute t "align"))
      with Not_found -> None);
      current_row_valign := 
     (try Some (String.lowercase (get_attribute t "valign"))
      with Not_found -> None)
    in 

   let cell_aligns attrs =
     begin try Some (String.lowercase (get_attribute attrs "align"))
       with Not_found -> !current_row_align
     end,
     begin try Some (String.lowercase (get_attribute attrs "valign"))
       with Not_found -> !current_row_valign
     end
   in
    (* <TR> : starts a row *)
    let open_tr fo t = change_aligns t; tm.open_row t
    and close_tr fo = tm.close_row() in
    mach#add_tag "tr" open_tr close_tr;

    (* A new cell *)
    let open_cell kind fo t =
      let align,valign = cell_aligns t in
      let align = match align with 
    Some align -> align
      |	None -> match kind with 
      HeaderCell -> "center"
    | DataCell -> "left"
      in
      (* Create a new formatter, given as parent the table widget *)
      let formatter, tcell = 
    mach#create_formatter NestedFormatter tm.table_master in
    mach#push_formatter formatter;
    push_width (tm.new_cell kind t tcell align)

    and close_cell fo =
      (* fo is the formatter that was open for *this* cell *)
      fo.flush();
      (* pop it *)
      mach#pop_formatter;
      pop_width()
    in
    mach#add_tag "th" (open_cell HeaderCell) close_cell;
    mach#add_tag "td" (open_cell DataCell) close_cell;
    mach#add_tag "col" (fun fo t -> tm.add_col t) (fun _ -> ());

  and close_table fo = 
    (* close the table manager *)
    (tm()).close_table();
    pop_table();
    fo.close_paragraph ();
     (* NOTE: this is the correct fo only if minimisation were applied
        and the correct current formatter is passed to close table
      *)
    (* remove tags *)
    List.iter mach#remove_tag ["tr";"th";"td";"col"];
  in

  mach#add_tag "table" open_table close_table;

end
@


\subsection*{[[./display/styles.mli]]}

<<signature Styles.init>>=
(*
 * Definition of attributes of symbolic fonts (font-modifiers)
 *)

val init : string -> string -> unit
    (* [init family slant] *)
@

<<signature Styles.set_font>>=
val set_font : string -> fontAttrs -> unit
    (* [set_font symbolic_name attrs] *)
@

<<signature Styles.get_font>>=
val get_font : string -> fontAttrs
    (* [get_font symbolic_name] *)
@

<<signature Styles.get>>=
(*
 * Retrieves graphical attributes for a given font
 *)

val get : string -> Htmlfmt.gattr list
@


%-------------------------------------------------------------

<<./display/styles.mli>>=
open Fonts

<<signature Styles.init>>

<<signature Styles.set_font>>
<<signature Styles.get_font>>

<<signature Styles.get>>
@


\subsection*{[[./display/styles.ml]]}

<<constant Styles.fonttable>>=
(* Definition of font attributes *)
let fonttable = (Hashtbl.create 37 : (string, fontAttrs) Hashtbl.t)
@

<<constant Styles.get_font>>=
let get_font =  Hashtbl.find fonttable
@

<<function Styles.set_font>>=
let set_font name attrs =
  Hashtbl.remove fonttable name;
  Hashtbl.add fonttable name attrs;
  if name = "default" then 
    Fonts.default := Fonts.merge !Fonts.default attrs
@

<<constant Styles.table>>=
(* 
 * Graphical attributes for a given symbolic name 
 * TODO: to support a notion of style sheet, this table should be
 * specific to each display machine, and should define all the properties
 * of the style sheet display model
 *)
let table = (Hashtbl.create 37 : (string, gattr list) Hashtbl.t)
@

<<function Styles.get>>=
(* Merge font attributes and other attributes *)
let get s = 
  let fontattrs = 
   try Hashtbl.find fonttable s with Not_found -> []
  and otherattrs =
   try Hashtbl.find table s with Not_found -> []
  in
  let attrs =  List.map (fun fi -> Font fi) fontattrs @ otherattrs 
  in
   if attrs = [] then raise Not_found else attrs
@

<<function Styles.define_style>>=
let define_style name attrs =
  Hashtbl.remove table name;
  Hashtbl.add table name attrs
@

<<function Styles.init>>=
let init family slant =
  Hashtbl.clear fonttable;
  Hashtbl.clear table;
  (* font initialisation is moot if we have preferences,
     but just in case (no preference file at all), we keep it*)
  List.iter (function (name,attrs) -> set_font name attrs)
    [ "default",  [Family family;  Weight "medium"; Slant "r";  FontIndex 3];
      "header1", [Family family;  Weight "bold"; Slant "r"; FontIndex 7];
      "header2", [Family family;  Weight "bold"; Slant "r"; FontIndex 6];
      "header3", [Family family;  Weight "medium"; Slant slant; FontIndex 5];
      "header4", [Family family;  Weight "bold"; Slant "r"; FontIndex 4];
      "header5", [Family family;  Weight "medium"; Slant slant; FontIndex 4];
      "header6", [Family family;  Weight "bold"; Slant "r"; FontIndex 4];
      "bold", [ Weight "bold"];
      "italic", [ Slant slant];
      (* should be a fixed font. Since we have newlines, spacing should be 0 *)
      "verbatim", [Family "courier"];
      "fixed", [Family "courier"]
    ];
  List.iter (function (name,attrs) -> define_style name attrs)
    [ "default", [Justification "center"; Spacing 2];
      "verbatim", [Spacing 1];
      "header1", [Justification "center"; Spacing 20];
      "header2", [Justification "center"; Spacing 10];
      "header3", [Justification "left"; Spacing 10];
      "header4", [Justification "left"; Spacing 5];
      "header5", [Justification "left"];
      "header6", [Justification "left"]
    ]
@

<<toplevel Styles._1>>=
let _ = init "helvetica" "o"
@


%-------------------------------------------------------------

<<./display/styles.ml>>=
(* Styles are common display attributes *)
open Htmlfmt
open Fonts


<<constant Styles.fonttable>>

<<constant Styles.get_font>>
<<function Styles.set_font>>


<<constant Styles.table>>

<<function Styles.get>>

<<function Styles.define_style>>

<<function Styles.init>>


<<toplevel Styles._1>>
@


\subsection*{[[./display/table.mli]]}

<<signature Table.debug>>=
(* TABLES *)

val debug : bool ref
@

<<signature Table.strict_32>>=
val strict_32 : bool ref
@

<<type Table.cell_type>>=
type cell_type = HeaderCell | DataCell
@

<<type Table.t>>=
type t = {
  table_master : Widget.widget;
  add_col : Html.tag -> unit;
  open_row : Html.tag -> unit;
  close_row : unit -> unit;
  close_table : unit -> unit;
  new_cell : cell_type -> Html.tag -> Widget.widget -> string -> Htmlfmt.width_constraint;
  bound : unit -> bool
  }
@

<<signature Table.create>>=
val create : Widget.widget -> Html.tag -> Htmlfmt.width_constraint -> t
@

<<signature Table.topwidth>>=
val topwidth : Widget.widget -> int
@


%-------------------------------------------------------------

<<./display/table.mli>>=
<<signature Table.debug>>
<<signature Table.strict_32>>

<<type Table.cell_type>>

<<type Table.t>>

<<signature Table.create>>

<<signature Table.topwidth>>
@


\subsection*{[[./display/table.ml]]}

<<constant Table.debug>>=
(* Table support using the grid manager and a gross hack to obtain 
   resizing of a text widget to show its entire content.

 * Notes:
  1  we must keep geometry propagation on the grid, otherwise we'll never
     get vertical resizing
  2  the same is valid for each cell (frame around text)
  3  the spec says that the table should grow to fit its contents. However,
     this is ambiguous because in practice we must limit the width to the
     currently displayed page width.
     Having geometry propagation turned on, and letting all cells grow will
     of course keep the grid growing...
     Thus we have to set a maximum width for each cell.
     For text cells, we have to put a limit on their "automatic" horizontal
     resizing. When the limit is reached, we switch to vertical resizing,
     resetting wordwrap if allowed.
 *)

let debug = ref false
@

<<constant Table.strict_32>>=
let strict_32 = ref true
    (* in this mode, we ignore WIDTH of TD defined with %
       This is also better for pages written for MSIE where you find
       either TD WIDTH=100% or TD WIDTH=NN
       *)
@

<<type Table.cell_type (./display/table.ml)>>=
(* a manager for a single TABLE *)
type cell_type = HeaderCell | DataCell
@

<<type Table.t (./display/table.ml)>>=
type t = {
  table_master : Widget.widget;
  add_col : Html.tag -> unit;
  open_row : Html.tag -> unit;
  close_row : unit -> unit;
  close_table : unit -> unit;
  new_cell : cell_type -> Html.tag -> Widget.widget -> string -> width_constraint;
  bound : unit -> bool
  }
@

<<type Table.table>>=
(* Internal structure of tables *)
type table = {
  master_widget : Widget.widget;
  width : length;
  mutable slaves :
      (Widget.widget * (int*int*int*int*width_constraint*length*string)) list;
  mutable cur_col : int;
  mutable cur_row : int;
  mutable slots : int array;
  mutable cols : int option list;
  cellpadding : int;
  cellspacing : int
  }
@

<<function Table.topwidth>>=
(* Get up to the widget that has HFrame class, or to toplevel *)
let topwidth wid =
  let f = ref wid in
  try
    while true do
      let cl = Winfo.class_name !f in
      if List.mem cl ["MMM"; "HFrame"] then raise Exit
      else f := Winfo.parent !f
    done;
    0
  with
    Exit ->    
      truncate (float (Winfo.width !f) *. 0.95)
@

<<function Table.text_align>>=
let text_align cell align =
  Text.tag_add cell "align" Frx_text.textBegin Frx_text.textEnd;
  Text.tag_configure cell "align"
    (match align with
      "right" -> [Justify Justify_Right]
    | "center" -> [Justify Justify_Center]
    | _ -> [Justify Justify_Left])
@

<<function Table.dynamic_fight>>=
(* Fight for your life ! *)
let dynamic_fight cell nowrap gameover align =
  match Winfo.class_name cell with
  | "Text" ->
      if !debug then
    Log.f (sprintf "DYNAMIC %s" (Widget.name cell));
      let when_finished () =
    if !debug then
      Log.f (sprintf "Switching %s to vertical resize"
                     (Widget.name cell));
        (* in all cases, we have to grow vertically *)
       let scroll, check = Fit.vert cell in
       Text.configure cell [YScrollCommand scroll];
        (* A posteriori updates for embedded windows
       List.iter 
      (fun embedded ->
        bind embedded [[], Configure]
          (BindSet([], (fun _ ->
           bind embedded [[], Configure] BindRemove;
           Frx_after.idle check;
              ()))))
          (Text.window_names cell)
         *)
      in
      let scroll, check = Fit.horiz cell gameover (
    let first_time = ref true in
    (fun () ->
      if !first_time then begin
        first_time := false;
        text_align cell align;
        if not nowrap then Text.configure cell [Wrap WrapWord];
        when_finished()
    end))
      in
      Text.configure cell [XScrollCommand scroll];
      check()
  | s ->
      if !debug then
    Log.f (sprintf "Table.dynamic_size: unknown children class %s" s);
@

<<function Table.fixed_size>>=
(* We know the size in pixels *)
let fixed_size cell width nowrap align =
  match Winfo.class_name cell with
  | "Text" ->
      if !debug then
    Log.f (sprintf "FIXED %s to %d" (Widget.name cell) width);
      if not nowrap then Text.configure cell [Wrap WrapWord];
      Fit.fixed_horiz cell width;
      (* we have to do alignment here, because it kills horizontal resizing *)
      text_align cell align;
      (* in all cases, we have to grow vertically *)
      let scroll, check = Fit.vert cell in
      Text.configure cell [YScrollCommand scroll];
      (* A posteriori updates for embedded windows
      List.iter 
    (fun embedded ->
      bind embedded [[], Configure]
        (BindSet([], (fun _ ->
          bind embedded [[], Configure] BindRemove;
          Frx_after.idle check;
             ()))))
        (Text.window_names cell);
       *)
      check()
  | s ->
      if !debug then
    Log.f (sprintf "Table.dynamic_size: unknown children class %s" s);
@

<<function Table.sizing>>=
(*
 * Determine how we should set resizing for our cells
 *  table.width contains the specified width for the table
 *  contextwidth was the width computed the context of the table
 *)
let sizing table nowrap width =
  (* For cells of given width and colspan 1, set a col minsize *)
  let colwidths = Array.create (Array.length table.slots) 0 in
  let setcolwidth col n =
    if n > colwidths.(col) then begin
      colwidths.(col) <- n;
      if !debug then
    Log.f (sprintf "%s col %d minsize %d"
               (Widget.name table.master_widget) col n);
      Grid.column_configure table.master_widget col [Minsize (Pixels n)]
    end
  in
  (* second pass to see if we have a proper column width for these *)
  let dynamic = ref [] in
  let add_dynamic w f = dynamic := (w,f) :: !dynamic in
  (* adjust sizes with padding/spacing *)
  let adjust w = w - 2 * table.cellspacing - 2 * table.cellpadding in
  (* Set initial size and dynamic resizing *)
  List.iter (function w,(_,col,_,cspan,cellwidth,_,align) -> 
    (* set initial width from images *)
    let initw = Fit.set_initial_width w
    (* set initial height from line number *)
    and _ = Fit.set_initial_height w in
    match cellwidth with
      FixedWidth n ->
    if cspan=1 then setcolwidth col n; (* this col is at least n*)
    fixed_size w (adjust n) nowrap align
    | UnknownWidth bound ->
    add_dynamic w bound
    | _ -> assert false)
    (List.rev table.slaves);
  (* second pass on dynamics : if we know exactly the size of the
     cell because we know exactly the size of each column it belongs to
     then set it *)
  List.iter (fun (w, f) ->
    let unknown_col = ref false
    and width = ref 0 in
    let (_,col,_,cspan,_,_,align) = List.assoc w table.slaves in
    for i = col to col + cspan - 1 do
      width := !width + colwidths.(i);
      if colwidths.(i) = 0 then unknown_col := true
    done;
    if not !unknown_col then fixed_size w (adjust !width) nowrap align
    else dynamic_fight w nowrap f align)
    !dynamic
@

<<function Table.packem>>=
(* TODO: alignment *)
let packem table =
  let default_opts = [Sticky "nswe";
    PadX (Pixels table.cellspacing); PadY (Pixels table.cellspacing);
    IPadX (Pixels table.cellpadding); IPadY (Pixels table.cellpadding)]
  in
  List.iter 
    (fun (w, (row,col,rspan,cspan, _, _, _)) ->
       (* Sticky opt gives Expand true, Fill Both *)
       grid [w] ([Row row; Column col; RowSpan rspan; ColumnSpan cspan]
                 @default_opts))
    table.slaves
@

<<function Table.get_slot>>=
(* 
 * Slots represent, by column, the number of "pending" row-spanning cells 
 * If this number is zero, the slot is empty. When we allocate slots for
 * col-spanning cells, we keep these slots contiguous (case of overlapping
 * cells)
 *)

let get_slot table needed_cols rspan =
  (* First free slot in cur_col *)
  let rec first_free n =
    if n < Array.length table.slots then
      if table.slots.(n) = 0 then n
      else first_free (n+1)
    else raise Not_found in
  try 
    let first = first_free table.cur_col in
    (* Grow if overflow  (the next free would be first + needed_cols) *)
    if first + needed_cols > Array.length table.slots then
      table.slots <- 
         Array.append table.slots 
           (Array.create (first + needed_cols - (Array.length table.slots)) 
                         rspan);
    (* Mark used *)
    for i = first to first + needed_cols - 1 do
      table.slots.(i) <- max rspan table.slots.(i)
    done;
    table.cur_col <- first + needed_cols;
    first
  with
    Not_found -> (* Grow *)
      let first = Array.length table.slots in
      table.slots <- Array.append table.slots (Array.create needed_cols rspan);
      table.cur_col <- Array.length table.slots;
      first
@

<<function Table.next_row>>=
let next_row table =
  for i = 0 to Array.length table.slots - 1 do
    table.slots.(i) <- 
       match table.slots.(i) with
      0|1 -> 0
    | n -> n-1
  done
@

<<function Table.create>>=
(*
 * The table manager 
 * [top] is the frame that will be embedded in the text widget
 *)


let create top tag contextwidth =
 let width = 
   try length_of_string (get_attribute tag "width")
   with Not_found -> Nolength
 and cellpadding =
   try int_of_string (get_attribute tag "cellpadding")
   with Not_found | Failure "int_of_string" -> 0 
 and cellspacing =
   try int_of_string (get_attribute tag "cellspacing")
   with Not_found | Failure "int_of_string" -> 0
 and bwidth =
   try int_of_string (get_attribute tag "border")
   with Not_found -> 0
      | Failure "int_of_string" -> 1
 and nowrap = has_attribute tag "nowrap"
 (* align attribute is ignored (flow of text) *)
 in
 Frame.configure top [BorderWidth (Pixels bwidth); Relief Raised];
 let tab = {
    master_widget = top;
    slaves = [];
    width = width;
    cur_col = 0;
    cur_row = -1; (* Start with TR *)
    slots = [||];
    cols = [];
    cellpadding = cellpadding;
    cellspacing = cellspacing} in

 (* Compute (if possible) the width of this table *)
 (* Set up the resize condition for cells of this table *)
 let size, bound = 
   match width with
     Nolength | LengthRel _ -> (* assume then 100% of context *)
       begin match contextwidth with
     TopWidth ->
       let w = topwidth tab.master_widget in
       None, Fit.bound_check tab.master_widget w
       | FixedWidth n -> (* size of parent cell *)
       Some n, Fit.bound_check tab.master_widget n
       | UnknownWidth f -> 
           (* the previous bound must have been reached
        * and we (the frame) may occupy 100% of the context 
        * (the text widget). Adjust to 95% for tuning.
        *)
       None, (fun () ->
         f() &&
           let w1 = Winfo.reqwidth top
           and w2 = Winfo.width (Winfo.parent top) in
           if !debug then
         Log.f (sprintf "Grow check %s=%d %s=%d"
                    (Widget.name top) w1
                    (Widget.name (Winfo.parent top)) w2);
            float w1 >= (float w2 *. 0.95))
       end
   | LengthPixels n -> 
       Some n, Fit.bound_check tab.master_widget n
   | LengthRatio r -> (* check the context *)
       begin match contextwidth with
     TopWidth ->
       let w = truncate (float (topwidth tab.master_widget) *. r) in
       Some w, Fit.bound_check tab.master_widget w
       | FixedWidth n -> (* size of parent cell *)
       let w = truncate (float n *. r) in
       Some w, Fit.bound_check tab.master_widget w
       | UnknownWidth f -> 
       None,
      (* the previous bound must have been reached,
         and we must occupy the ratio *)
       (fun () -> f()
           && 
         (let w1 = Winfo.reqwidth top in
          let w2 = Winfo.width (Winfo.parent top) in
           if !debug then
         Log.f (sprintf "Grow check %s=%d %s=%d"
                    (Widget.name top) w1
                    (Widget.name (Winfo.parent top)) w2);
          w1 >= truncate (r *. float w2)))
       end
  in
  (* SPECIAL FIX FOR THE PEOPLE WHO DON'T RESPECT THE DTD : we always make
     sure we are in a row *)
  let in_row = ref false in

   {table_master = top;
    bound = bound;
    close_table =
     (fun () ->
       packem tab;
       sizing tab nowrap size);
    add_col =  (fun tag -> 
      let span = 
       try int_of_string (get_attribute tag "span")
       with Not_found | Failure "int_of_string" -> 1 in
      let width = 
       (* Specification of the columns width (only pixel size supported) *)
       try Some (int_of_string (get_attribute tag "width"))
       with Not_found | Failure "int_of_string" -> None
      in 
      for i = 1 to span do
    tab.cols <- width :: tab.cols 
      done);

    open_row = (fun t ->
    tab.cur_col <- 0;
    tab.cur_row <- 1 + tab.cur_row;
        in_row := true;
        next_row tab);

    close_row = (fun () -> in_row := false);

    new_cell = (fun ctype attrs w align ->
      (* SPECIAL FIX FOR THE PEOPLE WHO DON'T RESPECT THE DTD *)
      if not !in_row then begin
    tab.cur_col <- 0;
    tab.cur_row <- 1 + tab.cur_row;
        in_row := true;
        next_row tab
    end;
      let opts = match ctype with
     HeaderCell -> [Relief Groove]
       | DataCell -> [Relief Sunken]
      in
      begin match Winfo.class_name w with
      |	"Text" -> Text.configure w opts
      |	_ -> assert false
      end;
      (* Tk needs spans > 0 *)
      let rspan = 
    try max 1 (int_of_string (get_attribute attrs "rowspan")) 
    with Not_found | Failure "int_of_string" -> 1
      and cspan = 
    try max 1 (int_of_string (get_attribute attrs "colspan"))
    with Not_found | Failure "int_of_string" -> 1
      and width = 
    try length_of_string (get_attribute attrs "width")
    with Not_found -> Nolength
      and height = 
    try length_of_string (get_attribute attrs "height")
    with Not_found -> Nolength
      in
      (* find its place *)
      let real_col = get_slot tab cspan rspan in
      if !debug then
          Log.f (sprintf "Cell %s at row=%d col=%d rspan=%d cspan=%d"
                 (Widget.name w)
                     tab.cur_row real_col rspan cspan);
      (* compute the size of this cell, so that tables in it have 
     something to work on *)
      let wconstraint = match width with
       Nolength | LengthRel _ -> UnknownWidth bound
      |	LengthPixels n -> FixedWidth n
      |	LengthRatio r -> 
      if !strict_32 then UnknownWidth bound
      else
        (* variable size : do we know the size of the table ? *)
      match size with
        None -> UnknownWidth (fun () ->
          bound() &&
           let w1 = Winfo.reqwidth w
           and w2 = Winfo.width top in
           w1 >= truncate (float w2 *. r))
      | Some n -> FixedWidth (truncate (float n *. r))
      in
       (* We delay the gridding until we have all cells *)
       tab.slaves <- 
          (w, (tab.cur_row, real_col,
           rspan, cspan,
           wconstraint, height, align))
         :: tab.slaves;
       wconstraint
       )}
@


%-------------------------------------------------------------

<<./display/table.ml>>=
open Printf
open Tk
open Html
open Htmlfmt

<<constant Table.debug>>
<<constant Table.strict_32>>

<<type Table.cell_type (./display/table.ml)>>
<<type Table.t (./display/table.ml)>>

<<type Table.table>>

<<function Table.topwidth>>


<<function Table.text_align>>

<<function Table.dynamic_fight>>
      assert false


<<function Table.fixed_size>>
      assert false

<<function Table.sizing>>

<<function Table.packem>>


<<function Table.get_slot>>
      

<<function Table.next_row>>


<<function Table.create>>
@


\subsection*{[[./display/htframe.ml]]}

<<constant Htframe.geom_sep>>=
(* geometry specs *)
let geom_sep = Str.regexp "[ \t\n]+\|\([ \t\n]*,[ \t\n]*\)"
@

<<function Htframe.parse_geom>>=
let parse_geom s = List.map Html.length_of_string (Str.split geom_sep s)
@

<<function Htframe.figure_geom>>=
(* to deal with relative length n*, we have to combine relD and absD
 *   n* is n fragments of Total - Fixed
 *   = (Total - Fixed) * n/Sigma_n
 *   = Total * n/Sigma_n - Fixed * n/Sigma_n
 *   -> -relD (n/Sigma_n) -absD (-Fixed * n/Sigma_n)
 *)
let figure_geom l =
  (* compute the amount of fixed size *)
  let fixed = ref 0
  and totalrel = ref 0 in
  List.iter (function 
      LengthPixels n -> fixed := n + !fixed
    | LengthRel n -> totalrel := n + !totalrel
    | _ -> ())
    l;
  if !totalrel = 0 then (* simple case *)
    List.map (fun x -> [x]) l
  else
    List.map (function
      |	LengthRel n ->
      let ratio = float n /. float !totalrel in
      let opts = [LengthRatio (min ratio 1.)] in
      if !fixed = 0 then opts
      else
        opts @ [LengthPixels (- (truncate (float !fixed *. ratio)))]
      |	x -> [x])
      l
@

<<type Htframe.frame>>=
type frame = {
    frame_src : string;
    frame_name : string;
    frame_scrolling : string; (* yes | no | auto *)
    frame_opts : Tk.options list;
    frame_params : (string * string) list;
  } 
@

<<type Htframe.frameset>>=
and frameset =
    int ref * int ref * celldesc array array
@

<<type Htframe.cell_contents>>=
and cell_contents = 
  | Frame of frame
  | Frameset of frameset
@

<<type Htframe.celldesc>>=
and celldesc = {
    cell_width : Html.length list;
    cell_height : Html.length list;
    mutable cell_contents : cell_contents option
  } 
@

<<function Htframe.ignore_fo>>=
(* This is morally for the <noframes> section *)
let ignore_fo f = {
  new_paragraph = (fun () -> ());
  close_paragraph = (fun () -> ());
  print_newline = (fun b -> ());
  print_verbatim = (fun s -> ());
  format_string = (fun s -> ());
  hr = (fun l n b -> ());
  bullet = (fun n -> ());
  set_defaults = (fun s l -> ());
  push_attr = (fun l -> ());
  pop_attr = (fun l -> ());
  isindex = (fun s s' -> ());
  start_anchor = (fun () -> ());
  end_anchor = (fun h -> ());
  add_mark = (fun _ -> ());
  create_embedded = (fun a w h -> Frame.create f []);
  see_frag = (fun _ -> ());
  flush = (fun () -> ());
  } 
@

<<constant Htframe.ignore_close>>=
let ignore_close = fun _ -> ()
@

<<function Htframe.add_frames>>=
let add_frames load_frames kill_body top mach =
  (* we start from an initial cell of "full size" *)
  let initial_cell = { 
    cell_width = [LengthRatio 100.];
    cell_height = [LengthRatio 100.];
    cell_contents = None 
  } in
  (* framesets can be defined recursively, this is our context stack *)
  let framesets = ref ([] : frameset list) in
  (* each nested frame/frameset occupies a cell in its parent
   * the current cell to occupy is defined by ri/rj.
   *)
  let next_cell set ri rj =
    incr rj;
    if !rj >= Array.length set.(!ri) then begin
      rj := 0; incr ri
    end
  in

  (* Create the frames with the proper placing, launch the display *)
  let doit () =
    (* compute the real frames (the ones with embedded documents) *)
    let frames = ref ([] : (frame * Widget.widget) list) in
    let framesym = Mstring.egensym "framecell" in
    (* in some top window, place the given cell and proceed with its
     * contents recursively. [pos] defines the placing options in x/y
     *)
    let rec docell top cell pos = 
      let f = 
    Frame.create_named top 
      (if cell == initial_cell then "frames"
       else framesym()) [Class "HFrame"] in
      let place_opts = ref (In top :: pos) in
      (* the displacement caused by this cell in its parent *)
      let delta_x = ref 0 and delta_relx = ref 0.
      and delta_y = ref 0 and delta_rely = ref 0.
      in
      List.iter (function
       | Nolength | LengthRel _ -> assert false
       | LengthPixels n ->
        place_opts := Width (Pixels n) :: !place_opts;
        delta_x := n
       | LengthRatio w -> 
        place_opts := RelWidth w :: !place_opts;
        delta_relx := w)
    cell.cell_width;
      List.iter (function
       | Nolength | LengthRel _ -> assert false
       | LengthPixels n ->
        place_opts := Height (Pixels n) :: !place_opts;
        delta_y := n
       | LengthRatio w -> 
        place_opts := RelHeight w :: !place_opts;
        delta_rely := w)
    cell.cell_height;
      (* place the cell, unless it is the top cell *)
      if cell == initial_cell then begin
    pack [f] [Expand true; Fill Fill_Both];
    Pack.propagate_set f false
      end else place f !place_opts;
      (* proceed with its contents *)
      begin match cell.cell_contents with
      |	None -> () (* this is an error ! *)
      |	Some (Frame frame) ->
      (* just store it so we can run the viewers later.
         (we need to have all frames in order to give proper navigation
         context for links with targets) *)
      frames := (frame, f) :: !frames;
      Frame.configure f frame.frame_opts
                    
      |	Some (Frameset (_,_,rows)) ->
      (* this is again a frameset. Thus [f] is still only a container *)
      (* positions of the embedded cells *)
      let curabs_x = ref 0 and curabs_y = ref 0
      and currel_x = ref 0. and currel_y = ref 0. in
      (* placer options for each embedded cell *)
      let curpos () = [X (Pixels !curabs_x); RelX !currel_x;
               Y (Pixels !curabs_y); RelY !currel_y] in
      (* Iterate on cells *)
      Array.iter (fun row ->
        (* for each row, we start horizontally at 0 *)
        curabs_x := 0; currel_x := 0.;
        (* the vertical size contributed by this row. It's constant
           for all cells in the row, but we compute it n times...*)
        let row_delta_y = ref 0
        and row_delta_rely = ref 0. in
        (* now iterate on each cell in this row (eg on columns) *)
        Array.iter (fun cell -> 
          (* place this cell and return its occupation *)
          let delta_x, delta_relx, delta_y, delta_rely =
        docell f cell (curpos()) in
          (* switch current horiz position, store vert occupation *)
          curabs_x := delta_x + !curabs_x;
          currel_x := delta_relx +. !currel_x;
          row_delta_y := delta_y;
          row_delta_rely := delta_rely
          ) row;
        (* we finished the row. Move vertically now *)
        curabs_y := !curabs_y + !row_delta_y;
        currel_y := !currel_y +. !row_delta_rely)
        rows
      end;
      (* our caller expects us to return our size *)
      !delta_x, !delta_relx, !delta_y, !delta_rely
    in
    (* The initial cell is always at 0/0 *)
    ignore (docell top initial_cell [X (Pixels 0); Y (Pixels 0)]);
    (* And now proceed with frame loading *)
    load_frames !frames;
    (* some people put a body outside the noframes section, so we should
       ignore it completely if we saw frames. And we must kill the body
       if it was already created *)
    kill_body();
    mach#add_tag "body"
      (fun fo t -> mach#look_for EOF) ignore_close

  in
  mach#add_tag "frameset"
      (fun fo t ->
    let rows = get_attribute t "rows"
    and cols = get_attribute t "cols" in
    let newset =
      ref 0, ref 0,
      Array.of_list
        (List.map (fun h ->  
          Array.of_list (List.map  (fun w -> 
        { cell_width = w;
          cell_height = h;
          cell_contents = None})
                   (figure_geom (parse_geom cols))))
           (figure_geom (parse_geom rows)))
    in
    match !framesets with
    | [] -> 
        (* if there two or more non-nested framesets, we will cause 
           an error later *)
        if initial_cell.cell_contents <> None then
          raise (Invalid_Html "illegal <frameset>")
        else begin
          initial_cell.cell_contents <- Some (Frameset newset);
          framesets := newset :: !framesets
        end
    | (ri, rj, set)::l ->
        if !ri >= Array.length set then
          raise (Invalid_Html "no room for <frameset> in this <frameset>")
        else begin
          set.(!ri).(!rj).cell_contents <-  Some (Frameset newset);
          next_cell set ri rj;
          framesets := newset :: !framesets
        end)
      (fun t -> 
    match !framesets with
    | [] -> 
        raise (Invalid_Html "unmatched </frameset>")
    | [x] -> (* the last one *)
        framesets := [];
        doit()
    | x::l ->
        framesets := l);

  mach#add_tag "frame"  
    (fun fo t ->
      match !framesets with
      | [] -> raise (Invalid_Html "<frame> outside <frameset>")
      |	(ri, rj, set) :: _ ->
      if !ri >= Array.length set then
        raise (Invalid_Html "no room for <frame> in this <frameset>")
      else begin
        try
          let src = get_attribute t "src"
          and name = try get_attribute t "name" with Not_found -> ""
          and border = 
           try int_of_string (get_attribute t "frameborder")
           with Failure "int_of_string" -> 
        (* compatibility ? *)
          if String.lowercase (get_attribute t "frameborder") = "no"
          then 0 else 1
          and scrolling = String.lowercase (get_attribute t "scrolling")
          in
          let borderopts = 
           if border = 0 then [BorderWidth (Pixels 0)]
           else [BorderWidth (Pixels border); Relief Ridge]
          in
          set.(!ri).(!rj).cell_contents <-
         Some (Frame { frame_src = src;
                   frame_name = name;
                   frame_opts = borderopts;
                   frame_scrolling = scrolling;
                   frame_params = t.attributes });
          next_cell set ri rj
        with
          Not_found -> 
           raise (Invalid_Html "missing src in <FRAME>")
      end)
    ignore_close;

  (* note: <noframes> does not necessarily cover the whole body of the
   * document. It may only hide a toc which is displayed in another frame.
   * Basically, <noframes> doesn't imply there was a <frameset> in the
   * same document. Of course, we should interpret noframes ONLY if the
   * other frame supposed to contain the info IS displayed. But we don't
   * know that, do we ?
   *)
  mach#add_tag "noframes"
    (fun fo t -> 
      mach#push_formatter (ignore_fo top);
      mach#look_for (CloseTag "noframes"))

    (fun t -> mach#pop_formatter; ())
@


%-------------------------------------------------------------

<<./display/htframe.ml>>=
open Tk
open Html
open Htmlfmt

(* Frames *)

<<constant Htframe.geom_sep>>
<<function Htframe.parse_geom>>

<<function Htframe.figure_geom>>

(* We build this data structure when parsing FRAMESET *)
<<type Htframe.frame>>

<<type Htframe.frameset>>

<<type Htframe.cell_contents>>

<<type Htframe.celldesc>>

<<function Htframe.ignore_fo>>

<<constant Htframe.ignore_close>>


<<function Htframe.add_frames>>

@


\subsection*{[[./display/textw_fo.mli]]}

<<signature Textw_fo.html_bg>>=
val html_bg : string ref
@

<<signature Textw_fo.html_fg>>=
val html_fg : string ref
@

<<signature Textw_fo.usecolors>>=
val usecolors : bool ref
@

<<signature Textw_fo.internal_buffer>>=
val internal_buffer : int ref
@

<<signature Textw_fo.create>>=
val create :
  (unit -> string) ->
  Htmlfmt.formatterSpec -> Widget.widget -> Viewers.context ->  
    Htmlfmt.formatter * Widget.widget
@


%-------------------------------------------------------------

<<./display/textw_fo.mli>>=

<<signature Textw_fo.html_bg>>
<<signature Textw_fo.html_fg>>

<<signature Textw_fo.usecolors>>
<<signature Textw_fo.internal_buffer>>

<<signature Textw_fo.create>>
@


\subsection*{[[./display/textw_fo.ml]]}

<<constant Textw_fo.html_bg>>=
(* Default background and foreground colors *)
let html_bg = ref "white"
@

<<constant Textw_fo.html_fg>>=
let html_fg = ref "black"
@

<<constant Textw_fo.usecolors>>=
(* Preference settings *)
let usecolors = ref true     (* use colors (fg/bg) specified in document *)
@

<<constant Textw_fo.internal_buffer>>=
let internal_buffer = ref 4000
@

<<function Textw_fo.create>>=
(* Build a formatter, as required by html_disp *)
let create namer spec top ctx =
  let other_bg = ref (fun _ -> ()) in
  let fhtml, thtml =
    match spec with
      TopFormatter pscrolling ->
    let f,t = 
     if pscrolling then begin
      let f,t = 
        Ctext.create top [Wrap WrapWord; State Disabled] true in
        Canvas.configure (Winfo.parent t)
           [Background (NamedColor !html_bg)];
         other_bg := Canvas.configure (Winfo.parent t);
        f, t
      end
     else
       new_scrollable_text top 
          [Wrap WrapWord; State Disabled]
          true 
    in
    (* Try to solve focus problem -- JPF *)
    bind t [[],Enter] (BindSet ([], fun _ -> Focus.set t));
    f, t
    | NestedFormatter -> (* Embedded formatters (tables) *)
       let t = Text.create_named top (namer())
            [BorderWidth (Pixels 0); State Disabled; 
              Relief Sunken; Wrap WrapNone;
          TextWidth 1; TextHeight 1]
    in
        t, t
    | FrameFormatter args -> 
    let marginwidth = 
      try [PadX (Pixels (int_of_string (List.assoc "marginwidth" args)))]
      with Not_found | Failure "int_of_string" -> []
    and marginheight = 
      try [PadY (Pixels (int_of_string (List.assoc "marginheight" args)))]
      with Not_found | Failure "int_of_string" -> []
    in
   let f,t = 
     Ctext.create top (marginwidth @ marginheight @ 
                [TextHeight 1; 
                  Wrap WrapWord; State Disabled]) true in
   Canvas.configure (Winfo.parent t)
     [Background (NamedColor !html_bg)];
         other_bg := Canvas.configure (Winfo.parent t);

    f, t
  in

  (* Tk4.0pl3 fix, + avoid cb to scrollbar *)
  (* Make the widget searchable *)
  (* NOTE: search doesn't apply to nested windows *)
  begin match spec with
    TopFormatter _ | FrameFormatter _ -> 
      Text.configure thtml [TakeFocus true; InsertOffTime 0];
      Frx_text.addsearch thtml
  | NestedFormatter -> 
      Text.configure thtml [TakeFocus false; InsertOffTime 0]
  end;

  (* Set (other) defaults *)
  let _, html_font = Fonts.compute_tag !Fonts.default in
   Text.configure thtml html_font;

  (* transparent GIF hack *)
  Textvariable.set (Textvariable.coerce "TRANSPARENT_GIF_COLOR") !html_bg;

  (* The formatter
   *    to minimize calls to Tk, we write only one string for 
   * each paragraph larger than some size. Because of this, it seems
   * that we also have to set tags and marks at the end.
   *)

  (* Things queued *)
  let marks = ref []
  and embedded = ref []
  and tagdefs = new Attrs.tags thtml
  (* Hypertext Anchor support *)
  and anchors = new Attrs.anchortags thtml

  (* It's easier for us to keep character positions as offsets from the
   * beginning, but it's very costly in Tk (conversion 0+nchars -> index),
   * especially when the size gets large.
   * Thus, we keep the base index of the current buffer, and positions
   * as offsets from there.
   * We must be careful not to leave position values relative to old
   * buffer_base.
   *)
  and buffer_base = ref (LineChar(0,0))
  and position = ref 0
  and anchor_start = ref (TextIndex(LineChar(0,0),[]))

  (* Paragraphs and space squeezing *)
  and trailing_space = ref false
  and prev_is_newline = ref false
      (* if this is false, we are displaying text. if this is true, we
         just issued a newline *)
  in

  (* Index for Tk *)
  let get_index p = TextIndex (!buffer_base, [CharOffset p]) in
  let cur () = get_index !position in

  (* colors for *this* window, can be changed by set_defaults *)
  let fg = ref !html_fg
  and bg = ref !html_bg
  in
  (* inherited properties (set_defaults) : we apply them to embedded
     formatters (table cells) *)
  let inherited = ref [] in
  anchors#init ctx;      (* install bindings *)
  anchors#define "visited" [Foreground (NamedColor "MidnightBlue")];
  anchors#define "anchor" [Foreground (NamedColor "#0000ff"); Underline true];


  (* Size of buffer can impact performances *)
  let refresh_threshold = 
     if !internal_buffer < 1000 then 1000 else !internal_buffer in
  let buffer = Ebuffer.create (2 * refresh_threshold)
  and last_flush = ref !Low.global_time in

  let internal_flush refresh = (* flush the buffer *)
    last_flush := !Low.global_time;
    Text.configure thtml [State Normal];
    Text.insert thtml textEnd (Ebuffer.get buffer) [];
    Ebuffer.reset buffer;
    List.iter 
      (function (opts,p) -> Text.window_create thtml (get_index p) opts)
      (List.rev !embedded);
    List.iter (function (m,p) -> Text.mark_set thtml m (get_index p)) !marks;
    tagdefs#flush;
    anchors#flush;
    Text.configure thtml [State Disabled];
    marks := [];
    embedded := [];
     (* reset the position *)
    buffer_base := 
       Text.index thtml (TextIndex(!buffer_base,[CharOffset !position]));
    position := 0;
     (* try to give a reasonable initial height for the text widget *)
    if refresh then begin 
     begin match spec with
       TopFormatter true 
     | NestedFormatter 
     | FrameFormatter _ -> Fit.set_initial_height thtml
     | _ -> ()
     end;
     Low.update_idletasks()
    end
     in

  let put_text s =
    match String.length s with
      0 -> ()
    | l ->
        position := !position + Lexkanji.length s;
        prev_is_newline := false;
        Ebuffer.output_string buffer s;
    trailing_space := s.[l-1] = ' ';
    if  !Low.global_time > !last_flush + 4 (* it's been a while *)
    then internal_flush true
    else if  Ebuffer.used buffer > refresh_threshold 
    then internal_flush false
       in

  (* Logic for tag manipulation *)
  let margins = new Attrs.margin tagdefs
  and aligns = new Attrs.align tagdefs
  and fonts = new Attrs.font tagdefs
  and fgcolors = new Attrs.fgcolor tagdefs
  and bgcolors = new Attrs.bgcolor tagdefs
  and spacing = new Attrs.spacing tagdefs
  and offset = new Attrs.offset tagdefs
  and underline = new Attrs.misc (tagdefs, "underline", [Underline true])
  and strike = new Attrs.misc (tagdefs, "strike", [OverStrike true])

  in
  let put_embedded w align =
    let opts = match String.lowercase align with
      "top" -> [Align Align_Top]
    | "middle" -> [Align Align_Center] (* not exactly *)
    | "bottom" -> [Align Align_Baseline] 
    |  _ -> [] in
    embedded := ((Window w)::opts, !position) :: !embedded;
    prev_is_newline := false;
    incr position    (* an embedded window is one char wide *)    
  in

  let break () =
     if not !prev_is_newline then begin
       put_text "\n"; prev_is_newline := true
       end
  in

  let paropen = ref (cur()) in

  let formatter =           
  { new_paragraph = 
     (function () -> break(); spacing#push (cur()) 5; paropen := cur());
    close_paragraph = 
     (function () -> spacing#pop (cur()) 5; 
       if (cur() = !paropen) then prev_is_newline := false;
       break());
    print_newline = (function force -> 
      if force then begin
        put_text "\n"; 
    trailing_space := true
       end
      else break()
      );
    print_verbatim = (function s -> put_text s; prev_is_newline := false);

    format_string = 
      (function s -> 
        if not !prev_is_newline then (* we are in text *)
           put_text (Html.beautify !trailing_space s)
     else (* decide if we should start a text *)
         let bs = Html.beautify true s in
        if bs = "" then () (* it was all spaces *)
        else begin
          put_text bs;
          prev_is_newline := false
        end);

    flush = 
      (function () -> 
    fonts#pop_all (cur());	(* basefont lossage *)
    internal_flush true);

    hr = 
    begin
      let hrsym = Mstring.egensym "hr" in
      (fun width height solid ->
      let fr = Hr.create_named thtml (hrsym()) width height solid in
      Frame.configure fr [Background (NamedColor !fg)];
      put_embedded fr "")
    end;
    (* TODO *)
    bullet = 
    begin
     let bulletsym = Mstring.egensym "bullet" in
     (function s -> 
       try let img = Hashtbl.find Attrs.bullet_table s in
         put_embedded (Label.create_named thtml (bulletsym())
             [img; BorderWidth (Pixels 0);
               Background (NamedColor !html_bg)]) ""
       with Not_found  -> put_text "*")
    end;

    (* TODO : vlink *)
    set_defaults = 
      (fun name attrs -> 
    inherited := (name, attrs) :: !inherited;
    match name with
      "background" ->
        List.iter (function
        BgColor s ->
          if !usecolors then
            let c = Attrs.html_color s in
            if Frx_color.check c then begin
              bg := c;
              Resource.add 
            (sprintf "Mmm%s*background" (Widget.name thtml))
                     c Interactive;
              Text.configure thtml [Background (NamedColor c)];
              !other_bg [Background (NamedColor c)]
                    end
          | _ -> ())
          attrs
    | "foreground" ->
        List.iter (function
          | FgColor s ->
          if !usecolors then
            let c = Attrs.html_color s in
            if Frx_color.check c then begin
              fg := c;
              Resource.add 
            (sprintf "Mmm%s*foreground" (Widget.name thtml))
                     c Interactive;
              Text.configure thtml [Foreground (NamedColor c)]
            end
          | _ -> ())
          attrs
    | "link" ->
        List.iter (function
          | FgColor s ->
          if !usecolors then
            let c = Attrs.html_color s in
            if Frx_color.check c then 
              anchors#change "anchor" [Foreground (NamedColor c)]
          | _ -> ())
          attrs
    | "alink" ->
        List.iter (function
          | FgColor s ->
          if !usecolors then
            let c = Attrs.html_color s in
            if Frx_color.check c then 
              anchors#change "visited" [Foreground (NamedColor c)]
          | _ -> ())
          attrs
    | "font" ->
        List.iter (function
          |	Font (FontIndex x)  -> 
          fonts#set_base (cur()) x
          |	_ -> ())
          attrs
    | _ -> ());
    
    push_attr =
      (function l ->
        let fis = ref [] in
      List.iter (function
               Font fi -> fis := fi :: !fis
             | Margin n -> margins#push (cur()) n
             | Justification a -> aligns#push (cur()) a
                     | FgColor s -> 
             if !usecolors then fgcolors#push (cur()) s
                     | BgColor s ->
             if !usecolors then bgcolors#push (cur()) s
                     | Spacing n -> spacing#push (cur()) n
                     | Underlined -> underline#push (cur())
                     | Striked -> strike#push (cur())
                     | Superscript -> 
                  fis := (FontDelta (-2)) :: !fis;
                  offset#push (cur()) 5
                     | Lowerscript ->
                  fis := (FontDelta (-2)) :: !fis;
                  offset#push (cur()) (-5)
                     )
            l;
          if !fis <> [] then begin
        fonts#push (cur()) !fis;
      end);
    
    pop_attr =
      (function l ->
        let fis = ref [] in
      List.iter (function
               Font fi -> fis := fi :: !fis
             | Margin n -> margins#pop (cur()) n
             | Justification a -> aligns#pop (cur()) a
                     | FgColor s -> 
             if !usecolors then fgcolors#pop (cur()) s
                     | BgColor s ->
             if !usecolors then bgcolors#pop (cur()) s
                     | Spacing n -> spacing#pop (cur()) n
                     | Underlined -> underline#pop (cur())
                     | Striked -> strike#pop (cur())
                     | Superscript ->
                  fis := (FontDelta (-2)) :: !fis;
                  offset#pop (cur()) 5
                     | Lowerscript ->
                  fis := (FontDelta (-2)) :: !fis;
                  offset#pop (cur()) (-5)
            )
            l;
          if !fis <> [] then begin
        fonts#pop (cur()) !fis;
      end);

     (* Compliance: text is not part of document ? *)
    isindex =
    (fun prompt base ->
      let f,e = Frx_entry.new_label_entry thtml prompt
          (function s -> 
            ctx#goto { h_uri = "?" ^ Urlenc.encode s;
                       h_context = Some base;
                       h_method = GET;
               h_params = []}) in
      (* default size 0 ! *)
      Entry.configure e [TextWidth 20];
      put_embedded f "";
      put_text "\n");

    start_anchor =
      (fun () -> anchor_start := (cur()));
    end_anchor =
     (* set the tag for the anchor *)
      (fun link -> anchors#add_anchor !anchor_start (cur()) link);

    (* WARNING: if anchor name is a standard tk name, such as end,
       we're f*cked, so we force # *)
    add_mark = (fun s -> marks := ("#"^s, !position) :: !marks );

    create_embedded =
    (* avoid space leak in Tk hash table : reuse the same names *)
    begin
      let embsym = Mstring.egensym "emb" in
      (fun a w h ->
    let f = Frame.create_named thtml (embsym()) 
        [Class "HtmlEmbedded"] in
    if !usecolors then 
      Frame.configure f [Background (NamedColor !bg)];
     (* To solve the focus problem 
     Tk.bindtags  f ((WidgetBindings thtml) :: Tk.bindtags_get f);
     bind f [[],Enter] (BindSet ([], fun _ -> Focus.set thtml)); 
      *)
     (* -- end *)
       (match w, h with
         Some w, Some h ->
           Frame.configure f [Width (Pixels w); Height (Pixels h);
                  BorderWidth (Pixels 0)];
           Pack.propagate_set f false
             | _, _ -> ());
        put_embedded f "";
        f)
    end;
    (* we try to remember the last "reading" position, so you can easily
     * switch back from a goto to some particular place in the document
     *)
    see_frag = begin
      let prev_frag = ref false
      and view_mem = ref 0.0 in
      match spec with
    TopFormatter true -> (* this is pscrolling mode *)
      (function
          None -> (* no place in particular *)
       if !prev_frag then begin
          try Canvas.yview (Winfo.parent thtml) (MoveTo !view_mem)
          with Protocol.TkError _ -> ()
       end;
       prev_frag := false
        | Some s ->
       if not !prev_frag then begin
          try view_mem := fst (Canvas.yview_get (Winfo.parent thtml))
          with Protocol.TkError _ -> ()
       end;
       prev_frag := true;
       if s <> "" then
          try
            let _,y,_,_,_  = Text.dlineinfo thtml
            (TextIndex (Mark ("#"^s), [LineOffset (-2)]))
            and _,ye,_,_,_ = Text.dlineinfo thtml 
            (TextIndex (End, [CharOffset (-1)])) in
            Canvas.yview (Winfo.parent thtml) 
              (MoveTo (float y /. float ye))
          with Protocol.TkError _ -> ())
      |	_ ->
      (function
          None -> (* no place in particular *)
          if !prev_frag then begin
          (* we were at view_mem *)
          try Text.yview thtml (MoveTo !view_mem)
          with Protocol.TkError _ -> ()
          end;
          prev_frag := false
        | Some s -> (* go to s *)
          if not !prev_frag then begin
          (* we were not in some special place, remember it *)
          try view_mem := fst (Text.yview_get thtml)
          with Protocol.TkError _ -> ()
          end;
          prev_frag := true;
          if s <> "" then
          try Text.yview_index thtml 
              (TextIndex (Mark ("#"^s), [LineOffset (-1)]))
          with Protocol.TkError _ -> ())
    end
    } in

  formatter, fhtml
@


%-------------------------------------------------------------

<<./display/textw_fo.ml>>=
open Printf
open Tk
open Frx_text
open Hyper
open Viewers
open Html
open Htmlfmt
open Fonts


(* Text widget formatter for the HTML Display Machine
 * The main function builds a GfxHTML, in two cases
 *    1- normal (viewing an HTML document)
 *    2- nested (a cell in a table)
 *    3- 
 *)

<<constant Textw_fo.html_bg>>
<<constant Textw_fo.html_fg>>

<<constant Textw_fo.usecolors>>
<<constant Textw_fo.internal_buffer>>

<<function Textw_fo.create>>
@


\subsection*{[[./display/html_disp.mli]]}

<<signature Html_disp.attempt_tables>>=
val attempt_tables : bool ref
@

<<signature Html_disp.verbose>>=
val verbose : bool ref
@

<<signature Html_disp.add_hook>>=
val add_hook: (machine -> unit) -> unit
@


%-------------------------------------------------------------

<<./display/html_disp.mli>>=

<<signature Html_disp.attempt_tables>>
<<signature Html_disp.verbose>>

class  virtual imgloader : (unit) -> object
  method virtual add_image : Embed.embobject -> unit	 (* add one image *)
  method virtual flush_images : unit	         (* flush when document is loaded *)
  method virtual load_images : unit		 (* manual flush *)
  method virtual update_images : unit
end


class  virtual machine : (unit) -> object
  method virtual formatter : Htmlfmt.formatter
  method virtual imgmanager : imgloader
  method virtual base : string
  method virtual set_base : string -> unit
  method virtual target : string option
  method virtual set_target : string -> unit
  method virtual ctx : Viewers.context
  method virtual add_tag: 
    string -> (Htmlfmt.formatter -> Html.tag -> unit) -> 
    (Htmlfmt.formatter -> unit) -> 
    unit
  method virtual get_tag : 
    string -> 
    (Htmlfmt.formatter -> Html.tag -> unit) * (Htmlfmt.formatter -> unit)

  method virtual remove_tag : string -> unit
  method virtual push_action : (string -> unit) -> unit
  method virtual pop_action : unit
  method virtual push_formatter : Htmlfmt.formatter -> unit
  method virtual pop_formatter : Htmlfmt.formatter
  method virtual create_formatter : 
      Htmlfmt.formatterSpec -> Widget.widget -> 
    Htmlfmt.formatter * Widget.widget
  method virtual send : Html.token -> unit
  method virtual look_for : Html.token -> unit
  method virtual add_embedded : Embed.embobject -> unit
  method virtual embedded : Embed.embobject list
  method virtual see_frag : string option -> unit
    
  (* For other languages) *)
  (* encode the internal i18n strings to corresponding encodings *)
  method virtual i18n_encoder : string -> string
  method virtual set_i18n_encoder : (string -> string) -> unit
end

<<signature Html_disp.add_hook>>

module Make 
  (G: Htmlfmt.GfxHTML) 
  (F: Htmlfmt.FormDisplay) 
  (T: Htmlfmt.TableDisplay) 
  : sig
    (* Do we need to export FormLogic and TableLogic so that extensions
     *  can access them ?
     *)
    val create : Viewers.context * imgloader -> machine
end
@


\subsection*{[[./display/html_disp.ml]]}

<<constant Html_disp.attempt_tables>>=
(* Preference settings *)
let attempt_tables = ref false
@

<<constant Html_disp.verbose>>=
let verbose = ref false
@

<<function Html_disp.lowernumber>>=
(* SMOP Utilities for OL numbering *)
let lowernumber n =
  let rec f cur n = 
    if n < 0 then cur
    else  f (String.make 1 (Char.chr (97 + n mod 26)) ^ cur) (n / 26 - 1)
  in 
  if n <= 0 then "*" else f "" (n-1)
@

<<function Html_disp.uppernumber>>=
let uppernumber n =
  let rec f cur n = 
    if n < 0 then cur
    else  f (String.make 1 (Char.chr (64 + n mod 26)) ^ cur) (n / 26 - 1)
  in
  if n <= 0 then "*" else f "" (n-1)
@

<<constant Html_disp.romans>>=
let romans = [|
@

<<function Html_disp.roman>>=
let roman n =
  let rec r cur level n =
    if n = 0 then cur
    else if level > 3 then "*" ^ cur
    else r (romans.(level).(n mod 10) ^ cur) (succ level)  (n / 10)
  in if n <= 0 then "*" else r "" 0 n
@

<<constant Html_disp.user_hooks>>=
(* Hooks for applets/modules. Control is made elsewhere *)
let user_hooks = ref []
@

<<function Html_disp.add_hook>>=
let add_hook f = 
  user_hooks := f :: !user_hooks
@

<<constant Html_disp.default_fo>>=
(* This is the default formatter *)
let default_fo = {
  new_paragraph = (fun () -> ());
  close_paragraph = (fun () -> ());
  print_newline = (fun b -> ());
  print_verbatim = (fun s -> ());
  format_string = (fun s -> ());
  hr = (fun l n b -> ());
  bullet = (fun n -> ());
  set_defaults = (fun s l -> ());
  push_attr = (fun l -> ());
  pop_attr = (fun l -> ());
  isindex = (fun s s' -> ());
  start_anchor = (fun () -> ());
  end_anchor = (fun h -> ());
  add_mark = (fun _ -> ());
  create_embedded = (fun a w h -> assert false);
  see_frag = (fun _ -> ());
  flush = (fun () -> ());
} 
@


%-------------------------------------------------------------

<<./display/html_disp.ml>>=
(* HTML Display Machine *)
open Printf
open Html
open Htmlfmt
open Hyper
open Www
open Document
open Maps
open Embed
open Viewers
open Fonts

<<constant Html_disp.attempt_tables>>
<<constant Html_disp.verbose>>

<<function Html_disp.lowernumber>>

<<function Html_disp.uppernumber>>

<<constant Html_disp.romans>>
  [| ""; "I"; "II"; "III"; "IV"; "V"; "VI"; "VII"; "VIII"; "IX" |];
  [| ""; "X"; "XX"; "XXX"; "XL"; "L"; "LX"; "LXX"; "LXXX"; "XC" |];
  [| ""; "C"; "CC"; "CCC"; "CD"; "D"; "DC"; "DCC"; "DCCC"; "CM" |];
  [| ""; "M"; "MM"; "MMM"; "*MMM"; "*MMM"; "*MMM"; "*MMM"; "*MMM"; "*MMM" |];
  |]

<<function Html_disp.roman>>

class  virtual imgloader (unit : unit) =
 object
  method virtual add_image : embobject -> unit	 (* add one image *)
  method virtual flush_images : unit	         (* flush when document is loaded *)
  method virtual load_images : unit		 (* manual flush *)
  method virtual update_images : unit
end

class  virtual machine (unit : unit) =
 object
  method virtual formatter : formatter
  method virtual imgmanager : imgloader
  method virtual base : string
  method virtual set_base : string -> unit
  method virtual target : string option
  method virtual set_target : string -> unit
  method virtual ctx : Viewers.context
  method virtual add_tag : string -> (formatter -> Html.tag -> unit) -> (formatter -> unit) -> unit
  method virtual get_tag : string -> (formatter -> Html.tag -> unit) * (formatter -> unit)
  method virtual remove_tag : string -> unit
  method virtual push_action : (string -> unit) -> unit
  method virtual pop_action : unit
  method virtual push_formatter : formatter -> unit
  method virtual pop_formatter : formatter
  method virtual create_formatter : formatterSpec -> Widget.widget -> formatter * Widget.widget
  method virtual send : Html.token -> unit
  method virtual look_for : Html.token -> unit
  method virtual add_embedded : embobject -> unit
  method virtual embedded : embobject list
  method virtual see_frag : string option -> unit

  (* For other languages *)
  (* encode the internal i18n strings to corresponding encodings *)
  method virtual i18n_encoder : string -> string
  method virtual set_i18n_encoder : (string -> string) -> unit
end

<<constant Html_disp.user_hooks>>
<<function Html_disp.add_hook>>

<<constant Html_disp.default_fo>>

module Make (G : GfxHTML) (F: FormDisplay) (T: TableDisplay) = struct

  module FormLogic = Html_form.Make(F)
  module TableLogic = Html_table.Make(T)

  type anchor_type = HREF | NAME

  (* Tag machinery *)
    
  type html_behavior = {
        tag_open  : formatter -> tag -> unit;
   tag_close : formatter -> unit
    }
    
  let ignore_open = fun _ _ -> ()
  let ignore_close = fun _ -> ()


  class display_machine (ctx, imgmanager) =
 object (self) 
    inherit machine ()
    (* Keep a copy of the arguments *) 
(*  val ctx = (ctx : Viewers.context)  JPF: for ocaml2.00 *)
    method ctx = ctx

    (* val imgmanager = imgmanager *)
    method imgmanager = imgmanager    

    (* record all embedded objects in this machine *)
    val mutable (*private*) embedded = []
    method add_embedded x = 
      Embed.add x;
      embedded <- x :: embedded
    method embedded = embedded

    val mutable base = Url.string_of ctx#base.document_url
    method base = base
    method set_base s = base <- s

    val mutable target = None
    method target = target
    method set_target t = 
      target <- Some t

    val (*private*) tags = (Hashtbl.create 101 : (string, html_behavior) Hashtbl.t)
    val mutable (*private*) action = (fun s -> ())
    val mutable (*private*) action_stack = []
    val mutable (*private*) formatter_stack = []
    
    (* Accessing the variables *)
    val mutable (*private*) formatter = default_fo
    method formatter = formatter

    (* Adding and removing tag behaviors *)
    method add_tag t o c = Hashtbl.add tags t {tag_open = o; tag_close = c}
    method get_tag t =
      let {tag_open = o; tag_close = c} = Hashtbl.find tags t in 
      o,c
    method remove_tag = Hashtbl.remove tags

    (* Changing the default mode for pcdata and cdata *)
    method push_action f =
      action_stack <-  f :: action_stack;
      action <- f
    method pop_action =
      match action_stack with
      | [] -> Log.f "Warning: empty action stack"
      |	old::l ->
      action_stack <- l;
      action <- match l with [] -> (fun s ->()) | newa::_ -> newa

    (* This is an intrusion of graphics, but I don't see any other way 
     * The last formatter always tries see_frag...
     *)
    val mutable see_frag = (fun _ -> ())
    method see_frag = see_frag

    (* Nested formatters for table cells and other usage *)
    method push_formatter fo =
      formatter <- fo;
      formatter_stack <- fo :: formatter_stack;
      self#push_action fo.format_string;
      see_frag <- fo.see_frag

    method pop_formatter =
      self#pop_action;
      match formatter_stack with
    [] -> 
      Log.f "Warning: empty formatter stack";
      default_fo
      | old::l ->
      old.flush();
      see_frag <- old.see_frag;
      formatter_stack <- l;
      formatter <- (match l with [] -> default_fo | newf :: _ -> newf);
      old

    (* This is only for robustness *)
    method flush_formatters =
      while List.length formatter_stack > 0 do
    Log.f "WARNING: too many formatters in stack";
    self#pop_formatter.flush()
      done


    (* Nested windows *)
    val table_namer = Mstring.egensym "tablecell"
    method create_formatter spec w = G.create table_namer spec w ctx

    (* ignore everything up to some tag *)
    val mutable look_for = None

    method look_for e = 
      look_for <- Some e

    (* Dispatching a token *)
    method private normal_send = function
    EOF -> self#flush_formatters;
      | CData s -> action s
      | PCData s -> action s
      | OpenTag t ->
       begin try
         let tag = Hashtbl.find tags t.tag_name in
           tag.tag_open formatter t
       with
         Not_found ->
           if !verbose then
         Log.f (sprintf "Display machine: <%s> ignored" t.tag_name)
       end
      | CloseTag n ->
       begin try
         (Hashtbl.find tags n).tag_close formatter
       with
         Not_found ->
           if !verbose then
         Log.f (sprintf "Display machine: </%s> ignored" n)
       end
      | Comment _ -> ()
      | Doctype _ -> ()

   method send tok =
     match look_for with
       None -> self#normal_send tok
     | Some it when it = tok -> 
     self#normal_send tok;
     look_for <- None
     | _ -> ()
     
   val mutable i18n_encoder = (fun s -> s : string -> string)
   method i18n_encoder = i18n_encoder
   method set_i18n_encoder enc = i18n_encoder <- enc
end


(* Standard initialisation for HTML 2.0 (+bits of 3.2) *)
let init mach =
  (* Style abbreviation 
   * TODO?: check stack.
   *)
  let push_style fo s =
   try fo.push_attr (Styles.get s)
   with Not_found -> Log.f (sprintf "Missing style : %s" s)
  and pop_style fo s =
   try fo.pop_attr (Styles.get s)
   with Not_found -> Log.f (sprintf "Missing style : %s" s)

  in

(* 5.1 HTML *)
mach#add_tag "html" ignore_open ignore_close;

(*
 * 5.2 Head: <HEAD>
 * <!ENTITY % head.content "TITLE & ISINDEX? & BASE? %head.extra">
 * <!ENTITY % head.extra "& NEXTID?">
 * NOTE: this is now handled elsewhere
 *)
mach#add_tag "head" ignore_open ignore_close;

(*
 * 5.2.1 Title: <TITLE>
 * assumes a unique Text token inside since
 * <!ELEMENT TITLE - -  (#PCDATA)*>
 * the title is not printed
 * NOTE: this is now handled elsewhere
 *)
mach#add_tag "title" ignore_open ignore_close;

(*
 * 5.2.2 Base Address: <BASE>
 * TARGET is from PR-HTML4.0
 *)

mach#add_tag "base"
    (fun fo tag ->
      begin 
    try mach#set_target (get_attribute tag "target")
       with Not_found -> ()
      end;
      begin 
    try mach#set_base (get_attribute tag "href")
       with Not_found -> 
    raise (Invalid_Html "HREF required in BASE")
      end)
    ignore_close;


(*
 * 5.2.3 Keyword Index: <ISINDEX>
 * HTML3.2: PROMPT attribute (default given)
 * NOTE: ISINDEX in HEAD is handled elsewhere, but we must keep it
 *       here because it may appear in BODY
 *)
mach#add_tag "isindex"
   (fun fo t -> fo.isindex (get_attribute t "prompt") mach#base)
   ignore_close;

(*
 * 5.2.4 Link: <LINK>
 * 5.2.5 Associated Meta-information: <META>
 * 5.2.6 Next Id: <NEXTID>
 * NOTE: this is now handled elsewhere (only in HEAD)
 *)
List.iter (fun t -> mach#add_tag t ignore_open ignore_close)
    ["link"; "meta"; "nextid"];

(*
 * 5.3 Body: <BODY>
 * <!ENTITY % html.content "HEAD, BODY">
 * Note: with textw_fo, flush disables the text widget, so anything
   beyond </BODY> will not be displayed. Some documents have multiple
   bodies, or </BODY> before the end of the document. So we decide
   to completely ignore this tag. A stricter interpretation would be
   {tag_open = ...; tag_close = (fun fo -> fo.flush())};
   Our simpled minded minimization rules also introduce multiple BODY.
 *)

mach#add_tag "body" ignore_open ignore_close;

(*
 * 5.4 Headings <H1> ... <H6>
 * <!ELEMENT ( %heading )  - -  (%text;)*>
 * Assume headings may contain typographic styles, anchors
 * HTML3.2
 * <!ATTLIST ( %heading )
 *         align  (left|center|right) #IMPLIED
 *         >
 *)

(* Private variables of header *)
let header_size = ref 0 
and header_align = ref None in

let open_header size fo tag =
  fo.new_paragraph() ;
  header_size := size;
  push_style fo (sprintf "header%d" size);
  try
    let align = get_attribute tag "align" in 
      fo.push_attr [Justification align];
      header_align := Some align
  with
    Not_found -> header_align := None

and close_header fo =
  pop_style fo (sprintf "header%d" !header_size);
  fo.close_paragraph();
  match !header_align with
    None -> ()
  | Some a -> fo.pop_attr [Justification a]

in

List.iter (function headnum ->
         mach#add_tag (sprintf "h%d" headnum)
          (open_header headnum)
          close_header)
         [1;2;3;4;5;6];

(*
 * 5.5.1 Paragraph: <P>
 *   a bit approximative in HTML 2.0
 * HTML3.2
 * <!ATTLIST P
 *         align  (left|center|right) #IMPLIED
 *         >
 *)
let paligns = ref [] in

mach#add_tag "p" 
  (fun fo tag -> 
     fo.new_paragraph ();
     try
       let a = get_attribute tag "align" in
     paligns := (Some a) :: !paligns;
     fo.push_attr [Justification a]
     with
       Not_found -> paligns := None :: !paligns)
  (fun fo ->
     fo.close_paragraph();
     match !paligns with
       [] -> () (* that's an error actually *)
     | (Some a)::l ->
     fo.pop_attr [Justification a];
     paligns := l
     | None::l ->
     paligns := l
    );

(* 
 * 5.5.2 Preformatted Text : <PRE>
 *    TODO: optional attribute WIDTH
 *    should be fixed font, respecting newlines
 *    local styles authorized however (i.e. markup is parsed)
*)
let open_pre fo tag =
  fo.new_paragraph();
  push_style fo "verbatim";
  mach#push_action fo.print_verbatim
and close_pre fo =
  pop_style fo "verbatim";
  fo.close_paragraph();
  mach#pop_action

in
(* 5.5.2.1 Example and Listing: <XMP>, <LISTING>
 *    deprecated anyway
 *)

List.iter (function s -> mach#add_tag s open_pre close_pre)
          ["pre"; "listing"; "xmp"];

(*
 * 5.5.3 Address: <ADDRESS>
 *)
mach#add_tag "address" 
   (fun fo tag -> fo.new_paragraph(); push_style fo "italic")
   (fun fo -> pop_style fo "italic"; fo.close_paragraph());

(*
 * 5.5.4 Block Quote: <BLOCKQUOTE>
 *)
mach#add_tag "blockquote"
   (fun fo tag ->
      fo.new_paragraph();
      push_style fo "italic";
      fo.push_attr [Margin 10])
   (fun fo ->
      pop_style fo "italic";
      fo.pop_attr [Margin 10];
      fo.close_paragraph());

(*
 * 5.6.1 Unordered List: <UL>, <LI>
 * HTML3.2 
 * <!ENTITY % ULStyle "disc|square|circle">
 * 
 * <!ATTLIST UL -- unordered lists --
 *         type    (%ULStyle)   #IMPLIED   -- bullet style --
 *         compact (compact)    #IMPLIED   -- reduced interitem spacing --
 *         >
 *)

let list_level = ref 0 in
let open_list fo tag =
  fo.push_attr [Margin 10];
  incr list_level;
  let bullet = 
    try get_attribute tag "type" 
    with Not_found ->
       match !list_level mod 3 with
         1 -> "disc" | 2 -> "circle" | _ -> "square" in
  let compact = has_attribute tag "compact"
  and first_line = ref true in
  fo.new_paragraph();
  mach#add_tag "li"
     (fun fo tag -> 
        if !first_line then first_line := false
    else if compact then fo.print_newline false else fo.new_paragraph();
        let bullet = try get_attribute tag "type" with Not_found -> bullet in
    fo.bullet bullet)
     (fun fo -> 
        if not compact then fo.close_paragraph())

and close_list fo =
  decr list_level;
  fo.close_paragraph();
  fo.pop_attr [Margin 10];
  mach#remove_tag "li"
in

mach#add_tag "ul" open_list close_list;

(* 
 * 5.6.2 Ordered List: <OL>, <LI>
 * HTML3.2
 * <!--
 *        Numbering style
 *     1   arablic numbers     1, 2, 3, ...
 *     a   lower alpha         a, b, c, ...
 *     A   upper alpha         A, B, C, ...
 *     i   lower roman         i, ii, iii, ...
 *     I   upper roman         I, II, III, ...
 * 
 *     The style is applied to the sequence number which by default
 *     is reset to 1 for the first list item in an ordered list.
 * -->
 * 
 * <!ENTITY % OLStyle "CDATA" -- "1|a|A|i|I" but SGML folds case -->
 * 
 * <!ATTLIST OL -- ordered lists --
 *         type     (%OLStyle)  #IMPLIED   -- numbering style --
 *         start     NUMBER     #IMPLIED   -- starting sequence number --
 *         compact  (compact)   #IMPLIED   -- reduced interitem spacing --
 *         >
 *)

let numbering_styles =
  ["1", string_of_int;
   "a", lowernumber;
   "A", uppernumber;
   "i", (function i -> String.lowercase (roman i));
   "I", roman
  ]
in

let open_nlist, close_nlist =
  let nesting = ref [] in
  (* open_list *)
  (fun fo tag ->
    let li_counter = ref (try int_of_string (get_attribute tag "start")
                          with _ -> 1) in
     fo.push_attr [Margin 10];
     nesting := li_counter :: !nesting;
     let thisnumbers = List.rev !nesting
     and numbering = 
       try List.assoc (get_attribute tag "type") numbering_styles 
       with Not_found -> string_of_int
     and compact = has_attribute tag "compact" in
     mach#add_tag "li"
       (fun fo tag ->
      fo.new_paragraph();
      if compact then fo.push_attr [Spacing 0];
      (* if value is given, use it as number *)
      begin
        try
          let n = int_of_string (get_attribute tag "value") in
          match !nesting with
        c::_ -> c := n
          |	_ -> () (* assert false *)
        with
          Not_found | Failure "int_of_string" -> ()
      end;
      List.iter (function i ->
            fo.format_string (numbering !i);
            fo.format_string ".")
            thisnumbers
      )
       (fun fo ->
     incr li_counter;
      if compact then fo.pop_attr [Spacing 0];
      fo.close_paragraph())),
  (* close_list *)
  (fun fo ->
    fo.pop_attr [Margin 10];
    nesting := begin match !nesting with [] -> [] | x::l -> l end;
    mach#remove_tag "li")
  in

mach#add_tag "ol" open_nlist close_nlist;

(*
 * 5.6.3 Directory List: <DIR>
 * 5.6.4 Menu List: <MENU>
 *  do as <UL>, but we should work on presentation
 *)

mach#add_tag "dir" open_list close_list;
mach#add_tag "menu" open_list close_list;

(*
 * 5.6.5 Definition List: <DL>, <DT>, <DD> 
 *)
let open_dl, close_dl =
  (* open_dl *)
  (fun fo tag ->
    let compact = has_attribute tag "compact" in
      fo.new_paragraph();
      fo.push_attr [Margin 10];
      if not compact then begin
      let prev_is_dt = ref false in
    mach#add_tag "dt"
      (fun fo tag -> 
        if not !prev_is_dt then begin
          fo.new_paragraph();
          prev_is_dt := true
         end
        else fo.print_newline false;
        push_style fo "bold")
      (fun fo -> pop_style fo "bold");
    mach#add_tag "dd"
      (fun fo tag ->
          if !prev_is_dt then begin
        fo.close_paragraph();
        prev_is_dt := false
           end;
          fo.new_paragraph();
          fo.push_attr [Margin 20])
      (fun fo ->
          fo.pop_attr [Margin 20];
          fo.close_paragraph())
       end
      else begin
    let first_item = ref true in
    mach#add_tag "dt"
      (fun fo tag -> 
        if not !first_item then fo.print_newline false
            else first_item := false;
            push_style fo "bold")
      (fun fo -> pop_style fo "bold");
    mach#add_tag "dd"
      (fun fo tag ->
        if not !first_item then fo.print_newline false
            else first_item := false;
        fo.push_attr [Margin 20])
      (fun fo -> fo.pop_attr [Margin 20])
       end),
   (* close_dl *)
   (fun fo ->
      fo.pop_attr [Margin 10];
      fo.close_paragraph();
      mach#remove_tag "dt";
      mach#remove_tag "dd")
in

mach#add_tag "dl" open_dl close_dl;

(* Different typographic styles, shared *)
let italic_style t = 
  mach#add_tag t 
     (fun fo tag -> push_style fo "italic")
     (fun fo -> pop_style fo "italic")
and fixed_style t =
  mach#add_tag t 
    (fun fo tag -> push_style fo "fixed")
    (fun fo -> pop_style fo "fixed")
and bold_style t =
  mach#add_tag t 
    (fun fo tag -> push_style fo "bold")
    (fun fo -> pop_style fo "bold")
in

(*
 * 5.7.1.1 Citation: <CITE>
 * 5.7.1.2 Code: <CODE>
 * 5.7.1.3 Emphasis: <EM>
 * 5.7.1.4 Keyboard: <KBD>
 * 5.7.1.5 Sample: <SAMP>
 * 5.7.1.6 Strong Emphasis: <STRONG>
 * 5.7.1.7 Variable: <VAR>
 *)

List.iter italic_style ["cite"; "em"; "var"];
List.iter fixed_style ["code"; "kbd"; "samp"];
bold_style "strong";
(*
 * 5.7.2.1 Bold: <B>
 * 5.7.2.2 Italic: <I>
 * 5.7.2.3 Teletype: <TT>
 *)
bold_style "b";
italic_style "i";
fixed_style "tt";

(*
 * 5.7.3 Anchor: <A> 
 * Assumes anchors are not nested
 * Can be both HREF and NAME.
 *)

let anchor_type = ref None
and anchor_link = 
  ref {h_uri = ""; h_context = None; h_method = GET; h_params = []}
and in_anchor = ref false
in
let open_anchor fo tag =
  anchor_type := None;
  (* is there a NAME attribute ? *)
  begin
     try 
       fo.add_mark (get_attribute tag "name");
       anchor_type := Some NAME
     with 
       Not_found -> ()
  end;
  (* is there an HREF attribute ? (if both, anchor_type is set to HREF *)
  (* so that close_anchor does the right thing) *)
  begin
    try
      let href = get_attribute tag "href" in
      let h_params =
    try ["target", get_attribute tag "target"]
    with
      Not_found ->
        match mach#target with
          Some s -> ["target", s]
        | None -> []
      in
      anchor_link := 
    { h_uri = href;
      h_context = Some mach#base;
      h_method = 
         (try parse_method (get_attribute tag "methods")
          with _ -> GET);
      h_params = h_params};
      in_anchor := true;
      anchor_type := Some HREF;
      fo.start_anchor ();
      (* push_style fo "anchor" *)
    with
      Not_found ->
    match !anchor_type with
      None -> raise (Invalid_Html "Missing NAME or HREF in <A>")
    | _ -> ()
  end

and close_anchor fo =
  match !anchor_type with
    Some HREF -> 
      fo.end_anchor !anchor_link;
      (* pop_style fo "anchor"; *)
      in_anchor := false;
      anchor_type := None
 |  Some NAME ->
      in_anchor := false;
      anchor_type := None
 |  None -> raise (Invalid_Html "Unmatched </A>")

in

mach#add_tag "a" open_anchor close_anchor;

(*
 * 5.8 Line break: <BR> 
 *)
mach#add_tag "br" 
    (fun fo tag ->
      fo.print_newline true)
    ignore_close;

(*
 * 5.9 Horizontal Rule: <HR>
 *)
mach#add_tag "hr"
    (fun fo tag -> 
      let width =
    try length_of_string (get_attribute tag "width")
    with Not_found -> Nolength 
      and height =
    try int_of_string (get_attribute tag "size")
    with Not_found | Failure "int_of_string" -> 1
      and solid = has_attribute tag "noshade" in
      fo.print_newline false;
      fo.hr width height solid;
      fo.print_newline false)
    ignore_close;

(*
 * 5.10 Image: <IMG>
 *)

mach#add_tag "img"
    (fun fo tag -> 
      try
       let src = get_attribute tag "src" in
       let align = get_attribute tag "align"
       and width = 
     try Some (int_of_string (get_attribute tag "width"))
     with Not_found | Failure "int_of_string" -> None
       and height = 
     try Some (int_of_string (get_attribute tag "height"))
     with Not_found | Failure "int_of_string" -> None
       and alt = 
     try get_attribute tag "alt"
         with Not_found ->
          let image_name = 
       let pos = 
         let cpos = ref (String.length src) in
         try
           while !cpos > 0 do
         match src.[!cpos - 1] with
           '/' | '\\' (* for f!@#ing DOS users *) -> raise Exit
         | _ -> decr cpos
           done;
           0
         with
           Exit -> !cpos
       in
       if pos = String.length src then "IMAGE"
       else String.sub src pos (String.length src - pos)
     in
         Printf.sprintf "[%s]" image_name	 
       in          
       let w = fo.create_embedded align width height in
       let link =
      { h_uri = src; h_context = Some mach#base;
        h_method = GET; h_params = []} in
       (* some people use both ismap and usemap...
          prefer usemap
        *)
       let map = 
     try 
       let mapname = get_attribute tag "usemap"  in
         Maps.ClientSide { h_uri = mapname;
                   h_context = Some mach#base;
                   h_method = GET;
                   h_params = []}
     with Not_found -> 
       if !in_anchor then
         if has_attribute tag "ismap"
         then Maps.ServerSide !anchor_link
         else Maps.Direct !anchor_link
       else NoMap
       in
       mach#imgmanager#add_image  
            {embed_hlink = link;
             embed_frame = w;
             embed_context = mach#ctx#for_embed tag.attributes [];
             embed_map = map;
             embed_alt = alt}
      with
       Not_found -> (* only on SRC *)
    raise (Invalid_Html "missing SRC in IMG"))
   ignore_close;

(* FORMS: they are defined elsewhere (html_form) *)
  FormLogic.init mach;
(* standard basic HTML2.0 initialisation stops here *)

(* TABLE support *)
  if !attempt_tables then TableLogic.init mach
  else begin
    let behave_as oldtag newtag =
      mach#add_tag newtag
    (fun fo t -> mach#send (OpenTag {tag_name = oldtag; attributes = []}))
    (fun fo -> mach#send (CloseTag oldtag)) in
    (* use DL for tables *)
    behave_as "dl" "table";
    mach#add_tag "tr" ignore_open ignore_close;
    behave_as "dt" "th";
    behave_as "dd" "td"
    end;

(* EMBED
 *  The definition is a mix of what was done for earlier versions
 *  of MMM and Netscape Navigator. The reason is to get compatible HTML for
 *  Caml Applets in both browsers.
 *)

  mach#add_tag "embed"
    (fun fo tag -> 
       try
     let link = {
       h_uri = get_attribute tag "src";
       h_method = GET;
       h_context = Some mach#base;
       h_params = []} in
     let width =
       try Some (int_of_string (get_attribute tag "width"))
       with Not_found -> None
     and height =
       try Some (int_of_string (get_attribute tag "height"))
       with Not_found -> None
     and alttxt = get_attribute tag "alt" in

     let fr = fo.create_embedded "" width height in
     mach#add_embedded {
         embed_hlink = link;
         embed_frame = fr;
         embed_context = mach#ctx#for_embed tag.attributes [];
         embed_map = NoMap; (* yet *)
         embed_alt = alttxt
        }
       with
     Not_found ->
       raise (Invalid_Html ("SRC missing in EMBED")))
    ignore_close;

  (* Some HTML 3.2 obnoxious features *)
  (* STYLE, SCRIPT in HEAD: not managed here
     For some reason, script is also allowed in text by the DTD.
     Make sure we just dump the contents...
     We do the same for style, just in case people dont respect the DTD
   *)
  mach#add_tag "style"
      (fun fo t -> mach#push_action (fun s -> ()))
      (fun fo -> mach#pop_action);
  mach#add_tag "script"
      (fun fo t -> mach#push_action (fun s -> ()))
      (fun fo -> mach#pop_action);
  (* Some HTML 3.2 flashy features *)
  mach#add_tag "center"
      (fun fo t -> fo.push_attr [Justification "center"])
      (fun fo -> fo.pop_attr [Justification "center"]);
  mach#add_tag "div"
      (fun fo t -> fo.push_attr [Justification (get_attribute t "align")])
      (fun fo -> fo.pop_attr [Justification "whocares"]);
  mach#add_tag "big"
      (fun fo t -> fo.push_attr [Font (FontDelta 2)])
      (fun fo  -> fo.pop_attr [Font (FontDelta 2)]);
  mach#add_tag "small"
      (fun fo t -> fo.push_attr [Font (FontDelta (-2))])
      (fun fo  -> fo.pop_attr [Font (FontDelta (-2))]);
  mach#add_tag "u"
      (fun fo t -> fo.push_attr [Underlined])
      (fun fo  -> fo.pop_attr [Underlined]);
  mach#add_tag "strike"
      (fun fo t -> fo.push_attr [Striked])
      (fun fo  -> fo.pop_attr [Striked]);
  mach#add_tag "sup"
      (fun fo t -> fo.push_attr [Superscript])
      (fun fo  -> fo.pop_attr [Superscript]);
  mach#add_tag "sub"
      (fun fo t -> fo.push_attr [Lowerscript])
      (fun fo  -> fo.pop_attr [Lowerscript]);
  mach#add_tag "basefont"
      (fun fo t -> 
    try
      let n = int_of_string (get_attribute t "size") in
      fo.set_defaults "font" [Font (FontIndex n)]
    with
      Not_found | Failure "int_of_string" ->
        raise (Invalid_Html "invalide SIZE"))
      ignore_close;
  let fontchanges = ref [] in
  mach#add_tag "font"
      (fun fo t ->
     let attrs = [] in
     let attrs =
       try
             let size = get_attribute t "size" in
             let l = String.length size in
           if l = 0 then raise Not_found
           else if size.[0] = '+' then
        (Font (FontDelta (int_of_string (String.sub size 1 (pred l)))))
                     :: attrs
               else if size.[0] = '-' then
             (Font (FontDelta (int_of_string size)))::attrs
               else (Font (FontIndex (int_of_string size)))::attrs
       with 
          Not_found -> attrs 
            | Failure _ -> attrs
       in
         let attrs = 
       try
         let color = get_attribute t "color" in
               (FgColor color)::attrs
       with Not_found -> attrs in
     (* attrs may well be the empty list *)
      if attrs <> [] then fo.push_attr attrs;
      fontchanges := attrs :: !fontchanges)
      (fun fo -> 
     match !fontchanges with
      [] -> raise (Invalid_Html "unmatched </font>")
        | x::l -> 
        fontchanges := l;
        if x <> [] then fo.pop_attr x);

  (* Some HTML 3.2 good features *)
  let areas = ref []
  and mapname = ref ""
  in
  mach#add_tag "map"
      (fun fo t ->
         (* the name of the map *)
         let absname = 
           try 
        let name = get_attribute t "name" in
        (* we must get a normalized name here *)
          Hyper.string_of {h_uri = "#"^name; h_context = Some mach#base;
                  h_method = GET; h_params = []}
           with
         Not_found -> 
           Hyper.string_of {h_uri = mach#base; h_context = None;
                h_method = GET; h_params = []}
         in
         mapname := absname;
         areas := [];
         mach#add_tag "area" 
        (fun fo tag -> 
           let shape = String.lowercase (get_attribute tag "shape")
           and href = 
         try Some (get_attribute tag "href") with Not_found -> None
               and coords =
         try Maps.parse_coords (get_attribute tag "coords")
         with _ -> [] 
               and alttxt =
                 try get_attribute tag "alt" with Not_found -> ""
               in
           let h_params =
         try ["target", get_attribute tag "target"]
         with
           Not_found ->
             match mach#target with
               Some s -> ["target", s]
             |	None -> []
           in
               match href with
         None -> () (* this creates a HOLE. not yet supported *)
           | Some uri ->
          let link = {h_uri = uri; h_context = Some mach#base;
                  h_method = GET; h_params = h_params} in
                  let area = 
            match shape with
             "default" -> {area_kind = Default; area_coords = [];
                   area_link = link; area_alt = alttxt}
           | "rect" -> {area_kind = Rect; area_coords = coords;
                area_link = link; area_alt = alttxt}
           | "circle" -> {area_kind = Circle; area_coords = coords;
                  area_link = link; area_alt = alttxt}
           | "poly" -> {area_kind = Poly; area_coords = coords;
                area_link = link; area_alt = alttxt} 
           | _ -> {area_kind = Default; area_coords = [];
                area_link = link; area_alt = alttxt} in
                  areas := area :: !areas)
            ignore_close)
 
     (fun fo -> 
     mach#remove_tag "area";
     Maps.add !mapname !areas)


let create (ctx, imgmanager) =
 let mach = new display_machine (ctx, imgmanager) in
   init mach;
   List.iter (fun f -> f (mach :> machine)) !user_hooks;
   (mach :> machine)

end

@


\section{[[./gui/]]}

\subsection*{[[./gui/about.mli]]}

<<signature About.create_tachy>>=
val create_tachy : Widget.widget -> Low.tachymeter
@

<<signature About.f>>=
val f : unit -> unit
@


%-------------------------------------------------------------

<<./gui/about.mli>>=
<<signature About.create_tachy>>

<<signature About.f>>
@


\subsection*{[[./gui/about.ml]]}

<<function About.f>>=
let f () =
  ignore (
    Frx_dialog.f Widget.default_toplevel (Mstring.gensym "about")
    "About MMM" (Version.about (Lang.lang ()))
    (Tk.Predefined "info") 0 ["Thanks"])
@

<<constant About.tachy_data>>=
(* inside bitmap, circle is in +16+7 +66+57, radius 25 *)

let tachy_data = "GIF\056\057aP\000A\000\227\000\000\000\000\000\
\044\044\044\060\000\000YYY\138\138\138\154\154\154\170\
\170\170\186\186\186\203\203\203\219\219\219\231qq\235\235\
\235\243yy\255\255\255\000\000\000\000\000\000\033\249\004\
\001\000\000\009\000\044\000\000\000\000P\000A\000\000\004\
\255\048\201I\171\189\024H\157\056\199\096\040\142\164\213\
Hg\146\166e\235\190p\060\013\052\045\223DN\000\
M\225\223\148\001\133\005\020\233\142\187\158oY\184\009\
\039\196\162\005I\229\049\153\006\131E\032z\162\164\023\
\042\178\144\188\250\178\232J\180\226U\021\063\146\129\248\
\136\174c\235\233\009\220\212\232\175a\041\052sx\132\
\133\133P\096\033p\130H\134\142\143\006\007z\137\032\
\129rt\144\153x\007\156\136\148\147\051\151\058\154\164\
Y\156\156\004\160\159n\009\003\000\152\165\164\167I\158\
\171\173r\175\004\177\187\007I\157\018\092\171\140\059\187\
\197\060\167\146\095\148\195\186\197\197\200\008\008\182\173\176\
\206\188\007\209\210\194\213\214\187\217\209\171\141\221\206\223\
\218\137\226\227\228\223\148\220\233\222\217\231\237\238\165\229\
\096\242\143\001\001\003\001\006\174\053\006\249\000\210\131\039\
\229\158\035\125\253\250\001\232\055\064\033\141\129\230\054\196\
\064G\010\192\190\044\251\030fA\056\240\194\031\035\163\
\255b\185J\008\208\031\198\128\177\216\133\044\165\049\203\
\194\135\015\045\166\180\176\167\132AC\045\255\213\216\185\
\203\227\011\138\243\172\197\203\017t\030\205\018\031n\022\
\037u\164\150\136\020J\151f\002\064\181f\139\170\011\
\221\037\152\231\039\133\213\011\031\186J\029\167\160\172\002\
\167\033\160\046\025\219\205\236Y\025w\216\022s\043\241\
\197\021\185\187\220\190e\229\034\046\094Mt\129\248\253\
\011\041p\135\024\131\009\059\050\204\183\197\093\197\143\220\
\050\144\178\022r\228\178\147\041\023\176\092X\001\131\204\
E\054s\094\236\249s\162\209\139\063\131\150\130\186P\
i\211\148Z\215y\189\026\140l\052\170a\127\186M\
\123Z\029N\144\049\171\158\182\053R\175\172x\001\044\
\016N\092\002\170cx\023\044P\094\182\249\004\095\192\
\199J\151\174\220\250\016d\217\231m\031\239\253\176s\
\240\008\196\143\151\190\225k\034\022\208\178u\091\191\125\
\210G\091\156\202\201\039E\159\252\144\251\211\232\183N\
\045qxH\208\095\125\229\149\032\096\005\180Lp\096\
\130\048\012HA\131\009\244\007a\056\060\024\232\223\133\
\024\158\192\030\135\032\134\040\226\136\036\194\016\001\000\059\
"
@

<<constant About.park_data>>=
let park_data =
"#define break_width 15
#define break_height 11
static char break_bits[] = {
   0x0c, 0x18, 0xf4, 0x17, 0x3a, 0x2e, 0xba, 0x2d, 0xb9, 0x4d, 0x3d, 0x5e,
   0xb9, 0x4f, 0xba, 0x2f, 0xba, 0x2f, 0xf4, 0x17, 0x08, 0x08};
"
@

<<constant About.pi>>=
let pi = 3.1415926 
@

<<constant About.log10>>=
let log10 = log 10.0 
@

<<function About.create_tachy>>=
let create_tachy top = 
  let o = new default_tachy top in
  o#start;
@


%-------------------------------------------------------------

<<./gui/about.ml>>=
open Tk

<<function About.f>>


(* Tachymeter *)

(* gif is 80x65 *)
<<constant About.tachy_data>>
<<constant About.park_data>>


<<constant About.pi>>
<<constant About.log10>>

class default_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable canvas = top (* dummy initialisation *)
  val mutable alive = false

  (* Various components of the canvas, all with dummy init values *)
  val mutable i_park = Tag "none"
  val mutable kilos = Tag "none"
  val mutable aig = Tag "none"
  val mutable pendings = Tag "none"


  (* this one is private *)
  method start =
    let c =
      Canvas.create_named top "tachymeter"
       [Width (Pixels 80); Height (Pixels 80); 
         BorderWidth (Pixels 0);
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *)] in
    (* Use colors so that images are not transparent *)  
    let tachy_image = 
      begin
       try
      let bgc = Tk.cget c CBackground in
           Protocol.tkCommand 
        [|Protocol.TkToken "set";
          Protocol.TkToken "TRANSPARENT_GIF_COLOR";
          Protocol.TkToken bgc |]
       with _ -> ()
      end;
    (* Agghaaa !!! TCL/TK doesn't support -data for GIF !!! *)
      let file = Msys.mktemp "tachy.gif" in
      let oc = open_out_bin file in
      output_string oc tachy_data;
      close_out oc;
      let img = Imagephoto.create [File file] in
      Msys.rm file;
      img
    and park_image =
      Imagebitmap.create [Data park_data; Foreground Red] in

    i_park <-
      Canvas.create_rectangle c 
     (Pixels 72) (Pixels 3) 
     (Pixels 75) (Pixels 6) [FillColor Black];
    
    kilos <-
      Canvas.create_text c (Pixels 40) (Pixels 73) [Text "0"];
    
    aig <-
      Canvas.create_line c [Pixels 41; Pixels 32; Pixels 41; Pixels 57]
                       [Width (Pixels 2)];
    pendings <-
      Canvas.create_text c (Pixels 70) (Pixels 60) [Text "0"];

    let i_tachy =
      Canvas.create_image c (Pixels 0) (Pixels 0)
       [ImagePhoto tachy_image; Anchor NW]

    in

    Canvas.lower_bot c pendings;
    (* All other items must be put above the background image *)
    List.iter (fun i -> Canvas.raise_above c i i_tachy)
      [kilos; aig; i_park];

    bind c (Glevents.get "tachy_about") (BindSet ([], (fun _ -> f ())));

    bind c (Glevents.get "tachy_gc") (BindSet ([], (fun _ -> Frx_mem.f())));

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));

    pack [c][];
    alive <- true;
    canvas <- c

  val mutable last_speed = 0.
  val mutable last_total = 0
  val mutable idle = false

  method update speed total =
    if speed = 0.0 then begin
      if not idle then begin
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black];
    idle <- true
      end
    end
    else begin
      Canvas.configure_rectangle canvas i_park [FillColor Green;
                         Outline Green];
      idle <- false
    end;
    if total <> last_total then
      Canvas.configure_text canvas kilos [Text (string_of_int total)];
    last_total <- total;
    let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
    let speeds = (last_speed +. speed) /. 2. in
    if abs_float (speeds -. last_speed) > 0.1 then begin
      last_speed <- speeds;
      let v = speeds /. log10 in
      let angle = v /. 4.0 *. pi in
      let angle = if angle < 0.1 then 0.0 else angle in
      let x = 41.0 -. (sin angle *. 25.0)
      and y = 32.0 +. (cos angle *. 25.0) in
      Canvas.coords_set canvas aig 
    [Pixels 41; Pixels 32;
      Pixels (truncate x); Pixels (truncate y)];
      Low.update_idletasks()
    end

  method report_cnx n = 
    if Winfo.exists canvas then
      if n = 0 then begin
    Canvas.configure_text canvas pendings [Text ""];
       Canvas.lower_bot canvas pendings
      end
      else begin
    Canvas.configure_text canvas pendings 
      [Text (string_of_int n)];
       Canvas.raise_top canvas pendings
      end

  method report_busy busy =
    if Winfo.exists canvas then
      if busy then begin
       Canvas.lower_bot canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Red;
                          Outline Red];
    Low.update_idletasks()
      end
      else begin
       Canvas.raise_top canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy canvas

end

<<function About.create_tachy>>
  (o :> Low.tachymeter)

@


\subsection*{[[./gui/fontprefs.ml]]}

<<function Fontprefs.fontspec2attrs>>=
let fontspec2attrs s =
  let tokens = Mstring.split_str (fun c -> c='-') s in
  if List.length tokens <> 14 then
    failwith ("incomplete font specification: " ^ s)
  else (* should not fail *)
    let attrs = ref [] in
      (match List.nth tokens 1 
       with "*" -> () | s -> attrs := (Family s) :: !attrs);
      (match List.nth tokens 2 
       with "*" -> () | s -> attrs := (Weight s) :: !attrs);
      (match List.nth tokens 3 
       with "*" -> () | s -> attrs := (Slant s) :: !attrs);
      (match List.nth tokens 6 with
         "*" -> () 
    | s -> try
             attrs := (FontIndex (font_index (int_of_string s))) :: !attrs
           with Failure "int_of_string" ->
         failwith ("pxlsz not an integer: " ^ s));
      !attrs
@

<<function Fontprefs.attrs2fontspec>>=
let attrs2fontspec l =
  let rec family = function
     [] -> "*"
   | (Family s)::_ -> s
   | x::l -> family l
  and weight = function
     [] -> "*"
   | (Weight s)::_ -> s
   | x::l -> weight l
  and slant = function
     [] -> "*"
   | (Slant s)::_ -> s
   | x::l -> slant l
  and pxlsz = function
     [] -> "*"
   | (FontIndex s)::_ -> string_of_int (Fonts.pxlsz s)
   | x::l -> pxlsz l in

  sprintf "-*-%s-%s-%s-normal-*-%s-*-*-*-*-*-iso8859-1"
          (family l) (weight l) (slant l) (pxlsz l)
@

<<constant Fontprefs.default_families>>=
(* Build a family menu *)
let default_families = 
  ["courier"; "helvetica"; "lucida"; "new century schoolbook";
   "times"; "fixed"; "*"]
@

<<function Fontprefs.families>>=
let families () =
 Tkresource.stringlist "fontFamilies" default_families
@

<<function Fontprefs.family_select>>=
let family_select top v = 
  Optionmenu.create  top v (families())
@

<<constant Fontprefs.default_weights>>=
(* Build a weight menu *)
let default_weights = ["bold"; "medium"; "*"]
@

<<function Fontprefs.weights>>=
let weights () =
  Tkresource.stringlist "fontWeights" default_weights
@

<<function Fontprefs.weight_select>>=
let weight_select top v =
  Optionmenu.create top v (weights())
@

<<constant Fontprefs.default_slants>>=
(* Build a slant menu *)
let default_slants = ["r"; "i"; "o"; "*"]
@

<<function Fontprefs.slants>>=
let slants () = 
  Tkresource.stringlist "fontSlants" default_slants
@

<<function Fontprefs.slant_select>>=
let slant_select top v =
  Optionmenu.create top v (slants())
@

<<function Fontprefs.pixels>>=
(* Build a pixel size menu *)
let pixels() =
  Tkresource.stringlist "fontPixels" Fonts.default_sizes
@

<<function Fontprefs.pixels_select>>=
let pixels_select top v = 
  Optionmenu.create top v (pixels())
@

<<function Fontprefs.font_select>>=
(* fontspecv is the variable used for the full X font name; it is used
 * internally (and for saving the prefs), and must be maintained consistent
 * with the displayed state.
 *   - initialisation time : 
 *      given the attributes, write the X name in the variable
 *   - edition time:
 *      electric update of the variable and the styles
 *)

let font_select top getattrs setattrs =
  let familyv = Textvariable.create_temporary top
  and weightv = Textvariable.create_temporary top
  and slantv = Textvariable.create_temporary top
  and pixelsv = Textvariable.create_temporary top
  and fontspecv = Textvariable.create_temporary top
  in
  let f = Frame.create top [] in
  let buttons = 
    List.map2 (fun create v -> 
                 Textvariable.set v "*"; 
                 let x,_ = create f v in x) 
              [family_select; weight_select; slant_select; pixels_select]
              [familyv; weightv; slantv; pixelsv] in
  pack buttons [Side Side_Left];
  (* electric updates 
   * Whenever one of the attributes changes, we must change the fontspec
   * and possibly recompute the attributes
   *)
  let setv _ =
    let font = sprintf "-*-%s-%s-%s-normal-*-%s-*-*-*-*-*-iso8859-1"
        (Textvariable.get familyv)
    (Textvariable.get weightv)
    (Textvariable.get slantv)
        (Textvariable.get pixelsv)
    in 
    let attrs = fontspec2attrs font in
    Textvariable.set fontspecv font;
    setattrs attrs
  in
  List.iter (fun v ->
    let rec el () = Textvariable.handle v (fun () -> setv(); el()) in el())
    [familyv; weightv; slantv; pixelsv];
  
  (* initialisation from memory (v=fontspecv) *)
  let init_pref v =
    let attrs = getattrs() in
    (* Set all variables; electric update does the rest *)
    List.iter (function
        Family s -> Textvariable.set familyv s
      | Weight s -> Textvariable.set weightv s
      | Slant s -> Textvariable.set slantv s
      | FontIndex s ->
          Textvariable.set pixelsv (string_of_int (Fonts.pxlsz s))
      |	_ -> assert false)
      attrs
  (* initialisation from loaded strings (v=fontspecv) *)
  and set_pref v =
    let font = Textvariable.get v in
    let attrs = fontspec2attrs font in
    (* Set all variables; electric update rewrites everything (duh) *)
    List.iter (function
        Family s -> Textvariable.set familyv s
      | Weight s -> Textvariable.set weightv s
      | Slant s -> Textvariable.set slantv s
      | FontIndex s ->
          Textvariable.set pixelsv (string_of_int (Fonts.pxlsz s))
      |	_ -> assert false)
      attrs
  in
  f, fontspecv, init_pref, set_pref
@


%-------------------------------------------------------------

<<./gui/fontprefs.ml>>=
open Printf
open Tk
(* Specify set of attributes of a font *)
(* family, weight, slant, pxlsz *)
(* We use a font string, and select only the relevant components *)
(* 
-fndry-fmly-wght-slant-sWdth-adstyl-pxlsz-ptSz-resx-resy-spc-avgWdth-reg-enc
   0    1    2    3     4      5     6     7    8    9   10    11     12  13
*)
open Fonts

<<function Fontprefs.fontspec2attrs>>

<<function Fontprefs.attrs2fontspec>>

<<constant Fontprefs.default_families>>
<<function Fontprefs.families>>

<<function Fontprefs.family_select>>

<<constant Fontprefs.default_weights>>
<<function Fontprefs.weights>>
<<function Fontprefs.weight_select>>

<<constant Fontprefs.default_slants>>
<<function Fontprefs.slants>>
<<function Fontprefs.slant_select>>

<<function Fontprefs.pixels>>
<<function Fontprefs.pixels_select>>


<<function Fontprefs.font_select>>

    

@


\subsection*{[[./gui/gcache.mli]]}

<<signature Gcache.debug>>=
(* Cache by "widget unmapping"
 *  For each navigator, we keep the list of displayed documents
 *)

val debug : bool ref
@

<<signature Gcache.max_keep>>=
val max_keep : int ref
@

<<signature Gcache.kill>>=
val kill : int -> unit
  (* [kill hkey] destroy all widget cached for navigator [hkey]
     If in history mode, accordingly remove from Cache documents
     that are not shared with other navigator windows
   *)
@

<<signature Gcache.find>>=
val find : int -> Document.document_id -> Viewers.display_info
@

<<signature Gcache.add>>=
val add : int -> Document.document_id -> Viewers.display_info -> unit
@

<<signature Gcache.remove>>=
val remove : int -> Document.document_id -> unit
@

<<signature Gcache.displace>>=
val displace : int -> Document.document_id -> unit
@

<<signature Gcache.postmortem>>=
val postmortem : unit -> unit
@


%-------------------------------------------------------------

<<./gui/gcache.mli>>=
<<signature Gcache.debug>>

<<signature Gcache.max_keep>>

<<signature Gcache.kill>>

<<signature Gcache.find>>
<<signature Gcache.add>>
<<signature Gcache.remove>>
<<signature Gcache.displace>>

<<signature Gcache.postmortem>>

@


\subsection*{[[./gui/gcache.ml]]}

<<constant Gcache.debug>>=
(* Cache by "widget unmapping"
 *  For each navigator, we keep the list of displayed documents
 *)

let debug = ref false
@

<<constant Gcache.max_keep>>=
let max_keep = ref 5
  (* maximum number of cached widget in a given window *)
@

<<constant Gcache.table>>=
let table = (Hashtbl.create 37 :
              (int, (document_id * display_info) list ref) Hashtbl.t)
@

<<function Gcache.get_nav>>=
let get_nav hkey =
  try
    Hashtbl.find table hkey
  with
    Not_found ->
      let r = ref [] in
       Hashtbl.add table hkey r;
       r
@

<<function Gcache.find>>=
(* Find a document in a given window
 * Called by the navigator when attempting to display a new request.
 * Also called by back/forward navigation in the history
 *)
let find hkey did =
  let r = get_nav hkey in
  List.assoc did !r
@

<<function Gcache.nocache>>=
(* History mode: when we remove a document from the gcache, and that it
   was its only displayed instance, then we must also remove it from cache
 *)
let nocache did =
 if !debug then Log.f
    (sprintf "Removing %s from cache" (Url.string_of did.document_url));
 let shared = ref false in
  Hashtbl.iter (fun key dis -> if List.mem_assoc did !dis then shared := true)
    table;
 if not !shared then Cache.kill did
 else  
   if !debug then Log.f "Don't, it's shared"
@

<<function Gcache.remove>>=
(* Removes a given dinfo for a cached document
 *   used when adding in the middle of the history
 *)
let remove hkey did =
  if !debug then Log.f
    (sprintf "Removing %s in window %d" (Url.string_of did.document_url) hkey);
  try
    let r = Hashtbl.find table hkey in
    let di = List.assoc did !r in
     di#di_abort;
     di#di_destroy;
     r := Mlist.except_assoc did !r;
    if !Cache.history_mode then nocache did
  with
     Not_found -> Log.debug "Gcache.remove failed !"
@

<<function Gcache.displace>>=
(* Removing only to redisplay (update) *)
let displace hkey did =
  if !debug then Log.f
    (sprintf "Displacing %s in window %d" (Url.string_of did.document_url) hkey);
  try
    let r = Hashtbl.find table hkey in
    let di = List.assoc did !r in
     di#di_abort;
     di#di_destroy;
     r := Mlist.except_assoc did !r;
  with
     Not_found -> Log.debug "Gcache.remove failed !"
@

<<function Gcache.add>>=
(* Add a new display_info for a document in the cache *)
let add hkey did di =
  try
    let r = Hashtbl.find table hkey in
     r := (did, di) :: !r;
    (* the problem is to find the correct ones to delete, because we are
       not sure that the older are really the older in history. Well.
     *)
    if List.length !r > !max_keep then
      let l = Sort.list (fun (_,di) (_,di') -> di_compare di di') !r in
      let fluff = Mlist.tln l !max_keep in
    List.iter (fun (did,_) -> remove hkey did) fluff
  with
    Not_found -> ()
@

<<function Gcache.kill>>=
(* A window is being destroyed: kill all visible instances
 *  Note: there could be a document still being retrieved and displayed,
 *  but not present in the history. 
 *)
let kill hkey =
 if !debug then Log.f (sprintf "Killing gcache for nav %d" hkey);
 let r = get_nav hkey in
  List.iter (fun (did, di) -> di#di_abort) !r;
  if !Cache.history_mode then begin
     let fluff = !r in
       r := []; (* so that we don't find them again *)
       List.iter (fun (did, _) -> nocache did) fluff
  end;
 Hashtbl.remove table hkey
@

<<function Gcache.postmortem>>=
let postmortem () =
  Hashtbl.iter (fun key dis ->
      Log.f (sprintf "Navigator %d" key);
      List.iter (fun (did,_) ->
     Log.f (sprintf "%s(%d)"
          (Url.string_of did.document_url)
          did.document_stamp))
         !dis)
   table
@

<<function Gcache.sorry>>=
(* If the normal cache gets full, we might *have* to destroy documents
 * that are visible. In that case, kill the gcache as well, so that
 * we don't get strange phenomenons such as image disappearing, ...
 *)

let sorry did =
  Hashtbl.iter (fun key dis -> 
    if List.mem_assoc did !dis then remove key did) table
@

<<toplevel Gcache._1>>=
let _ =
  Cache.cutlinks := sorry :: !Cache.cutlinks
@


%-------------------------------------------------------------

<<./gui/gcache.ml>>=
open Printf
open Document
open Viewers

<<constant Gcache.debug>>

<<constant Gcache.max_keep>>

<<constant Gcache.table>>

<<function Gcache.get_nav>>

<<function Gcache.find>>

<<function Gcache.nocache>>

<<function Gcache.remove>>

<<function Gcache.displace>>

<<function Gcache.add>>


<<function Gcache.kill>>


<<function Gcache.postmortem>>


<<function Gcache.sorry>>


<<toplevel Gcache._1>>
@


\subsection*{[[./gui/plink.mli]]}

<<signature Plink.make>>=
val make : Hyper.link -> Www.request
    (* [make hlink] is an error correcting version of Www.make
       For invalid links, a dialog box is displayed and offers
       edition facilities
     *)
@


%-------------------------------------------------------------

<<./gui/plink.mli>>=
<<signature Plink.make>>
@


\subsection*{[[./gui/plink.ml]]}

<<function Plink.dial>>=
let dial hlink err =
  let t = Toplevel.create Widget.default_toplevel [Class "Dialog"] in
  Focus.set t;
  Wm.title_set t (I18n.sprintf "Malformed link error");

  let vuri = Textvariable.create_temporary t 
  and vcontext = Textvariable.create_temporary t in

  Textvariable.set vuri hlink.h_uri;
  (match hlink.h_context with
    Some s -> Textvariable.set vcontext s
  | None -> ());

  let msg = match err with
      LinkResolve s -> s
   |  UrlLexing (s,_) -> s in

  let tit = Label.create t [Text (I18n.sprintf "Malformed link error")]
  and fc,ec = Frx_entry.new_labelm_entry t "Context" vcontext
  and fu,eu = Frx_entry.new_labelm_entry t "Relative" vuri
  and lmsg = Label.create t [Text msg]
  in
  let cancelled = ref false in
  let fb = Frame.create t [] in
    let bok = Button.create fb
            [Text "Ok"; Command (fun _ -> Grab.release t; destroy t)]
    and bcancel = Button.create fb
            [Text "Cancel"; Command (fun _ -> cancelled := true;
                                          Grab.release t; destroy t)]
    in

    pack [bok] [Side Side_Left; Expand true];
    pack [bcancel] [Side Side_Right; Expand true];
    pack [tit;fc;fu;lmsg;fb] [Fill Fill_X];
    Tkwait.visibility t;
    Focus.set eu;
    Grab.set t;
    Tkwait.window t;
    (* because the window gets destroyed, the variables too. *)
    if !cancelled then None
    else Some
         {h_uri = Textvariable.get vuri;
      h_context = (match Textvariable.get vcontext with
                 "" -> None
                | s -> Some s);
          h_method = hlink.h_method;
      h_params = hlink.h_params}
@

<<function Plink.make>>=
(* Utility for catching link resolving errors *)
let rec make hlink =
  try
    Www.make hlink
  with
    Invalid_link msg ->
      match dial hlink msg with
    None -> raise (Invalid_link msg)
      | Some hlink -> make hlink
@


%-------------------------------------------------------------

<<./gui/plink.ml>>=
open Tk
open Hyper

<<function Plink.dial>>

<<function Plink.make>>

        
@


\subsection*{[[./gui/prefs.mli]]}

<<type Prefs.pref_type>>=
(* Exported so that we can plug applet preferences *)
type pref_type =
   Bool of bool ref
 | String of string ref
 | Int of int ref
 | Float of float ref
 | AbstractType of (Textvariable.textVariable -> unit) * 
                (Textvariable.textVariable -> unit)
                 (* init, set *)
@

<<type Prefs.pref>>=
type pref = {
  packed_widget : Widget.widget;
  pref_variable : Textvariable.textVariable;
  pref_type : pref_type;
  pref_name : string; (* shall not contain : *)
  resource_name : string (* shall not contain : *)
}
@

<<type Prefs.pref_family>>=
(* A family of preferences *)
type pref_family =
  {family_widget: Widget.widget;
   family_init : unit -> unit;
   family_save : unit -> string PrefMap.t;
   family_load : unit -> unit;
   family_title : string
  }
@

<<signature Prefs.bool_pref>>=
val bool_pref : string -> bool ref -> Widget.widget -> pref
@

<<signature Prefs.int_pref>>=
val int_pref : string -> int ref -> Widget.widget -> pref
@

<<signature Prefs.float_pref>>=
val float_pref : string -> float ref -> Widget.widget -> pref
@

<<signature Prefs.string_pref>>=
val string_pref : string -> string ref -> Widget.widget -> pref
    (* [<type>_pref name internal_location top] *)
@

<<signature Prefs.option_pref>>=
val option_pref :
    string ->
    (Textvariable.textVariable -> unit) *
    (Textvariable.textVariable -> unit) * string list ->
    Widget.widget -> pref
@

<<signature Prefs.abstract_bool_pref>>=
val abstract_bool_pref :
    string ->
      (Textvariable.textVariable -> unit) ->
      (Textvariable.textVariable -> unit) -> Widget.widget -> pref
@

<<signature Prefs.abstract_string_pref>>=
val abstract_string_pref :
    string ->
      (Textvariable.textVariable -> unit) ->
      (Textvariable.textVariable -> unit) -> Widget.widget -> pref
@

<<signature Prefs.option_handlers>>=
val option_handlers :
    ('a * string) list ->
    (unit -> 'a) ->
    ('a -> unit) ->
    (Textvariable.textVariable -> unit) * (Textvariable.textVariable -> unit) *
    string list
@

<<signature Prefs.family>>=
val family :
    Widget.widget -> string -> (Widget.widget -> pref) list -> pref_family
@

<<signature Prefs.pref_error>>=
val pref_error : string -> unit
@

<<signature Prefs.resource_name>>=
val resource_name : string -> string
@

<<signature Prefs.define>>=
val define :
    string ->
    (Widget.widget -> pref_family) list -> (unit -> unit) list -> unit -> unit
    (* [define filename pref_builders pref_mute]
       returns a function that displays the preference panel
     *)
@


%-------------------------------------------------------------

<<./gui/prefs.mli>>=
<<type Prefs.pref_type>>

<<type Prefs.pref>>

module PrefMap : Map.S with type key = string

<<type Prefs.pref_family>>

<<signature Prefs.bool_pref>>
<<signature Prefs.int_pref>>
<<signature Prefs.float_pref>>
<<signature Prefs.string_pref>>

<<signature Prefs.option_pref>>


<<signature Prefs.abstract_bool_pref>>

<<signature Prefs.abstract_string_pref>>


<<signature Prefs.option_handlers>>



<<signature Prefs.family>>

<<signature Prefs.pref_error>>

<<signature Prefs.resource_name>>

<<signature Prefs.define>>
@


\subsection*{[[./gui/prefs.ml]]}

<<function Prefs.pref_error>>=
(* Generic report *)
let pref_error msg =
   ignore (
     Frx_dialog.f Widget.default_toplevel (gensym "error")
      (I18n.sprintf "Preference Error") 
      msg
      (Predefined "") 0 [I18n.sprintf "Ok"])
@

<<function Prefs.resource_name>>=
(* Converts an arbitrary string to a name suitable as a "global" resource *)
let resource_name pref_name =
  let words = Mstring.split_str (function ' ' -> true | _ -> false) pref_name 
  in
  (* for each words, remove non alpha-numerics *)
  (* in addition, make the each first characters capital *)
  let words' = List.map (fun word ->
    let buf = String.create (String.length word) in
    let pos = ref 0 in
    for i = 0 to String.length word - 1 do
      if   ('A' <= word.[i] && word.[i] <= 'Z') 
    or ('a' <= word.[i] && word.[i] <= 'z') 
    or ('0' <= word.[i] && word.[i] <= '9') then begin
        buf.[!pos] <- word.[i];
        incr pos
    end;
    done;
    let x = String.sub buf 0 !pos in
    begin 
      try
    if 'a' <= x.[0] && x.[0] <= 'z' then
      x.[0] <- Char.chr (Char.code x.[0] + Char.code 'A' - Char.code 'a');
      with
    Invalid_argument _ -> 
      (* Strangely, x could be "". *) ()
    end;
    x ) words
  in
    "pref" ^ String.concat "" words'
@

<<constant Prefs.class_name>>=
let class_name = resource_name 
  (* it is not correct but works *)
@

<<type Prefs.pref_type (./gui/prefs.ml)>>=
(*
 * Various predefined preference types
 *)
type pref_type =
   Bool of bool ref
 | String of string ref
 | Int of int ref
 | Float of float ref
 | AbstractType of (Textvariable.textVariable -> unit) * 
                (Textvariable.textVariable -> unit)
                 (* init, set  as defined below *)
@

<<type Prefs.pref (./gui/prefs.ml)>>=
(*
 * Support for interactive setting of a preference 
 *)
type pref = {
  packed_widget : Widget.widget;	       (* visual feedback *)
  pref_variable : Textvariable.textVariable;   (* placeholder for string
                          version of pref value, and
                          possibly "electric" change *)
  pref_type : pref_type;		       (* internal definition *)
  pref_name : string;	 (* internal name (shall not contain :) *)
  resource_name : string (* resource name (shall not contain :) *)
}
@

<<function Prefs.init_pref>>=
(*
 * Init the Tk variables in the pref editor from the internal 
 * value of the preference (usually a reference)
 *)
let init_pref {pref_type = typ; pref_variable = v} = match typ with
   Bool r -> Textvariable.set v (if !r then "1" else "0")
 | String r -> Textvariable.set v !r
 | Int r ->  Textvariable.set v (string_of_int !r)
 | Float r ->  Textvariable.set v (string_of_float !r)
 | AbstractType(i,_) -> i v
@

<<function Prefs.set_pref>>=
(* 
 * Set the internal preference value from the editor value (ie textvariable)
 * NOTE: basic predefined types do not allow extra code to run when the
 * value is modified.
 *)
let set_pref {pref_type = typ; pref_variable = v} = match typ with
   Bool r -> r := Textvariable.get v = "1"
 | String r -> r := Textvariable.get v
 | Int r ->
     let s = Textvariable.get v in
      begin try r := int_of_string s
      with Failure "int_of_string" ->
            pref_error (I18n.sprintf "Not an integer: %s" s)
      end
 | Float r ->
     let s = Textvariable.get v in
      begin try r := float_of_string s
      with Failure "float_of_string" ->
            pref_error (I18n.sprintf "Not a float: %s" s)
      end
 | AbstractType(_,s) -> s v
@

<<function Prefs.load_pref>>=
(* 
 * Given the current resource database, set the internal and editor values
 * of the preference.
 *)
let load_pref pref =
  try 
    let prefdata = Resource.get Widget.default_toplevel 
      pref.resource_name pref.resource_name (* it is not correct but works *)
    in
    (* ONLY if non-empty ! *)
    if prefdata <> "" then begin
      Textvariable.set pref.pref_variable prefdata;
      set_pref pref
    end
  with
    Not_found -> () (* Never happen if database is complete *)
@

<<function Prefs.save_pref>>=
(* 
 * Adds the current pref value (from pref editor) to a preference table
 *)
let save_pref add pref =
  add pref.resource_name (Textvariable.get pref.pref_variable)
@

<<function Prefs.bool_pref>>=
(*
 * Building the preference manager for predefined preference types
 *)


let bool_pref name r top = 
  let v = Textvariable.create_temporary top in
  (* The frame is just to avoid expanding *)
  let f = Frame.create top [] in
  let w = Checkbutton.create f [Text name; Variable v] in
   pack [w][Side Side_Left; Anchor W; Fill Fill_X];
  let p =
    { pref_type = Bool r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name } in
  (* Automatically perform the preference change when you trigger the button *)
  Checkbutton.configure w [Command (fun () -> set_pref p)];
  p
@

<<function Prefs.int_pref>>=
let int_pref name r top = 
  let v = Textvariable.create_temporary top in
  let f,e = Frx_entry.new_labelm_entry top name v in
  let p =
    { pref_type = Int r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name } in
  (* Automatically perform the preference change when you edit the entry *)
  (* NOTE: we have to use a "tracer" on the variable, since the user does *)
  (* not necessarily type Enter when editing is finished. OTOH, this will *)
  (* cause additionnal invocations during load_pref and init_pref *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function Prefs.float_pref>>=
let float_pref name r top = 
  let v = Textvariable.create_temporary top in
  let f,e = Frx_entry.new_labelm_entry top name v in
  let p = 
    { pref_type = Float r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name} in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function Prefs.string_pref>>=
let string_pref name r top = 
  let v = Textvariable.create_temporary top in
  let f,e = Frx_entry.new_labelm_entry top name v in
  let p = 
    { pref_type = String r;
      pref_variable = v;
      packed_widget = f;
      pref_name = name;
      resource_name = resource_name name } in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function Prefs.option_pref>>=
let option_pref name (i, s, p) top =
  let v = Textvariable.create_temporary top in
  let f = Frame.create top [] in
  let l = Label.create f [Text name]
  and o,_ = Optionmenu.create f v p in
    pack [l;o][Side Side_Left];
  let p = {
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = name;
    resource_name = resource_name name} in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function Prefs.abstract_bool_pref>>=
(*
 * Like bool_pref, but with additional handling code
 *)

let abstract_bool_pref name i s top =
  let v = Textvariable.create_temporary top in
  (* The frame is just to avoid expanding *)
  let f = Frame.create top [] in
  let w = Checkbutton.create f [Text name; Variable v] in
   pack [w][Side Side_Left; Anchor W; Fill Fill_X];
  let p = {
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = name;
    resource_name = resource_name name} in
  (* Automatically perform the preference change when you trigger the button *)
  Checkbutton.configure w [Command (fun () -> set_pref p)];
  p
@

<<function Prefs.abstract_string_pref>>=
(*
 * Like string_pref, but with additional handling code
 *)
let abstract_string_pref name i s top =
  let v = Textvariable.create_temporary top in
  let f,e = Frx_entry.new_labelm_entry top name v in
  let p ={
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = name;
    resource_name = resource_name name} in
  (* see above *)
  let rec el () = Textvariable.handle v (fun () -> set_pref p; el()) in
  el(); p
@

<<function Prefs.option_handlers>>=
(*
 * Utility for option_pref
 *)

let option_handlers mapping read_internal write_internal =
  let rev_mapping = List.map (fun (x,v) -> (v,x)) mapping in
  let init v =
    let current = read_internal() in
    let s =
      try
    List.assoc current mapping
      with
    Not_found ->
      match mapping with
        [] -> "undefined"
      | (x,v)::l -> v
    in
    Textvariable.set v s
  and set v =
    let current = Textvariable.get v in
    let value =
      try
    List.assoc current rev_mapping
      with
    Not_found ->
      match mapping with
        [] -> assert false
      | (x,v)::l -> x
    in
    write_internal value
  in
  init, set, List.map snd mapping
@

<<function Prefs.load_file>>=
let load_file f =
  (* It just loads the file as resource *)
  try
    Tkresource.readfile f Interactive
  with
    Protocol.TkError _ -> 
      failwith (I18n.sprintf "Can't open preference file: %s" f)
@

<<function Prefs.save_file>>=
let save_file prefmaps f =
  let delimiter = "!!! Don't edit below this line !!!" in
  try
    (* create $HOME/.mmm (by default) silently *)
    let prefdir = Filename.dirname f in 
    if not (Sys.file_exists prefdir) then Munix.digdir prefdir 0o755;
    let oc = open_out (f ^ ".tmp") in
    try
      let ic = open_in f in
      try
    while true do
      let l = input_line ic in
      if l = delimiter then raise End_of_file
      else output_string oc (l ^ "\n")
    done
      with
    End_of_file -> 
      close_in ic; 
      raise End_of_file
    with
      Sys_error _ 
    | End_of_file ->
   (* the delimiter is found, no delimiter in the file
      or no pref file is found *)
    output_string oc (delimiter ^ "\n");
    List.iter (
    PrefMap.iter (fun name data ->
      output_char oc '*'; output_string oc name; output_char oc ':'; 
      output_string oc data; output_char oc '\n'))
      prefmaps;
    close_out oc;
    Unix.rename (f ^ ".tmp") f
  with
    Sys_error s ->
      pref_error (I18n.sprintf "Can't open preference file: %s (%s)" f s)
@
%$

<<type Prefs.pref_family (./gui/prefs.ml)>>=
(* Builds a family of preferences *)
type pref_family =
  {family_widget: Widget.widget;    (* the main widget for this family *)
   family_init : unit -> unit;	    (* init the display from memory *)
   family_save : unit -> string PrefMap.t; (* return current bindings *)
   family_load : unit -> unit;  (* loads from persistent storage *)
   family_title : string;
  }
@

<<function Prefs.family>>=
(* Computing a family from the predefined preference types *)
let family top title preff =
  let f = 
    Frame.create_named top (Mstring.gensym "family")
      [Relief Sunken; BorderWidth (Pixels 1)] in
  (* create the widgets *)
  let prefs = List.map (fun p -> p f) preff in
  (* define the functions for the family *) 
  let init _ = List.iter init_pref prefs
  and load () = List.iter load_pref prefs
  and save () = 
    List.fold_right 
      (fun pref map -> save_pref (fun k v -> PrefMap.add k v map) pref)
      prefs
      PrefMap.empty
  in
  (* initialize the text variables *)
  init();
  (* wrapping stuff *)
  let t = Label.create f [Text title] in
  pack [t][];
  pack (List.map (fun p -> p.packed_widget) prefs) 
       [Fill Fill_X; Expand true; Anchor W];
  {family_widget = f; family_init = init;
   family_load = load; family_save = save;
   family_title = title}
@

<<function Prefs.init>>=
(* This is the startup *)

let rec init filename status interactive mute =
  let top = Toplevel.create_named Widget.default_toplevel "prefs" 
                 [Class "MMMPrefs"] in
   Wm.title_set top (I18n.sprintf "MMM Preferences");
   Wm.withdraw top;
   status := Some top;
   bind top [[], Destroy] 
     (BindSet ([Ev_Widget],
           (fun ei -> if ei.ev_Widget = top then status := None)));

  let preffilev = Textvariable.create_temporary top in

  (* The menu bar *)
  let mbar = Frame.create_named top "menubar" [] in
  let file = 
      Menubutton.create_named mbar "file"
        [Text (I18n.sprintf "File"); UnderlinedChar 0]
  in
  pack [file][Side Side_Left];
  pack [mbar][Side Side_Top; Anchor W; Fill Fill_X];
  (* The window *)
  let hgroup = Frame.create_named top "panels" [] in
  (* section choice *)
  let sectionf = Frame.create_named hgroup "sections" [] in
  let buttonsf = Frame.create_named top "buttons" [] in
  pack [sectionf] [Side Side_Left; Fill Fill_Y];
  pack [hgroup] [Side Side_Top; Fill Fill_Both; Expand true];
  pack [buttonsf] [Side Side_Bottom];

  Textvariable.set preffilev !filename;	(* for the file selector *)

  (* We must load the file because some elements of the panel depend
     on resources defined in this file *)
  begin 
    try load_file !filename
    with Failure s -> pref_error s
  end;


  (* Then we must do the mute stuff *)
    List.iter (fun f -> f()) mute;

  (* Then we can build the families *)
  let families = List.map (fun f -> f hgroup) interactive in

  (* Then we do the interactive stuff *)
  List.iter (fun f -> f.family_load ()) families;

  let reset () =
    destroy top; status := None;
    init filename status interactive mute
  in

  (* select a preference file to load *)
  let rec load () =
    Fileselect.f (I18n.sprintf "Load a preference file")
      (function [] -> ()
              | [s] -> 
         (* we must restart the panel, because resources
            may affect the displayed menus *)
          if Sys.file_exists s then begin
            destroy top;
            filename := s;
            init filename status interactive mute
          end
          else
            pref_error (I18n.sprintf "%s : no such preference file"
                             s)
              | l -> raise (Failure "multiple selection"))
      (Filename.concat (Filename.dirname (Textvariable.get preffilev))
       "*")
      (Filename.basename (Textvariable.get preffilev))
      false
      false

  (* select a new preference file to save in *)
  and save_as () =
    Fileselect.f (I18n.sprintf "Save preferences to file")
      (function 
      [] -> ()
        | [s] ->
        Textvariable.set preffilev s;
        filename := s;
       begin
              try 
        save_file (List.map (fun f -> f.family_save()) families) s;
        dismiss()
         with Failure s -> pref_error s
            end
        | l -> raise (Failure "multiple selection"))
      (Filename.concat (Filename.dirname (Textvariable.get preffilev))
       "*")
      (Filename.basename (Textvariable.get preffilev))
      false
      false

  (* save in the last defined preference file *)
  and save () =
    try
      save_file (List.map (fun f -> f.family_save()) families) 
            (Textvariable.get preffilev);
      dismiss()
    with
      Failure s -> pref_error s

  and dismiss() = 
    Wm.withdraw top

  in

  (* Fill in the menu *)
  let mfile = Menu.create_named file "filemenu" [] in
    Menu.add_command mfile 
       [Label (I18n.sprintf "Load"); Command load; UnderlinedChar 0];
    Menu.add_command mfile 
       [Label (I18n.sprintf "Save"); Command save; UnderlinedChar 0];
    Menu.add_command mfile 
       [Label (I18n.sprintf "Save As"); Command save_as; UnderlinedChar 0];
    Menu.add_command mfile 
        [Label (I18n.sprintf "Dismiss"); Command dismiss; UnderlinedChar 0];
    Menubutton.configure file [Menu mfile];

  (* Define the buttons *)
    let saveb = Button.create_named buttonsf "save"
      [Text (I18n.sprintf "Save"); Command save]
    and resetb = Button.create_named buttonsf "reset"
      [Text (I18n.sprintf "Reset"); Command reset]
    and dismissb = Button.create_named buttonsf "dismiss"
      [Text (I18n.sprintf "Dismiss"); Command dismiss]
    in
    pack [saveb;resetb;dismissb][Side Side_Left; PadX (Pixels 20)];


  let current = ref (List.hd families) in

  let set_current f =
    Pack.forget [!current.family_widget];
    f.family_init();
    pack [f.family_widget]
         [Side Side_Top; Fill Fill_Both; Expand true];
    current := f in

  let sectionv = Textvariable.create_temporary sectionf in
  let selectors =
    List.map (fun f ->
      Radiobutton.create sectionf [
        Variable sectionv; Text f.family_title; Value f.family_title;
        Command (fun () -> set_current f)]
      )
    families;
  in
  pack selectors [Anchor W];

  Textvariable.set sectionv !current.family_title;

  set_current (List.hd families)
@

<<function Prefs.define>>=
(* Define a preference panel *)
let define filename interactive mute =
  let inited = ref None 
  and current_file = ref filename in
  (function () -> 
    match !inited with
      Some w -> Wm.deiconify w
    | None -> (* we have been destroyed ! *)
    init current_file inited interactive mute)
@


%-------------------------------------------------------------

<<./gui/prefs.ml>>=
(* Preferences *)
open Tk
open Mstring
open Fontprefs

<<function Prefs.pref_error>>

<<function Prefs.resource_name>>

<<constant Prefs.class_name>>

<<type Prefs.pref_type (./gui/prefs.ml)>>

<<type Prefs.pref (./gui/prefs.ml)>>


<<function Prefs.init_pref>>

<<function Prefs.set_pref>>

<<function Prefs.load_pref>>

<<function Prefs.save_pref>>


<<function Prefs.bool_pref>>

<<function Prefs.int_pref>>

<<function Prefs.float_pref>>

<<function Prefs.string_pref>>

<<function Prefs.option_pref>>


<<function Prefs.abstract_bool_pref>>

<<function Prefs.abstract_string_pref>>


<<function Prefs.option_handlers>>


(*
 * Loading and saving preferences from a resource file
 *)

module PrefMap = Map.Make(struct type t = string let compare = compare end)

<<function Prefs.load_file>>

<<function Prefs.save_file>>
      
<<type Prefs.pref_family (./gui/prefs.ml)>>

<<function Prefs.family>>


<<function Prefs.init>>


<<function Prefs.define>>
@


\subsection*{[[./gui/debug.ml]]}




%-------------------------------------------------------------

<<./gui/debug.ml>>=
open Tk
open Protocol
<<function Debug.active_cb>>

<<function Debug.init>>

@


\subsection*{[[./gui/history.ml]]}

<<type History.history_entry>>=
(* 
   Linear history: we keep going adding to the end of the list,
   EXCEPT when you go back and then on a new link.
*)


type history_entry = {
  h_did : document_id;
  h_fragment : string option;
  h_prev : history_entry option;
  mutable h_next : history_entry option
  }
@

<<type History.t>>=
type t = {
  h_key : int;
  mutable h_start : history_entry;
  mutable h_current: history_entry;
  mutable h_first : bool
  }
@

<<function History.contents>>=
let contents h =
  let l = ref [] in
  let rec walk e =
    l := e :: !l;
    match e.h_next with
       None -> !l
      | Some e -> walk e
  in walk h.h_start
@

<<function History.obsolete>>=
(* Since a did may occur several times in the history, the list of
   obsolete entries is not simply the overwritten entries *)

let obsolete current next =
  let kept = ref DocumentIDSet.empty
  and forgotten = ref DocumentIDSet.empty in
  let rec back e =
    kept := DocumentIDSet.add e.h_did !kept;
    match e.h_prev with
      None -> ()
    | Some e -> back e in
  let rec forw e =
    forgotten := DocumentIDSet.add e.h_did !forgotten;
    match e.h_next with
      None -> ()
    | Some e -> forw e in
  back current;
  forw next;
  DocumentIDSet.diff !forgotten !kept
@

<<function History.add>>=
(* Add hinfo to the current point *)
let add h did frag =
  (* Hack for the initial document *)
  if h.h_first then begin
    let newe = {h_did = did;
        h_fragment = frag;
        h_prev = None;
        h_next = None} in
      h.h_start <- newe;
      h.h_current <- newe;
      h.h_first <- false
      end
  else
    match h.h_current.h_next with
      None -> (* last in the list *)
    (* the new entry *)
    let newe = {h_did = did;
            h_fragment = frag;
            h_prev = Some h.h_current;
            h_next = None} in
    (* fix the linked list *)
    h.h_current.h_next <- Some newe;
    (* set the new current *)
    h.h_current <- newe
   | Some e -> (* adding in the middle of the list *)
    let newe = {h_did = did;
            h_fragment = frag;
            h_prev = Some h.h_current;
            h_next = None} in
    let dropped = obsolete newe e in
    h.h_current.h_next <- Some newe;
    h.h_current <- newe;
    DocumentIDSet.iter (Gcache.remove h.h_key) dropped
@

<<constant History.create>>=
let create =
  let keycnter = ref 0 in
  (fun did ->
    let e = { h_did = did;
             h_fragment = None;
             h_prev = None;
          h_next = None} in
    { h_key = (incr keycnter; !keycnter);
      h_start = e;
      h_current = e;
      h_first = true
    })
@

<<function History.back>>=
let back h =
    match h.h_current.h_prev with
       None -> None
      | Some e -> h.h_current <- e; Some (e.h_did, e.h_fragment)
@

<<function History.forward>>=
let forward h =
    match h.h_current.h_next with
       None -> None
      | Some e -> h.h_current <-e ; Some (e.h_did, e.h_fragment)
@

<<function History.set_current>>=
let set_current h e =
  h.h_current <- e
@


%-------------------------------------------------------------

<<./gui/history.ml>>=
(* History *)
open Document

<<type History.history_entry>>

<<type History.t>>

<<function History.contents>>

(* Did made obsolete by history overwriting *)
<<function History.obsolete>>

<<function History.add>>

<<constant History.create>>

<<function History.back>>

<<function History.forward>>

<<function History.set_current>>

@


\subsection*{[[./gui/nav.mli]]}

<<type Nav.t>>=
type t =
  { nav_id: int;
    nav_viewer_frame: Widget.widget;
    nav_error: Error.t;
    nav_add_hist: Document.document_id -> string option -> unit;
    nav_show_current: Viewers.display_info -> string option -> unit;
    nav_log: string -> unit;
    nav_new: Hyper.link -> unit;
    nav_add_active: Url.t -> (unit -> unit) -> unit;
    nav_rem_active: Url.t -> unit }
@

<<signature Nav.request>>=
val request :
  t ->
  bool ->
  (Www.request -> Www.request) ->
  (t -> Www.request -> Document.handle -> unit) ->
  (t -> Document.document_id -> Www.request -> unit) -> Hyper.link -> unit
@

<<signature Nav.display_headers>>=
val display_headers : Document.handle -> unit
@

<<signature Nav.copy_link>>=
val copy_link : t -> Hyper.link -> unit
@

<<signature Nav.save_link>>=
val save_link : t -> (Unix.file_descr * bool) option -> Hyper.link -> unit
@

<<signature Nav.follow_link>>=
val follow_link : t -> Hyper.link -> unit
@

<<signature Nav.add_user_navigation>>=
val add_user_navigation : string -> Viewers.hyper_func -> unit
@

<<signature Nav.make_ctx>>=
val make_ctx : t -> Document.document_id -> Viewers.context
@

<<signature Nav.absolutegoto>>=
val absolutegoto : t -> string -> unit
@

<<signature Nav.historygoto>>=
val historygoto : t -> Document.document_id -> string option -> bool -> bool
@

<<signature Nav.update>>=
val update : t -> Document.document_id -> bool -> unit
@

<<signature Nav.dont_check_cache>>=
(*-*)
val dont_check_cache : Www.request -> bool
@


%-------------------------------------------------------------

<<./gui/nav.mli>>=
<<type Nav.t>>

<<signature Nav.request>>

<<signature Nav.display_headers>>

<<signature Nav.copy_link>>
<<signature Nav.save_link>>
<<signature Nav.follow_link>>

<<signature Nav.add_user_navigation>>

<<signature Nav.make_ctx>>

<<signature Nav.absolutegoto>>
<<signature Nav.historygoto>>
<<signature Nav.update>>

<<signature Nav.dont_check_cache>>
@


\subsection*{[[./gui/nav.ml]]}

<<type Nav.t (./gui/nav.ml)>>=
(* Navigation *)

type t = {
  nav_id : int;  (* key for the gfx cache *)
  nav_viewer_frame : Widget.widget;
  nav_error : Error.t;			(* popping error dialogs *)
  nav_add_hist : document_id -> string option -> unit;
  nav_show_current: display_info -> string option -> unit;
  nav_log : string -> unit;
  nav_new : Hyper.link -> unit;
  nav_add_active : Url.t -> (unit -> unit) -> unit;
  nav_rem_active : Url.t -> unit
 }
@

<<exception Nav.Duplicate>>=
exception Duplicate of Url.t
@

<<function Nav.dont_check_cache>>=
(* Some requests should not be looked for in the cache *)
let dont_check_cache wwwr =
  (match wwwr.www_link.h_method with
      POST _ -> true
    | _ -> false)
@

<<function Nav.request>>=
(* [request nav usecache wrapwr process specific] produces a function that
   takes an hyperlink, and apply the given behavior to it.
   [usecache] : do we look in the cache to see if we have it already
   [process nav wr dh] : what to to with the retrieved document
   [specific nav did wr] : some specific behavior, checked before we
     look in the cache. Must either raise Not_found or process completely
     the link
   [wrapwr wr] : returns a modified wr
 *)

let request nav usecache wrapwr process specific =
  (* Normally execute the request and process its answer (dh) *)
  let rec retrieve_and_handle wr =
    match Retrieve.f wr handle_link
    { document_finish = (fun _ -> nav.nav_rem_active wr.www_url);
      document_process = (fun dh ->
        process nav wr dh;
            nav.nav_rem_active wr.www_url)}
    with
    | Retrieve.Started abort -> nav.nav_add_active wr.www_url abort
    | Retrieve.InUse -> raise (Duplicate wr.www_url)
      
  (* Wrapper to deal with general/specific cache *)
  and handle_wr wr =
    try
      match wr.www_url.protocol with
       MAILTO -> Mailto.f wr
    (* mailto: is really a pain. It doesn't fit the retrieval semantics
       of WWW requests. *)
      | _ ->
         if (not usecache) || dont_check_cache wr then retrieve_and_handle wr
      else
          (* If the the document can be cached, then it is with no_stamp *)
        let did = {document_url = wr.www_url; document_stamp = no_stamp} in
        try
          specific nav did wr
        with
          Not_found ->
               try
            let doc = Cache.find did in
            try (* display it from source *)
                process nav wr (Cache.make_handle wr doc)
            with
            Sys_error s ->
              wr.www_error#f 
            (I18n.sprintf
               "Cache error occurred during save of temporary buffer (%s)"
               s)
            | Unix_error (e,fname,arg) ->
              wr.www_error#f
            (I18n.sprintf 
               "Cache error occurred when opening temporary file\n%s: %s (%s)"
               fname (Unix.error_message e) arg)
               with 
            Not_found -> (* we don't have the document *)
            retrieve_and_handle wr
    with
      Duplicate url ->
        wr.www_error#f (I18n.sprintf "The document %s\nis currently being retrieved for some other purpose.\nMMM cannot process your request until retrieval is completed." (Url.string_of url))

  and handle_link h =
    try (* Convert the link into a request *)
      let wr = Plink.make h in
      wr.www_error <- nav.nav_error;
      handle_wr (wrapwr wr)
    with
      Invalid_link msg ->
       nav.nav_error#f (I18n.sprintf "Invalid link")
    | Invalid_request (wr, msg) ->
       nav.nav_error#f (I18n.sprintf "Invalid request %s\n%s"
                   (Url.string_of wr.www_url) msg)
  in
  handle_link
@

<<function Nav.nothing_specific>>=
(*
 * Three instances of this general mechanism : view, save, head
 *)
let nothing_specific nav did wr = raise Not_found
@

<<function Nav.process_viewer>>=
(* Specific handling of "view" requests *)
let process_viewer addhist make_ctx = fun nav wr dh ->
  let ctx = make_ctx nav dh.document_id in
  match Viewers.view nav.nav_viewer_frame ctx dh with
    None -> () (* external viewer *)
  | Some di ->
      Gcache.add nav.nav_id dh.document_id di;
      if addhist then nav.nav_add_hist dh.document_id dh.document_fragment;
      nav.nav_show_current di dh.document_fragment
@

<<function Nav.specific_viewer>>=
(* check the widget cache *)
let specific_viewer addhist = fun nav did wr ->
  let di = Gcache.find nav.nav_id did in
  if addhist then nav.nav_add_hist did wr.www_fragment;
  (* make it our current displayed document, since it is available *)
  nav.nav_show_current di wr.www_fragment
@

<<function Nav.process_save>>=
(* Specific handling of "save" requests *)
let process_save dest = fun nav wr dh ->
  match dh.document_status with
    200 -> Save.transfer wr dh dest
  | n ->
    if wr.www_error#choose 
        (I18n.sprintf "Request for %s\nreturned %d %s.\nDo you wish to save ?"
         (Url.string_of wr.www_url) n (status_msg dh.document_headers))
    then Save.transfer wr dh dest
    else dclose true dh
@

<<function Nav.display_headers>>=
(* Simple implementation of HEAD *)

let display_headers dh =
  let mytop = Toplevel.create Widget.default_toplevel [] in
    Wm.title_set mytop 
       (sprintf "HEAD %s" (Url.string_of dh.document_id.document_url));
    let hs =
      List.map (function h -> Label.create mytop [Text h; Anchor W])
               dh.document_headers in
     pack (List.rev hs) [Fill Fill_X];
  let b = Button.create mytop
             [Command (fun _ -> destroy mytop); Text "Dismiss"] in
     pack [b] [Anchor Center]
@

<<constant Nav.process_head>>=
let process_head = fun nav wr dh ->
  dclose true dh;
  display_headers dh
@

<<function Nav.make_head>>=
(* But for head, we need to change the hlink *)
let make_head hlink =
  { h_uri = hlink.h_uri;
    h_context = hlink.h_context;
    h_method = HEAD;
    h_params = hlink.h_params
    }
@

<<function Nav.copy_link>>=
(* Copying a link to the X Selection *)
let copy_link nav h =
  try Frx_selection.set (Hyper.string_of h)
  with Invalid_link msg ->
    nav.nav_error#f (I18n.sprintf "Invalid link")
@

<<constant Nav.user_navigation>>=
let user_navigation = ref []
@

<<function Nav.add_user_navigation>>=
let add_user_navigation (s : string) (f : Viewers.hyper_func) =
  user_navigation := (s,f) :: !user_navigation
@

<<function Nav.id_wr>>=
let id_wr wr = wr
@

<<function Nav.make_ctx>>=
let make_ctx nav did = 
  let o = new stdctx(did, nav) in
  ignore (o#init);
@

<<function Nav.save_link>>=
(* Simple wrappers *)
let save_link nav whereto =
  request nav true id_wr (process_save whereto) nothing_specific
@

<<function Nav.follow_link>>=
let follow_link nav =
  request nav true id_wr (process_viewer true make_ctx) (specific_viewer true)
@

<<function Nav.absolutegoto>>=
(* Used outside an hyperlink *)
let absolutegoto nav uri =
  let follow_link = 
    request nav true id_wr 
      (process_viewer true make_ctx) (specific_viewer true)
  in
  follow_link { h_uri = uri; h_context = None; h_method = GET; h_params = []}
@

<<function Nav.historygoto>>=
(* Used by navigators for back/forward/reload *)
let historygoto nav did frag usecache =
  Log.debug "historygoto";
  if did.document_stamp = no_stamp then begin
    (* we can safely consider this as normal navigation *)
    let uri = match frag with
           None -> Url.string_of did.document_url
         | Some f ->
            sprintf "%s#%s" (Url.string_of did.document_url) f 
    in
    (* modify wr *)
    let follow_link =
      request nav usecache
    (function wr ->
      if not usecache then
        wr.www_headers <- "Pragma: no-cache" :: wr.www_headers;
      wr)
    (process_viewer false make_ctx) (* don't add to history *)
    (specific_viewer false)
    in
    follow_link { h_uri = uri;
          h_context = None;
          h_method = GET;
          h_params = []};
    true
  end else begin
    (* the url is a "non-unique" document, that is, its url is not
       enough to retrieve the document. We should not attempt to
       reload or retrieve if flushed from the cache
    *)
    try
      let di = Gcache.find nav.nav_id did in
     nav.nav_show_current di frag;
     true
    with
      Not_found ->
        nav.nav_error#f 
     (I18n.sprintf "Document was flushed from cache, and should be reloaded from its url\n(probably a POST request)");
        false
   end
@

<<function Nav.update>>=
let update nav did nocache =
  (* This gets called if answer is 200 but also 304 *)
  let process_update nav wr dh =
    match dh.document_status with
      304 -> 
    Cache.patch dh.document_id dh.document_headers;
    dclose true dh;
    begin try
      let di = Gcache.find nav.nav_id did in
      di#di_update
    with
      Not_found -> () (* weird *)
    end;
    wr.www_error#ok (I18n.sprintf "Document %s has not changed.\n"
               (Url.string_of wr.www_url))
    | 200 | _ ->
        (* kill the previous displayed window *)
     Gcache.displace nav.nav_id did;
    (* we may have been redirected : check new did *)
    let oldurl = Url.string_of did.document_url in
    let newurl = Url.string_of dh.document_id.document_url in
    let add_hist = oldurl <> newurl in
    if add_hist then 
      wr.www_error#ok (I18n.sprintf "Document %s is relocated to:\n%s"
                 oldurl newurl);
     wr.www_logging <- nav.nav_log;
     process_viewer add_hist make_ctx nav wr dh
  in
  try
    let doc = Cache.find did in
    try
      (* find the date of previous download, (or last-modified ?) *)
      let date_received = get_header "date" doc.document_info in
      let follow_link =
    request nav 
      false (* we don't want to use cache here *)
          (* setup additional headers *)
      (fun wr -> 
        wr.www_headers <- 
           ("If-Modified-Since: "^date_received) :: wr.www_headers;
        if nocache then
          wr.www_headers <- "Pragma: no-cache" :: wr.www_headers;
        wr)
      process_update nothing_specific in
      follow_link { h_uri = Url.string_of did.document_url;
            h_context = None;
            h_method = GET;
            h_params = []}
    with
      Not_found ->
    nav.nav_error#f ("Document has no Date: header.")
  with
    Not_found ->
      nav.nav_error#f (I18n.sprintf "Document %s\nhas been flushed from cache"
                        (Url.string_of did.document_url))
@


%-------------------------------------------------------------

<<./gui/nav.ml>>=
open Printf
open Unix
open Tk
open Hyper
open Www
open Url
open Uri
open Document
open Http_headers
open Viewers
open Embed

<<type Nav.t (./gui/nav.ml)>>

<<exception Nav.Duplicate>>

(* Important note: we assume two requests on the same url are identical
   (when we control emission of requests). This is not the case for 
   POST requests, because we would need to check the POST data.
   This means that you can't post twice *simultaneously* on the same
   url. Proper fix: change the equality semantics of active cnx
 *)

<<function Nav.dont_check_cache>>

<<function Nav.request>>

<<function Nav.nothing_specific>>

<<function Nav.process_viewer>>

<<function Nav.specific_viewer>>


<<function Nav.process_save>>

<<function Nav.display_headers>>
 
<<constant Nav.process_head>>

<<function Nav.make_head>>

(*
 *  Other handlers, less general
 *)

<<function Nav.copy_link>>

<<constant Nav.user_navigation>>
<<function Nav.add_user_navigation>>

<<function Nav.id_wr>>

(* WARNING: we take copies of these objects, so "self" must *not* be
 * captured in a closure (it would always point to the old object).
 * A new object is created for each new top viewer (follow_link).
 * AND for each frame_goto operation.
 *)
class stdctx (did, nav) =
 object (self)
  inherit Viewers.context (did, []) as super
  (* val nav = nav *)  
  (* val did = did *)

  method log = nav.nav_log
  method init =
    (* a new context for a toplevel window *)
    let make_ctx nav did = 
      ((new stdctx(did, nav))#init :> Viewers.context) in
    (* a new context for an embedded window *)
    let make_embed_ctx w targets = 
      let targets = 
    ("_self", w) :: ("_parent", Winfo.parent w) :: (frame_fugue targets) in
      let newctx = (new stdctx(did,nav))#init in
      begin
    try 
      let f = List.assoc "pointsto" self#hyper_funs in
      let g = List.assoc "clearpointsto" self#hyper_funs in
      newctx#add_nav ("pointsto", f);
      newctx#add_nav ("clearpointsto", g);
    with
      Not_found -> ()
      end;
      (newctx#for_embed [] targets :> Viewers.context) in
    (* by default, use the cache, don't touch the request *)
    let default_request = request nav true id_wr in
    let follow_link _ = 
      default_request (process_viewer true make_ctx) (specific_viewer true)
    and save_link _ =
      default_request (process_save None) nothing_specific
    and copy_link _ = copy_link nav
    and head_link = 
      let f = default_request process_head nothing_specific in
      (fun _ hlink -> f (make_head hlink))
    and new_link _ = nav.nav_new
    in 
    let frame_goto targets hlink =
      try
      (* target semantics PR-HTML 4.0 16.3.2 *)
       match List.assoc "target" hlink.h_params with
       | "_blank" ->
        let w = Toplevel.create Widget.default_toplevel [] in
        Embed.add { 
        embed_hlink = hlink;
        embed_frame = w;
        embed_context = make_embed_ctx w targets;
        embed_map = Maps.NoMap;
        embed_alt = "" }
       | "_self" ->
        let w = List.assoc "_self" targets in
        Embed.add {
        embed_hlink = hlink;
        embed_frame = w;
        embed_context = make_embed_ctx w targets;
        embed_map = Maps.NoMap;
        embed_alt = "" }
       | "_top" -> follow_link targets hlink
       | "_parent" ->
        let w = List.assoc "_parent" targets in
        Embed.add { 
        embed_hlink = hlink;
        embed_frame = w;
        embed_context = make_embed_ctx w targets;
        embed_map = Maps.NoMap;
        embed_alt = "" }
       | s ->
        let w = List.assoc s targets in
        Embed.add {
        embed_hlink = hlink;
        embed_frame = w;
        embed_context = make_embed_ctx w targets;
        embed_map = Maps.NoMap;
        embed_alt = "" }
      with
       Not_found -> (* if we are in a frame, it is available as _self *)
      try
        let w = List.assoc "_self" targets in
        Embed.add {
        embed_hlink = hlink;
        embed_frame = w;
        embed_context = make_embed_ctx w targets;
        embed_map = Maps.NoMap;
        embed_alt = "" }
      with
        Not_found -> follow_link targets hlink
    in
    List.iter super#add_nav !user_navigation;
    List.iter (fun (name, f, txt) ->
      self#add_nav
    (name, {hyper_visible = true; hyper_func = f; hyper_title = txt}))
       ["copy", copy_link, I18n.sprintf "Copy this Link to clipboard";
    "head", head_link, I18n.sprintf "Headers of document";
    "save", save_link, I18n.sprintf "Save this Link";
    "gotonew", new_link, I18n.sprintf "New window with this Link";
        "goto", frame_goto, I18n.sprintf "Open this Link";
       ];
    self
end

<<function Nav.make_ctx>>
  (o :> Viewers.context)

<<function Nav.save_link>>
<<function Nav.follow_link>>
    
(*
 * Other navigation functions
 *)

<<function Nav.absolutegoto>>
    
<<function Nav.historygoto>>


<<function Nav.update>>
@


\subsection*{[[./gui/mmmprefs.mli]]}

<<signature Mmmprefs.plug_applets>>=
(* We need a more generic mechanism *)
val plug_applets : (Widget.widget -> pref_family) -> unit
@

<<signature Mmmprefs.home>>=
val home : string ref
@

<<signature Mmmprefs.f>>=
val f : string -> unit -> unit
@


%-------------------------------------------------------------

<<./gui/mmmprefs.mli>>=
open Prefs

<<signature Mmmprefs.plug_applets>>

<<signature Mmmprefs.home>>

<<signature Mmmprefs.f>>
@


\subsection*{[[./gui/mmmprefs.ml]]}

<<function Mmmprefs.font_pref>>=
(*
 * Font preference
 *)
let font_pref title name top = 
  let f = Frame.create top [] in
  let l = Label.create_named f "fontname" [Text title] in
  let f', v, i, s =
    Fontprefs.font_select f
      (fun () -> Styles.get_font name)  (* get from internal value *)
      (Styles.set_font name)		(* set internal value *)
  in
   pack [l;f'][Side Side_Left];
  (* map exceptions to error *)
  let i v = try i v with Failure s -> pref_error s
  and s v = try s v with Failure s -> pref_error s
  in
  let p = {
    pref_type = AbstractType(i,s);
    pref_variable = v;
    packed_widget = f;
    pref_name = title;
    resource_name = resource_name title} in
  p
@

<<constant Mmmprefs.image_loading>>=
(*
 * Image loading mode
 *)
let image_loading =
  option_handlers 
    [ Imgload.AfterDocManual, "After document, manual"; 
      Imgload.AfterDocAuto, "After document, automatic";
      Imgload.DuringDoc, "During document loading"]
    (fun () -> !Imgload.mode)
    (fun v -> Imgload.mode := v)
@

<<function Mmmprefs.network>>=
let network top = 
  family top (I18n.sprintf "Protocols") [
    string_pref "Proxy host" Http.proxy;
    int_pref "Proxy port" Http.proxy_port;
    bool_pref "Always Use Proxy" Http.always_proxy;
    bool_pref "HTTP Send Referer" Http.send_referer;
    string_pref "User Agent" Http.user_agent;
    int_pref "Timeout on headers (seconds)" Http.timeout;
    int_pref "Password lifetime (minutes)" Auth.lifetime;
    string_pref "Password save file" Auth.auth_file;
    abstract_string_pref "Local binaries path" 
      Tk_file.pref_init Tk_file.pref_set
    ]
@

<<function Mmmprefs.internal>>=
let internal top =
  family top (I18n.sprintf "Internal settings and debugging") [
    bool_pref "Strict encoding of Form field names" Urlenc.strict_form_standard;
    bool_pref "HTTP Requests" Http.verbose;
    int_pref "Internal buffer" Textw_fo.internal_buffer;
    bool_pref "General trace" Log.debug_mode;
    bool_pref "Scheduler" Scheduler.debug;
    bool_pref "Cache debug" Cache.debug;
    bool_pref "Widget Cache debug" Gcache.debug;
    bool_pref  "HTML Display log" Html_disp.verbose;
    bool_pref "Table debug" Table.debug;
    bool_pref "Text fit debug" Fit.debug;
    bool_pref "Image loading debug" Img.ImageData.verbose;
    bool_pref "CamlTk Debug" Protocol.debug;
    ]
@

<<function Mmmprefs.html>>=
let html top = 
  family top (I18n.sprintf "HTML parsing and display") [
    option_pref "DTD" (dtd_i, dtd_s, dtd_p);
    bool_pref "Strict HTML lexing" Lexhtml.strict;
    bool_pref "Attempt tables" Html_disp.attempt_tables;
    bool_pref "Ignore relative TD width" Table.strict_32;
    bool_pref "Attempt smooth scroll" Htmlw.pscrolling;
    bool_pref "Frames as links" Htmlw.frames_as_links;
    abstract_string_pref "Background color"
      (fun v -> Textvariable.set v !Textw_fo.html_bg)
      (fun v ->
     let color = Textvariable.get v in
        Textw_fo.html_bg := color;
      (* transparent GIF hack, for the initial images *)
        Textvariable.set (Textvariable.coerce "TRANSPARENT_GIF_COLOR")
                         color;
            (* set the resource for each possible class of embedded windows *)
        Resource.add "*Html*Text.background" color WidgetDefault;
            Resource.add "*Html*Message.background" color WidgetDefault;
            Resource.add "*Html*Label.background" color WidgetDefault;
            Resource.add "*Html*Listbox.background" color WidgetDefault;
            Resource.add "*Html*Button.background" color WidgetDefault;
            Resource.add "*Html*Entry.background" color WidgetDefault;
            Resource.add "*Html*Menubutton.background" color WidgetDefault;
            Resource.add "*Plain*Text.background" color WidgetDefault
        );
    string_pref "Entry and Textarea color" Form.form_bg;
    bool_pref "Follow document colors" Textw_fo.usecolors; 
    font_pref "Default font" "default";
    font_pref "<H1> font" "header1";
    font_pref "<H2> font" "header2";
    font_pref "<H3> font" "header3";
    font_pref "<H4> font" "header4";
    font_pref "<H5> font" "header5";
    font_pref "<H6> font" "header6";
    font_pref "Bold"   "bold";
    font_pref "Italic" "italic";
    font_pref "Fixed" "verbatim"
    ]
@

<<function Mmmprefs.i18n>>=
let i18n top =
  family top (I18n.sprintf "Internationalization (Japanese)") [
    (* bool_pref "Japanese mode" Version.japan; *)
    bool_pref "Ignore META charset" Htmlw.ignore_meta_charset
  ] 
@

<<function Mmmprefs.images>>=
let images top =
  family top (I18n.sprintf "Images") [
    bool_pref "No images at all" Imgload.no_images;
    option_pref "Image loading" image_loading;
       (* image_loading_i image_loading_s image_loading_p; *)
    int_pref "Max image connections" Img.ImageScheduler.maxactive;
    int_pref "Max image connections (same host)" Img.ImageScheduler.maxsamehost;
    float_pref "Gamma correction" Img.ImageData.gamma;
    string_pref "JPEG converter"  Img.ImageData.jpeg_converter
    ]
@

<<function Mmmprefs.cache>>=
let cache top =
  family top (I18n.sprintf "Cache settings") [
    int_pref "Max number of documents"  Cache.max_documents;
    int_pref "Delete how much when full" Cache.cleann;
    bool_pref "Keep only history" Cache.history_mode;
    int_pref "Max cached widgets per window" Gcache.max_keep
    ]
@

<<function Mmmprefs.progs>>=
let progs top =
  family top (I18n.sprintf "External programs") [
    string_pref "Mailto program" Mailto.mailer;
    string_pref "Hotlist program" Hotlist.program;
    string_pref "Printing program" Save.print_command;
    ]
@

<<function Mmmprefs.misc>>=
let misc top =
  family top (I18n.sprintf "Misc. settings") [
    bool_pref "Use balloon helps" Balloon.flag;
    bool_pref "Use GIF animation" Img.gif_anim_load;
    bool_pref "Automatic GIF animation display" Imgload.gif_anim_auto
    ]
@

<<constant Mmmprefs.appsys_plug>>=
(* The default appsys preference only keeps track of
   the preference values, but does not allow changes
 *)
let appsys_plug = ref (fun top -> 
  let f = Frame.create top [Relief Sunken; BorderWidth (Pixels 1)] in
  let t = Label.create f [Text (I18n.sprintf "Applets")] in
  let msg =
   Message.create f [Text (I18n.sprintf "Applets are not available \
                                         in the native version")] in
  pack [t][Side Side_Top];
  pack [msg][Side Side_Bottom];
  (* we must keep track of applet preferences in the 
     bytecode version : "Active" and "Paranoid" *)
  let active = ref false  and active_name = resource_name "Active"
  and paranoid = ref true and paranoid_name = resource_name "Paranoid" in
  let init () = ()  (* nothing special to be done *)
  and save () =
    List.fold_right 
      (fun (name,value) map -> PrefMap.add name value map)
      [active_name, (if !active then "1" else "0");
       paranoid_name, (if !paranoid then "1" else "0")]
      PrefMap.empty
  and load () = 
    List.iter (fun (name, setf) ->
      try
    let prefdata = Resource.get Widget.default_toplevel name name in
    setf prefdata
      with
    Not_found -> ())
      [active_name, (function data -> active := data = "1");
       paranoid_name, (function data -> paranoid := data = "1")]
  in
  {family_widget = f; family_init = init;
   family_save = save; family_load = load;
   family_title = I18n.sprintf "Applets"})
@

<<function Mmmprefs.plug_applets>>=
let plug_applets f =
  appsys_plug := f
@

<<function Mmmprefs.applets>>=
let applets w = !appsys_plug w
@

<<constant Mmmprefs.home>>=
(* There is no right place for this *)
let home = ref ""
@

<<function Mmmprefs.reset_home>>=
let reset_home () =
  home :=  Tkresource.string "wwwHome" 
       (try Sys.getenv "WWW_HOME"
       with Not_found -> (Version.initurl (Lang.lang ())))
@

<<constant Mmmprefs.mute>>=
(* Internal preferences *)
let mute = [
  reset_home;
  Fonts.reset;
  Viewers.reset;			(* viewers definition *)
  Glevents.reset;			(* bindings *)
  ]
@

<<constant Mmmprefs.families>>=
(* Interactive preferences *)
let families = [ network; html; i18n; images; progs; cache; applets;
         misc; internal ]
@

<<function Mmmprefs.f>>=
let f preffile = Prefs.define preffile families mute
@


%-------------------------------------------------------------

<<./gui/mmmprefs.ml>>=
open Tk
open Prefs

(* MMM Preferences *)

<<function Mmmprefs.font_pref>>


<<constant Mmmprefs.image_loading>>


(*
 * Choose from available DTDs for HTML parsing 
 *)
let dtd_i v =
  Textvariable.set v (Dtd.name !Dtd.current)
and dtd_s v =
  Dtd.current := 
    try
      Dtd.get (Textvariable.get v)
    with
      Not_found -> Dtd.dtd32
and dtd_p = Dtd.names()


<<function Mmmprefs.network>>

<<function Mmmprefs.internal>>

<<function Mmmprefs.html>>

<<function Mmmprefs.i18n>>

<<function Mmmprefs.images>>
    

<<function Mmmprefs.cache>>

<<function Mmmprefs.progs>>

<<function Mmmprefs.misc>>

<<constant Mmmprefs.appsys_plug>>

<<function Mmmprefs.plug_applets>>

<<function Mmmprefs.applets>>


<<constant Mmmprefs.home>>
<<function Mmmprefs.reset_home>>


<<constant Mmmprefs.mute>>

<<constant Mmmprefs.families>>

<<function Mmmprefs.f>>
@


\subsection*{[[./gui/mmm.mli]]}

<<signature Mmm.user_file>>=
val user_file : string -> string
    (* [user_file base] returns $HOME/.mmm/[base] *)
@
%$

<<signature Mmm.initial_navigator>>=
val initial_navigator : string -> string option -> Nav.t option
@

<<signature Mmm.main_navigator>>=
val main_navigator : Nav.t option ref
@

<<signature Mmm.helpurl>>=
(* Preferences, options *)
val helpurl : Url.t ref
@

<<signature Mmm.initial_geom>>=
val initial_geom : string option ref
@

<<signature Mmm.add_user_menu>>=
(* Used for applets *)
val add_user_menu : string -> (Viewers.context -> unit) -> unit
@

<<signature Mmm.navigator>>=
val navigator : bool -> Url.t -> Nav.t option
@

<<signature Mmm.new_window_initial>>=
val new_window_initial : unit -> unit
@

<<signature Mmm.new_window_sel>>=
val new_window_sel : unit -> unit
@

<<signature Mmm.change_tachy>>=
val change_tachy : (Widget.widget -> Low.tachymeter) -> unit
@


%-------------------------------------------------------------

<<./gui/mmm.mli>>=
<<signature Mmm.user_file>>

<<signature Mmm.initial_navigator>>
<<signature Mmm.main_navigator>>

<<signature Mmm.helpurl>>
<<signature Mmm.initial_geom>>

<<signature Mmm.add_user_menu>>
<<signature Mmm.navigator>>
<<signature Mmm.new_window_initial>>
<<signature Mmm.new_window_sel>>
<<signature Mmm.change_tachy>>
@


\subsection*{[[./gui/mmm.ml]]}

<<constant Mmm.hotlist>>=
(* Preference settings *)
let hotlist = ref ""
@

<<constant Mmm.helpurl>>=
let helpurl = ref (Lexurl.make (Version.helpurl (Lang.lang ())))
@

<<constant Mmm.initial_page>>=
let initial_page = ref None
@

<<constant Mmm.initial_geom>>=
let initial_geom = ref None
@

<<constant Mmm.home>>=
let home =
  try
    Sys.getenv "HOME"
  with
  | Not_found -> 
      prerr_endline "Please set the HOME environment variable.";
      exit (-1)
@

<<function Mmm.user_file>>=
let user_file name =
  Filename.concat (Filename.concat home ".mmm") name
@

<<constant Mmm.preferences>>=
(* placeholder for preference panel *)
let preferences = ref (fun () -> ())
@

<<constant Mmm.container_frame>>=
(* Tachymeter support
 * [container_frame] is the parent frame for displaying a tachymeter
 * It's initialized only after the first navigator window is created.
 * [tachy_maker] contains the current tachymeter creation function.
 * [change_tachy] changes the current tachymeter. It has immediate
 * effect if the first navigator window is already available. Otherwise,
 * it will take effect at creation time, using [start_tachy].
 *)
let container_frame = ref None
@

<<constant Mmm.tachy_maker>>=
let tachy_maker = ref About.create_tachy
@

<<function Mmm.change_tachy>>=
let change_tachy (t : Widget.widget -> Low.tachymeter) = 
  !Low.cur_tachy#quit;
  tachy_maker := t;
  begin match !container_frame with
    Some f -> 
      List.iter Tk.destroy (Winfo.children f);
      Low.cur_tachy := t f
  | None -> ()
  end
@

<<function Mmm.start_tachy>>=
let start_tachy () = 
  begin match !container_frame with
    Some f -> 
      Low.cur_tachy := !tachy_maker f
  | None -> ()
  end
@

<<function Mmm.quit>>=
let quit confirm =
  if confirm then
    match Frx_dialog.f Widget.default_toplevel (gensym "quit")
      (I18n.sprintf "Confirm") 
      (I18n.sprintf "Do you really want to quit ?")
       (Predefined "question") 0 
       [I18n.sprintf "Yep"; I18n.sprintf "Nope"] with
      0 -> destroy Widget.default_toplevel
    | _ -> ()
  else destroy Widget.default_toplevel
@

<<constant Mmm.user_menus>>=
(* User defined menus *)
let user_menus = ref []
@

<<function Mmm.add_user_menu>>=
let add_user_menu entry f = 
  user_menus := (entry,(fun x -> try f x with _ ->())) :: !user_menus;
  Frx_synth.broadcast "user_menu"
@

<<constant Mmm.navigators>>=
(*
 * A navigator window
 *)
let navigators = ref 0
@

<<constant Mmm.client_navigator>>=
let client_navigator = navigator false
@

<<constant Mmm.main_navigator>>=
let main_navigator = ref None
@

<<function Mmm.initial_navigator>>=
let initial_navigator preffile init_url =
  preferences := Mmmprefs.f preffile;
  !preferences();
  initial_page := Some (
     match init_url with
       None -> Lexurl.make !Mmmprefs.home
     | Some x -> 
     begin
       try 
         Lexurl.make x 
       with 
         _ -> (* If fails, try to use file: *)
           let path = 
         if x.[0] = '/' then x
         else Filename.concat (Unix.getcwd ()) x
           in
           Lexurl.make ("file://localhost" ^ path)
     end);
  main_navigator :=
     navigator true (match !initial_page with
       Some u -> u
     | None -> assert false);
  !main_navigator
@


%-------------------------------------------------------------

<<./gui/mmm.ml>>=
(* The navigation window *)
open Printf
open Unix
open Tk
open Mstring
open Url
open Hyper
open Www
open History
open Document
open Viewers
open Nav

<<constant Mmm.hotlist>>
<<constant Mmm.helpurl>>
<<constant Mmm.initial_page>>
<<constant Mmm.initial_geom>>

<<constant Mmm.home>>
      

<<function Mmm.user_file>>

<<constant Mmm.preferences>>

<<constant Mmm.container_frame>>
<<constant Mmm.tachy_maker>>

<<function Mmm.change_tachy>>

<<function Mmm.start_tachy>>

(* Switching current viewers in the browser *)
let undisplay di = 
  if Winfo.exists di#di_widget then Pack.forget [di#di_widget]
and display di = 
  if Winfo.exists di#di_widget
  then pack [di#di_widget][Fill Fill_Both; Expand true]
  else !Error.default#f "fatal error: window was destroyed";
  let tl = Winfo.toplevel di#di_widget
  and title = I18n.sprintf "MMM Browser@%s" di#di_title in
  if Widget.known_class tl = "toplevel" then
  (Wm.title_set tl title; Wm.iconname_set tl title)

<<function Mmm.quit>>

<<constant Mmm.user_menus>>
<<function Mmm.add_user_menu>>

<<constant Mmm.navigators>>

let rec navigator has_tachy initial_url =
  incr navigators;
  (* The first navigator is named, so we can put special information in
     window manager configurations, such as sticky *)
  let top = 
    if has_tachy then
      Toplevel.create_named Widget.default_toplevel "mmm" [Class "MMM"]
    else
      Toplevel.create Widget.default_toplevel [Class "MMM"]
  and current_di = ref None
  and update_vhistory = ref (fun () -> ()) (* duh *) in
  let entryv = Textvariable.create_temporary top
  in
  Wm.title_set top (I18n.sprintf "MMM Browser");
  (* the size of the navigator MUST NOT depend on what is displayed inside *)
  (* Instead, we rely on defaults for class MMM, *MMM.Width, *MMM.Height   *)
  Pack.propagate_set top false;
  try (* protect all the other initialisations *)
  let initial_did = {document_url = initial_url; document_stamp = no_stamp} in
  (* The frame in which a viewer might want to display *)
  let viewer_frame = Frame.create_named top "viewer" [] in
  let hist = History.create initial_did in
  (* Change view, independantly of history manip *)
  let show_current di frag =
      di#di_touch;
      begin match !current_di with
       None -> display di
      | Some olddi -> 
        if olddi == di then () 
         else begin
        undisplay olddi;
        display di
        end
      end;
      current_di := Some di;
      (* bogus if two views with fragment on the same pending document *)
      di#di_fragment frag;
      (* Bof *)
      Textvariable.set entryv (Url.string_of hist.h_current.h_did.document_url)

  and add_hist did frag =
    History.add hist did frag;
    !update_vhistory ()

  and error = new Tk_error.t top

  and loggingv = Textvariable.create_temporary top

  and actives = Hashtbl.create 37

  in
  let nav = { 
      nav_id = hist.h_key;
      nav_viewer_frame = viewer_frame;
      nav_error = error;
      nav_add_hist = add_hist;
      nav_show_current = show_current;
      nav_new = (fun link ->
           try
             let wwwr = Plink.make link in
               navigator false wwwr.www_url |> ignore; ()
           with
              Invalid_link msg -> 
                error#f (I18n.sprintf "Invalid link"));
      nav_log = (fun s -> Textvariable.set loggingv s);
      nav_add_active = Hashtbl.add actives;
      nav_rem_active = Hashtbl.remove actives
      } in

  (* The navigation functions 
   *  The cache may have been cleared, so the document may be lost.
   *  historygoto implements the proper logic for this, taking care
   *  of non-unique documents.
   *)

  let back () = 
    match History.back hist with
       None -> ()
     | Some (did, frag) -> 
    if not (historygoto nav did frag true) then
          ignore (History.forward hist)
  and forward () =
     match History.forward hist with
    None -> ()
      | Some (did, frag) -> 
     if not (historygoto nav did frag true) then begin
          ignore (History.back hist)
       end
  and reload () =
    let did = hist.h_current.h_did
    and frag = hist.h_current.h_fragment in
      if did.document_stamp = no_stamp then begin
    (* kill both in cache and in gcache *)
    Cache.kill did; Gcache.remove hist.h_key did;
    ignore (historygoto nav did frag false)
    end
      else
        error#f (I18n.sprintf "Document cannot be reloaded from its url\n(probably a POST request)")

  and update nocache =
    let did = hist.h_current.h_did in
    if did.document_stamp = no_stamp then
      Nav.update nav did nocache
    else (* POST result *)
      error#f (I18n.sprintf "Can't update document\n(probably a POST request)")

   (* A bunch of other functions *)
  and new_window () =
       navigator false hist.h_current.h_did.document_url |> ignore
  and new_window_initial () =
       navigator false initial_url |> ignore
  and new_window_sel () =
    try 
     let url = Selection.get [] in
       navigator false (Lexurl.make url); ()
    with
      _ -> navigator false initial_url; ()
  and abort () =
    Hashtbl.iter (fun url abort -> abort()) actives;
    Hashtbl.clear actives;
    match !current_di with
      None -> ()
    | Some di -> di#di_abort
  and open_sel () =
    try 
     let url = Selection.get [] in
      absolutegoto nav url
    with
      _ -> ()
  and open_file () =
     Fileselect.f (I18n.sprintf "Open File")
       (function [] -> ()
           | [s] -> 
           let path = Msys.tilde_subst s in
           absolutegoto nav ("file://localhost/"^path)
           | l -> raise (Failure "multiple selection"))
       "*" 
       ""
       false
       false
  and save () = Save.document hist.h_current.h_did None
  and print () = 
    Save.document hist.h_current.h_did 
       (Some (sprintf "|%s" !Save.print_command))
  and close () =
    if !navigators = 1 then quit true
    else destroy top
  and really_quit () = quit false
  and gohome () = absolutegoto nav !Mmmprefs.home
  and redisplay () =
    match !current_di with
       None -> ()
      | Some di -> di#di_redisplay
  and add_to_hotlist () =
    match !current_di with
       None -> ()
      | Some di -> 
      Hotlist.f (Url.string_of hist.h_current.h_did.document_url)
                di#di_title
  and load_images () =
    match !current_di with
       None -> ()
      | Some di -> di#di_load_images
  and view_source () =     
    match !current_di with
       None -> ()
      | Some di -> di#di_source
  in

  (***           Short cuts and menus             ***)
  (* All the available shortcuts functions and their short cut keys. *)
  (* If you put a new function with its short cut key here, then *)
  (* Short cut string will be displayed automatically, when these *)
  (* functions are added as menu elements. *)

  (* Sorry, we use function equality, so we cannot use lambdas in the list *)
  let update_true = fun () -> update true in

  (* The shortcuts and the default settings *)
  let all_short_cuts = [
    (* function    resource name      default key sequence *)
    About.f,     "About",           [[], KeyPressDetail "F1"]; 
    new_window,    "NewWindow",       [[Alt], KeyPressDetail "n"];
    open_sel,      "OpenSelection",   [[Alt], KeyPressDetail "y"];
    open_file,     "OpenFile",        [[Alt], KeyPressDetail "o"];
    save,          "Save",            [[Alt], KeyPressDetail "s"];
    print,         "Print",           [];
    !preferences,  "Preference",      [[Alt], KeyPressDetail "p"];
    close,         "Close",           [[Alt], KeyPressDetail "c"];
    really_quit,   "Quit",            [[Alt], KeyPressDetail "q"];

    gohome,        "Home",            [];
    back,          "Back",            [[Alt], KeyPressDetail "Left"];
    forward,       "Forward",         [[Alt], KeyPressDetail "Right"];
    reload,        "Reload",          [[Alt], KeyPressDetail "r"];
    abort,         "Abort",           [[], KeyPressDetail "Escape"];

    update_true,   "Update",          [[Alt], KeyPressDetail "u"];
    redisplay,     "Redisplay",       [[Control], KeyPressDetail "l"];
    add_to_hotlist, "AddToHotlist",   [[Alt], KeyPressDetail "a"];
    load_images,   "LoadImages",      [[Alt], KeyPressDetail "i"];
    view_source,   "ViewSource",      [[Alt], KeyPressDetail "e"]
  ] 
  in

  (* Real shortcuts information actually used *)
  let my_short_cuts = List.map (fun (f,r,d) ->
    f, Tkresource.event_sequence ("shortcut" ^ r) d) all_short_cuts
  in
  
  let configure_menu_elements menu =
    let rec list_assoc_address k = function
    (k',v)::_ when k == k' -> v
      | _::xs -> list_assoc_address k xs
      |	[] -> raise Not_found
    in
    List.iter (function l ->
      let opts = 
    List.fold_right (fun opt st ->
      (match opt with
        Command f -> 
          begin
        Command f :: 
              try
            [ Accelerator (Tkresource.short_event_sequence
                     (list_assoc_address f my_short_cuts))]
          with Not_found -> []
          end
      | _ -> [opt]) @ st) l []
      in
      match opts with
    [] -> Menu.add_separator menu
      |	_ -> Menu.add_command menu opts)
  in

  (* we break after each event so that All bindings, such as menu traversal,
   * dont get invoked if we destroyed the window for some reason
   * may be required only for things like reload
   *)
  List.iter (fun (f, eventl) -> 
    if eventl <> [] then
      bind top eventl (BindSetBreakable ([], fun _ -> f(); break())))
  my_short_cuts;

  (* Invariable part (the rest being the di stuff)
     hgroup: blah and tachymeter
   *)
  let hgroup = Frame.create_named top "hgroup" [] in
  let vgroup = Frame.create_named hgroup "vgroup" [] in (* Menus, open entry *)
    let mbar = 
      Frame.create_named vgroup "menubar" [] in
     (* MMM menu *)
     let mmm = Menubutton.create_named mbar 
       "mmm" [Text (I18n.sprintf "MMM")] in
     let mmmm = Menu.create_named mmm "menu" [] in
       Menubutton.configure mmm [Menu mmmm];
       configure_menu_elements mmmm [ 	    
         [Label (I18n.sprintf "About"); Command About.f];
         [];
         [Label (I18n.sprintf "New Window"); Command new_window];
         [Label (I18n.sprintf "Open Selection"); Command open_sel];
         [Label (I18n.sprintf "Open File..."); Command open_file];
         [Label (I18n.sprintf "Save document..."); Command save];
         [Label (I18n.sprintf "Print document"); Command print];
        [Label (I18n.sprintf "Preferences..."); Command !preferences];
     [];
         [Label (I18n.sprintf "Close Window"); Command close];
     [];
        [Label (I18n.sprintf "Quit"); Command really_quit]
        ];
    (* Navigation menu *)
    let navb = 
       Menubutton.create_named mbar "navigate"
          [Text (I18n.sprintf "Navigate")] in
    let navm = Menu.create_named navb "menu" [] in
        Menubutton.configure navb [Menu navm];
        configure_menu_elements navm [ 
         [Label (I18n.sprintf "Home"); Command gohome];
         [Label (I18n.sprintf "Back"); Command back];
         [Label (I18n.sprintf "Forward"); Command forward];
      []
        ];
        (* The history menu is destroyed and rebuild each time. 
           Deleting all entries will cause a callback leak since
           entries are associated to the menu itself *)
    let history_mindex = Pattern (I18n.sprintf "History") in
    let hmenu = ref (Menu.create_named navm "history" []) in 
        Menu.add_cascade navm [Label (I18n.sprintf "History")];
    update_vhistory := (fun () ->
       destroy !hmenu;
       hmenu := Menu.create_named navm "history" [];
       List.iter
             (fun e ->
          let label = ref (Url.string_of e.h_did.document_url) in
          begin match e.h_fragment with
             None -> ()
           | Some f -> label := !label^"#"^f
          end;
          begin match e.h_did.document_stamp with
             0 -> ()
           | n -> label := !label^"("^string_of_int n^")"
          end;
          Menu.add_command !hmenu 
             [Label !label;
              Command (fun () ->
              let cure = hist.h_current in
               History.set_current hist e;
               if not (historygoto nav e.h_did e.h_fragment true)
               then History.set_current hist cure)])
           (History.contents hist);
           Menu.configure_cascade navm history_mindex [Menu !hmenu]);
    let docb = 
       Menubutton.create_named mbar "document"
          [Text (I18n.sprintf "Document")] in
    let docm = Menu.create_named docb "menu" [] in
        Menubutton.configure docb [Menu docm];
        configure_menu_elements docm [	    
      [Label (I18n.sprintf "Abort"); Command abort];
      [Label (I18n.sprintf "Reload"); Command reload];
      [Label (I18n.sprintf "Update"); Command update_true];
      [Label (I18n.sprintf "Redisplay"); Command redisplay];
      [Label (I18n.sprintf "Add to hotlist"); Command add_to_hotlist];
      [Label (I18n.sprintf "Load Images"); Command load_images];
      [Label (I18n.sprintf "View Source"); Command view_source]
        ];
    (* Other stuff *)
    let othersb = 
      Menubutton.create_named mbar "others" [Text (I18n.sprintf "Others")] in
    let othersm = Menu.create_named othersb "menu" [] in
      Menubutton.configure othersb [Menu othersm];
      Menu.add_command othersm
    [Label (I18n.sprintf "Load Authorizations..."); Command Auth.load];
      Menu.add_command othersm
    [Label (I18n.sprintf "Edit Authorizations..."); Command Auth.edit];
      Menu.add_command othersm
    [Label (I18n.sprintf "Save Authorizations..."); Command Auth.save];

(*      Menu.add_command othersm
       [Label (I18n.sprintf "Caml Modules"); 
        Command (fun _ -> Applets.edit())];
      Menu.add_command othersm
       [Label (I18n.sprintf "Load Caml Extension");
     Command (fun _ ->
                Fileselect.f (I18n.sprintf "Load Caml Extension")
            (function [] -> ()
                    | [s] -> Applets.load_local s
                | l -> raise (Failure "multiple selection"))
            "*.cmo"
            ""
            false
            false)
        ];
*)
             
    (* Help menu *)
    let helpb = 
      Menubutton.create_named mbar "help" [Text (I18n.sprintf "Help")] in
    let helpm = Menu.create_named helpb "menu" [] in
      Menubutton.configure helpb [Menu helpm];
       Menu.add_command helpm
          [Label (I18n.sprintf "Version information");
       Command (fun () -> 
         absolutegoto nav (Version.initurl (Lang.lang ())))];
       Menu.add_command helpm
      [Label (I18n.sprintf "Help on MMM");
       Command (fun () -> navigator false !helpurl; ())];
       Menu.add_command helpm
          [Label (I18n.sprintf "Home Page of MMM");
       Command (fun () -> navigator false
         (Lexurl.make (Version.home (Lang.lang ()))); ())];

    (* User menu, extensible by applets *)
    let userb =
      Menubutton.create_named mbar "user" [Text (I18n.sprintf "User")] in
    let userm = ref (Menu.create_named userb "menu" []) in
    let reset_user_menu _ =
      destroy !userm;
      userm := Menu.create_named userb "menu" [];
      List.iter (function (entry, f) ->
                 Menu.add_command !userm 
                  [Label entry; 
                   Command (fun () -> f 
                      (Nav.make_ctx nav hist.h_current.h_did))])
        !user_menus;
      Menubutton.configure userb [Menu !userm] in
      
     reset_user_menu();
     Frx_synth.bind userb "user_menu" reset_user_menu;

     pack [mmm; navb; docb; othersb][Side Side_Left];
     pack [helpb; userb] [Side Side_Right];

    (* URL display and edit *)
    let f,e = Frx_entry.new_label_entry vgroup (I18n.sprintf "Open URL:")
                     (absolutegoto nav)
    (* Navigation buttons *)
    and fb = Frame.create_named vgroup "buttons" [] in
    let backb = Button.create_named fb 
      "back" [Text (I18n.sprintf "Back"); Command back ]
    and abortb = Button.create_named fb 
      "abort" [Text (I18n.sprintf "Abort"); Command abort]
    and reloadb = Button.create_named fb
      "reload" [Text (I18n.sprintf "Reload"); Command reload]
    and forwardb = Button.create_named fb 
      "forward" [Text (I18n.sprintf "Forward"); Command forward]
    and loggingb = Label.create_named fb "logging"
    [TextWidth 40; TextVariable loggingv; Anchor W]
    and homeb = Button.create_named fb "home"
      [ Text (I18n.sprintf "Home"); Command gohome]
    in
     Entry.configure e [TextVariable entryv; TextWidth 40];
     pack [mbar][Anchor NW; Side Side_Top; Fill Fill_X];
     pack [backb;homeb;forwardb;reloadb;abortb; loggingb]
         [Side Side_Left; Fill Fill_X];
     pack [f][Fill Fill_X; Expand true; Side Side_Bottom; Anchor SW];
     pack [fb][Fill Fill_X];
     (* Initial window only *)
     if has_tachy then begin
      (match !initial_geom with None -> ()
       | Some g -> Wm.geometry_set top g);
       (* put this as a function so we can restart it if needed *)
       let rec restart_tachy () =
       (* We must not pass hgroup to tachymeter applets *)
       let fcontainer = Frame.create hgroup [] in
       container_frame := Some fcontainer;
       (* restart it if destroyed *)
       bind fcontainer [[], Destroy]
     (BindSet ([Ev_Widget],
           (fun ei -> 
             if ei.ev_Widget = fcontainer 
                     && Winfo.exists hgroup (* but we're not dead *) then
               restart_tachy())));

       let rw = Winfo.reqwidth fcontainer
       and rh = Winfo.reqheight fcontainer
       in
       Wm.minsize_set top rw rh;
       pack [fcontainer][Side Side_Right; Anchor N];
       start_tachy();
       (* Bad hack to do bindings for our own internal tachymeter:
      others, in applets, can just access these functions from the safe
      library *)
       if !tachy_maker == About.create_tachy then begin 
     match Winfo.children fcontainer with
       [c] ->
         bind c (Glevents.get "tachy_new")
               (BindSet ([], (fun _ -> new_window_initial ())));
         bind c (Glevents.get "tachy_sel")
               (BindSet ([], (fun _ -> new_window_sel ())));
     | _ -> ()
       end
       in
       restart_tachy(); (* first initialisation *)
       (* good size for keeping only the tachy *)
       Wm.minsize_set top 80 80;
     end;
     (* Pack last to avoid lossage when resizing *)
     pack [vgroup][Fill Fill_X; Expand true; Side Side_Left];
     pack [hgroup][Fill Fill_X];
     pack [viewer_frame][Fill Fill_Both; Expand true];

  (* We receive this event for each children destroyed because we are
     a toplevel *)
  bind top [[], Destroy] 
   (BindSet ([Ev_Widget],
      (fun ei -> 
       if ei.ev_Widget = top then begin
    decr navigators;
    Gcache.kill hist.h_key;
    (* we were destroyed by wm *)
    if !navigators = 0 && Winfo.exists Widget.default_toplevel
        then destroy Widget.default_toplevel
        end)));
  Tkwait.visibility hgroup;
  !update_vhistory();
  (* Yet another timer to avoid flushing displayed documents *)
  let rec touch_current () =
    if Winfo.exists top then begin
      Cache.touch hist.h_current.h_did;
      Timer.set 10000 touch_current
    end in
  touch_current();
  absolutegoto nav (Url.string_of initial_url);
  Some nav
  with
      e -> 
    !Error.default#f (I18n.sprintf "Can't view initial document: %s\n%s"
                      (Url.string_of initial_url)
                  (Printexc.to_string e));
    if !navigators = 1 then begin
           destroy Widget.default_toplevel;
        raise e
        end
    else begin 
         destroy top;
      None
        end

and new_window_initial () =
  ignore (
   navigator false
    (match !initial_page with
     | Some u -> u
     | None -> assert false))

and new_window_sel () =
  try 
    let url = Selection.get [] in
    ignore (navigator false (Lexurl.make url))
  with
    _ -> new_window_initial ()

<<constant Mmm.client_navigator>>

<<constant Mmm.main_navigator>>

<<function Mmm.initial_navigator>>
@


\subsection*{[[./gui/cci.ml]]}

<<function Cci.handler>>=
(* CCI was cool, but nobody implements it anymore. More over,
 * it's trivial to fork mmm_remote and let the protocol be managed
 * by it *)

let handler fd line =
  let len = String.length line in 
  if len > 4 && String.sub line 0 4 = "GET " then begin
    let url = String.sub line 4 (len - 4) in
    match !Mmm.main_navigator with
      None -> 
    Munix.write_string fd "No main navigator\n";
    close fd
    | Some nav ->
    Nav.save_link nav (Some (fd, true))
      {h_uri = url; h_context = None; h_method = GET; h_params = []}
  end else if len > 5 && String.sub line 0 5 = "GETB " then begin
    let url = String.sub line 5 (len - 5) in
    match !Mmm.main_navigator with
      None ->
    Munix.write_string fd "No main navigator\n";
    close fd
    | Some nav ->
    Nav.save_link nav (Some (fd, false))
      {h_uri = url; h_context = None; h_method = GET; h_params = []}
  end else if len > 5 && String.sub line 0 5 = "HEAD " then begin
    let url = String.sub line 5 (len - 5) in
    match !Mmm.main_navigator with
      None ->
    Munix.write_string fd "No main navigator\n";
    close fd
    | Some nav ->
    Nav.save_link nav (Some (fd, true))
      {h_uri = url; h_context = None; h_method = HEAD; h_params = []}
  end else if len > 8 && String.sub line 0 8 = "DISPLAY " then begin
    let url = String.sub line 8 (len - 8) in
    close fd;
    ignore (Mmm.navigator false (Lexurl.make url))
  end else begin (* assume DISPLAY (backward compatibility) *)
    close fd;
    ignore (Mmm.navigator false (Lexurl.make line))
  end
@

<<function Cci.init>>=
(* External requests *)
let init () =
 let file = Mmm.user_file "remote" in
 try
  let socket = socket PF_UNIX SOCK_STREAM 0 in
    begin try bind socket (ADDR_UNIX file) 
    with
      _ -> 
    if not (Sys.file_exists file) then raise Not_found;
    begin match 
      Frx_dialog.f Widget.default_toplevel 
        (Mstring.gensym "confirm")
        (I18n.sprintf "Confirm")
        (I18n.sprintf "%s already exists. This may mean that there is another MMM already running. Do you want to remove this file and create again ? (Note that you must be sure there is no other MMM with -external option)" file)
        (Predefined "question") 0
        [ I18n.sprintf "Yes"; 
          I18n.sprintf "No, I give up to use -external option"] 
    with
      0 -> 
        Unix.unlink file;  
        bind socket (ADDR_UNIX file) 
    | _ -> raise Exit
    end
    end;
    
    listen socket 5;
    Fileevent.add_fileinput socket
       (fun () -> 
      try 
          let fd,_ = accept socket in
       handler fd (Munix.read_line fd)
      with _ -> ());
    at_exit (fun () -> Msys.rm file)
 with
   e ->
     !Error.default#f (I18n.sprintf "Can't initialize %s\n%s"
                       file (Printexc.to_string e))
@


%-------------------------------------------------------------

<<./gui/cci.ml>>=
open Tk
open Unix
open Hyper


<<function Cci.handler>>
      


<<function Cci.init>>


@


\section{[[./]]}

\subsection*{[[./main.ml]]}


%-------------------------------------------------------------

<<./main.ml>>=
open Common

(*****************************************************************************)
(* Purpose *)
(*****************************************************************************)

(*****************************************************************************)
(* Flags *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Main.safe_loop>>
       
<<function Main.localize>>

(*****************************************************************************)
(* The options *)
(*****************************************************************************)

(*****************************************************************************)
(* Main entry point *)
(*****************************************************************************)

<<constant Main.usage_str>>

<<function Main.main>>
      
<<function Main.postmortem>>

<<toplevel Main._1>>
@


\subsection*{[[./main_remote.ml]]}


%-------------------------------------------------------------

<<./main_remote.ml>>=
(* Talk to an mmm master *)
open Unix

<<function Main_remote.request>>
    
<<function Main_remote.main>>

<<toplevel Main_remote._1>>
@


\section{[[./extensions/]]}

\subsection*{[[./extensions/audio.ml]]}


%-------------------------------------------------------------

<<./extensions/audio.ml>>=
open Safe418mmm
open Tk
open Hyper
open Viewers
open Document

module Provide = struct
  let capabilities = Capabilities.get()
  end
module Mmm = Get(Provide)


<<function Audio.fake_embed>>
<<toplevel Audio._1>>
@


\subsection*{[[./extensions/images.ml]]}

<<function Images.images>>=
let images lexbuf =
  let uris = ref [] in
  try
    let lexer = ParseHTML.sgml_lexer Dtd.dtd32 in
    while true do
      try 
        let _,_,tokens,loc = lexer lexbuf in
      List.iter (function
         OpenTag {tag_name = "img"; attributes = attrs} ->
           begin try
        uris := List.assoc "src" attrs :: !uris
           with Not_found -> ()
           end
       | EOF -> raise End_of_file
       | _ -> ())
          tokens
      with
        Html_Lexing _ -> ()
      | Invalid_Html _ -> ()
    done;
    !uris
  with
    End_of_file -> List.rev !uris
@

<<function Images.show_images>>=
(* Pops up a dialog box with the list of image URLs *)
let show_images ctx l =
  let w = Applets.get_toplevel_widget [] 
  and base = Url.string_of (ctx#base.document_url)
  in
  Wm.withdraw w;
  Frx_req.open_list "Display Images" l
    (fun uri -> 
      let link = 
    {h_uri = uri; h_context = Some base; h_method = GET; h_params = []} in
        ctx#goto link)
    (fun _ -> destroy w)
@

<<function Images.f>>=
(* When the menu item is activated, this function is called :
   we're interested mostly in the URL of the currently displayed document,
   but the ctx will be used later so we can trigger new navigation functions
   on the URLs of the in-lined images.
   What we do is request a copy of this document, on which we run an HTML
   lexer.
 *)
let f ctx =
  let cont = {
    document_process = (fun dh ->
      let lexbuf = Lexing.from_function
                   (fun buf n -> dh.document_feed.feed_read buf 0 n) in
      let l = images lexbuf in
        dclose true dh;
        show_images ctx l);
    document_finish = (fun _ -> ())
    } in
  let link = {h_uri = Url.string_of ctx#base.document_url;
          h_context = None;
          h_method = GET;
          h_params = []} in

  Net.retrieve link cont
@

<<toplevel Images._1>>=
let _ = Mmm.add_user_menu "In-lined images" f
@

<<toplevel Images._2>>=
let _ = Applets.register "main"
    (fun f ctx ->
      pack [Label.create f [Text "Menu User/images installed"]][])
@


%-------------------------------------------------------------

<<./extensions/images.ml>>=
open Safe418mmm

(* This module demonstrates
    - how to add an user menu
    - how to call the HTML lexer
*)

module Provide = struct
  let capabilities = Capabilities.get()
  end

module Net = Retrieval(Provide)
module Mmm = Get(Provide)

open Tk
open Net
open Html
open Document
open Feed
open Hyper
open Viewers

<<function Images.images>>

<<function Images.show_images>>

<<function Images.f>>

<<toplevel Images._1>>


<<toplevel Images._2>>
@


\subsection*{[[./extensions/remove_simple_table.ml]]}

<<function Remove_simple_table.log>>=
let log s = try prerr_endline s with _ -> () 
@

<<type Remove_simple_table.table_token>>=
type table_token =
    ChildTable of Html.token list
  | Token of Html.token 
@

<<type Remove_simple_table.rst_env>>=
type rst_env = {
    mutable tokens : table_token list;
    mutable trs : int;
    mutable tds : int 
  } 
@

<<function Remove_simple_table.remove_simple_table>>=
let remove_simple_table parentf = 
  let stack = ref [] in

  let push_tbl tbl = stack := tbl :: !stack in
  let pop_tbl () =
   match !stack with
   | t :: tl -> stack := tl; t
   | _ -> assert false in
  let head_stack () = List.hd !stack in
  let empty_stack () = !stack = [] in

  let flush_childtable tkns =
    if empty_stack () then List.iter parentf tkns
    else begin
      let top = head_stack () in
      top.tokens <- top.tokens @ [ChildTable tkns]
    end
  in

  fun tkn -> match tkn with
    EOF ->
      while not (empty_stack ()) do
    log "EOFflush";
    let tbl = pop_tbl () in
    flush_childtable 
      (List.fold_right (fun xtkn st ->
        match xtkn with 
          Token tkn -> tkn :: st
        | ChildTable tkns -> tkns @ st) tbl.tokens [])
      done;
      parentf EOF
  | OpenTag {tag_name = "table"} ->
      log "ENTER";
      let tbl = {tokens= [Token tkn]; trs= 0; tds= 0} in
      push_tbl tbl;
  | CloseTag "table" when not (empty_stack ()) -> 
      let tbl = pop_tbl () in
      log "REMOVE";
      let tokens = 
    if tbl.trs <= 1 && tbl.tds <= 1 then begin
      log "ERASE";
      let tokens = 
       (* remove table, tr, td *)
       List.fold_right (fun xtkn st ->
          match xtkn with
        Token tkn -> begin
          match tkn with
            OpenTag {tag_name= "table"}
          | OpenTag {tag_name= "tr"}
          | OpenTag {tag_name= "td"}
          | CloseTag "table"
          | CloseTag "tr"
          | CloseTag "td" -> st
          | _ -> tkn :: st
        end
          |	ChildTable tkns ->
          tkns @ st) tbl.tokens []
      in
      [OpenTag {tag_name="br"; attributes=[]};
        CloseTag "br"; 
        PCData "[[" ] @ tokens @
      [ PCData "]]";
        OpenTag {tag_name="br"; attributes=[]}; 
        CloseTag "br" ]
    end else begin
      tbl.tokens <- tbl.tokens @ [Token tkn];
      List.fold_right (fun xtkn st ->
        match xtkn with
          Token tkn -> tkn :: st
        | ChildTable tkns -> tkns @ st) tbl.tokens []
    end
      in
      flush_childtable tokens
  | _ when not (empty_stack ()) -> 
      let tbl = head_stack () in
      begin
    match tkn with
      OpenTag {tag_name = "td"} ->
        tbl.tds <- tbl.tds + 1
    | OpenTag {tag_name = "tr"} -> 
        tbl.trs <- tbl.trs + 1
    | _ -> ()
      end;
      tbl.tokens <- tbl.tokens @ [Token tkn]
  | _ ->  (* !stack = [] *)
      parentf tkn
@

<<toplevel Remove_simple_table._1>>=
let _ =
  Mmm.add_html_filter remove_simple_table
@


%-------------------------------------------------------------

<<./extensions/remove_simple_table.ml>>=
open Safe418mmm

<<function Remove_simple_table.log>>

(* an example of html filter *)

(* This example removes the tables with atmost one <TD> (<TR> also) tag. *)
(* This reduces the widgets creations... *)
  
module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)

open Html

<<type Remove_simple_table.table_token>>

<<type Remove_simple_table.rst_env>>

<<function Remove_simple_table.remove_simple_table>>

<<toplevel Remove_simple_table._1>>
@


\subsection*{[[./extensions/tachy_aftermmm.ml]]}

<<constant Tachy_aftermmm.tachy_data>>=
(* inside bitmap, circle is in +10+6 +47+43, radius 18.5 *)

let tachy_data = "GIF\056\055a\058\000\060\000\165\000\000\168\168\168\
\168\152\176\152\152\168\152\152\152\152\136\160\136\152\152\136\
\136\152\128\136\128\128t\152\144\172\200\136\152\184\144\132\
\168\128\132\152\136\136\136\000\000\000\248\252\248\216\216\216\
\040\040\040p\136\136\184\184\184\200\200\200XXX\128\
txht\152pt\136\040\044\040ptphd\
\144\232\232\232\096d\136\224pp\240xx\096dp\
\096\096h\096TpPdpHXxXTX\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\044\000\000\
\000\000\058\000\060\000\000\006\254\064\128\016\016\032\026\139\
\001\001R\201\020\052\007\004\168\148P\160Z\013W\002\
\214\096\056p\187\136\195\016\144\024\011\145\000\005\064\176\
n\179\005\010\167\160\048\159\091\011\139\042\190\096\224\243\
\191\006\012\129\006gCh\135JDJ\003I\002\003\
\142\142QVPzY\091\093\152\007aae\134G\
FjEjr\002\013\166\167\014\015\003\003\166\016\149\
\123\095\127\092\017\180\180\018\008\135G\137I\188N\172\
\167\192\013\169\171\196\019\020\174Z\092\201\094\179\155\018\
\016bf\159\163n\193\214\195\196\003c\016\125\221\128\
\018\017\130\183\220\185\136\189\214\193\019c\196\210\016\220\
\153\096\017\155\007\016\018\159h\161m\021\214\171\210\254\
\237\128\004\025\136pk\028\046\093Kx\057\216\215\224\
\215\191\135f\038L\128\006F\211\051w\238\236\009\201\
G\141\205\062\134\013\033\138\148\056\193A\061\003\018P\
\034\040\184\242\160\057\038\251\022\134\020\057\178d\003w\
\154r\174\180\032\129\231\254\180\053N\000\124\020V\129\
\166Q\000\013\000H\172\215\146\165\132\011\188\020\245\026\
j\234\232Q\137\020\142\021\228\185\019\003\040\055k\128\
i\179j\212XV\008MW\094\144\128\033a\147\096\
d\173f\061\203\179\046\006\011\094G\005u\034\054\174\
\220\179\005\215b\192\000\149I\163\095\167\252Z\053\155\
\017\239\096\188\096\229\000\051\154\161B\006\162E\043g\
\016\057\023\130\096\182l\123AB\156\148f\209\152B\
\133V\230\124\204\029\094\199\026\246J\062\053\022b\131\
\213\183\047\035\205\160\014\226D\140\131\217\014\062\012i\
\178\233\210\167\027TX\094T\036F\008\176\055x\037\
\053\199\184\200\125B\150\011e\222\220\057\004\014\194\007\
c\024\029\201\186b\185\192\053\096P\031\091\014\029\005\
\180\207\251\061\037\030C\007\012Q\034Aq\192\191\182\
\252\163\252\057\032\221\006\026\016\232\004\029\008\146T\026\
Y\020\040F\210\096\234\221\167\159\021\166\248\247\159Q\
\030d\184\030\129\004\254\190gG\001\236\092hU\134\
\030\220w\095\129\146T\146\141\136F\125\144\225\007\028\
\022\168\001\130w\172\200\162H\030\124\160\035\123\004\226\
\247J\020\033\222\248\208\139\048\202\216\225\029\147\244\035\
\228\063\057\234\184\161\145Hb\001\162\133K\142A\164\
\145\026h\000\130\030yP\177\128\146U\154\049\064\147\
E\174\215\001\138\063bAe\152\058\234\024c\150Y\
\190\146\007\023aJ\211\230\142\049\018\216\129\022\124\126\
\161E\131u\010q\167\140Zn\000\130\150\092\250\209\
\013\004CH\180\036\153\031\152\169\193\153g\130\096\201\
\050\006\048\042\145r\055\054\064\036\129Z\194y\232\150\
s\002\002\008\004\019\008\195\168\136\015\056\224b\145\049\
V\010\130\165\126r\161\147\038\020\152D\146\124\020p\
\224\171\171\160\142\170\229\172\179\202\194\135\064\040\037\139\
\042I\128\198\229\235\003\190B\160\231\164\212\018\171\037\
\001\007\044\019FE\059\045kV\179\052\245\234\235\184\
\193\134\042\236\172\254\033\152\250EJ\226\180\004\193\092\
\240be\198\092\227\214\203\193\180\211\018\171\239\023\183\
\058\211\020\094\238\192\219\171\059\037\061\128\145\189\028\064\
\064\232\185\250\130\016\130\008\233\014\034N\178N\053u\
\193\187\024cT\176\059\245\026\028\043\181\178\018\059\002\
\008\035W\196mO\091\161\252\218\093\024\060\183q\189\
\160\194i\238\176\163\058\012\177\195\223\012Rq\096\225\
\133\055\152\137O\230\009\050\008\033\207\058\178\209\034\204\
\227\239V\044\059\198\242\134\016\010\045\244\204\013\219\252\
\240\213\019\167\228\212Zj\129\134\129\207\246\133\045c\
\208\213\154\171\239\200h\147\012\194\201\092\245t\151\219\
\043\175\039\055\150o\202\204\176\190W\091\045\194\008\005\
\169\180\179\096\245\213\007\052\221\050RJ\052\205F\139\
\188\055\201I\091\244o\211\226E\135\129\212\132\046l\
\054\222\016g\254\240\008\123km\049h\128\127\029\054\
\132b\247\136e\165\151\039\158\054\218\123\039\141rW\
\043\199\061\054j\225\049\139\154\058\186\154g\206\249\230\
\059w\029\184\224\165\019\046k\209j\035\205\058\231\035\
\144\240x\220\245\209\142e\161YZ\091\245\213\173o\
\222\250\008\033\148\192\179\232\096\015\062\183\233\031\223\173\
\058\227\199\239MB\242\176C\030\029\143\132\203L\181\
\195\196RO\061\242\123g\159\253S\219\255N\250\137\
\148\135\140\184\218\229\163\095\242\146W\002\018\004\001\000\
\059\
"
@

<<constant Tachy_aftermmm.park_data>>=
let park_data =
"#define break_width 15
#define break_height 11
static char break_bits[] = {
   0x0c, 0x18, 0xf4, 0x17, 0x3a, 0x2e, 0xba, 0x2d, 0xb9, 0x4d, 0x3d, 0x5e,
   0xb9, 0x4f, 0xba, 0x2f, 0xba, 0x2f, 0xf4, 0x17, 0x08, 0x08};
"
@

<<constant Tachy_aftermmm.pi>>=
let pi = 3.1415926 
@

<<constant Tachy_aftermmm.log10>>=
let log10 = log 10.0 
@

<<function Tachy_aftermmm.create_tachy>>=
let create_tachy top = 
  let o = new default_tachy top in
  o#start;
@

<<toplevel Tachy_aftermmm._1>>=
let _ = 
  let top = Applets.get_toplevel_widget [] in
  Wm.withdraw top;
  begin match Frx_dialog.f top (Mstring.gensym "foo")
        "Tachy test" "Use this aftermmm tachymeter"
    (Tk.Predefined "question") 1 ["Yes"; "No"] with
    0 -> Mmm.set_tachy create_tachy
  | _ -> ()
  end;
  destroy top
@


%-------------------------------------------------------------

<<./extensions/tachy_aftermmm.ml>>=
open Safe418mmm
open Tk

module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)

(* Tachymeter *)

(* gif is 58x60 *)
<<constant Tachy_aftermmm.tachy_data>>

<<constant Tachy_aftermmm.park_data>>


<<constant Tachy_aftermmm.pi>>
<<constant Tachy_aftermmm.log10>>

class default_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable canvas = top (* dummy initialisation *)
  val mutable alive = false

  (* Various components of the canvas, all with dummy init values *)
  val mutable i_park = Tag "none"
  val mutable kilos = Tag "none"
  val mutable aig = Tag "none"
  val mutable pendings = Tag "none"


  (* this one is private *)
  method start =
    let c =
      Canvas.create_named top "tachymeter"
       [Width (Pixels 56); Height (Pixels 60); 
         BorderWidth (Pixels 0);
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *)] in
    (* Use colors so that images are not transparent *)  
    (*
    let tachy_image = 
      begin
       try
      let bgc = Tk.cget c CBackground in
      Protocol.tkEval 
        [|Protocol.TkToken "set";
          Protocol.TkToken "TRANSPARENT_GIF_COLOR";
          Protocol.TkToken bgc |]; () 
       with _ -> ()
      end;
      *)
    let tachy_image = Frx_misc.create_photo [Data tachy_data]
    and park_image =
      Imagebitmap.create [Data park_data; Foreground Red] in

    i_park <-
      Canvas.create_rectangle c 
     (Pixels 50) (Pixels 4) 
     (Pixels 53) (Pixels 7) [FillColor Black];
    
    kilos <-
      Canvas.create_text c (Pixels 28) (Pixels 52) [Text "0"; Font "-adobe-helvetica-medium-r-*-*-8-*-*-*-*-*-*-*"];
    
    aig <-
      Canvas.create_line c [Pixels 27; Pixels 25; Pixels 27; Pixels 43]
                       [Width (Pixels 2)];
    pendings <-
      Canvas.create_text c (Pixels 52) (Pixels 39) [Text "0"; Font "-adobe-helvetica-medium-r-*-*-8-*-*-*-*-*-*-*"];

    let i_tachy =
      Canvas.create_image c (Pixels 56) (Pixels 0)
       [ImagePhoto tachy_image; Anchor NE]

    in

    Canvas.lower_bot c pendings;

    (* All other items must be put above the background image *)
    List.iter (fun i -> Canvas.raise_above c i i_tachy)
      [kilos; aig; i_park];

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));

    (* These bindings are specific to the applet version *)
    bind c [[], ButtonPressDetail 1] 
      (BindSet ([], (fun _ -> Mmm.new_window_initial (); ())));
    bind c [[], ButtonPressDetail 2] 
      (BindSet ([], (fun _ -> Mmm.new_window_sel (); ())));

    alive <- true;
    pack [c][];
    canvas <- c

  val mutable last_speed = 0.
  val mutable last_total = 0
  val mutable idle = false

  method update speed total =
    if speed = 0.0 then begin
      if not idle then begin
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black];
    idle <- true
      end
    end
    else begin
      Canvas.configure_rectangle canvas i_park [FillColor Green;
                         Outline Green];
      idle <- false
    end;
    if total <> last_total then
      Canvas.configure_text canvas kilos [Text (string_of_int total)];
    last_total <- total;
    let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
    let speeds = (last_speed +. speed) /. 2. in
    if abs_float (speeds -. last_speed) > 0.1 then begin
      last_speed <- speeds;
      let v = speeds /. log10 in
      let angle = v /. 4.0 *. pi in
      let angle = if angle < 0.1 then 0.0 else angle in
      let x = 27.0 -. (sin angle *. 18.5)
      and y = 25.0 +. (cos angle *. 18.5) in
      Canvas.coords_set canvas aig 
    [Pixels 27; Pixels 25;
      Pixels (truncate x); Pixels (truncate y)];
      update_idletasks()
    end

  method report_cnx n = 
    if Winfo.exists canvas then
      if n = 0 then begin
    Canvas.configure_text canvas pendings [Text ""];
       Canvas.lower_bot canvas pendings
      end
      else begin
    Canvas.configure_text canvas pendings 
      [Text (string_of_int n)];
       Canvas.raise_top canvas pendings
      end

  method report_busy busy =
    if Winfo.exists canvas then
      if busy then begin
       Canvas.lower_bot canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Red;
                          Outline Red];
    update_idletasks()
      end
      else begin
       Canvas.raise_top canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy canvas

end

<<function Tachy_aftermmm.create_tachy>>
  (o :> Mmm.tachymeter)

<<toplevel Tachy_aftermmm._1>>

@


\subsection*{[[./extensions/tachy_space.ml]]}

<<constant Tachy_space.mpoly_data>>=
(* Tachymeter *)

let mpoly_data = 
[5.684359, -36.000000;
14.760086, -36.000000;
19.000000, -20.736308;
23.239914, -36.000000;
31.760086, -36.000000;
36.000000, -20.736308;
40.239914, -36.000000;
46.315641, -36.000000;
37.760086, -5.200000;
30.239914, -5.200000;
26.000000, -20.463692;
21.760086, -5.200000;
14.239914, -5.200000]
@

<<type Tachy_space.vector>>=
type vector = float * float * float
@

<<type Tachy_space.matrix>>=
type matrix = vector * vector * vector
@

<<function Tachy_space.matrix_vector>>=
let matrix_vector ((a11,a21,a31), (a12,a22,a32), (a13,a23,a33)) (x,y,z) =
  (a11*.x+.a12*.y+.a13*.z, a21*.x+.a22*.y+.a23*.z, a31*.x+.a32*.y+.a33*.z)
@

<<constant Tachy_space.pi>>=
let pi = 3.1415926 
@

<<constant Tachy_space.log10>>=
let log10 = log 10.0 
@

<<type Tachy_space.ball>>=
type ball = {
  tag : Tk.tagOrId;
  mutable x : float;
  mutable y : float;
  mutable z : float
 }
@

<<function Tachy_space.create_tachy>>=
let create_tachy top = 
  let o = new space_tachy top in
  o#start;
@

<<toplevel Tachy_space._1>>=
let _ = 
  let top = Applets.get_toplevel_widget [] in
  Wm.withdraw top;
  begin match Frx_dialog.f top (Mstring.gensym "foo")
        "Tachy test" "Use the space tachymeter"
    (Tk.Predefined "question") 1 ["Yes"; "No"] with
    0 -> Mmm.set_tachy create_tachy
  | _ -> ()
  end;
  destroy top
@


%-------------------------------------------------------------

<<./extensions/tachy_space.ml>>=
open Safe418mmm
open Tk


module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)


<<constant Tachy_space.mpoly_data>>

<<type Tachy_space.vector>>
<<type Tachy_space.matrix>>

let x_rotation a = let c = cos a and s = sin a in
    ((1.0,0.0,0.0), (0.0,c,s), (0.0,-.s,c))
and y_rotation a = let c = cos a and s = sin a in
    ((c,0.0,-.s), (0.0,1.0,0.0), (s,0.0,c))

<<function Tachy_space.matrix_vector>>

<<constant Tachy_space.pi>>
<<constant Tachy_space.log10>>

<<type Tachy_space.ball>>

class space_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable fr = top (* dummy initialisation *)
  val mutable c = top (* dummy initialisation *)
  val mutable c2 = top (* dummy initialisation *)
  val mutable mpoly = Tag "none" (* dummy initialisation *)
  val mutable i_park = Tag "none" (* dummy initialisation *)
  val mutable kilos = Tag "none" (* dummy initialisation *)
  val mutable pendings = Tag "none" (* dummy initialisation *)
  val mutable alive = false

  val mutable balls = Array.create 32 {tag = Tag "none"; x = 0.; y = 0.; z = 0.}
  val spacewidth = 4.0

  (* this one is private *)
  method start =
    fr <- Frame.create_named top "tachymeter" [BorderWidth (Pixels 2)];
    c <- Canvas.create fr
       [ Width (Pixels 72); Height (Pixels 72); 
         BorderWidth (Pixels 1);
      Relief Sunken;
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *);
      Background Black];
    c2 <- Canvas.create fr [Width (Pixels 72); Height (Pixels 16)];
    pack [c; c2] [Side Side_Top; Fill Fill_X];

    i_park <- 
       Canvas.create_rectangle c2 
      (Pixels 1) (Pixels 1) 
      (Pixels 4) (Pixels 4) [FillColor Black];

    kilos <-
       Canvas.create_text c2
        (Pixels 36) (Pixels 8)
     [Text "0"; Font "variable"];

    pendings <-
       Canvas.create_text c2
        (Pixels 68) (Pixels 8)
     [Text "0"; Font "variable"];

    balls <-
       Array.map (fun _ -> 
     { tag = Canvas.create_line c [Pixels 100; Pixels 100; 
                                  Pixels 100; Pixels 100] 
                                  [FillColor (NamedColor "White")];
       x = Random.float spacewidth -. (spacewidth /. 2.0);
       y = Random.float spacewidth -. (spacewidth /. 2.0);
       z = Random.float 0.9 +. 0.1 }) balls;

    mpoly <- Canvas.create_polygon c (List.fold_right (fun (x,y) s ->  
      let x = truncate ((x -. 26.0) *. 1.3) + 36
      and y = 36 - truncate ((20.6 +. y) *. 1.3) 
      in [Pixels x; Pixels y] @ s) 
                       mpoly_data [])
       [Width (Pixels 2); FillColor Green; Outline White];

    for i = 0 to Array.length balls - 1 do
      self#ball_update balls.(i) 0.0
    done;
    
    Canvas.lower_bot c2 pendings;

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));
    (* These bindings are specific to the applet version *)
    bind c [[], ButtonPressDetail 1] 
      (BindSet ([], (fun _ -> Mmm.new_window_initial (); ())));
    bind c [[], ButtonPressDetail 2] 
      (BindSet ([], (fun _ -> Mmm.new_window_sel (); ())));

    alive <- true;
    pack [fr][]
    
  val mutable mx = 0.
  val mutable my = 0.
  val mutable last_speed = 0.
  val mutable last_speed2 = 0.
  val mutable last_total = 0
  val mutable idle = false

  method ball_update ball speed =
    let x = truncate (ball.x *. (0.2 /. ball.z) *. 32.0) + 36
    and y = truncate (ball.y *. (0.2 /. ball.z) *. 32.0) + 36
    and x' = truncate (ball.x *. (0.2 /. (ball.z +. speed)) *. 32.0) + 36
    and y' = truncate (ball.y *. (0.2 /. (ball.z +. speed)) *. 32.0) + 36
    in
    let x', y' = if (x,y) = (x',y') then x', y'+1 else x', y' in 
    Canvas.coords_set c ball.tag
      [Pixels x; Pixels y; Pixels x'; Pixels y'];
    let x =
      Printf.sprintf "%02X" (truncate ((1.0 -. ball.z) /. (1.0 -. 0.1) *. 255.0)) in
    Canvas.configure_line c ball.tag [FillColor (NamedColor ("#"^x^x^x))]

    
  method update speed total =
     Canvas.coords_set c mpoly 
       (List.fold_right (fun (x,y) s ->  
     let x = (x -. 26.0) *. 1.3
     and y = (20.6 +. y) *. 1.3
         in
     let (x,y,z) = matrix_vector (x_rotation mx) (matrix_vector (y_rotation my) (x,y,0.0)) in
       let r = (z +. 200.0) /. 200.0 in
       let x = truncate ( x *. r ) + 36
       and y = - truncate ( y *. r ) + 36
         in [Pixels x; Pixels y] @ s) mpoly_data []) ;
        mx <- mx +. 0.01;
        my <- my +. 0.02;
      if speed = 0.0 then begin
    if not idle then begin
      Canvas.configure_rectangle c2 i_park [FillColor Black;
                           Outline Black];
      idle <- true
    end
       end
      else begin
    Canvas.configure_rectangle c2 i_park [FillColor Green;
                         Outline Green];
        idle <- false
      end;
       if total <> last_total then
          Canvas.configure_text c2 kilos 
        [Text (if total > 1000000 then 
                 Printf.sprintf "%d.%02dM" (total/1000000)
                                         ((total mod 1000000)/10000)
               else if total > 1000 then
             Printf.sprintf "%d.%01dK" (total/1000)
                                             ((total mod 1000)/100)
           else string_of_int total)];
       last_total <- total;
       let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
       last_speed2 <-
      if last_speed2 > speed *. 0.8 +. last_speed2 *. 0.2
      then last_speed2 -. 0.1
      else speed;
       let speeds = 
     if last_speed2 -. last_speed > 0.2 then last_speed +. 0.2
     else if last_speed2 -. last_speed < (-0.1) then last_speed -. 0.1
     else last_speed
       in   
       (* let speeds = last_speed *. 0.5 +. speed *. 0.5 in *)
       if abs_float (speeds -. last_speed) > 0.05 then begin
         last_speed <- speeds;
     let v = speeds /. log10 *. 0.02 in

     for i = 0 to Array.length balls - 1 do
       balls.(i).z <- balls.(i).z -. v;
       if( balls.(i).z < 0.1 ) then begin
         balls.(i).z <- 1.0;
         balls.(i).x <- Random.float spacewidth -. (spacewidth /. 2.0);
         balls.(i).y <- Random.float spacewidth -. (spacewidth /. 2.0)
       end;
       self#ball_update balls.(i) v;
     done;
         update_idletasks()
        end


  method report_cnx n = 
    if Winfo.exists c2 then
      if n = 0 then begin
    Canvas.configure_text c2 pendings [Text ""];
       Canvas.lower_bot c2 pendings
      end
      else begin
    Canvas.configure_text c2 pendings 
      [Text (string_of_int n)];
       Canvas.raise_top c2 pendings
      end

  method report_busy busy =
    if Winfo.exists c2 then
      if busy then begin
       Canvas.lower_bot c2 pendings;
    Canvas.configure_rectangle c2 i_park [FillColor Red;
                          Outline Red];
    update_idletasks()
      end
      else begin
       Canvas.raise_top c2 pendings;
    Canvas.configure_rectangle c2 i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy fr

end

<<function Tachy_space.create_tachy>>
  (o :> Mmm.tachymeter)

<<toplevel Tachy_space._1>>

@


\subsection*{[[./extensions/tachy_test.ml]]}

<<constant Tachy_test.tachy_data>>=
(* inside bitmap, circle is in +16+7 +66+57, radius 25 *)

let tachy_data = "GIF\056\057aP\000A\000\227\000\000\000\000\000\
\044\044\044\060\000\000YYY\138\138\138\154\154\154\170\
\170\170\186\186\186\203\203\203\219\219\219\231qq\235\235\
\235\243yy\255\255\255\000\000\000\000\000\000\033\249\004\
\001\000\000\009\000\044\000\000\000\000P\000A\000\000\004\
\255\048\201I\171\189\024H\157\056\199\096\040\142\164\213\
Hg\146\166e\235\190p\060\013\052\045\223DN\000\
M\225\223\148\001\133\005\020\233\142\187\158oY\184\009\
\039\196\162\005I\229\049\153\006\131E\032z\162\164\023\
\042\178\144\188\250\178\232J\180\226U\021\063\146\129\248\
\136\174c\235\233\009\220\212\232\175a\041\052sx\132\
\133\133P\096\033p\130H\134\142\143\006\007z\137\032\
\129rt\144\153x\007\156\136\148\147\051\151\058\154\164\
Y\156\156\004\160\159n\009\003\000\152\165\164\167I\158\
\171\173r\175\004\177\187\007I\157\018\092\171\140\059\187\
\197\060\167\146\095\148\195\186\197\197\200\008\008\182\173\176\
\206\188\007\209\210\194\213\214\187\217\209\171\141\221\206\223\
\218\137\226\227\228\223\148\220\233\222\217\231\237\238\165\229\
\096\242\143\001\001\003\001\006\174\053\006\249\000\210\131\039\
\229\158\035\125\253\250\001\232\055\064\033\141\129\230\054\196\
\064G\010\192\190\044\251\030fA\056\240\194\031\035\163\
\255b\185J\008\208\031\198\128\177\216\133\044\165\049\203\
\194\135\015\045\166\180\176\167\132AC\045\255\213\216\185\
\203\227\011\138\243\172\197\203\017t\030\205\018\031n\022\
\037u\164\150\136\020J\151f\002\064\181f\139\170\011\
\221\037\152\231\039\133\213\011\031\186J\029\167\160\172\002\
\167\033\160\046\025\219\205\236Y\025w\216\022s\043\241\
\197\021\185\187\220\190e\229\034\046\094Mt\129\248\253\
\011\041p\135\024\131\009\059\050\204\183\197\093\197\143\220\
\050\144\178\022r\228\178\147\041\023\176\092X\001\131\204\
E\054s\094\236\249s\162\209\139\063\131\150\130\186P\
i\211\148Z\215y\189\026\140l\052\170a\127\186M\
\123Z\029N\144\049\171\158\182\053R\175\172x\001\044\
\016N\092\002\170cx\023\044P\094\182\249\004\095\192\
\199J\151\174\220\250\016d\217\231m\031\239\253\176s\
\240\008\196\143\151\190\225k\034\022\208\178u\091\191\125\
\210G\091\156\202\201\039E\159\252\144\251\211\232\183N\
\045qxH\208\095\125\229\149\032\096\005\180Lp\096\
\130\048\012HA\131\009\244\007a\056\060\024\232\223\133\
\024\158\192\030\135\032\134\040\226\136\036\194\016\001\000\059\
"
@

<<constant Tachy_test.park_data>>=
let park_data =
"#define break_width 15
#define break_height 11
static char break_bits[] = {
   0x0c, 0x18, 0xf4, 0x17, 0x3a, 0x2e, 0xba, 0x2d, 0xb9, 0x4d, 0x3d, 0x5e,
   0xb9, 0x4f, 0xba, 0x2f, 0xba, 0x2f, 0xf4, 0x17, 0x08, 0x08};
"
@

<<constant Tachy_test.pi>>=
let pi = 3.1415926 
@

<<constant Tachy_test.log10>>=
let log10 = log 10.0 
@

<<function Tachy_test.create_tachy>>=
let create_tachy top = 
  let o = new default_tachy top in
  o#start;
@

<<toplevel Tachy_test._1>>=
let _ = 
  let top = Applets.get_toplevel_widget [] in
  Wm.withdraw top;
  begin match Frx_dialog.f top (Mstring.gensym "foo")
        "Tachy test" "Use this test tachymeter"
    (Tk.Predefined "question") 1 ["Yes"; "No"] with
    0 -> Mmm.set_tachy create_tachy
  | _ -> ()
  end;
  destroy top
@


%-------------------------------------------------------------

<<./extensions/tachy_test.ml>>=
open Safe418mmm
open Tk

module Provide = struct
  let capabilities = Capabilities.get()
  end

module Mmm = Get(Provide)

(* Tachymeter *)

(* gif is 80x65 *)
<<constant Tachy_test.tachy_data>>
<<constant Tachy_test.park_data>>


<<constant Tachy_test.pi>>
<<constant Tachy_test.log10>>

class default_tachy (top : Widget.widget) =
 object (self)
  (* val top = top *)
  val mutable canvas = top (* dummy initialisation *)
  val mutable alive = false

  (* Various components of the canvas, all with dummy init values *)
  val mutable i_park = Tag "none"
  val mutable kilos = Tag "none"
  val mutable aig = Tag "none"
  val mutable pendings = Tag "none"


  (* this one is private *)
  method start =
    let c =
      Canvas.create_named top "tachymeter"
       [Width (Pixels 80); Height (Pixels 80); 
         BorderWidth (Pixels 0);
         HighlightThickness (Pixels 0);
         TakeFocus true (* pl3 fix *)] in
    (* Use colors so that images are not transparent *)  
    (*
    let tachy_image = 
      begin
       try
      let bgc = Tk.cget c CBackground in
      Protocol.tkEval 
        [|Protocol.TkToken "set";
          Protocol.TkToken "TRANSPARENT_GIF_COLOR";
          Protocol.TkToken bgc |]; () 
       with _ -> ()
      end;
      *)
    let tachy_image = Frx_misc.create_photo [Data tachy_data]
    and park_image =
      Imagebitmap.create [Data park_data; Foreground Red] in

    i_park <-
      Canvas.create_rectangle c 
     (Pixels 72) (Pixels 3) 
     (Pixels 75) (Pixels 6) [FillColor Black];
    
    kilos <-
      Canvas.create_text c (Pixels 40) (Pixels 73) [Text "0"];
    
    aig <-
      Canvas.create_line c [Pixels 41; Pixels 32; Pixels 41; Pixels 57]
                       [Width (Pixels 2)];
    pendings <-
      Canvas.create_text c (Pixels 70) (Pixels 60) [Text "0"];

    let i_tachy =
      Canvas.create_image c (Pixels 0) (Pixels 0)
       [ImagePhoto tachy_image; Anchor NW]

    in

    Canvas.lower_bot c pendings;

    (* All other items must be put above the background image *)
    List.iter (fun i -> Canvas.raise_above c i i_tachy)
      [kilos; aig; i_park];

    bind c [[], Destroy] (BindSet ([], (fun _ -> alive <- false)));

    (* These bindings are specific to the applet version *)
    bind c [[], ButtonPressDetail 1] 
      (BindSet ([], (fun _ -> Mmm.new_window_initial ())));
    bind c [[], ButtonPressDetail 2] 
      (BindSet ([], (fun _ -> Mmm.new_window_sel ())));

    alive <- true;
    pack [c][];
    canvas <- c

  val mutable last_speed = 0.
  val mutable last_total = 0
  val mutable idle = false

  method update speed total =
    if speed = 0.0 then begin
      if not idle then begin
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black];
    idle <- true
      end
    end
    else begin
      Canvas.configure_rectangle canvas i_park [FillColor Green;
                         Outline Green];
      idle <- false
    end;
    if total <> last_total then
      Canvas.configure_text canvas kilos [Text (string_of_int total)];
    last_total <- total;
    let speed = if speed = 0. then 0. else log speed in
       (* Smooth *)
    let speeds = (last_speed +. speed) /. 2. in
    if abs_float (speeds -. last_speed) > 0.1 then begin
      last_speed <- speeds;
      let v = speeds /. log10 in
      let angle = v /. 4.0 *. pi in
      let angle = if angle < 0.1 then 0.0 else angle in
      let x = 41.0 -. (sin angle *. 25.0)
      and y = 32.0 +. (cos angle *. 25.0) in
      Canvas.coords_set canvas aig 
    [Pixels 41; Pixels 32;
      Pixels (truncate x); Pixels (truncate y)];
      update_idletasks()
    end

  method report_cnx n = 
    if Winfo.exists canvas then
      if n = 0 then begin
    Canvas.configure_text canvas pendings [Text ""];
       Canvas.lower_bot canvas pendings
      end
      else begin
    Canvas.configure_text canvas pendings 
      [Text (string_of_int n)];
       Canvas.raise_top canvas pendings
      end

  method report_busy busy =
    if Winfo.exists canvas then
      if busy then begin
       Canvas.lower_bot canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Red;
                          Outline Red];
    update_idletasks()
      end
      else begin
       Canvas.raise_top canvas pendings;
    Canvas.configure_rectangle canvas i_park [FillColor Black;
                          Outline Black]
      end

  method report_traffic tick_duration bytes_read sample_read =
    if alive then
      self#update (float sample_read *. 1000. /. float tick_duration)
    bytes_read

  method quit =
    alive <- false;
    destroy canvas

end

<<function Tachy_test.create_tachy>>
  (o :> Mmm.tachymeter)

<<toplevel Tachy_test._1>>

@


